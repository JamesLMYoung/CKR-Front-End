"use strict";Object.defineProperty(exports, "__esModule", {value: true});var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// src/selectors.ts
var Selectors = {
  Cell: '[role="cell"],[role="gridcell"],[role="columnheader"],[role="rowheader"],td,th',
  Row: '[role="row"],tr',
  RowGroup: '[role="rowgroup"],thead,tbody,tfoot',
  /** Selector from here: https://github.com/Shopify/polaris/blob/main/polaris-react/src/utilities/focus.ts#L10 */
  Focusable: 'a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not([aria-disabled="true"]):not([tabindex="-1"]):not(:disabled),*[tabindex]'
};

// src/index.ts
var DataGridNav = class {
  constructor(config = {}) {
    this.keys = [];
    this.debugLog = (functionName, message) => {
      if (this.debug)
        console.info(`[${functionName}]: ${message}`);
    };
    const { selectors = {}, pageUpDown, debug = false } = config;
    this.selectors = __spreadValues(__spreadValues({}, Selectors), selectors);
    this.pageUpDown = pageUpDown;
    this.keys = [];
    this.debug = debug;
    this.disabled = false;
  }
  /**
   * Disables the keyboard listener in cases
   * that elements inside the grid need to use
   * arrows keys etc., like select dropdowns
   */
  disable() {
    this.disabled = true;
  }
  /**
   * Enables the keyboard listeners
   */
  enable() {
    this.disabled = false;
  }
  isFocusable(el) {
    return el instanceof HTMLElement || el instanceof SVGElement;
  }
  /** Used as a keyboard listener for key up */
  tableKeyUp() {
    this.keys = [];
  }
  /** Used as a keyboard listener for key down */
  tableKeyDown(e) {
    var _a;
    this.debugLog("tableKeyDown", `Key pressed: ${e.key}`);
    if (this.disabled) {
      this.debugLog("tableKeyDown", "interaction is disabled");
      return;
    }
    if ("ArrowDown" /* ArrowDown */ === e.key || "ArrowUp" /* ArrowUp */ === e.key || "ArrowLeft" /* ArrowLeft */ === e.key || "ArrowRight" /* ArrowRight */ === e.key) {
      e.preventDefault();
    }
    if (this.keys.length === 0 || this.keys[this.keys.length - 1] !== e.key) {
      this.keys.push(e.key);
    }
    if (!(e.target instanceof Element))
      return;
    const cell = (_a = e.target.parentElement) == null ? void 0 : _a.closest(
      `${this.selectors.Cell},${this.selectors.Row}`
    );
    if (!cell) {
      this.debugLog("tableKeyDown", "cell not found");
      return;
    }
    if (cell.matches(this.selectors.Cell)) {
      this.debugLog("tableKeyDown", "event captured in cell");
      this.cellNavigation(e);
    } else {
      this.debugLog("tableKeyDown", "event captured in cell");
      this.gridNavigation(e);
    }
  }
  /**
   * Handles the navigation inside a cell
   */
  cellNavigation(e) {
    if (!(e.target instanceof Element))
      return;
    if (e.key === "Escape" /* Escape */) {
      const cell = e.target.closest(this.selectors.Cell);
      if (cell && this.isFocusable(cell)) {
        cell.focus();
        return;
      }
    }
    if (e.key === "ArrowRight" /* ArrowRight */ || e.key === "ArrowDown" /* ArrowDown */) {
      const cell = e.target.closest(this.selectors.Cell);
      if (!cell) {
        this.debugLog("cellNavigation", "cell not found");
        return;
      }
      const focusableWidgets = [
        ...cell.querySelectorAll(this.selectors.Focusable)
      ];
      const widgetIdx = focusableWidgets.findIndex((el) => el === e.target);
      const nextFocusable = widgetIdx === focusableWidgets.length - 1 ? 0 : widgetIdx + 1;
      const widgetToFocus = focusableWidgets[nextFocusable];
      if (this.isFocusable(widgetToFocus)) {
        widgetToFocus.focus();
      }
      return;
    }
    if (e.key === "ArrowLeft" /* ArrowLeft */ || e.key === "ArrowUp" /* ArrowUp */) {
      const cell = e.target.closest(this.selectors.Cell);
      if (!cell) {
        this.debugLog("cellNavigation", "cell not found");
        return;
      }
      const focusableWidgets = [
        ...cell.querySelectorAll(this.selectors.Focusable)
      ];
      const widgetIdx = focusableWidgets.findIndex((el) => el === e.target);
      const previousFocusable = widgetIdx === 0 ? focusableWidgets.length - 1 : widgetIdx - 1;
      const widgetToFocus = focusableWidgets[previousFocusable];
      if (this.isFocusable(widgetToFocus)) {
        widgetToFocus.focus();
      }
      return;
    }
  }
  /**
   * Handles the navigation outside a cell
   * on the grid level
   */
  gridNavigation(e) {
    var _a;
    const { target } = e;
    if (!(e.target instanceof Element))
      return;
    if (!(target instanceof Element))
      return;
    if (this.keys.length === 1) {
      if (e.key === "Enter" /* Enter */) {
        const cell = e.target.querySelector(this.selectors.Focusable);
        if (cell && this.isFocusable(cell)) {
          cell.focus();
          e.preventDefault();
        }
      }
      if (e.key === "ArrowLeft" /* ArrowLeft */ || e.key === "ArrowRight" /* ArrowRight */) {
        const direction = e.key === "ArrowLeft" /* ArrowLeft */ ? "prev" : "next";
        const cell = e.target.closest(this.selectors.Cell);
        if (cell && cell instanceof Element) {
          const closeFocusable = this.findUntil(
            direction,
            cell,
            this.selectors.Cell
          );
          if (closeFocusable) {
            closeFocusable.focus();
          }
        }
      }
      if (e.key === "ArrowDown" /* ArrowDown */ || e.key === "ArrowUp" /* ArrowUp */) {
        this.verticalCellNavigation(e);
        return;
      }
      if (e.key === "PageUp" /* PageUp */ || e.key === "PageDown" /* PageDown */) {
        this.pageCellNavigation(e);
        return;
      }
      if (e.key === "Home" /* Home */ || e.key === "End" /* End */) {
        const row = e.target.closest(this.selectors.Row);
        const rowChildren = [...(row == null ? void 0 : row.children) || []];
        if (e.key === "End")
          rowChildren.reverse();
        this.focusOnFirstCell(rowChildren);
      }
    } else {
      const [firstKey, secondKey] = this.keys;
      if (firstKey === "Control" && (secondKey === "Home" /* Home */ || secondKey === "End" /* End */)) {
        const row = e.target.closest(this.selectors.Row);
        const siblings = (_a = row.parentElement) == null ? void 0 : _a.children;
        if (!siblings) {
          this.debugLog("cellNavigation", "siblings not found");
          return;
        }
        const rowToFocus = secondKey === "Home" /* Home */ ? siblings[0] : siblings[siblings.length - 1];
        const rowChildren = [...(rowToFocus == null ? void 0 : rowToFocus.children) || []];
        if (secondKey === "End" /* End */)
          rowChildren.reverse();
        this.focusOnFirstCell(rowChildren);
      }
    }
  }
  pageCellNavigation(e) {
    var _a;
    if (!(e.target instanceof Element))
      return;
    const row = e.target.closest(this.selectors.Row);
    const cell = e.target.closest(this.selectors.Cell);
    if (row && cell) {
      const position = this.getColumnIndex(cell);
      if (position === void 0) {
        this.debugLog("cellNavigation", "position not found");
        return;
      }
      const direction = e.key === "PageUp" /* PageUp */ ? "prev" : "next";
      const siblings = (_a = row.parentElement) == null ? void 0 : _a.children;
      if (!siblings) {
        this.debugLog("cellNavigation", "siblings not found");
        return;
      }
      let destinationRow;
      if (this.pageUpDown) {
        const methodClbk = direction === "prev" ? "previousSibling" : "nextSibling";
        let sibling = row[methodClbk];
        if (sibling === null)
          return;
        let lastVisitedSibling = sibling;
        for (let i = 0; i < this.pageUpDown - 1 && sibling; i++) {
          sibling = sibling[methodClbk];
          if (sibling) {
            lastVisitedSibling = sibling;
          }
        }
        destinationRow = sibling ? sibling : lastVisitedSibling;
      } else {
        destinationRow = direction === "prev" ? siblings[0] : siblings[siblings.length - 1];
      }
      if (!destinationRow || !(destinationRow instanceof Element))
        return;
      const child = destinationRow.children[position];
      if (child && this.isFocusable(child))
        child.focus();
    }
  }
  verticalCellNavigation(e) {
    var _a, _b, _c, _d, _e;
    if (!(e.target instanceof Element))
      return;
    const row = e.target.closest(this.selectors.Row);
    const cell = e.target.closest(this.selectors.Cell);
    if (row && cell) {
      const cellPosition = this.getColumnIndex(cell);
      const rowPosition = this.getRowIndex(row);
      this.debugLog("gridNavigation", `Initial row position: ${rowPosition}`);
      this.debugLog("gridNavigation", `Initial cell position: ${cellPosition}`);
      if (cellPosition === void 0 || rowPosition === void 0) {
        this.debugLog(
          "verticalCellNavigation",
          "row or cell position not found"
        );
        return;
      }
      const direction = e.key === "ArrowUp" /* ArrowUp */ ? "prev" : "next";
      if (rowPosition === 0 && direction === "prev") {
        const currentRowGroup = (_a = row.parentElement) == null ? void 0 : _a.closest(
          this.selectors.RowGroup
        );
        const siblingRowGroups = [
          ...((_b = currentRowGroup == null ? void 0 : currentRowGroup.parentElement) == null ? void 0 : _b.children) || []
        ];
        const currentRowGroupIdx = siblingRowGroups.findIndex(
          (el) => el === currentRowGroup
        );
        if (currentRowGroupIdx !== 0) {
          const previousRowGroup = siblingRowGroups[currentRowGroupIdx - 1];
          const rows = [
            ...previousRowGroup.querySelectorAll(this.selectors.Row)
          ];
          const child2 = rows[rows.length - 1].children[cellPosition];
          if (child2 && this.isFocusable(child2))
            child2.focus();
          return;
        }
      }
      const siblingRows = [
        ...((_c = row.parentElement) == null ? void 0 : _c.querySelectorAll(this.selectors.Row)) || []
      ];
      if (rowPosition === siblingRows.length - 1 && direction === "next") {
        const currentRowGroup = (_d = row.parentElement) == null ? void 0 : _d.closest(
          this.selectors.RowGroup
        );
        const siblingRowGroups = [
          ...((_e = currentRowGroup == null ? void 0 : currentRowGroup.parentElement) == null ? void 0 : _e.children) || []
        ];
        const currentRowGroupIdx = siblingRowGroups.findIndex(
          (el) => el === currentRowGroup
        );
        if (currentRowGroupIdx !== siblingRowGroups.length - 1) {
          const nextRowGroup = siblingRowGroups[currentRowGroupIdx + 1];
          const rows = [...nextRowGroup.querySelectorAll(this.selectors.Row)];
          const child2 = rows[0].children[cellPosition];
          if (child2 && this.isFocusable(child2))
            child2.focus();
          return;
        }
        return;
      }
      const destinationRow = this.findUntil(direction, row, this.selectors.Row);
      if (!destinationRow)
        return;
      const child = destinationRow.children[cellPosition];
      if (child && this.isFocusable(child))
        child.focus();
    }
  }
  /**
   * Sending a row `Element` and then the first cell will be focused.
   *
   * If you want to focus the last cell then the row children can be passed in
   * reversed order
   */
  focusOnFirstCell(el) {
    for (let i = 0; i < el.length; i++) {
      const child = el[i];
      if (this.isFocusable(child)) {
        child.focus();
        return;
      }
    }
  }
  /**
   * Get the column index of a `cell` based on the first `row` parent.
   * `cellIndex` could be used, but it's not supported in HTML tables.
   */
  getColumnIndex(cell) {
    var _a;
    let position = 0;
    const siblings = (_a = cell == null ? void 0 : cell.parentNode) == null ? void 0 : _a.children;
    if (!siblings)
      return void 0;
    while (cell !== siblings[position] && siblings[position] !== void 0) {
      position++;
    }
    if (siblings[position] === void 0) {
      this.debugLog("getColumnIndex", "position finding was not successful");
      return void 0;
    }
    return position;
  }
  /**
   * Get the row index of a `row` based
   * on its sibling rows
   */
  getRowIndex(row) {
    var _a;
    let position = 0;
    const siblings = (_a = row == null ? void 0 : row.parentNode) == null ? void 0 : _a.children;
    if (!siblings)
      return void 0;
    while (row !== siblings[position] && siblings[position] !== void 0) {
      position++;
    }
    if (siblings[position] === void 0) {
      this.debugLog("getRowIndex", "position finding was not successful");
      return void 0;
    }
    return position;
  }
  /**
   * Equivalent to prevUntil/nextUntil in jQuery
   * https://api.jquery.com/prevUntil/
   */
  findUntil(direction, el, matchSelector, exitSelector) {
    let element = el;
    const method = direction === "next" ? "nextSibling" : "previousSibling";
    while (element[method]) {
      const sibling = element[method];
      if (!sibling)
        return null;
      if (exitSelector && sibling instanceof Element && sibling.matches(exitSelector)) {
        return null;
      }
      if (sibling instanceof Element && sibling.matches(matchSelector)) {
        return sibling;
      }
      element = sibling;
    }
    return null;
  }
};


exports.DataGridNav = DataGridNav;
//# sourceMappingURL=index.js.map