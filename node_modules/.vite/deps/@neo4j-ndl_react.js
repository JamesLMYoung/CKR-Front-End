import {
  require_refractor
} from "./chunk-KVDDLF7C.js";
import "./chunk-S7SCOYB6.js";
import "./chunk-6FPG2GAC.js";
import "./chunk-6D4WPYB5.js";
import "./chunk-XZ55SO27.js";
import "./chunk-MVREPKUI.js";
import {
  require_core as require_core2
} from "./chunk-KHB7NXAN.js";
import "./chunk-KVO24BOF.js";
import "./chunk-OTLZ4UL7.js";
import "./chunk-J4X4QRJV.js";
import "./chunk-3NWGPZAU.js";
import "./chunk-MBG3BFWR.js";
import "./chunk-UG6DC4I2.js";
import "./chunk-2MLYTTZC.js";
import "./chunk-JWIZF6EM.js";
import "./chunk-MMIXMPAT.js";
import "./chunk-C47EJ2MT.js";
import "./chunk-GUQSRZIE.js";
import "./chunk-CEI557DW.js";
import "./chunk-FVL2QZ4L.js";
import "./chunk-ID47L722.js";
import "./chunk-EB5TKG2M.js";
import "./chunk-SNAPMJR3.js";
import "./chunk-CQBJKGYA.js";
import "./chunk-RJBTAJBH.js";
import "./chunk-I5V6JEXE.js";
import "./chunk-DHJ3ZJ6T.js";
import "./chunk-ZRQA7MVC.js";
import "./chunk-KDF2XIFP.js";
import "./chunk-CRNOXWBV.js";
import "./chunk-MD3Y5EGT.js";
import "./chunk-BKJDRZXO.js";
import "./chunk-VLCW3UOZ.js";
import "./chunk-V3AVKFYI.js";
import "./chunk-HBP7DNWQ.js";
import "./chunk-7PKEF3YS.js";
import "./chunk-CEBOM323.js";
import "./chunk-6QDJYMSU.js";
import "./chunk-QXBN3QVB.js";
import "./chunk-N4FA5RAK.js";
import "./chunk-UUEDNVCA.js";
import "./chunk-LVFUU76V.js";
import "./chunk-J2T5OTEQ.js";
import "./chunk-CAHSUOEU.js";
import "./chunk-ARFWHRE7.js";
import "./chunk-P7YMG5NQ.js";
import "./chunk-RPUTYQG5.js";
import "./chunk-Y4EGF4Q4.js";
import "./chunk-ERARKWTL.js";
import "./chunk-AUDTNUL4.js";
import "./chunk-73IXRQ4O.js";
import "./chunk-K2RKF25I.js";
import "./chunk-6WL2WAE5.js";
import "./chunk-MQN3ZMR2.js";
import "./chunk-I7SGRRKL.js";
import "./chunk-6LV5WQXM.js";
import "./chunk-MGTKV367.js";
import "./chunk-4RZ7NHZM.js";
import "./chunk-HVCPUNT5.js";
import "./chunk-LMDNYFI7.js";
import "./chunk-YHBADZWA.js";
import "./chunk-JPZQOOE5.js";
import "./chunk-EOD4UESA.js";
import "./chunk-55TEY7YB.js";
import "./chunk-PVBMWUQO.js";
import "./chunk-6YD4MIRW.js";
import "./chunk-ZKQ2XUM2.js";
import "./chunk-ZWKDYLQY.js";
import "./chunk-L3CSZHT5.js";
import "./chunk-P6FATIOF.js";
import "./chunk-AKFIUF4I.js";
import "./chunk-HRPUNYVN.js";
import "./chunk-ZQJLHRMB.js";
import "./chunk-FTAGPI44.js";
import "./chunk-HPTMXLJB.js";
import "./chunk-7BFUG5PP.js";
import "./chunk-5EAGO5VN.js";
import "./chunk-FL2XOCPW.js";
import "./chunk-NPAQGCTL.js";
import "./chunk-OJJ2Y4D5.js";
import "./chunk-AAURMOJZ.js";
import "./chunk-B4YDKTBN.js";
import "./chunk-YXLAAGH5.js";
import "./chunk-5QMI6F3V.js";
import "./chunk-KM7SGSKZ.js";
import "./chunk-E7QTFNHF.js";
import "./chunk-W5WXB4IT.js";
import "./chunk-3SKGPMVP.js";
import "./chunk-BKJV3TEP.js";
import "./chunk-RYJNVEXI.js";
import "./chunk-JSU57PLC.js";
import "./chunk-OUFGSU54.js";
import "./chunk-BVY66QWM.js";
import "./chunk-YS5I7JSI.js";
import "./chunk-OE6QSUSU.js";
import "./chunk-FO6NNNRI.js";
import "./chunk-XADMHYND.js";
import "./chunk-FTXIC7T4.js";
import "./chunk-JPQWXPMM.js";
import "./chunk-YJMSZCZF.js";
import "./chunk-J4TKJWM6.js";
import "./chunk-C426HSRB.js";
import "./chunk-XEGHTW3L.js";
import "./chunk-WIUBTAVF.js";
import "./chunk-7VTLJTLY.js";
import "./chunk-ENEKAXC4.js";
import "./chunk-ATL5V4C3.js";
import "./chunk-4XXZJJJM.js";
import "./chunk-DIHP6K4B.js";
import "./chunk-URIMJYXO.js";
import "./chunk-43NAURW7.js";
import "./chunk-GG2N7LEA.js";
import "./chunk-BQ4S7YRZ.js";
import "./chunk-PN5KCPMS.js";
import "./chunk-35B7YVDK.js";
import "./chunk-CFEWJDG6.js";
import "./chunk-EMCIXKSI.js";
import "./chunk-4ECDGBXS.js";
import "./chunk-RKVKMGMW.js";
import "./chunk-BXX4T4TW.js";
import "./chunk-CVBQBIN4.js";
import "./chunk-CJI2GGL6.js";
import "./chunk-OOTRGD4N.js";
import "./chunk-UB5X7MAD.js";
import "./chunk-ZRJMJ2ZC.js";
import "./chunk-XMMXLWOT.js";
import "./chunk-YEPDTASY.js";
import "./chunk-4UI3JU2U.js";
import "./chunk-5WF6KMW4.js";
import "./chunk-GOPVD5ZV.js";
import "./chunk-ADASVZ34.js";
import "./chunk-5OWI6SO6.js";
import "./chunk-X6DRW57L.js";
import "./chunk-UXJYYXYP.js";
import "./chunk-RDVVGBP2.js";
import "./chunk-PFU3WTL6.js";
import "./chunk-QFBLSXNP.js";
import "./chunk-YI6VY6FE.js";
import "./chunk-EBKTQW6Y.js";
import "./chunk-V4PQVMSW.js";
import "./chunk-3UPWCFQL.js";
import "./chunk-Q5QT6DJ4.js";
import "./chunk-DVQXADP2.js";
import "./chunk-NOHLMWOE.js";
import "./chunk-PE3Q3I42.js";
import "./chunk-QGKR2B6L.js";
import "./chunk-5V6UKUCC.js";
import "./chunk-TCCQZ2DZ.js";
import "./chunk-SY4IVC4D.js";
import "./chunk-GDMMDX5O.js";
import "./chunk-37OFAFSC.js";
import "./chunk-7GDYQMRM.js";
import "./chunk-AF3YPO4D.js";
import "./chunk-BNNEGLRF.js";
import "./chunk-U3H2S6RV.js";
import "./chunk-IPR6KHYL.js";
import "./chunk-BVQDF3OD.js";
import "./chunk-WRXBAPMH.js";
import "./chunk-DWO6VMRS.js";
import "./chunk-ORIQCSUJ.js";
import "./chunk-BRGY3ATO.js";
import "./chunk-SIHRUY6G.js";
import "./chunk-YYBWCQTK.js";
import "./chunk-4LLUIDYX.js";
import "./chunk-3P6NCAC6.js";
import "./chunk-5D5B65TX.js";
import "./chunk-YDC5O65G.js";
import "./chunk-2XFAWP6P.js";
import "./chunk-Q2SJUQPW.js";
import "./chunk-BUGWVXF5.js";
import "./chunk-BQMKPATB.js";
import "./chunk-NISNTZ4E.js";
import "./chunk-K7B3UDEP.js";
import "./chunk-5BAVXMAT.js";
import "./chunk-TNMVEPJ7.js";
import "./chunk-UUNMTSTY.js";
import "./chunk-4RRZQCOH.js";
import "./chunk-ZWMISSBE.js";
import "./chunk-PYKKT6VT.js";
import "./chunk-NGFLFEDA.js";
import "./chunk-MAASRASO.js";
import "./chunk-IVTDIOML.js";
import "./chunk-XMEEQIGK.js";
import "./chunk-XG5NPO6F.js";
import "./chunk-GR7FEFNZ.js";
import "./chunk-NYMC2VKQ.js";
import "./chunk-JK34GKGQ.js";
import "./chunk-CYRXVMXN.js";
import "./chunk-6A5O2UCS.js";
import "./chunk-BUJFQIYH.js";
import "./chunk-DETTXIUA.js";
import "./chunk-XUQMLYOD.js";
import "./chunk-UKPYVTNI.js";
import "./chunk-TNQJILXF.js";
import "./chunk-PQ7PL2RJ.js";
import "./chunk-7SC4SLM4.js";
import "./chunk-62EGEHA6.js";
import "./chunk-ZKUZTFLW.js";
import "./chunk-WMWZE62R.js";
import "./chunk-4YRQ6OGM.js";
import "./chunk-T6QAL3SY.js";
import "./chunk-R2663WFP.js";
import "./chunk-M2REI7CN.js";
import "./chunk-6KKXUDRD.js";
import "./chunk-RRLENTD7.js";
import "./chunk-S4SUVV4N.js";
import "./chunk-FJFY6GIZ.js";
import "./chunk-IKR6V42K.js";
import "./chunk-E5VGBLG2.js";
import "./chunk-HXUKGGTE.js";
import "./chunk-JT5CAMD2.js";
import "./chunk-M4MAPYHO.js";
import "./chunk-GN3OXNWP.js";
import "./chunk-U336MR33.js";
import "./chunk-Y5TIBHX5.js";
import "./chunk-SZC7U5OL.js";
import "./chunk-T6CL3DJJ.js";
import "./chunk-T5SCTV55.js";
import "./chunk-D7TV34HH.js";
import "./chunk-F6KACTLN.js";
import "./chunk-ERROOWZW.js";
import "./chunk-3A62HIZN.js";
import "./chunk-B3PVAOHS.js";
import "./chunk-KCFRTT5O.js";
import "./chunk-KEJYAZ3P.js";
import "./chunk-RDAZWYZX.js";
import "./chunk-MBZFQYYW.js";
import "./chunk-D7XCV6QN.js";
import "./chunk-4JB43BJG.js";
import "./chunk-K3TH4ZRM.js";
import "./chunk-WUFUQAMT.js";
import "./chunk-KNNRPE6M.js";
import "./chunk-BLDSRBUE.js";
import "./chunk-GLKPBUNJ.js";
import "./chunk-AWWFFVQR.js";
import "./chunk-FTGLYWJS.js";
import "./chunk-XCK5GXLR.js";
import "./chunk-CZQ2BDEG.js";
import "./chunk-6PJ7E6HT.js";
import "./chunk-TWCNTUKG.js";
import "./chunk-VCFV3NCI.js";
import "./chunk-SM3APIJD.js";
import "./chunk-G5EJLBBX.js";
import "./chunk-BCRIONX5.js";
import "./chunk-ES26CZRK.js";
import "./chunk-CQ5DYOZR.js";
import "./chunk-HLFGSA75.js";
import "./chunk-FAHUMT6D.js";
import "./chunk-5DOFMJJ6.js";
import "./chunk-QME5XJXK.js";
import "./chunk-LZTPU5X5.js";
import "./chunk-7SAYSM6R.js";
import "./chunk-GQKDCWCR.js";
import "./chunk-5J36JXMX.js";
import "./chunk-LONQ25N4.js";
import "./chunk-LTGJ7Y2M.js";
import "./chunk-XOC3KKMF.js";
import "./chunk-GEXDBFPH.js";
import "./chunk-JQACA5I3.js";
import "./chunk-RWJG2ERU.js";
import "./chunk-JB4476BE.js";
import "./chunk-TQYZ6KKY.js";
import "./chunk-A4JRVTHX.js";
import "./chunk-CUBO4JIV.js";
import "./chunk-7L3FVYOP.js";
import "./chunk-TN5P4BYD.js";
import "./chunk-AEZOQZRP.js";
import "./chunk-PKSKES25.js";
import "./chunk-LRASLVM4.js";
import "./chunk-R2MPTXJZ.js";
import "./chunk-U6ICMAAR.js";
import "./chunk-4ISHD6CT.js";
import "./chunk-NYRM3ML5.js";
import "./chunk-HQGMOH57.js";
import "./chunk-NGY3PZJY.js";
import "./chunk-OAS2MFJM.js";
import "./chunk-DCCAONBT.js";
import "./chunk-2ANWIHUQ.js";
import "./chunk-7JXFLTZ3.js";
import {
  require_vbscript_html
} from "./chunk-ZFTJA3L2.js";
import {
  require_verilog
} from "./chunk-XCRTFJBR.js";
import {
  require_vhdl
} from "./chunk-A7H27JLE.js";
import {
  require_vim
} from "./chunk-G2S64SWG.js";
import {
  require_x86asm
} from "./chunk-VOOLENRP.js";
import {
  require_xl
} from "./chunk-H5KHZQTN.js";
import {
  require_xquery
} from "./chunk-M7TZGOGA.js";
import {
  require_zephir
} from "./chunk-I2GSCLJX.js";
import {
  require_tcl
} from "./chunk-QKPV3TGT.js";
import {
  require_thrift
} from "./chunk-SV4NXYTF.js";
import {
  require_tp
} from "./chunk-2NUCSW4E.js";
import {
  require_twig
} from "./chunk-YETRUIRY.js";
import {
  require_typescript
} from "./chunk-Z4EE3YJF.js";
import {
  require_vala
} from "./chunk-6SFK5KAG.js";
import {
  require_vbnet
} from "./chunk-NXCP3WRZ.js";
import {
  require_vbscript
} from "./chunk-X7WTHRCY.js";
import {
  require_stata
} from "./chunk-GCA3FXXF.js";
import {
  require_step21
} from "./chunk-TQOOPIPM.js";
import {
  require_stylus
} from "./chunk-45X5NLIY.js";
import {
  require_subunit
} from "./chunk-QRM7SZ2I.js";
import {
  require_swift
} from "./chunk-KXUFENSV.js";
import {
  require_taggerscript
} from "./chunk-2UMRCPPP.js";
import {
  require_yaml
} from "./chunk-GH3OZZM4.js";
import {
  require_tap
} from "./chunk-JZ3VMPRH.js";
import {
  require_shell
} from "./chunk-BGME5ODQ.js";
import {
  require_smali
} from "./chunk-RW73X2HQ.js";
import {
  require_smalltalk
} from "./chunk-M2EZ3FPK.js";
import {
  require_sml
} from "./chunk-4UF4AEXY.js";
import {
  require_sqf
} from "./chunk-DDFS6BPC.js";
import {
  require_sql_more
} from "./chunk-FZPUNRAR.js";
import {
  require_sql
} from "./chunk-GG2UF7NE.js";
import {
  require_stan
} from "./chunk-5CD527QX.js";
import {
  require_rsl
} from "./chunk-ZTFEEBBK.js";
import {
  require_ruleslanguage
} from "./chunk-HUSR4DFB.js";
import {
  require_rust
} from "./chunk-DYCQGMZ2.js";
import {
  require_sas
} from "./chunk-3LNOZGXT.js";
import {
  require_scala
} from "./chunk-K5AEB5DX.js";
import {
  require_scheme
} from "./chunk-HE6IMQPK.js";
import {
  require_scilab
} from "./chunk-DMLUY6DM.js";
import {
  require_scss
} from "./chunk-Z6V2V4JL.js";
import {
  require_python_repl
} from "./chunk-JKVPUQZ7.js";
import {
  require_q
} from "./chunk-A6I7ARTK.js";
import {
  require_qml
} from "./chunk-UCOQXPWE.js";
import {
  require_r
} from "./chunk-S6MOZPIC.js";
import {
  require_reasonml
} from "./chunk-SL73WSOY.js";
import {
  require_rib
} from "./chunk-LJXQX7M4.js";
import {
  require_roboconf
} from "./chunk-YAG6VWVK.js";
import {
  require_routeros
} from "./chunk-IW6ZHV3J.js";
import {
  require_processing
} from "./chunk-IBLYFITA.js";
import {
  require_profile
} from "./chunk-MXV5JQJT.js";
import {
  require_prolog
} from "./chunk-G47HLVUH.js";
import {
  require_properties
} from "./chunk-SIQRHIIZ.js";
import {
  require_protobuf
} from "./chunk-TFP2X7LF.js";
import {
  require_puppet
} from "./chunk-2LMVWVRI.js";
import {
  require_purebasic
} from "./chunk-GYDGC7WL.js";
import {
  require_python
} from "./chunk-FQGR7PBQ.js";
import {
  require_parser3
} from "./chunk-SG3VC6KO.js";
import {
  require_pf
} from "./chunk-4E6ZHATS.js";
import {
  require_pgsql
} from "./chunk-V2UVFPV5.js";
import {
  require_php
} from "./chunk-JTP3EXFF.js";
import {
  require_php_template
} from "./chunk-NBJFQ66I.js";
import {
  require_plaintext
} from "./chunk-ZRXAMOUQ.js";
import {
  require_pony
} from "./chunk-2CDS2ENN.js";
import {
  require_powershell
} from "./chunk-M7WU32WD.js";
import {
  require_nim
} from "./chunk-QZYYLNAE.js";
import {
  require_nix
} from "./chunk-TZVFBRCP.js";
import {
  require_node_repl
} from "./chunk-WTQBKYQU.js";
import {
  require_nsis
} from "./chunk-2PUUYXNY.js";
import {
  require_objectivec
} from "./chunk-HUHNCJC2.js";
import {
  require_ocaml
} from "./chunk-LQY2VSSD.js";
import {
  require_openscad
} from "./chunk-WBS6HC7J.js";
import {
  require_oxygene
} from "./chunk-NWMLNNMV.js";
import {
  require_mipsasm
} from "./chunk-KBADJKZV.js";
import {
  require_mizar
} from "./chunk-CD2CJ52N.js";
import {
  require_perl
} from "./chunk-BBWSUW3U.js";
import {
  require_mojolicious
} from "./chunk-E2VDEILK.js";
import {
  require_monkey
} from "./chunk-YT3GVVYN.js";
import {
  require_moonscript
} from "./chunk-363IWAC2.js";
import {
  require_n1ql
} from "./chunk-MP6J7THP.js";
import {
  require_nginx
} from "./chunk-266NU7BV.js";
import {
  require_lsl
} from "./chunk-2GAKUF5J.js";
import {
  require_lua
} from "./chunk-36QSZQFW.js";
import {
  require_makefile
} from "./chunk-ZXIUXXN3.js";
import {
  require_mathematica
} from "./chunk-REWQLQLQ.js";
import {
  require_matlab
} from "./chunk-ERT7XDGJ.js";
import {
  require_maxima
} from "./chunk-WJY2VMLL.js";
import {
  require_mel
} from "./chunk-5ULQAELI.js";
import {
  require_mercury
} from "./chunk-54UJCEV3.js";
import {
  require_latex
} from "./chunk-QAJUWWDP.js";
import {
  require_ldif
} from "./chunk-L3U3RTZT.js";
import {
  require_leaf
} from "./chunk-F5RUDY7Z.js";
import {
  require_less
} from "./chunk-P7ON4O3V.js";
import {
  require_lisp
} from "./chunk-3A6NLVEJ.js";
import {
  require_livecodeserver
} from "./chunk-K6RYYP5E.js";
import {
  require_livescript
} from "./chunk-3U7IWS4G.js";
import {
  require_llvm
} from "./chunk-KNNALJBC.js";
import {
  require_java
} from "./chunk-DZEPILT5.js";
import {
  require_javascript
} from "./chunk-KPYP53LD.js";
import {
  require_jboss_cli
} from "./chunk-QVGL47XW.js";
import {
  require_json
} from "./chunk-ZSLMBQI7.js";
import {
  require_julia
} from "./chunk-26WPLJX4.js";
import {
  require_julia_repl
} from "./chunk-YJNIF3N4.js";
import {
  require_kotlin
} from "./chunk-CG6C5UIL.js";
import {
  require_lasso
} from "./chunk-F4FOVQHI.js";
import {
  require_hsp
} from "./chunk-JUQ5CMSN.js";
import {
  require_htmlbars
} from "./chunk-ISUD5OON.js";
import {
  require_http
} from "./chunk-Z5K6BJMH.js";
import {
  require_hy
} from "./chunk-JTZXMSUD.js";
import {
  require_inform7
} from "./chunk-343ZIXUA.js";
import {
  require_ini
} from "./chunk-PLUL6B44.js";
import {
  require_irpf90
} from "./chunk-NVRWRKUK.js";
import {
  require_isbl
} from "./chunk-XM26GWEW.js";
import {
  require_go
} from "./chunk-U6KUQCBU.js";
import {
  require_golo
} from "./chunk-O2254ZHN.js";
import {
  require_gradle
} from "./chunk-YS5N3YRR.js";
import {
  require_groovy
} from "./chunk-XIS6Y4IF.js";
import {
  require_haml
} from "./chunk-UV2CLNPV.js";
import {
  require_handlebars
} from "./chunk-E4KSJSXC.js";
import {
  require_haskell
} from "./chunk-GM5AU6BI.js";
import {
  require_haxe
} from "./chunk-K7QEHRBC.js";
import {
  require_fortran
} from "./chunk-3GSOQODX.js";
import {
  require_fsharp
} from "./chunk-2GDRKHPA.js";
import {
  require_gams
} from "./chunk-NRLRF2NG.js";
import {
  require_gauss
} from "./chunk-7BBPMROX.js";
import {
  require_gcode
} from "./chunk-QQMHTGNU.js";
import {
  require_gherkin
} from "./chunk-UQFLXHIU.js";
import {
  require_glsl
} from "./chunk-A7PV6IVF.js";
import {
  require_gml
} from "./chunk-QDKG2D6G.js";
import {
  require_elm
} from "./chunk-3XODC3OO.js";
import {
  require_ruby
} from "./chunk-K53Y2WVB.js";
import {
  require_erb
} from "./chunk-LLQUKLKC.js";
import {
  require_erlang_repl
} from "./chunk-BXJ2MGOF.js";
import {
  require_erlang
} from "./chunk-AXT4TDLD.js";
import {
  require_excel
} from "./chunk-P2EEIJP5.js";
import {
  require_fix
} from "./chunk-P3NEF5EJ.js";
import {
  require_flix
} from "./chunk-33UP4TT6.js";
import {
  require_dns
} from "./chunk-3SSBIFWF.js";
import {
  require_dockerfile
} from "./chunk-K7NVAJU5.js";
import {
  require_dos
} from "./chunk-6YXPFFHI.js";
import {
  require_dsconfig
} from "./chunk-XHD5FLPF.js";
import {
  require_dts
} from "./chunk-2AOB4N3D.js";
import {
  require_dust
} from "./chunk-45FL5I6D.js";
import {
  require_ebnf
} from "./chunk-FPZ4IDI2.js";
import {
  require_elixir
} from "./chunk-EMRWMNGH.js";
import {
  require_csp
} from "./chunk-HKJHSLUV.js";
import {
  require_css
} from "./chunk-IVWSDWZY.js";
import {
  require_d
} from "./chunk-I5G46PSL.js";
import {
  require_markdown
} from "./chunk-RI6TWFXH.js";
import {
  require_dart
} from "./chunk-VKKLS4OF.js";
import {
  require_delphi
} from "./chunk-HA7CQV7T.js";
import {
  require_diff
} from "./chunk-6CSHACUE.js";
import {
  require_django
} from "./chunk-KNIFI26I.js";
import {
  require_cmake
} from "./chunk-3VSGTXWY.js";
import {
  require_coffeescript
} from "./chunk-XOFPTLOP.js";
import {
  require_coq
} from "./chunk-TJE4YEAD.js";
import {
  require_cos
} from "./chunk-SYG22ZQB.js";
import {
  require_cpp
} from "./chunk-5IPEZX75.js";
import {
  require_crmsh
} from "./chunk-WU2ZTGM7.js";
import {
  require_crystal
} from "./chunk-T4HFNLJM.js";
import {
  require_csharp
} from "./chunk-2CXKX257.js";
import {
  require_c_like
} from "./chunk-R4FUQHOA.js";
import {
  require_c as require_c2
} from "./chunk-YP3HMHR5.js";
import {
  require_cal
} from "./chunk-65FYMMNC.js";
import {
  require_capnproto
} from "./chunk-RI5O2HLS.js";
import {
  require_ceylon
} from "./chunk-XP63EV4W.js";
import {
  require_clean
} from "./chunk-DK4PXQ3B.js";
import {
  require_clojure
} from "./chunk-IXFR4CNQ.js";
import {
  require_clojure_repl
} from "./chunk-KL3O3HFW.js";
import {
  require_autoit
} from "./chunk-77NVWQKQ.js";
import {
  require_avrasm
} from "./chunk-TQE3IYFP.js";
import {
  require_awk
} from "./chunk-ILKAMFZD.js";
import {
  require_axapta
} from "./chunk-MNMD6YF7.js";
import {
  require_bash
} from "./chunk-LZGW3HAH.js";
import {
  require_basic
} from "./chunk-6LUU3ESD.js";
import {
  require_bnf
} from "./chunk-IA2BT7K4.js";
import {
  require_brainfuck
} from "./chunk-6HGQSYVX.js";
import {
  require_applescript
} from "./chunk-6JOHBLMX.js";
import {
  require_arcade
} from "./chunk-MQA3MHK7.js";
import {
  require_arduino
} from "./chunk-R6RIBYGP.js";
import {
  require_armasm
} from "./chunk-62W2SWL5.js";
import {
  require_xml
} from "./chunk-PL55JBHD.js";
import {
  require_asciidoc
} from "./chunk-6GNLBSDT.js";
import {
  require_aspectj
} from "./chunk-EBZFFUY7.js";
import {
  require_autohotkey
} from "./chunk-4BSPTW7N.js";
import {
  require_core
} from "./chunk-4UB73M4G.js";
import {
  require_c
} from "./chunk-NIY7CWLD.js";
import {
  require_abnf
} from "./chunk-3252NQRQ.js";
import {
  require_accesslog
} from "./chunk-SDMVNJ53.js";
import {
  require_actionscript
} from "./chunk-E76EU3WZ.js";
import {
  require_ada
} from "./chunk-7KGABRCP.js";
import {
  require_angelscript
} from "./chunk-CLR4UGU3.js";
import {
  require_apache
} from "./chunk-XADHIPAS.js";
import {
  tokens
} from "./chunk-WWTN5JXH.js";
import {
  Circle_default,
  CollapseExpandLeft_default,
  CollapseExpandRight_default,
  ResizeCorner_default,
  Rhombus_default,
  Square_default,
  Triangle_default,
  import_ArrowLeftIcon,
  import_ArrowRightIcon,
  import_ArrowTopRightOnSquareIcon2 as import_ArrowTopRightOnSquareIcon,
  import_Bars3CenterLeftIcon,
  import_Bars3CenterLeftIcon2,
  import_BarsArrowDownIcon,
  import_BarsArrowUpIcon,
  import_CalendarIcon,
  import_CheckCircleIcon,
  import_CheckCircleIcon2,
  import_ChevronDownIcon,
  import_ChevronDownIcon2,
  import_ChevronLeftIcon,
  import_ChevronRightIcon,
  import_ChevronUpIcon,
  import_ExclamationCircleIcon,
  import_ExclamationCircleIcon2,
  import_ExclamationTriangleIcon,
  import_ExclamationTriangleIcon2,
  import_HomeIcon,
  import_InformationCircleIcon,
  import_InformationCircleIcon2,
  import_XMarkIcon
} from "./chunk-IRPEK4CZ.js";
import {
  require_jsx_runtime
} from "./chunk-U73TBONF.js";
import {
  require_react_dom
} from "./chunk-GSZ7ISAW.js";
import {
  require_react
} from "./chunk-ZGRSIX2Q.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module) {
    (function() {
      "use strict";
      var hasOwn2 = {}.hasOwnProperty;
      function classNames3() {
        var classes = "";
        for (var i2 = 0; i2 < arguments.length; i2++) {
          var arg = arguments[i2];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames3.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn2.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames3.default = classNames3;
        module.exports = classNames3;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames3;
        });
      } else {
        window.classNames = classNames3;
      }
    })();
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object2) {
          if (typeof object2 === "object" && object2 !== null) {
            var $$typeof = object2.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object2.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment10 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal2 = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object2) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object2) || typeOf(object2) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object2) {
          return typeOf(object2) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object2) {
          return typeOf(object2) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object2) {
          return typeOf(object2) === REACT_PROVIDER_TYPE;
        }
        function isElement4(object2) {
          return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object2) {
          return typeOf(object2) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object2) {
          return typeOf(object2) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object2) {
          return typeOf(object2) === REACT_LAZY_TYPE;
        }
        function isMemo(object2) {
          return typeOf(object2) === REACT_MEMO_TYPE;
        }
        function isPortal(object2) {
          return typeOf(object2) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object2) {
          return typeOf(object2) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object2) {
          return typeOf(object2) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object2) {
          return typeOf(object2) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment10;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal2;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement4;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i2 = 0; i2 < 10; i2++) {
          test2["_" + String.fromCharCode(i2)] = i2;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from2;
      var to = toObject(target);
      var symbols;
      for (var s3 = 1; s3 < arguments.length; s3++) {
        from2 = Object(arguments[s3]);
        for (var key in from2) {
          if (hasOwnProperty2.call(from2, key)) {
            to[key] = from2[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from2);
          for (var i2 = 0; i2 < symbols.length; i2++) {
            if (propIsEnumerable.call(from2, symbols[i2])) {
              to[symbols[i2]] = from2[symbols[i2]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x2) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign3 = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x2) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement2, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x2, y3) {
        if (x2 === y3) {
          return x2 !== 0 || 1 / x2 === 1 / y3;
        } else {
          return x2 !== x2 && y3 !== y3;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i2 = 0; i2 < propValue.length; i2++) {
            var error = typeChecker(propValue, i2, componentName, location, propFullName + "[" + i2 + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement2(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i2 = 0; i2 < expectedValues.length; i2++) {
            if (is(propValue, expectedValues[i2])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
          var checker = arrayOfTypeCheckers[i2];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i2 + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i3 = 0; i3 < arrayOfTypeCheckers.length; i3++) {
            var checker2 = arrayOfTypeCheckers[i3];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode4(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign3({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode4(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode4);
            }
            if (propValue === null || isValidElement2(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode4(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode4(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest14,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values,
  default: () => tslib_es6_default
});
function __extends(d3, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d3, b2);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __rest14(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
}
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d3 = decorators[i2])
        r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key, r2) : d3(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function")
      throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    var context = {};
    for (var p in contextIn)
      context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access)
      context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_ = accept(result.get))
        descriptor.get = _;
      if (_ = accept(result.set))
        descriptor.set = _;
      if (_ = accept(result.init))
        initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field")
        initializers.unshift(_);
      else
        descriptor[key] = _;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i2 = 0; i2 < initializers.length; i2++) {
    value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x2) {
  return typeof x2 === "symbol" ? x2 : "".concat(x2);
}
function __setFunctionName(f, name2, prefix3) {
  if (typeof name2 === "symbol")
    name2 = name2.description ? "[".concat(name2.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix3 ? "".concat(prefix3, " ", name2) : name2 });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e4) {
        reject(e4);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e4) {
        reject(e4);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t4[0] & 1)
      throw t4[1];
    return t4[1];
  }, trys: [], ops: [] }, f, y3, t4, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y3 && (t4 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t4 = y3["return"]) && t4.call(y3), 0) : y3.next) && !(t4 = t4.call(y3, op[1])).done)
          return t4;
        if (y3 = 0, t4)
          op = [op[0] & 2, t4.value];
        switch (op[0]) {
          case 0:
          case 1:
            t4 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t4 = _.trys, t4 = t4.length > 0 && t4[t4.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t4 || op[1] > t4[0] && op[1] < t4[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t4[1]) {
              _.label = t4[1];
              t4 = op;
              break;
            }
            if (t4 && _.label < t4[2]) {
              _.label = t4[2];
              _.ops.push(op);
              break;
            }
            if (t4[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e4) {
        op = [6, e4];
        y3 = 0;
      } finally {
        f = t4 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m3, o) {
  for (var p in m3)
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
      __createBinding(o, m3, p);
}
function __values(o) {
  var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o[s3], i2 = 0;
  if (m3)
    return m3.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i2 >= o.length)
          o = void 0;
        return { value: o && o[i2++], done: !o };
      }
    };
  throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m3 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m3)
    return o;
  var i2 = m3.call(o), r2, ar = [], e4;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e4 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"]))
        m3.call(i2);
    } finally {
      if (e4)
        throw e4.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
    ar = ar.concat(__read(arguments[i2]));
  return ar;
}
function __spreadArrays() {
  for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
    s3 += arguments[i2].length;
  for (var r2 = Array(s3), k2 = 0, i2 = 0; i2 < il; i2++)
    for (var a3 = arguments[i2], j = 0, jl = a3.length; j < jl; j++, k2++)
      r2[k2] = a3[j];
  return r2;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from2.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i2);
        ar[i2] = from2[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n) {
    if (g[n])
      i2[n] = function(v) {
        return new Promise(function(a3, b2) {
          q2.push([n, v, a3, b2]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e4) {
      settle(q2[0][3], e4);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator(o) {
  var i2, p;
  return i2 = {}, verb("next"), verb("throw", function(e4) {
    throw e4;
  }), verb("return"), i2[Symbol.iterator] = function() {
    return this;
  }, i2;
  function verb(n, f) {
    i2[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m3 = o[Symbol.asyncIterator], i2;
  return m3 ? m3.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n) {
    i2[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d3, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d3 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding(result, mod, k2);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env2, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env2.stack.push({ value, dispose, async });
  } else if (async) {
    env2.stack.push({ async: true });
  }
  return value;
}
function __disposeResources(env2) {
  function fail(e4) {
    env2.error = env2.hasError ? new _SuppressedError(e4, env2.error, "An error was suppressed during disposal.") : e4;
    env2.hasError = true;
  }
  function next2() {
    while (env2.stack.length) {
      var rec = env2.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async)
          return Promise.resolve(result).then(next2, function(e4) {
            fail(e4);
            return next2();
          });
      } catch (e4) {
        fail(e4);
      }
    }
    if (env2.hasError)
      throw env2.error;
  }
  return next2();
}
var extendStatics, __assign, __createBinding, __setModuleDefault, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.mjs"() {
    extendStatics = function(d3, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
        d4.__proto__ = b3;
      } || function(d4, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d4[p] = b3[p];
      };
      return extendStatics(d3, b2);
    };
    __assign = function() {
      __assign = Object.assign || function __assign4(t4) {
        for (var s3, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s3 = arguments[i2];
          for (var p in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p))
              t4[p] = s3[p];
        }
        return t4;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? function(o, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m3, k2);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m3[k2];
    };
    __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e4 = new Error(message);
      return e4.name = "SuppressedError", e4.error = error, e4.suppressed = suppressed, e4;
    };
    tslib_es6_default = {
      __extends,
      __assign,
      __rest: __rest14,
      __decorate,
      __param,
      __metadata,
      __awaiter,
      __generator,
      __createBinding,
      __exportStar,
      __values,
      __read,
      __spread,
      __spreadArrays,
      __spreadArray,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault,
      __classPrivateFieldGet,
      __classPrivateFieldSet,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources
    };
  }
});

// node_modules/react-fast-compare/index.js
var require_react_fast_compare = __commonJS({
  "node_modules/react-fast-compare/index.js"(exports, module) {
    var hasElementType = typeof Element !== "undefined";
    var hasMap = typeof Map === "function";
    var hasSet = typeof Set === "function";
    var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
    function equal(a3, b2) {
      if (a3 === b2)
        return true;
      if (a3 && b2 && typeof a3 == "object" && typeof b2 == "object") {
        if (a3.constructor !== b2.constructor)
          return false;
        var length2, i2, keys2;
        if (Array.isArray(a3)) {
          length2 = a3.length;
          if (length2 != b2.length)
            return false;
          for (i2 = length2; i2-- !== 0; )
            if (!equal(a3[i2], b2[i2]))
              return false;
          return true;
        }
        var it2;
        if (hasMap && a3 instanceof Map && b2 instanceof Map) {
          if (a3.size !== b2.size)
            return false;
          it2 = a3.entries();
          while (!(i2 = it2.next()).done)
            if (!b2.has(i2.value[0]))
              return false;
          it2 = a3.entries();
          while (!(i2 = it2.next()).done)
            if (!equal(i2.value[1], b2.get(i2.value[0])))
              return false;
          return true;
        }
        if (hasSet && a3 instanceof Set && b2 instanceof Set) {
          if (a3.size !== b2.size)
            return false;
          it2 = a3.entries();
          while (!(i2 = it2.next()).done)
            if (!b2.has(i2.value[0]))
              return false;
          return true;
        }
        if (hasArrayBuffer && ArrayBuffer.isView(a3) && ArrayBuffer.isView(b2)) {
          length2 = a3.length;
          if (length2 != b2.length)
            return false;
          for (i2 = length2; i2-- !== 0; )
            if (a3[i2] !== b2[i2])
              return false;
          return true;
        }
        if (a3.constructor === RegExp)
          return a3.source === b2.source && a3.flags === b2.flags;
        if (a3.valueOf !== Object.prototype.valueOf && typeof a3.valueOf === "function" && typeof b2.valueOf === "function")
          return a3.valueOf() === b2.valueOf();
        if (a3.toString !== Object.prototype.toString && typeof a3.toString === "function" && typeof b2.toString === "function")
          return a3.toString() === b2.toString();
        keys2 = Object.keys(a3);
        length2 = keys2.length;
        if (length2 !== Object.keys(b2).length)
          return false;
        for (i2 = length2; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b2, keys2[i2]))
            return false;
        if (hasElementType && a3 instanceof Element)
          return false;
        for (i2 = length2; i2-- !== 0; ) {
          if ((keys2[i2] === "_owner" || keys2[i2] === "__v" || keys2[i2] === "__o") && a3.$$typeof) {
            continue;
          }
          if (!equal(a3[keys2[i2]], b2[keys2[i2]]))
            return false;
        }
        return true;
      }
      return a3 !== a3 && b2 !== b2;
    }
    module.exports = function isEqual4(a3, b2) {
      try {
        return equal(a3, b2);
      } catch (error) {
        if ((error.message || "").match(/stack|recursion/i)) {
          console.warn("react-fast-compare cannot handle circular refs");
          return false;
        }
        throw error;
      }
    };
  }
});

// node_modules/warning/warning.js
var require_warning = __commonJS({
  "node_modules/warning/warning.js"(exports, module) {
    "use strict";
    var __DEV__ = true;
    var warning2 = function() {
    };
    if (__DEV__) {
      printWarning = function printWarning2(format3, args) {
        var len = arguments.length;
        args = new Array(len > 1 ? len - 1 : 0);
        for (var key = 1; key < len; key++) {
          args[key - 1] = arguments[key];
        }
        var argIndex = 0;
        var message = "Warning: " + format3.replace(/%s/g, function() {
          return args[argIndex++];
        });
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x2) {
        }
      };
      warning2 = function(condition, format3, args) {
        var len = arguments.length;
        args = new Array(len > 2 ? len - 2 : 0);
        for (var key = 2; key < len; key++) {
          args[key - 2] = arguments[key];
        }
        if (format3 === void 0) {
          throw new Error(
            "`warning(condition, format, ...args)` requires a warning message argument"
          );
        }
        if (!condition) {
          printWarning.apply(null, [format3].concat(args));
        }
      };
    }
    var printWarning;
    module.exports = warning2;
  }
});

// node_modules/fast-deep-equal/react.js
var require_react2 = __commonJS({
  "node_modules/fast-deep-equal/react.js"(exports, module) {
    "use strict";
    module.exports = function equal(a3, b2) {
      if (a3 === b2)
        return true;
      if (a3 && b2 && typeof a3 == "object" && typeof b2 == "object") {
        if (a3.constructor !== b2.constructor)
          return false;
        var length2, i2, keys2;
        if (Array.isArray(a3)) {
          length2 = a3.length;
          if (length2 != b2.length)
            return false;
          for (i2 = length2; i2-- !== 0; )
            if (!equal(a3[i2], b2[i2]))
              return false;
          return true;
        }
        if (a3.constructor === RegExp)
          return a3.source === b2.source && a3.flags === b2.flags;
        if (a3.valueOf !== Object.prototype.valueOf)
          return a3.valueOf() === b2.valueOf();
        if (a3.toString !== Object.prototype.toString)
          return a3.toString() === b2.toString();
        keys2 = Object.keys(a3);
        length2 = keys2.length;
        if (length2 !== Object.keys(b2).length)
          return false;
        for (i2 = length2; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b2, keys2[i2]))
            return false;
        for (i2 = length2; i2-- !== 0; ) {
          var key = keys2[i2];
          if (key === "_owner" && a3.$$typeof) {
            continue;
          }
          if (!equal(a3[key], b2[key]))
            return false;
        }
        return true;
      }
      return a3 !== a3 && b2 !== b2;
    };
  }
});

// node_modules/js-cookie/src/js.cookie.js
var require_js_cookie = __commonJS({
  "node_modules/js-cookie/src/js.cookie.js"(exports, module) {
    (function(factory) {
      var registeredInModuleLoader;
      if (typeof define === "function" && define.amd) {
        define(factory);
        registeredInModuleLoader = true;
      }
      if (typeof exports === "object") {
        module.exports = factory();
        registeredInModuleLoader = true;
      }
      if (!registeredInModuleLoader) {
        var OldCookies = window.Cookies;
        var api = window.Cookies = factory();
        api.noConflict = function() {
          window.Cookies = OldCookies;
          return api;
        };
      }
    })(function() {
      function extend2() {
        var i2 = 0;
        var result = {};
        for (; i2 < arguments.length; i2++) {
          var attributes = arguments[i2];
          for (var key in attributes) {
            result[key] = attributes[key];
          }
        }
        return result;
      }
      function decode(s3) {
        return s3.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
      }
      function init(converter) {
        function api() {
        }
        function set2(key, value, attributes) {
          if (typeof document === "undefined") {
            return;
          }
          attributes = extend2({
            path: "/"
          }, api.defaults, attributes);
          if (typeof attributes.expires === "number") {
            attributes.expires = new Date(/* @__PURE__ */ new Date() * 1 + attributes.expires * 864e5);
          }
          attributes.expires = attributes.expires ? attributes.expires.toUTCString() : "";
          try {
            var result = JSON.stringify(value);
            if (/^[\{\[]/.test(result)) {
              value = result;
            }
          } catch (e4) {
          }
          value = converter.write ? converter.write(value, key) : encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
          key = encodeURIComponent(String(key)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape);
          var stringifiedAttributes = "";
          for (var attributeName in attributes) {
            if (!attributes[attributeName]) {
              continue;
            }
            stringifiedAttributes += "; " + attributeName;
            if (attributes[attributeName] === true) {
              continue;
            }
            stringifiedAttributes += "=" + attributes[attributeName].split(";")[0];
          }
          return document.cookie = key + "=" + value + stringifiedAttributes;
        }
        function get2(key, json) {
          if (typeof document === "undefined") {
            return;
          }
          var jar = {};
          var cookies = document.cookie ? document.cookie.split("; ") : [];
          var i2 = 0;
          for (; i2 < cookies.length; i2++) {
            var parts = cookies[i2].split("=");
            var cookie = parts.slice(1).join("=");
            if (!json && cookie.charAt(0) === '"') {
              cookie = cookie.slice(1, -1);
            }
            try {
              var name2 = decode(parts[0]);
              cookie = (converter.read || converter)(cookie, name2) || decode(cookie);
              if (json) {
                try {
                  cookie = JSON.parse(cookie);
                } catch (e4) {
                }
              }
              jar[name2] = cookie;
              if (key === name2) {
                break;
              }
            } catch (e4) {
            }
          }
          return key ? jar[key] : jar;
        }
        api.set = set2;
        api.get = function(key) {
          return get2(
            key,
            false
            /* read as raw */
          );
        };
        api.getJSON = function(key) {
          return get2(
            key,
            true
            /* read as json */
          );
        };
        api.remove = function(key, attributes) {
          set2(key, "", extend2(attributes, {
            expires: -1
          }));
        };
        api.defaults = {};
        api.withConverter = init;
        return api;
      }
      return init(function() {
      });
    });
  }
});

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports, module) {
    module.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i2 = 0; i2 < selection.rangeCount; i2++) {
        ranges.push(selection.getRangeAt(i2));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range) {
            selection.addRange(range);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports, module) {
    "use strict";
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format3(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy2(text, options2) {
      var debug, message, reselectPrevious, range, selection, mark, success = false;
      if (!options2) {
        options2 = {};
      }
      debug = options2.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e4) {
          e4.stopPropagation();
          if (options2.format) {
            e4.preventDefault();
            if (typeof e4.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format4 = clipboardToIE11Formatting[options2.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format4, text);
            } else {
              e4.clipboardData.clearData();
              e4.clipboardData.setData(options2.format, text);
            }
          }
          if (options2.onCopy) {
            e4.preventDefault();
            options2.onCopy(e4.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range.selectNodeContents(mark);
        selection.addRange(range);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options2.format || "text", text);
          options2.onCopy && options2.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message = format3("message" in options2 ? options2.message : defaultMessage);
          window.prompt(message, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module.exports = copy2;
  }
});

// node_modules/nano-css/index.js
var require_nano_css = __commonJS({
  "node_modules/nano-css/index.js"(exports) {
    "use strict";
    var KEBAB_REGEX = /[A-Z]/g;
    var hash4 = function(str) {
      var h3 = 5381, i2 = str.length;
      while (i2)
        h3 = h3 * 33 ^ str.charCodeAt(--i2);
      return "_" + (h3 >>> 0).toString(36);
    };
    exports.create = function(config2) {
      config2 = config2 || {};
      var assign3 = config2.assign || Object.assign;
      var client = typeof window === "object";
      if (true) {
        if (client) {
          if (typeof document !== "object" || !document.getElementsByTagName("HTML")) {
            console.error(
              'nano-css detected browser environment because of "window" global, but "document" global seems to be defective.'
            );
          }
        }
      }
      var renderer = assign3({
        raw: "",
        pfx: "_",
        client,
        assign: assign3,
        stringify: JSON.stringify,
        kebab: function(prop) {
          return prop.replace(KEBAB_REGEX, "-$&").toLowerCase();
        },
        decl: function(key, value) {
          key = renderer.kebab(key);
          return key + ":" + value + ";";
        },
        hash: function(obj) {
          return hash4(renderer.stringify(obj));
        },
        selector: function(parent, selector) {
          return parent + (selector[0] === ":" ? "" : " ") + selector;
        },
        putRaw: function(rawCssRule) {
          renderer.raw += rawCssRule;
        }
      }, config2);
      if (renderer.client) {
        if (!renderer.sh)
          document.head.appendChild(renderer.sh = document.createElement("style"));
        if (true) {
          renderer.sh.setAttribute("data-nano-css-dev", "");
          renderer.shTest = document.createElement("style");
          renderer.shTest.setAttribute("data-nano-css-dev-tests", "");
          document.head.appendChild(renderer.shTest);
        }
        renderer.putRaw = function(rawCssRule) {
          if (false) {
            var sheet = renderer.sh.sheet;
            try {
              sheet.insertRule(rawCssRule, sheet.cssRules.length);
            } catch (error) {
            }
          } else {
            try {
              renderer.shTest.sheet.insertRule(rawCssRule, renderer.shTest.sheet.cssRules.length);
            } catch (error) {
              if (config2.verbose) {
                console.error(error);
              }
            }
            renderer.sh.appendChild(document.createTextNode(rawCssRule));
          }
        };
      }
      renderer.put = function(selector, decls, atrule) {
        var str = "";
        var prop, value;
        var postponed = [];
        for (prop in decls) {
          value = decls[prop];
          if (value instanceof Object && !(value instanceof Array)) {
            postponed.push(prop);
          } else {
            if (!renderer.sourcemaps) {
              str += "    " + renderer.decl(prop, value, selector, atrule) + "\n";
            } else {
              str += renderer.decl(prop, value, selector, atrule);
            }
          }
        }
        if (str) {
          if (!renderer.sourcemaps) {
            str = "\n" + selector + " {\n" + str + "}\n";
          } else {
            str = selector + "{" + str + "}";
          }
          renderer.putRaw(atrule ? atrule + "{" + str + "}" : str);
        }
        for (var i2 = 0; i2 < postponed.length; i2++) {
          prop = postponed[i2];
          if (prop[0] === "@" && prop !== "@font-face") {
            renderer.putAt(selector, decls[prop], prop);
          } else {
            renderer.put(renderer.selector(selector, prop), decls[prop], atrule);
          }
        }
      };
      renderer.putAt = renderer.put;
      return renderer;
    };
  }
});

// node_modules/nano-css/addon/__dev__/warnOnMissingDependencies.js
var require_warnOnMissingDependencies = __commonJS({
  "node_modules/nano-css/addon/__dev__/warnOnMissingDependencies.js"(exports, module) {
    "use strict";
    var pkgName = "nano-css";
    module.exports = function warnOnMissingDependencies(addon, renderer, deps) {
      var missing = [];
      for (var i2 = 0; i2 < deps.length; i2++) {
        var name2 = deps[i2];
        if (!renderer[name2]) {
          missing.push(name2);
        }
      }
      if (missing.length) {
        var str = 'Addon "' + addon + '" is missing the following dependencies:';
        for (var j = 0; j < missing.length; j++) {
          str += '\n require("' + pkgName + "/addon/" + missing[j] + '").addon(nano);';
        }
        throw new Error(str);
      }
    };
  }
});

// node_modules/nano-css/addon/cssom.js
var require_cssom = __commonJS({
  "node_modules/nano-css/addon/cssom.js"(exports) {
    "use strict";
    exports.addon = function(renderer) {
      if (!renderer.client)
        return;
      if (true) {
        require_warnOnMissingDependencies()("cssom", renderer, ["sh"]);
      }
      document.head.appendChild(renderer.msh = document.createElement("style"));
      renderer.createRule = function(selector, prelude) {
        var rawCss = selector + "{}";
        if (prelude)
          rawCss = prelude + "{" + rawCss + "}";
        var sheet = prelude ? renderer.msh.sheet : renderer.sh.sheet;
        var index4 = sheet.insertRule(rawCss, sheet.cssRules.length);
        var rule = (sheet.cssRules || sheet.rules)[index4];
        rule.index = index4;
        if (prelude) {
          var selectorRule = (rule.cssRules || rule.rules)[0];
          rule.style = selectorRule.style;
          rule.styleMap = selectorRule.styleMap;
        }
        return rule;
      };
    };
  }
});

// node_modules/nano-css/addon/vcssom/removeRule.js
var require_removeRule = __commonJS({
  "node_modules/nano-css/addon/vcssom/removeRule.js"(exports) {
    function removeRule(rule) {
      var maxIndex = rule.index;
      var sh = rule.parentStyleSheet;
      var rules = sh.cssRules || sh.rules;
      maxIndex = Math.max(maxIndex, rules.length - 1);
      while (maxIndex >= 0) {
        if (rules[maxIndex] === rule) {
          sh.deleteRule(maxIndex);
          break;
        }
        maxIndex--;
      }
    }
    exports.removeRule = removeRule;
  }
});

// node_modules/nano-css/addon/vcssom.js
var require_vcssom = __commonJS({
  "node_modules/nano-css/addon/vcssom.js"(exports) {
    "use strict";
    var removeRule = require_removeRule().removeRule;
    exports.addon = function(renderer) {
      if (!renderer.client)
        return;
      if (true) {
        require_warnOnMissingDependencies()("cssom", renderer, ["createRule"]);
      }
      var kebab = renderer.kebab;
      function VRule(selector, prelude) {
        this.rule = renderer.createRule(selector, prelude);
        this.decl = {};
      }
      VRule.prototype.diff = function(newDecl) {
        var oldDecl = this.decl;
        var style = this.rule.style;
        var property;
        for (property in oldDecl)
          if (newDecl[property] === void 0)
            style.removeProperty(property);
        for (property in newDecl)
          if (newDecl[property] !== oldDecl[property])
            style.setProperty(kebab(property), newDecl[property]);
        this.decl = newDecl;
      };
      VRule.prototype.del = function() {
        removeRule(this.rule);
      };
      function VSheet() {
        this.tree = {};
      }
      VSheet.prototype.diff = function(newTree) {
        var oldTree = this.tree;
        for (var prelude in oldTree) {
          if (newTree[prelude] === void 0) {
            var rules = oldTree[prelude];
            for (var selector in rules)
              rules[selector].del();
          }
        }
        for (var prelude in newTree) {
          if (oldTree[prelude] === void 0) {
            for (var selector in newTree[prelude]) {
              var rule = new VRule(selector, prelude);
              rule.diff(newTree[prelude][selector]);
              newTree[prelude][selector] = rule;
            }
          } else {
            var oldRules = oldTree[prelude];
            var newRules = newTree[prelude];
            for (var selector in oldRules)
              if (!newRules[selector])
                oldRules[selector].del();
            for (var selector in newRules) {
              var rule = oldRules[selector];
              if (rule) {
                rule.diff(newRules[selector]);
                newRules[selector] = rule;
              } else {
                rule = new VRule(selector, prelude);
                rule.diff(newRules[selector]);
                newRules[selector] = rule;
              }
            }
          }
        }
        this.tree = newTree;
      };
      renderer.VRule = VRule;
      renderer.VSheet = VSheet;
    };
  }
});

// node_modules/nano-css/addon/vcssom/cssToTree.js
var require_cssToTree = __commonJS({
  "node_modules/nano-css/addon/vcssom/cssToTree.js"(exports) {
    function cssToTree2(tree, css5, selector, prelude) {
      var declarations = {};
      var hasDeclarations = false;
      var key, value;
      for (key in css5) {
        value = css5[key];
        if (typeof value !== "object") {
          hasDeclarations = true;
          declarations[key] = value;
        }
      }
      if (hasDeclarations) {
        if (!tree[prelude])
          tree[prelude] = {};
        tree[prelude][selector] = declarations;
      }
      for (key in css5) {
        value = css5[key];
        if (typeof value === "object") {
          if (key[0] === "@") {
            cssToTree2(tree, value, selector, key);
          } else {
            var hasCurrentSymbol = key.indexOf("&") > -1;
            var selectorParts = selector.split(",");
            if (hasCurrentSymbol) {
              for (var i2 = 0; i2 < selectorParts.length; i2++) {
                selectorParts[i2] = key.replace(/&/g, selectorParts[i2]);
              }
            } else {
              for (var i2 = 0; i2 < selectorParts.length; i2++) {
                selectorParts[i2] = selectorParts[i2] + " " + key;
              }
            }
            cssToTree2(tree, value, selectorParts.join(","), prelude);
          }
        }
      }
    }
    exports.cssToTree = cssToTree2;
  }
});

// node_modules/screenfull/dist/screenfull.js
var require_screenfull = __commonJS({
  "node_modules/screenfull/dist/screenfull.js"(exports, module) {
    (function() {
      "use strict";
      var document2 = typeof window !== "undefined" && typeof window.document !== "undefined" ? window.document : {};
      var isCommonjs = typeof module !== "undefined" && module.exports;
      var fn2 = function() {
        var val;
        var fnMap = [
          [
            "requestFullscreen",
            "exitFullscreen",
            "fullscreenElement",
            "fullscreenEnabled",
            "fullscreenchange",
            "fullscreenerror"
          ],
          // New WebKit
          [
            "webkitRequestFullscreen",
            "webkitExitFullscreen",
            "webkitFullscreenElement",
            "webkitFullscreenEnabled",
            "webkitfullscreenchange",
            "webkitfullscreenerror"
          ],
          // Old WebKit
          [
            "webkitRequestFullScreen",
            "webkitCancelFullScreen",
            "webkitCurrentFullScreenElement",
            "webkitCancelFullScreen",
            "webkitfullscreenchange",
            "webkitfullscreenerror"
          ],
          [
            "mozRequestFullScreen",
            "mozCancelFullScreen",
            "mozFullScreenElement",
            "mozFullScreenEnabled",
            "mozfullscreenchange",
            "mozfullscreenerror"
          ],
          [
            "msRequestFullscreen",
            "msExitFullscreen",
            "msFullscreenElement",
            "msFullscreenEnabled",
            "MSFullscreenChange",
            "MSFullscreenError"
          ]
        ];
        var i2 = 0;
        var l = fnMap.length;
        var ret = {};
        for (; i2 < l; i2++) {
          val = fnMap[i2];
          if (val && val[1] in document2) {
            for (i2 = 0; i2 < val.length; i2++) {
              ret[fnMap[0][i2]] = val[i2];
            }
            return ret;
          }
        }
        return false;
      }();
      var eventNameMap = {
        change: fn2.fullscreenchange,
        error: fn2.fullscreenerror
      };
      var screenfull2 = {
        request: function(element, options2) {
          return new Promise((function(resolve, reject) {
            var onFullScreenEntered = (function() {
              this.off("change", onFullScreenEntered);
              resolve();
            }).bind(this);
            this.on("change", onFullScreenEntered);
            element = element || document2.documentElement;
            var returnPromise = element[fn2.requestFullscreen](options2);
            if (returnPromise instanceof Promise) {
              returnPromise.then(onFullScreenEntered).catch(reject);
            }
          }).bind(this));
        },
        exit: function() {
          return new Promise((function(resolve, reject) {
            if (!this.isFullscreen) {
              resolve();
              return;
            }
            var onFullScreenExit = (function() {
              this.off("change", onFullScreenExit);
              resolve();
            }).bind(this);
            this.on("change", onFullScreenExit);
            var returnPromise = document2[fn2.exitFullscreen]();
            if (returnPromise instanceof Promise) {
              returnPromise.then(onFullScreenExit).catch(reject);
            }
          }).bind(this));
        },
        toggle: function(element, options2) {
          return this.isFullscreen ? this.exit() : this.request(element, options2);
        },
        onchange: function(callback) {
          this.on("change", callback);
        },
        onerror: function(callback) {
          this.on("error", callback);
        },
        on: function(event, callback) {
          var eventName = eventNameMap[event];
          if (eventName) {
            document2.addEventListener(eventName, callback, false);
          }
        },
        off: function(event, callback) {
          var eventName = eventNameMap[event];
          if (eventName) {
            document2.removeEventListener(eventName, callback, false);
          }
        },
        raw: fn2
      };
      if (!fn2) {
        if (isCommonjs) {
          module.exports = { isEnabled: false };
        } else {
          window.screenfull = { isEnabled: false };
        }
        return;
      }
      Object.defineProperties(screenfull2, {
        isFullscreen: {
          get: function() {
            return Boolean(document2[fn2.fullscreenElement]);
          }
        },
        element: {
          enumerable: true,
          get: function() {
            return document2[fn2.fullscreenElement];
          }
        },
        isEnabled: {
          enumerable: true,
          get: function() {
            return Boolean(document2[fn2.fullscreenEnabled]);
          }
        }
      });
      if (isCommonjs) {
        module.exports = screenfull2;
      } else {
        window.screenfull = screenfull2;
      }
    })();
  }
});

// node_modules/react-universal-interface/lib/render.js
var require_render = __commonJS({
  "node_modules/react-universal-interface/lib/render.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var react_1 = require_react();
    var isReact16Plus = parseInt(react_1.version.substr(0, react_1.version.indexOf("."))) > 15;
    var isFn = function(fn2) {
      return typeof fn2 === "function";
    };
    var render2 = function(props, data) {
      var more = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        more[_i - 2] = arguments[_i];
      }
      if (true) {
        if (typeof props !== "object") {
          throw new TypeError("renderChildren(props, data) first argument must be a props object.");
        }
        var children_1 = props.children, render_1 = props.render;
        if (isFn(children_1) && isFn(render_1)) {
          console.warn('Both "render" and "children" are specified for in a universal interface component. Children will be used.');
          console.trace();
        }
        if (typeof data !== "object") {
          console.warn("Universal component interface normally expects data to be an object, " + ('"' + typeof data + '" received.'));
          console.trace();
        }
      }
      var render3 = props.render, _a2 = props.children, children = _a2 === void 0 ? render3 : _a2, component = props.component, _b = props.comp, comp = _b === void 0 ? component : _b;
      if (isFn(children))
        return children.apply(void 0, tslib_1.__spreadArrays([data], more));
      if (comp) {
        return react_1.createElement(comp, data);
      }
      if (children instanceof Array)
        return isReact16Plus ? children : react_1.createElement.apply(void 0, tslib_1.__spreadArrays(["div", null], children));
      if (children && children instanceof Object) {
        if (true) {
          if (!children.type || typeof children.type !== "string" && typeof children.type !== "function" && typeof children.type !== "symbol") {
            console.warn('Universal component interface received object as children, expected React element, but received unexpected React "type".');
            console.trace();
          }
          if (typeof children.type === "string")
            return children;
          return react_1.cloneElement(children, Object.assign({}, children.props, data));
        } else {
          if (typeof children.type === "string")
            return children;
          return react_1.cloneElement(children, Object.assign({}, children.props, data));
        }
      }
      return children || null;
    };
    exports.default = render2;
  }
});

// node_modules/react-universal-interface/lib/wrapInStatefulComponent.js
var require_wrapInStatefulComponent = __commonJS({
  "node_modules/react-universal-interface/lib/wrapInStatefulComponent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var React63 = tslib_1.__importStar(require_react());
    var wrapInStatefulComponent = function(Comp) {
      var Decorated = function(_super) {
        tslib_1.__extends(class_1, _super);
        function class_1() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        class_1.prototype.render = function() {
          return Comp(this.props, this.context);
        };
        return class_1;
      }(React63.Component);
      if (true) {
        Decorated.displayName = "Decorated(" + (Comp.displayName || Comp.name) + ")";
      }
      return Decorated;
    };
    exports.default = wrapInStatefulComponent;
  }
});

// node_modules/react-universal-interface/lib/addClassDecoratorSupport.js
var require_addClassDecoratorSupport = __commonJS({
  "node_modules/react-universal-interface/lib/addClassDecoratorSupport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var wrapInStatefulComponent_1 = tslib_1.__importDefault(require_wrapInStatefulComponent());
    var addClassDecoratorSupport = function(Comp) {
      var isSFC = !Comp.prototype;
      return !isSFC ? Comp : wrapInStatefulComponent_1.default(Comp);
    };
    exports.default = addClassDecoratorSupport;
  }
});

// node_modules/react-universal-interface/lib/createEnhancer.js
var require_createEnhancer = __commonJS({
  "node_modules/react-universal-interface/lib/createEnhancer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.divWrapper = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var React63 = tslib_1.__importStar(require_react());
    var addClassDecoratorSupport_1 = tslib_1.__importDefault(require_addClassDecoratorSupport());
    var h3 = React63.createElement;
    var noWrap = function(Comp, propName, props, state) {
      var _a2;
      return h3(Comp, propName ? tslib_1.__assign((_a2 = {}, _a2[propName] = state, _a2), props) : tslib_1.__assign(tslib_1.__assign({}, state), props));
    };
    exports.divWrapper = function(Comp, propName, props, state) {
      return h3("div", null, noWrap(Comp, propName, props, state));
    };
    var createEnhancer = function(Facc, prop, wrapper) {
      if (wrapper === void 0) {
        wrapper = noWrap;
      }
      var enhancer = function(Comp, propName, faccProps) {
        if (propName === void 0) {
          propName = prop;
        }
        if (faccProps === void 0) {
          faccProps = null;
        }
        var isClassDecoratorMethodCall = typeof Comp === "string";
        if (isClassDecoratorMethodCall) {
          return function(Klass) {
            return enhancer(Klass, Comp || prop, propName);
          };
        }
        var Enhanced = function(props) {
          return h3(Facc, faccProps, function(state) {
            return wrapper(Comp, propName, props, state);
          });
        };
        if (true) {
          Enhanced.displayName = (Facc.displayName || Facc.name) + "(" + (Comp.displayName || Comp.name) + ")";
        }
        return isClassDecoratorMethodCall ? addClassDecoratorSupport_1.default(Enhanced) : Enhanced;
      };
      return enhancer;
    };
    exports.default = createEnhancer;
  }
});

// node_modules/react-universal-interface/lib/hookToRenderProp.js
var require_hookToRenderProp = __commonJS({
  "node_modules/react-universal-interface/lib/hookToRenderProp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var render_1 = tslib_1.__importDefault(require_render());
    var defaultMapPropsToArgs = function(props) {
      return [props];
    };
    var hookToRenderProp = function(hook, mapPropsToArgs) {
      if (mapPropsToArgs === void 0) {
        mapPropsToArgs = defaultMapPropsToArgs;
      }
      return function(props) {
        return render_1.default(props, hook.apply(void 0, mapPropsToArgs(props)));
      };
    };
    exports.default = hookToRenderProp;
  }
});

// node_modules/react-universal-interface/lib/index.js
var require_lib = __commonJS({
  "node_modules/react-universal-interface/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hookToRenderProp = exports.createEnhancer = exports.render = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var render_1 = tslib_1.__importDefault(require_render());
    exports.render = render_1.default;
    var createEnhancer_1 = tslib_1.__importDefault(require_createEnhancer());
    exports.createEnhancer = createEnhancer_1.default;
    var hookToRenderProp_1 = tslib_1.__importDefault(require_hookToRenderProp());
    exports.hookToRenderProp = hookToRenderProp_1.default;
  }
});

// node_modules/fast-shallow-equal/index.js
var require_fast_shallow_equal = __commonJS({
  "node_modules/fast-shallow-equal/index.js"(exports) {
    var keyList = Object.keys;
    exports.equal = function equal(a3, b2) {
      if (a3 === b2)
        return true;
      if (!(a3 instanceof Object) || !(b2 instanceof Object))
        return false;
      var keys2 = keyList(a3);
      var length2 = keys2.length;
      for (var i2 = 0; i2 < length2; i2++)
        if (!(keys2[i2] in b2))
          return false;
      for (var i2 = 0; i2 < length2; i2++)
        if (a3[keys2[i2]] !== b2[keys2[i2]])
          return false;
      return length2 === keyList(b2).length;
    };
  }
});

// node_modules/ts-easing/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/ts-easing/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.easing = {
      // No easing, no acceleration
      linear: function(t4) {
        return t4;
      },
      // Accelerates fast, then slows quickly towards end.
      quadratic: function(t4) {
        return t4 * (-(t4 * t4) * t4 + 4 * t4 * t4 - 6 * t4 + 4);
      },
      // Overshoots over 1 and then returns to 1 towards end.
      cubic: function(t4) {
        return t4 * (4 * t4 * t4 - 9 * t4 + 6);
      },
      // Overshoots over 1 multiple times - wiggles around 1.
      elastic: function(t4) {
        return t4 * (33 * t4 * t4 * t4 * t4 - 106 * t4 * t4 * t4 + 126 * t4 * t4 - 67 * t4 + 15);
      },
      // Accelerating from zero velocity
      inQuad: function(t4) {
        return t4 * t4;
      },
      // Decelerating to zero velocity
      outQuad: function(t4) {
        return t4 * (2 - t4);
      },
      // Acceleration until halfway, then deceleration
      inOutQuad: function(t4) {
        return t4 < 0.5 ? 2 * t4 * t4 : -1 + (4 - 2 * t4) * t4;
      },
      // Accelerating from zero velocity
      inCubic: function(t4) {
        return t4 * t4 * t4;
      },
      // Decelerating to zero velocity
      outCubic: function(t4) {
        return --t4 * t4 * t4 + 1;
      },
      // Acceleration until halfway, then deceleration
      inOutCubic: function(t4) {
        return t4 < 0.5 ? 4 * t4 * t4 * t4 : (t4 - 1) * (2 * t4 - 2) * (2 * t4 - 2) + 1;
      },
      // Accelerating from zero velocity
      inQuart: function(t4) {
        return t4 * t4 * t4 * t4;
      },
      // Decelerating to zero velocity
      outQuart: function(t4) {
        return 1 - --t4 * t4 * t4 * t4;
      },
      // Acceleration until halfway, then deceleration
      inOutQuart: function(t4) {
        return t4 < 0.5 ? 8 * t4 * t4 * t4 * t4 : 1 - 8 * --t4 * t4 * t4 * t4;
      },
      // Accelerating from zero velocity
      inQuint: function(t4) {
        return t4 * t4 * t4 * t4 * t4;
      },
      // Decelerating to zero velocity
      outQuint: function(t4) {
        return 1 + --t4 * t4 * t4 * t4 * t4;
      },
      // Acceleration until halfway, then deceleration
      inOutQuint: function(t4) {
        return t4 < 0.5 ? 16 * t4 * t4 * t4 * t4 * t4 : 1 + 16 * --t4 * t4 * t4 * t4 * t4;
      },
      // Accelerating from zero velocity
      inSine: function(t4) {
        return -Math.cos(t4 * (Math.PI / 2)) + 1;
      },
      // Decelerating to zero velocity
      outSine: function(t4) {
        return Math.sin(t4 * (Math.PI / 2));
      },
      // Accelerating until halfway, then decelerating
      inOutSine: function(t4) {
        return -(Math.cos(Math.PI * t4) - 1) / 2;
      },
      // Exponential accelerating from zero velocity
      inExpo: function(t4) {
        return Math.pow(2, 10 * (t4 - 1));
      },
      // Exponential decelerating to zero velocity
      outExpo: function(t4) {
        return -Math.pow(2, -10 * t4) + 1;
      },
      // Exponential accelerating until halfway, then decelerating
      inOutExpo: function(t4) {
        t4 /= 0.5;
        if (t4 < 1)
          return Math.pow(2, 10 * (t4 - 1)) / 2;
        t4--;
        return (-Math.pow(2, -10 * t4) + 2) / 2;
      },
      // Circular accelerating from zero velocity
      inCirc: function(t4) {
        return -Math.sqrt(1 - t4 * t4) + 1;
      },
      // Circular decelerating to zero velocity Moves VERY fast at the beginning and
      // then quickly slows down in the middle. This tween can actually be used
      // in continuous transitions where target value changes all the time,
      // because of the very quick start, it hides the jitter between target value changes.
      outCirc: function(t4) {
        return Math.sqrt(1 - (t4 = t4 - 1) * t4);
      },
      // Circular acceleration until halfway, then deceleration
      inOutCirc: function(t4) {
        t4 /= 0.5;
        if (t4 < 1)
          return -(Math.sqrt(1 - t4 * t4) - 1) / 2;
        t4 -= 2;
        return (Math.sqrt(1 - t4 * t4) + 1) / 2;
      }
    };
  }
});

// node_modules/attr-accept/dist/es/index.js
var require_es = __commonJS({
  "node_modules/attr-accept/dist/es/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = function(file, acceptedFiles) {
      if (file && acceptedFiles) {
        var acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(",");
        var fileName = file.name || "";
        var mimeType = (file.type || "").toLowerCase();
        var baseMimeType = mimeType.replace(/\/.*$/, "");
        return acceptedFilesArray.some(function(type) {
          var validType = type.trim().toLowerCase();
          if (validType.charAt(0) === ".") {
            return fileName.toLowerCase().endsWith(validType);
          } else if (validType.endsWith("/*")) {
            return baseMimeType === validType.replace(/\/.*$/, "");
          }
          return mimeType === validType;
        });
      }
      return true;
    };
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
    "use strict";
    var reactIs = require_react_is();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics2(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics2(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys2 = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys2 = keys2.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i2 = 0; i2 < keys2.length; ++i2) {
          var key = keys2[i2];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e4) {
            }
          }
        }
      }
      return targetComponent;
    }
    module.exports = hoistNonReactStatics2;
  }
});

// node_modules/lowlight/index.js
var require_lowlight = __commonJS({
  "node_modules/lowlight/index.js"(exports, module) {
    "use strict";
    var low = require_core();
    module.exports = low;
    low.registerLanguage("1c", require_c());
    low.registerLanguage("abnf", require_abnf());
    low.registerLanguage(
      "accesslog",
      require_accesslog()
    );
    low.registerLanguage(
      "actionscript",
      require_actionscript()
    );
    low.registerLanguage("ada", require_ada());
    low.registerLanguage(
      "angelscript",
      require_angelscript()
    );
    low.registerLanguage("apache", require_apache());
    low.registerLanguage(
      "applescript",
      require_applescript()
    );
    low.registerLanguage("arcade", require_arcade());
    low.registerLanguage("arduino", require_arduino());
    low.registerLanguage("armasm", require_armasm());
    low.registerLanguage("xml", require_xml());
    low.registerLanguage("asciidoc", require_asciidoc());
    low.registerLanguage("aspectj", require_aspectj());
    low.registerLanguage(
      "autohotkey",
      require_autohotkey()
    );
    low.registerLanguage("autoit", require_autoit());
    low.registerLanguage("avrasm", require_avrasm());
    low.registerLanguage("awk", require_awk());
    low.registerLanguage("axapta", require_axapta());
    low.registerLanguage("bash", require_bash());
    low.registerLanguage("basic", require_basic());
    low.registerLanguage("bnf", require_bnf());
    low.registerLanguage(
      "brainfuck",
      require_brainfuck()
    );
    low.registerLanguage("c-like", require_c_like());
    low.registerLanguage("c", require_c2());
    low.registerLanguage("cal", require_cal());
    low.registerLanguage(
      "capnproto",
      require_capnproto()
    );
    low.registerLanguage("ceylon", require_ceylon());
    low.registerLanguage("clean", require_clean());
    low.registerLanguage("clojure", require_clojure());
    low.registerLanguage(
      "clojure-repl",
      require_clojure_repl()
    );
    low.registerLanguage("cmake", require_cmake());
    low.registerLanguage(
      "coffeescript",
      require_coffeescript()
    );
    low.registerLanguage("coq", require_coq());
    low.registerLanguage("cos", require_cos());
    low.registerLanguage("cpp", require_cpp());
    low.registerLanguage("crmsh", require_crmsh());
    low.registerLanguage("crystal", require_crystal());
    low.registerLanguage("csharp", require_csharp());
    low.registerLanguage("csp", require_csp());
    low.registerLanguage("css", require_css());
    low.registerLanguage("d", require_d());
    low.registerLanguage("markdown", require_markdown());
    low.registerLanguage("dart", require_dart());
    low.registerLanguage("delphi", require_delphi());
    low.registerLanguage("diff", require_diff());
    low.registerLanguage("django", require_django());
    low.registerLanguage("dns", require_dns());
    low.registerLanguage(
      "dockerfile",
      require_dockerfile()
    );
    low.registerLanguage("dos", require_dos());
    low.registerLanguage("dsconfig", require_dsconfig());
    low.registerLanguage("dts", require_dts());
    low.registerLanguage("dust", require_dust());
    low.registerLanguage("ebnf", require_ebnf());
    low.registerLanguage("elixir", require_elixir());
    low.registerLanguage("elm", require_elm());
    low.registerLanguage("ruby", require_ruby());
    low.registerLanguage("erb", require_erb());
    low.registerLanguage(
      "erlang-repl",
      require_erlang_repl()
    );
    low.registerLanguage("erlang", require_erlang());
    low.registerLanguage("excel", require_excel());
    low.registerLanguage("fix", require_fix());
    low.registerLanguage("flix", require_flix());
    low.registerLanguage("fortran", require_fortran());
    low.registerLanguage("fsharp", require_fsharp());
    low.registerLanguage("gams", require_gams());
    low.registerLanguage("gauss", require_gauss());
    low.registerLanguage("gcode", require_gcode());
    low.registerLanguage("gherkin", require_gherkin());
    low.registerLanguage("glsl", require_glsl());
    low.registerLanguage("gml", require_gml());
    low.registerLanguage("go", require_go());
    low.registerLanguage("golo", require_golo());
    low.registerLanguage("gradle", require_gradle());
    low.registerLanguage("groovy", require_groovy());
    low.registerLanguage("haml", require_haml());
    low.registerLanguage(
      "handlebars",
      require_handlebars()
    );
    low.registerLanguage("haskell", require_haskell());
    low.registerLanguage("haxe", require_haxe());
    low.registerLanguage("hsp", require_hsp());
    low.registerLanguage("htmlbars", require_htmlbars());
    low.registerLanguage("http", require_http());
    low.registerLanguage("hy", require_hy());
    low.registerLanguage("inform7", require_inform7());
    low.registerLanguage("ini", require_ini());
    low.registerLanguage("irpf90", require_irpf90());
    low.registerLanguage("isbl", require_isbl());
    low.registerLanguage("java", require_java());
    low.registerLanguage(
      "javascript",
      require_javascript()
    );
    low.registerLanguage(
      "jboss-cli",
      require_jboss_cli()
    );
    low.registerLanguage("json", require_json());
    low.registerLanguage("julia", require_julia());
    low.registerLanguage(
      "julia-repl",
      require_julia_repl()
    );
    low.registerLanguage("kotlin", require_kotlin());
    low.registerLanguage("lasso", require_lasso());
    low.registerLanguage("latex", require_latex());
    low.registerLanguage("ldif", require_ldif());
    low.registerLanguage("leaf", require_leaf());
    low.registerLanguage("less", require_less());
    low.registerLanguage("lisp", require_lisp());
    low.registerLanguage(
      "livecodeserver",
      require_livecodeserver()
    );
    low.registerLanguage(
      "livescript",
      require_livescript()
    );
    low.registerLanguage("llvm", require_llvm());
    low.registerLanguage("lsl", require_lsl());
    low.registerLanguage("lua", require_lua());
    low.registerLanguage("makefile", require_makefile());
    low.registerLanguage(
      "mathematica",
      require_mathematica()
    );
    low.registerLanguage("matlab", require_matlab());
    low.registerLanguage("maxima", require_maxima());
    low.registerLanguage("mel", require_mel());
    low.registerLanguage("mercury", require_mercury());
    low.registerLanguage("mipsasm", require_mipsasm());
    low.registerLanguage("mizar", require_mizar());
    low.registerLanguage("perl", require_perl());
    low.registerLanguage(
      "mojolicious",
      require_mojolicious()
    );
    low.registerLanguage("monkey", require_monkey());
    low.registerLanguage(
      "moonscript",
      require_moonscript()
    );
    low.registerLanguage("n1ql", require_n1ql());
    low.registerLanguage("nginx", require_nginx());
    low.registerLanguage("nim", require_nim());
    low.registerLanguage("nix", require_nix());
    low.registerLanguage(
      "node-repl",
      require_node_repl()
    );
    low.registerLanguage("nsis", require_nsis());
    low.registerLanguage(
      "objectivec",
      require_objectivec()
    );
    low.registerLanguage("ocaml", require_ocaml());
    low.registerLanguage("openscad", require_openscad());
    low.registerLanguage("oxygene", require_oxygene());
    low.registerLanguage("parser3", require_parser3());
    low.registerLanguage("pf", require_pf());
    low.registerLanguage("pgsql", require_pgsql());
    low.registerLanguage("php", require_php());
    low.registerLanguage(
      "php-template",
      require_php_template()
    );
    low.registerLanguage(
      "plaintext",
      require_plaintext()
    );
    low.registerLanguage("pony", require_pony());
    low.registerLanguage(
      "powershell",
      require_powershell()
    );
    low.registerLanguage(
      "processing",
      require_processing()
    );
    low.registerLanguage("profile", require_profile());
    low.registerLanguage("prolog", require_prolog());
    low.registerLanguage(
      "properties",
      require_properties()
    );
    low.registerLanguage("protobuf", require_protobuf());
    low.registerLanguage("puppet", require_puppet());
    low.registerLanguage(
      "purebasic",
      require_purebasic()
    );
    low.registerLanguage("python", require_python());
    low.registerLanguage(
      "python-repl",
      require_python_repl()
    );
    low.registerLanguage("q", require_q());
    low.registerLanguage("qml", require_qml());
    low.registerLanguage("r", require_r());
    low.registerLanguage("reasonml", require_reasonml());
    low.registerLanguage("rib", require_rib());
    low.registerLanguage("roboconf", require_roboconf());
    low.registerLanguage("routeros", require_routeros());
    low.registerLanguage("rsl", require_rsl());
    low.registerLanguage(
      "ruleslanguage",
      require_ruleslanguage()
    );
    low.registerLanguage("rust", require_rust());
    low.registerLanguage("sas", require_sas());
    low.registerLanguage("scala", require_scala());
    low.registerLanguage("scheme", require_scheme());
    low.registerLanguage("scilab", require_scilab());
    low.registerLanguage("scss", require_scss());
    low.registerLanguage("shell", require_shell());
    low.registerLanguage("smali", require_smali());
    low.registerLanguage(
      "smalltalk",
      require_smalltalk()
    );
    low.registerLanguage("sml", require_sml());
    low.registerLanguage("sqf", require_sqf());
    low.registerLanguage("sql_more", require_sql_more());
    low.registerLanguage("sql", require_sql());
    low.registerLanguage("stan", require_stan());
    low.registerLanguage("stata", require_stata());
    low.registerLanguage("step21", require_step21());
    low.registerLanguage("stylus", require_stylus());
    low.registerLanguage("subunit", require_subunit());
    low.registerLanguage("swift", require_swift());
    low.registerLanguage(
      "taggerscript",
      require_taggerscript()
    );
    low.registerLanguage("yaml", require_yaml());
    low.registerLanguage("tap", require_tap());
    low.registerLanguage("tcl", require_tcl());
    low.registerLanguage("thrift", require_thrift());
    low.registerLanguage("tp", require_tp());
    low.registerLanguage("twig", require_twig());
    low.registerLanguage(
      "typescript",
      require_typescript()
    );
    low.registerLanguage("vala", require_vala());
    low.registerLanguage("vbnet", require_vbnet());
    low.registerLanguage("vbscript", require_vbscript());
    low.registerLanguage(
      "vbscript-html",
      require_vbscript_html()
    );
    low.registerLanguage("verilog", require_verilog());
    low.registerLanguage("vhdl", require_vhdl());
    low.registerLanguage("vim", require_vim());
    low.registerLanguage("x86asm", require_x86asm());
    low.registerLanguage("xl", require_xl());
    low.registerLanguage("xquery", require_xquery());
    low.registerLanguage("zephir", require_zephir());
  }
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    function _typeof3(o) {
      "@babel/helpers - typeof";
      return module.exports = _typeof3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof3(o);
    }
    module.exports = _typeof3, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports, module) {
    var _typeof3 = require_typeof()["default"];
    function _regeneratorRuntime3() {
      "use strict";
      module.exports = _regeneratorRuntime3 = function _regeneratorRuntime4() {
        return e4;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var t4, e4 = {}, r2 = Object.prototype, n = r2.hasOwnProperty, o = Object.defineProperty || function(t5, e5, r3) {
        t5[e5] = r3.value;
      }, i2 = "function" == typeof Symbol ? Symbol : {}, a3 = i2.iterator || "@@iterator", c2 = i2.asyncIterator || "@@asyncIterator", u2 = i2.toStringTag || "@@toStringTag";
      function define2(t5, e5, r3) {
        return Object.defineProperty(t5, e5, {
          value: r3,
          enumerable: true,
          configurable: true,
          writable: true
        }), t5[e5];
      }
      try {
        define2({}, "");
      } catch (t5) {
        define2 = function define3(t6, e5, r3) {
          return t6[e5] = r3;
        };
      }
      function wrap(t5, e5, r3, n2) {
        var i3 = e5 && e5.prototype instanceof Generator ? e5 : Generator, a4 = Object.create(i3.prototype), c3 = new Context(n2 || []);
        return o(a4, "_invoke", {
          value: makeInvokeMethod(t5, r3, c3)
        }), a4;
      }
      function tryCatch(t5, e5, r3) {
        try {
          return {
            type: "normal",
            arg: t5.call(e5, r3)
          };
        } catch (t6) {
          return {
            type: "throw",
            arg: t6
          };
        }
      }
      e4.wrap = wrap;
      var h3 = "suspendedStart", l = "suspendedYield", f = "executing", s3 = "completed", y3 = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a3, function() {
        return this;
      });
      var d3 = Object.getPrototypeOf, v = d3 && d3(d3(values([])));
      v && v !== r2 && n.call(v, a3) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t5) {
        ["next", "throw", "return"].forEach(function(e5) {
          define2(t5, e5, function(t6) {
            return this._invoke(e5, t6);
          });
        });
      }
      function AsyncIterator(t5, e5) {
        function invoke(r4, o2, i3, a4) {
          var c3 = tryCatch(t5[r4], t5, o2);
          if ("throw" !== c3.type) {
            var u3 = c3.arg, h4 = u3.value;
            return h4 && "object" == _typeof3(h4) && n.call(h4, "__await") ? e5.resolve(h4.__await).then(function(t6) {
              invoke("next", t6, i3, a4);
            }, function(t6) {
              invoke("throw", t6, i3, a4);
            }) : e5.resolve(h4).then(function(t6) {
              u3.value = t6, i3(u3);
            }, function(t6) {
              return invoke("throw", t6, i3, a4);
            });
          }
          a4(c3.arg);
        }
        var r3;
        o(this, "_invoke", {
          value: function value(t6, n2) {
            function callInvokeWithMethodAndArg() {
              return new e5(function(e6, r4) {
                invoke(t6, n2, e6, r4);
              });
            }
            return r3 = r3 ? r3.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(e5, r3, n2) {
        var o2 = h3;
        return function(i3, a4) {
          if (o2 === f)
            throw new Error("Generator is already running");
          if (o2 === s3) {
            if ("throw" === i3)
              throw a4;
            return {
              value: t4,
              done: true
            };
          }
          for (n2.method = i3, n2.arg = a4; ; ) {
            var c3 = n2.delegate;
            if (c3) {
              var u3 = maybeInvokeDelegate(c3, n2);
              if (u3) {
                if (u3 === y3)
                  continue;
                return u3;
              }
            }
            if ("next" === n2.method)
              n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h3)
                throw o2 = s3, n2.arg;
              n2.dispatchException(n2.arg);
            } else
              "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e5, r3, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s3 : l, p2.arg === y3)
                continue;
              return {
                value: p2.arg,
                done: n2.done
              };
            }
            "throw" === p2.type && (o2 = s3, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e5, r3) {
        var n2 = r3.method, o2 = e5.iterator[n2];
        if (o2 === t4)
          return r3.delegate = null, "throw" === n2 && e5.iterator["return"] && (r3.method = "return", r3.arg = t4, maybeInvokeDelegate(e5, r3), "throw" === r3.method) || "return" !== n2 && (r3.method = "throw", r3.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y3;
        var i3 = tryCatch(o2, e5.iterator, r3.arg);
        if ("throw" === i3.type)
          return r3.method = "throw", r3.arg = i3.arg, r3.delegate = null, y3;
        var a4 = i3.arg;
        return a4 ? a4.done ? (r3[e5.resultName] = a4.value, r3.next = e5.nextLoc, "return" !== r3.method && (r3.method = "next", r3.arg = t4), r3.delegate = null, y3) : a4 : (r3.method = "throw", r3.arg = new TypeError("iterator result is not an object"), r3.delegate = null, y3);
      }
      function pushTryEntry(t5) {
        var e5 = {
          tryLoc: t5[0]
        };
        1 in t5 && (e5.catchLoc = t5[1]), 2 in t5 && (e5.finallyLoc = t5[2], e5.afterLoc = t5[3]), this.tryEntries.push(e5);
      }
      function resetTryEntry(t5) {
        var e5 = t5.completion || {};
        e5.type = "normal", delete e5.arg, t5.completion = e5;
      }
      function Context(t5) {
        this.tryEntries = [{
          tryLoc: "root"
        }], t5.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e5) {
        if (e5 || "" === e5) {
          var r3 = e5[a3];
          if (r3)
            return r3.call(e5);
          if ("function" == typeof e5.next)
            return e5;
          if (!isNaN(e5.length)) {
            var o2 = -1, i3 = function next2() {
              for (; ++o2 < e5.length; )
                if (n.call(e5, o2))
                  return next2.value = e5[o2], next2.done = false, next2;
              return next2.value = t4, next2.done = true, next2;
            };
            return i3.next = i3;
          }
        }
        throw new TypeError(_typeof3(e5) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), o(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u2, "GeneratorFunction"), e4.isGeneratorFunction = function(t5) {
        var e5 = "function" == typeof t5 && t5.constructor;
        return !!e5 && (e5 === GeneratorFunction || "GeneratorFunction" === (e5.displayName || e5.name));
      }, e4.mark = function(t5) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t5, GeneratorFunctionPrototype) : (t5.__proto__ = GeneratorFunctionPrototype, define2(t5, u2, "GeneratorFunction")), t5.prototype = Object.create(g), t5;
      }, e4.awrap = function(t5) {
        return {
          __await: t5
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c2, function() {
        return this;
      }), e4.AsyncIterator = AsyncIterator, e4.async = function(t5, r3, n2, o2, i3) {
        void 0 === i3 && (i3 = Promise);
        var a4 = new AsyncIterator(wrap(t5, r3, n2, o2), i3);
        return e4.isGeneratorFunction(r3) ? a4 : a4.next().then(function(t6) {
          return t6.done ? t6.value : a4.next();
        });
      }, defineIteratorMethods(g), define2(g, u2, "Generator"), define2(g, a3, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e4.keys = function(t5) {
        var e5 = Object(t5), r3 = [];
        for (var n2 in e5)
          r3.push(n2);
        return r3.reverse(), function next2() {
          for (; r3.length; ) {
            var t6 = r3.pop();
            if (t6 in e5)
              return next2.value = t6, next2.done = false, next2;
          }
          return next2.done = true, next2;
        };
      }, e4.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(e5) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = t4, this.done = false, this.delegate = null, this.method = "next", this.arg = t4, this.tryEntries.forEach(resetTryEntry), !e5)
            for (var r3 in this)
              "t" === r3.charAt(0) && n.call(this, r3) && !isNaN(+r3.slice(1)) && (this[r3] = t4);
        },
        stop: function stop() {
          this.done = true;
          var t5 = this.tryEntries[0].completion;
          if ("throw" === t5.type)
            throw t5.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(e5) {
          if (this.done)
            throw e5;
          var r3 = this;
          function handle(n2, o3) {
            return a4.type = "throw", a4.arg = e5, r3.next = n2, o3 && (r3.method = "next", r3.arg = t4), !!o3;
          }
          for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
            var i3 = this.tryEntries[o2], a4 = i3.completion;
            if ("root" === i3.tryLoc)
              return handle("end");
            if (i3.tryLoc <= this.prev) {
              var c3 = n.call(i3, "catchLoc"), u3 = n.call(i3, "finallyLoc");
              if (c3 && u3) {
                if (this.prev < i3.catchLoc)
                  return handle(i3.catchLoc, true);
                if (this.prev < i3.finallyLoc)
                  return handle(i3.finallyLoc);
              } else if (c3) {
                if (this.prev < i3.catchLoc)
                  return handle(i3.catchLoc, true);
              } else {
                if (!u3)
                  throw new Error("try statement without catch or finally");
                if (this.prev < i3.finallyLoc)
                  return handle(i3.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(t5, e5) {
          for (var r3 = this.tryEntries.length - 1; r3 >= 0; --r3) {
            var o2 = this.tryEntries[r3];
            if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
              var i3 = o2;
              break;
            }
          }
          i3 && ("break" === t5 || "continue" === t5) && i3.tryLoc <= e5 && e5 <= i3.finallyLoc && (i3 = null);
          var a4 = i3 ? i3.completion : {};
          return a4.type = t5, a4.arg = e5, i3 ? (this.method = "next", this.next = i3.finallyLoc, y3) : this.complete(a4);
        },
        complete: function complete(t5, e5) {
          if ("throw" === t5.type)
            throw t5.arg;
          return "break" === t5.type || "continue" === t5.type ? this.next = t5.arg : "return" === t5.type ? (this.rval = this.arg = t5.arg, this.method = "return", this.next = "end") : "normal" === t5.type && e5 && (this.next = e5), y3;
        },
        finish: function finish(t5) {
          for (var e5 = this.tryEntries.length - 1; e5 >= 0; --e5) {
            var r3 = this.tryEntries[e5];
            if (r3.finallyLoc === t5)
              return this.complete(r3.completion, r3.afterLoc), resetTryEntry(r3), y3;
          }
        },
        "catch": function _catch(t5) {
          for (var e5 = this.tryEntries.length - 1; e5 >= 0; --e5) {
            var r3 = this.tryEntries[e5];
            if (r3.tryLoc === t5) {
              var n2 = r3.completion;
              if ("throw" === n2.type) {
                var o2 = n2.arg;
                resetTryEntry(r3);
              }
              return o2;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(e5, r3, n2) {
          return this.delegate = {
            iterator: values(e5),
            resultName: r3,
            nextLoc: n2
          }, "next" === this.method && (this.arg = t4), y3;
        }
      }, e4;
    }
    module.exports = _regeneratorRuntime3, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS({
  "node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
    var runtime = require_regeneratorRuntime()();
    module.exports = runtime;
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/@babel/runtime/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS({
  "node_modules/@babel/runtime/helpers/interopRequireDefault.js"(exports, module) {
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/coy.js
var require_coy = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/coy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "black",
        "background": "none",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "maxHeight": "inherit",
        "height": "inherit",
        "padding": "0 1em",
        "display": "block",
        "overflow": "auto"
      },
      'pre[class*="language-"]': {
        "color": "black",
        "background": "none",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "position": "relative",
        "margin": ".5em 0",
        "overflow": "visible",
        "padding": "1px",
        "backgroundColor": "#fdfdfd",
        "WebkitBoxSizing": "border-box",
        "MozBoxSizing": "border-box",
        "boxSizing": "border-box",
        "marginBottom": "1em"
      },
      'pre[class*="language-"] > code': {
        "position": "relative",
        "zIndex": "1",
        "borderLeft": "10px solid #358ccb",
        "boxShadow": "-1px 0px 0px 0px #358ccb, 0px 0px 0px 1px #dfdfdf",
        "backgroundColor": "#fdfdfd",
        "backgroundImage": "linear-gradient(transparent 50%, rgba(69, 142, 209, 0.04) 50%)",
        "backgroundSize": "3em 3em",
        "backgroundOrigin": "content-box",
        "backgroundAttachment": "local"
      },
      ':not(pre) > code[class*="language-"]': {
        "backgroundColor": "#fdfdfd",
        "WebkitBoxSizing": "border-box",
        "MozBoxSizing": "border-box",
        "boxSizing": "border-box",
        "marginBottom": "1em",
        "position": "relative",
        "padding": ".2em",
        "borderRadius": "0.3em",
        "color": "#c92c2c",
        "border": "1px solid rgba(0, 0, 0, 0.1)",
        "display": "inline",
        "whiteSpace": "normal"
      },
      'pre[class*="language-"]:before': {
        "content": "''",
        "display": "block",
        "position": "absolute",
        "bottom": "0.75em",
        "left": "0.18em",
        "width": "40%",
        "height": "20%",
        "maxHeight": "13em",
        "boxShadow": "0px 13px 8px #979797",
        "WebkitTransform": "rotate(-2deg)",
        "MozTransform": "rotate(-2deg)",
        "msTransform": "rotate(-2deg)",
        "OTransform": "rotate(-2deg)",
        "transform": "rotate(-2deg)"
      },
      'pre[class*="language-"]:after': {
        "content": "''",
        "display": "block",
        "position": "absolute",
        "bottom": "0.75em",
        "left": "auto",
        "width": "40%",
        "height": "20%",
        "maxHeight": "13em",
        "boxShadow": "0px 13px 8px #979797",
        "WebkitTransform": "rotate(2deg)",
        "MozTransform": "rotate(2deg)",
        "msTransform": "rotate(2deg)",
        "OTransform": "rotate(2deg)",
        "transform": "rotate(2deg)",
        "right": "0.75em"
      },
      "comment": {
        "color": "#7D8B99"
      },
      "block-comment": {
        "color": "#7D8B99"
      },
      "prolog": {
        "color": "#7D8B99"
      },
      "doctype": {
        "color": "#7D8B99"
      },
      "cdata": {
        "color": "#7D8B99"
      },
      "punctuation": {
        "color": "#5F6364"
      },
      "property": {
        "color": "#c92c2c"
      },
      "tag": {
        "color": "#c92c2c"
      },
      "boolean": {
        "color": "#c92c2c"
      },
      "number": {
        "color": "#c92c2c"
      },
      "function-name": {
        "color": "#c92c2c"
      },
      "constant": {
        "color": "#c92c2c"
      },
      "symbol": {
        "color": "#c92c2c"
      },
      "deleted": {
        "color": "#c92c2c"
      },
      "selector": {
        "color": "#2f9c0a"
      },
      "attr-name": {
        "color": "#2f9c0a"
      },
      "string": {
        "color": "#2f9c0a"
      },
      "char": {
        "color": "#2f9c0a"
      },
      "function": {
        "color": "#2f9c0a"
      },
      "builtin": {
        "color": "#2f9c0a"
      },
      "inserted": {
        "color": "#2f9c0a"
      },
      "operator": {
        "color": "#a67f59",
        "background": "rgba(255, 255, 255, 0.5)"
      },
      "entity": {
        "color": "#a67f59",
        "background": "rgba(255, 255, 255, 0.5)",
        "cursor": "help"
      },
      "url": {
        "color": "#a67f59",
        "background": "rgba(255, 255, 255, 0.5)"
      },
      "variable": {
        "color": "#a67f59",
        "background": "rgba(255, 255, 255, 0.5)"
      },
      "atrule": {
        "color": "#1990b8"
      },
      "attr-value": {
        "color": "#1990b8"
      },
      "keyword": {
        "color": "#1990b8"
      },
      "class-name": {
        "color": "#1990b8"
      },
      "regex": {
        "color": "#e90"
      },
      "important": {
        "color": "#e90",
        "fontWeight": "normal"
      },
      ".language-css .token.string": {
        "color": "#a67f59",
        "background": "rgba(255, 255, 255, 0.5)"
      },
      ".style .token.string": {
        "color": "#a67f59",
        "background": "rgba(255, 255, 255, 0.5)"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "namespace": {
        "Opacity": ".7"
      },
      'pre[class*="language-"].line-numbers.line-numbers': {
        "paddingLeft": "0"
      },
      'pre[class*="language-"].line-numbers.line-numbers code': {
        "paddingLeft": "3.8em"
      },
      'pre[class*="language-"].line-numbers.line-numbers .line-numbers-rows': {
        "left": "0"
      },
      'pre[class*="language-"][data-line]': {
        "paddingTop": "0",
        "paddingBottom": "0",
        "paddingLeft": "0"
      },
      "pre[data-line] code": {
        "position": "relative",
        "paddingLeft": "4em"
      },
      "pre .line-highlight": {
        "marginTop": "0"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/dark.js
var require_dark = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/dark.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "white",
        "background": "none",
        "textShadow": "0 -.1em .2em black",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "white",
        "background": "hsl(30, 20%, 25%)",
        "textShadow": "0 -.1em .2em black",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto",
        "border": ".3em solid hsl(30, 20%, 40%)",
        "borderRadius": ".5em",
        "boxShadow": "1px 1px .5em black inset"
      },
      ':not(pre) > code[class*="language-"]': {
        "background": "hsl(30, 20%, 25%)",
        "padding": ".15em .2em .05em",
        "borderRadius": ".3em",
        "border": ".13em solid hsl(30, 20%, 40%)",
        "boxShadow": "1px 1px .3em -.1em black inset",
        "whiteSpace": "normal"
      },
      "comment": {
        "color": "hsl(30, 20%, 50%)"
      },
      "prolog": {
        "color": "hsl(30, 20%, 50%)"
      },
      "doctype": {
        "color": "hsl(30, 20%, 50%)"
      },
      "cdata": {
        "color": "hsl(30, 20%, 50%)"
      },
      "punctuation": {
        "Opacity": ".7"
      },
      "namespace": {
        "Opacity": ".7"
      },
      "property": {
        "color": "hsl(350, 40%, 70%)"
      },
      "tag": {
        "color": "hsl(350, 40%, 70%)"
      },
      "boolean": {
        "color": "hsl(350, 40%, 70%)"
      },
      "number": {
        "color": "hsl(350, 40%, 70%)"
      },
      "constant": {
        "color": "hsl(350, 40%, 70%)"
      },
      "symbol": {
        "color": "hsl(350, 40%, 70%)"
      },
      "selector": {
        "color": "hsl(75, 70%, 60%)"
      },
      "attr-name": {
        "color": "hsl(75, 70%, 60%)"
      },
      "string": {
        "color": "hsl(75, 70%, 60%)"
      },
      "char": {
        "color": "hsl(75, 70%, 60%)"
      },
      "builtin": {
        "color": "hsl(75, 70%, 60%)"
      },
      "inserted": {
        "color": "hsl(75, 70%, 60%)"
      },
      "operator": {
        "color": "hsl(40, 90%, 60%)"
      },
      "entity": {
        "color": "hsl(40, 90%, 60%)",
        "cursor": "help"
      },
      "url": {
        "color": "hsl(40, 90%, 60%)"
      },
      ".language-css .token.string": {
        "color": "hsl(40, 90%, 60%)"
      },
      ".style .token.string": {
        "color": "hsl(40, 90%, 60%)"
      },
      "variable": {
        "color": "hsl(40, 90%, 60%)"
      },
      "atrule": {
        "color": "hsl(350, 40%, 70%)"
      },
      "attr-value": {
        "color": "hsl(350, 40%, 70%)"
      },
      "keyword": {
        "color": "hsl(350, 40%, 70%)"
      },
      "regex": {
        "color": "#e90"
      },
      "important": {
        "color": "#e90",
        "fontWeight": "bold"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "deleted": {
        "color": "red"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/funky.js
var require_funky = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/funky.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "background": "black",
        "color": "white",
        "boxShadow": "-.3em 0 0 .3em black, .3em 0 0 .3em black"
      },
      'pre[class*="language-"]': {
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": ".4em .8em",
        "margin": ".5em 0",
        "overflow": "auto",
        "background": `url('data:image/svg+xml;charset=utf-8,<svg%20version%3D"1.1"%20xmlns%3D"http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg"%20width%3D"100"%20height%3D"100"%20fill%3D"rgba(0%2C0%2C0%2C.2)">%0D%0A<polygon%20points%3D"0%2C50%2050%2C0%200%2C0"%20%2F>%0D%0A<polygon%20points%3D"0%2C100%2050%2C100%20100%2C50%20100%2C0"%20%2F>%0D%0A<%2Fsvg>')`,
        "backgroundSize": "1em 1em"
      },
      ':not(pre) > code[class*="language-"]': {
        "padding": ".2em",
        "borderRadius": ".3em",
        "boxShadow": "none",
        "whiteSpace": "normal"
      },
      "comment": {
        "color": "#aaa"
      },
      "prolog": {
        "color": "#aaa"
      },
      "doctype": {
        "color": "#aaa"
      },
      "cdata": {
        "color": "#aaa"
      },
      "punctuation": {
        "color": "#999"
      },
      "namespace": {
        "Opacity": ".7"
      },
      "property": {
        "color": "#0cf"
      },
      "tag": {
        "color": "#0cf"
      },
      "boolean": {
        "color": "#0cf"
      },
      "number": {
        "color": "#0cf"
      },
      "constant": {
        "color": "#0cf"
      },
      "symbol": {
        "color": "#0cf"
      },
      "selector": {
        "color": "yellow"
      },
      "attr-name": {
        "color": "yellow"
      },
      "string": {
        "color": "yellow"
      },
      "char": {
        "color": "yellow"
      },
      "builtin": {
        "color": "yellow"
      },
      "operator": {
        "color": "yellowgreen"
      },
      "entity": {
        "color": "yellowgreen",
        "cursor": "help"
      },
      "url": {
        "color": "yellowgreen"
      },
      ".language-css .token.string": {
        "color": "yellowgreen"
      },
      "variable": {
        "color": "yellowgreen"
      },
      "inserted": {
        "color": "yellowgreen"
      },
      "atrule": {
        "color": "deeppink"
      },
      "attr-value": {
        "color": "deeppink"
      },
      "keyword": {
        "color": "deeppink"
      },
      "regex": {
        "color": "orange"
      },
      "important": {
        "color": "orange",
        "fontWeight": "bold"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "deleted": {
        "color": "red"
      },
      "pre.diff-highlight.diff-highlight > code .token.deleted:not(.prefix)": {
        "backgroundColor": "rgba(255, 0, 0, .3)",
        "display": "inline"
      },
      "pre > code.diff-highlight.diff-highlight .token.deleted:not(.prefix)": {
        "backgroundColor": "rgba(255, 0, 0, .3)",
        "display": "inline"
      },
      "pre.diff-highlight.diff-highlight > code .token.inserted:not(.prefix)": {
        "backgroundColor": "rgba(0, 255, 128, .3)",
        "display": "inline"
      },
      "pre > code.diff-highlight.diff-highlight .token.inserted:not(.prefix)": {
        "backgroundColor": "rgba(0, 255, 128, .3)",
        "display": "inline"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/okaidia.js
var require_okaidia = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/okaidia.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "#f8f8f2",
        "background": "none",
        "textShadow": "0 1px rgba(0, 0, 0, 0.3)",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "#f8f8f2",
        "background": "#272822",
        "textShadow": "0 1px rgba(0, 0, 0, 0.3)",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto",
        "borderRadius": "0.3em"
      },
      ':not(pre) > code[class*="language-"]': {
        "background": "#272822",
        "padding": ".1em",
        "borderRadius": ".3em",
        "whiteSpace": "normal"
      },
      "comment": {
        "color": "#8292a2"
      },
      "prolog": {
        "color": "#8292a2"
      },
      "doctype": {
        "color": "#8292a2"
      },
      "cdata": {
        "color": "#8292a2"
      },
      "punctuation": {
        "color": "#f8f8f2"
      },
      "namespace": {
        "Opacity": ".7"
      },
      "property": {
        "color": "#f92672"
      },
      "tag": {
        "color": "#f92672"
      },
      "constant": {
        "color": "#f92672"
      },
      "symbol": {
        "color": "#f92672"
      },
      "deleted": {
        "color": "#f92672"
      },
      "boolean": {
        "color": "#ae81ff"
      },
      "number": {
        "color": "#ae81ff"
      },
      "selector": {
        "color": "#a6e22e"
      },
      "attr-name": {
        "color": "#a6e22e"
      },
      "string": {
        "color": "#a6e22e"
      },
      "char": {
        "color": "#a6e22e"
      },
      "builtin": {
        "color": "#a6e22e"
      },
      "inserted": {
        "color": "#a6e22e"
      },
      "operator": {
        "color": "#f8f8f2"
      },
      "entity": {
        "color": "#f8f8f2",
        "cursor": "help"
      },
      "url": {
        "color": "#f8f8f2"
      },
      ".language-css .token.string": {
        "color": "#f8f8f2"
      },
      ".style .token.string": {
        "color": "#f8f8f2"
      },
      "variable": {
        "color": "#f8f8f2"
      },
      "atrule": {
        "color": "#e6db74"
      },
      "attr-value": {
        "color": "#e6db74"
      },
      "function": {
        "color": "#e6db74"
      },
      "class-name": {
        "color": "#e6db74"
      },
      "keyword": {
        "color": "#66d9ef"
      },
      "regex": {
        "color": "#fd971f"
      },
      "important": {
        "color": "#fd971f",
        "fontWeight": "bold"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/solarizedlight.js
var require_solarizedlight = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/solarizedlight.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "#657b83",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "#657b83",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto",
        "borderRadius": "0.3em",
        "backgroundColor": "#fdf6e3"
      },
      'pre[class*="language-"]::-moz-selection': {
        "background": "#073642"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "background": "#073642"
      },
      'code[class*="language-"]::-moz-selection': {
        "background": "#073642"
      },
      'code[class*="language-"] ::-moz-selection': {
        "background": "#073642"
      },
      'pre[class*="language-"]::selection': {
        "background": "#073642"
      },
      'pre[class*="language-"] ::selection': {
        "background": "#073642"
      },
      'code[class*="language-"]::selection': {
        "background": "#073642"
      },
      'code[class*="language-"] ::selection': {
        "background": "#073642"
      },
      ':not(pre) > code[class*="language-"]': {
        "backgroundColor": "#fdf6e3",
        "padding": ".1em",
        "borderRadius": ".3em"
      },
      "comment": {
        "color": "#93a1a1"
      },
      "prolog": {
        "color": "#93a1a1"
      },
      "doctype": {
        "color": "#93a1a1"
      },
      "cdata": {
        "color": "#93a1a1"
      },
      "punctuation": {
        "color": "#586e75"
      },
      "namespace": {
        "Opacity": ".7"
      },
      "property": {
        "color": "#268bd2"
      },
      "tag": {
        "color": "#268bd2"
      },
      "boolean": {
        "color": "#268bd2"
      },
      "number": {
        "color": "#268bd2"
      },
      "constant": {
        "color": "#268bd2"
      },
      "symbol": {
        "color": "#268bd2"
      },
      "deleted": {
        "color": "#268bd2"
      },
      "selector": {
        "color": "#2aa198"
      },
      "attr-name": {
        "color": "#2aa198"
      },
      "string": {
        "color": "#2aa198"
      },
      "char": {
        "color": "#2aa198"
      },
      "builtin": {
        "color": "#2aa198"
      },
      "url": {
        "color": "#2aa198"
      },
      "inserted": {
        "color": "#2aa198"
      },
      "entity": {
        "color": "#657b83",
        "background": "#eee8d5",
        "cursor": "help"
      },
      "atrule": {
        "color": "#859900"
      },
      "attr-value": {
        "color": "#859900"
      },
      "keyword": {
        "color": "#859900"
      },
      "function": {
        "color": "#b58900"
      },
      "class-name": {
        "color": "#b58900"
      },
      "regex": {
        "color": "#cb4b16"
      },
      "important": {
        "color": "#cb4b16",
        "fontWeight": "bold"
      },
      "variable": {
        "color": "#cb4b16"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/tomorrow.js
var require_tomorrow = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/tomorrow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "#ccc",
        "background": "none",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "#ccc",
        "background": "#2d2d2d",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto"
      },
      ':not(pre) > code[class*="language-"]': {
        "background": "#2d2d2d",
        "padding": ".1em",
        "borderRadius": ".3em",
        "whiteSpace": "normal"
      },
      "comment": {
        "color": "#999"
      },
      "block-comment": {
        "color": "#999"
      },
      "prolog": {
        "color": "#999"
      },
      "doctype": {
        "color": "#999"
      },
      "cdata": {
        "color": "#999"
      },
      "punctuation": {
        "color": "#ccc"
      },
      "tag": {
        "color": "#e2777a"
      },
      "attr-name": {
        "color": "#e2777a"
      },
      "namespace": {
        "color": "#e2777a"
      },
      "deleted": {
        "color": "#e2777a"
      },
      "function-name": {
        "color": "#6196cc"
      },
      "boolean": {
        "color": "#f08d49"
      },
      "number": {
        "color": "#f08d49"
      },
      "function": {
        "color": "#f08d49"
      },
      "property": {
        "color": "#f8c555"
      },
      "class-name": {
        "color": "#f8c555"
      },
      "constant": {
        "color": "#f8c555"
      },
      "symbol": {
        "color": "#f8c555"
      },
      "selector": {
        "color": "#cc99cd"
      },
      "important": {
        "color": "#cc99cd",
        "fontWeight": "bold"
      },
      "atrule": {
        "color": "#cc99cd"
      },
      "keyword": {
        "color": "#cc99cd"
      },
      "builtin": {
        "color": "#cc99cd"
      },
      "string": {
        "color": "#7ec699"
      },
      "char": {
        "color": "#7ec699"
      },
      "attr-value": {
        "color": "#7ec699"
      },
      "regex": {
        "color": "#7ec699"
      },
      "variable": {
        "color": "#7ec699"
      },
      "operator": {
        "color": "#67cdcc"
      },
      "entity": {
        "color": "#67cdcc",
        "cursor": "help"
      },
      "url": {
        "color": "#67cdcc"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "inserted": {
        "color": "green"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/twilight.js
var require_twilight = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/twilight.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "white",
        "background": "none",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "textShadow": "0 -.1em .2em black",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "white",
        "background": "hsl(0, 0%, 8%)",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "textShadow": "0 -.1em .2em black",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "borderRadius": ".5em",
        "border": ".3em solid hsl(0, 0%, 33%)",
        "boxShadow": "1px 1px .5em black inset",
        "margin": ".5em 0",
        "overflow": "auto",
        "padding": "1em"
      },
      ':not(pre) > code[class*="language-"]': {
        "background": "hsl(0, 0%, 8%)",
        "borderRadius": ".3em",
        "border": ".13em solid hsl(0, 0%, 33%)",
        "boxShadow": "1px 1px .3em -.1em black inset",
        "padding": ".15em .2em .05em",
        "whiteSpace": "normal"
      },
      'pre[class*="language-"]::-moz-selection': {
        "background": "hsla(0, 0%, 93%, 0.15)",
        "textShadow": "none"
      },
      'pre[class*="language-"]::selection': {
        "background": "hsla(0, 0%, 93%, 0.15)",
        "textShadow": "none"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "hsla(0, 0%, 93%, 0.15)"
      },
      'code[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "hsla(0, 0%, 93%, 0.15)"
      },
      'code[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "hsla(0, 0%, 93%, 0.15)"
      },
      'pre[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "hsla(0, 0%, 93%, 0.15)"
      },
      'code[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "hsla(0, 0%, 93%, 0.15)"
      },
      'code[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "hsla(0, 0%, 93%, 0.15)"
      },
      "comment": {
        "color": "hsl(0, 0%, 47%)"
      },
      "prolog": {
        "color": "hsl(0, 0%, 47%)"
      },
      "doctype": {
        "color": "hsl(0, 0%, 47%)"
      },
      "cdata": {
        "color": "hsl(0, 0%, 47%)"
      },
      "punctuation": {
        "Opacity": ".7"
      },
      "namespace": {
        "Opacity": ".7"
      },
      "tag": {
        "color": "hsl(14, 58%, 55%)"
      },
      "boolean": {
        "color": "hsl(14, 58%, 55%)"
      },
      "number": {
        "color": "hsl(14, 58%, 55%)"
      },
      "deleted": {
        "color": "hsl(14, 58%, 55%)"
      },
      "keyword": {
        "color": "hsl(53, 89%, 79%)"
      },
      "property": {
        "color": "hsl(53, 89%, 79%)"
      },
      "selector": {
        "color": "hsl(53, 89%, 79%)"
      },
      "constant": {
        "color": "hsl(53, 89%, 79%)"
      },
      "symbol": {
        "color": "hsl(53, 89%, 79%)"
      },
      "builtin": {
        "color": "hsl(53, 89%, 79%)"
      },
      "attr-name": {
        "color": "hsl(76, 21%, 52%)"
      },
      "attr-value": {
        "color": "hsl(76, 21%, 52%)"
      },
      "string": {
        "color": "hsl(76, 21%, 52%)"
      },
      "char": {
        "color": "hsl(76, 21%, 52%)"
      },
      "operator": {
        "color": "hsl(76, 21%, 52%)"
      },
      "entity": {
        "color": "hsl(76, 21%, 52%)",
        "cursor": "help"
      },
      "url": {
        "color": "hsl(76, 21%, 52%)"
      },
      ".language-css .token.string": {
        "color": "hsl(76, 21%, 52%)"
      },
      ".style .token.string": {
        "color": "hsl(76, 21%, 52%)"
      },
      "variable": {
        "color": "hsl(76, 21%, 52%)"
      },
      "inserted": {
        "color": "hsl(76, 21%, 52%)"
      },
      "atrule": {
        "color": "hsl(218, 22%, 55%)"
      },
      "regex": {
        "color": "hsl(42, 75%, 65%)"
      },
      "important": {
        "color": "hsl(42, 75%, 65%)",
        "fontWeight": "bold"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      },
      ".language-markup .token.tag": {
        "color": "hsl(33, 33%, 52%)"
      },
      ".language-markup .token.attr-name": {
        "color": "hsl(33, 33%, 52%)"
      },
      ".language-markup .token.punctuation": {
        "color": "hsl(33, 33%, 52%)"
      },
      "": {
        "position": "relative",
        "zIndex": "1"
      },
      ".line-highlight.line-highlight": {
        "background": "linear-gradient(to right, hsla(0, 0%, 33%, .1) 70%, hsla(0, 0%, 33%, 0))",
        "borderBottom": "1px dashed hsl(0, 0%, 33%)",
        "borderTop": "1px dashed hsl(0, 0%, 33%)",
        "marginTop": "0.75em",
        "zIndex": "0"
      },
      ".line-highlight.line-highlight:before": {
        "backgroundColor": "hsl(215, 15%, 59%)",
        "color": "hsl(24, 20%, 95%)"
      },
      ".line-highlight.line-highlight[data-end]:after": {
        "backgroundColor": "hsl(215, 15%, 59%)",
        "color": "hsl(24, 20%, 95%)"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/prism.js
var require_prism = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/prism.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "black",
        "background": "none",
        "textShadow": "0 1px white",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "black",
        "background": "#f5f2f0",
        "textShadow": "0 1px white",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto"
      },
      'pre[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      'code[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      'code[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      'pre[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      'pre[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      'code[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      'code[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      ':not(pre) > code[class*="language-"]': {
        "background": "#f5f2f0",
        "padding": ".1em",
        "borderRadius": ".3em",
        "whiteSpace": "normal"
      },
      "comment": {
        "color": "slategray"
      },
      "prolog": {
        "color": "slategray"
      },
      "doctype": {
        "color": "slategray"
      },
      "cdata": {
        "color": "slategray"
      },
      "punctuation": {
        "color": "#999"
      },
      "namespace": {
        "Opacity": ".7"
      },
      "property": {
        "color": "#905"
      },
      "tag": {
        "color": "#905"
      },
      "boolean": {
        "color": "#905"
      },
      "number": {
        "color": "#905"
      },
      "constant": {
        "color": "#905"
      },
      "symbol": {
        "color": "#905"
      },
      "deleted": {
        "color": "#905"
      },
      "selector": {
        "color": "#690"
      },
      "attr-name": {
        "color": "#690"
      },
      "string": {
        "color": "#690"
      },
      "char": {
        "color": "#690"
      },
      "builtin": {
        "color": "#690"
      },
      "inserted": {
        "color": "#690"
      },
      "operator": {
        "color": "#9a6e3a",
        "background": "hsla(0, 0%, 100%, .5)"
      },
      "entity": {
        "color": "#9a6e3a",
        "background": "hsla(0, 0%, 100%, .5)",
        "cursor": "help"
      },
      "url": {
        "color": "#9a6e3a",
        "background": "hsla(0, 0%, 100%, .5)"
      },
      ".language-css .token.string": {
        "color": "#9a6e3a",
        "background": "hsla(0, 0%, 100%, .5)"
      },
      ".style .token.string": {
        "color": "#9a6e3a",
        "background": "hsla(0, 0%, 100%, .5)"
      },
      "atrule": {
        "color": "#07a"
      },
      "attr-value": {
        "color": "#07a"
      },
      "keyword": {
        "color": "#07a"
      },
      "function": {
        "color": "#DD4A68"
      },
      "class-name": {
        "color": "#DD4A68"
      },
      "regex": {
        "color": "#e90"
      },
      "important": {
        "color": "#e90",
        "fontWeight": "bold"
      },
      "variable": {
        "color": "#e90"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/a11y-dark.js
var require_a11y_dark = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/a11y-dark.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "#f8f8f2",
        "background": "none",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "#f8f8f2",
        "background": "#2b2b2b",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": "0.5em 0",
        "overflow": "auto",
        "borderRadius": "0.3em"
      },
      ':not(pre) > code[class*="language-"]': {
        "background": "#2b2b2b",
        "padding": "0.1em",
        "borderRadius": "0.3em",
        "whiteSpace": "normal"
      },
      "comment": {
        "color": "#d4d0ab"
      },
      "prolog": {
        "color": "#d4d0ab"
      },
      "doctype": {
        "color": "#d4d0ab"
      },
      "cdata": {
        "color": "#d4d0ab"
      },
      "punctuation": {
        "color": "#fefefe"
      },
      "property": {
        "color": "#ffa07a"
      },
      "tag": {
        "color": "#ffa07a"
      },
      "constant": {
        "color": "#ffa07a"
      },
      "symbol": {
        "color": "#ffa07a"
      },
      "deleted": {
        "color": "#ffa07a"
      },
      "boolean": {
        "color": "#00e0e0"
      },
      "number": {
        "color": "#00e0e0"
      },
      "selector": {
        "color": "#abe338"
      },
      "attr-name": {
        "color": "#abe338"
      },
      "string": {
        "color": "#abe338"
      },
      "char": {
        "color": "#abe338"
      },
      "builtin": {
        "color": "#abe338"
      },
      "inserted": {
        "color": "#abe338"
      },
      "operator": {
        "color": "#00e0e0"
      },
      "entity": {
        "color": "#00e0e0",
        "cursor": "help"
      },
      "url": {
        "color": "#00e0e0"
      },
      ".language-css .token.string": {
        "color": "#00e0e0"
      },
      ".style .token.string": {
        "color": "#00e0e0"
      },
      "variable": {
        "color": "#00e0e0"
      },
      "atrule": {
        "color": "#ffd700"
      },
      "attr-value": {
        "color": "#ffd700"
      },
      "function": {
        "color": "#ffd700"
      },
      "keyword": {
        "color": "#00e0e0"
      },
      "regex": {
        "color": "#ffd700"
      },
      "important": {
        "color": "#ffd700",
        "fontWeight": "bold"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/atom-dark.js
var require_atom_dark = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/atom-dark.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "#c5c8c6",
        "textShadow": "0 1px rgba(0, 0, 0, 0.3)",
        "fontFamily": "Inconsolata, Monaco, Consolas, 'Courier New', Courier, monospace",
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "#c5c8c6",
        "textShadow": "0 1px rgba(0, 0, 0, 0.3)",
        "fontFamily": "Inconsolata, Monaco, Consolas, 'Courier New', Courier, monospace",
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto",
        "borderRadius": "0.3em",
        "background": "#1d1f21"
      },
      ':not(pre) > code[class*="language-"]': {
        "background": "#1d1f21",
        "padding": ".1em",
        "borderRadius": ".3em"
      },
      "comment": {
        "color": "#7C7C7C"
      },
      "prolog": {
        "color": "#7C7C7C"
      },
      "doctype": {
        "color": "#7C7C7C"
      },
      "cdata": {
        "color": "#7C7C7C"
      },
      "punctuation": {
        "color": "#c5c8c6"
      },
      ".namespace": {
        "Opacity": ".7"
      },
      "property": {
        "color": "#96CBFE"
      },
      "keyword": {
        "color": "#96CBFE"
      },
      "tag": {
        "color": "#96CBFE"
      },
      "class-name": {
        "color": "#FFFFB6",
        "textDecoration": "underline"
      },
      "boolean": {
        "color": "#99CC99"
      },
      "constant": {
        "color": "#99CC99"
      },
      "symbol": {
        "color": "#f92672"
      },
      "deleted": {
        "color": "#f92672"
      },
      "number": {
        "color": "#FF73FD"
      },
      "selector": {
        "color": "#A8FF60"
      },
      "attr-name": {
        "color": "#A8FF60"
      },
      "string": {
        "color": "#A8FF60"
      },
      "char": {
        "color": "#A8FF60"
      },
      "builtin": {
        "color": "#A8FF60"
      },
      "inserted": {
        "color": "#A8FF60"
      },
      "variable": {
        "color": "#C6C5FE"
      },
      "operator": {
        "color": "#EDEDED"
      },
      "entity": {
        "color": "#FFFFB6",
        "cursor": "help"
      },
      "url": {
        "color": "#96CBFE"
      },
      ".language-css .token.string": {
        "color": "#87C38A"
      },
      ".style .token.string": {
        "color": "#87C38A"
      },
      "atrule": {
        "color": "#F9EE98"
      },
      "attr-value": {
        "color": "#F9EE98"
      },
      "function": {
        "color": "#DAD085"
      },
      "regex": {
        "color": "#E9C062"
      },
      "important": {
        "color": "#fd971f",
        "fontWeight": "bold"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/base16-ateliersulphurpool.light.js
var require_base16_ateliersulphurpool_light = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/base16-ateliersulphurpool.light.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "fontFamily": 'Consolas, Menlo, Monaco, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", "Courier New", Courier, monospace',
        "fontSize": "14px",
        "lineHeight": "1.375",
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "background": "#f5f7ff",
        "color": "#5e6687"
      },
      'pre[class*="language-"]': {
        "fontFamily": 'Consolas, Menlo, Monaco, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", "Courier New", Courier, monospace',
        "fontSize": "14px",
        "lineHeight": "1.375",
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "background": "#f5f7ff",
        "color": "#5e6687",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto"
      },
      'pre > code[class*="language-"]': {
        "fontSize": "1em"
      },
      'pre[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "#dfe2f1"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "#dfe2f1"
      },
      'code[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "#dfe2f1"
      },
      'code[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "#dfe2f1"
      },
      'pre[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#dfe2f1"
      },
      'pre[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "#dfe2f1"
      },
      'code[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#dfe2f1"
      },
      'code[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "#dfe2f1"
      },
      ':not(pre) > code[class*="language-"]': {
        "padding": ".1em",
        "borderRadius": ".3em"
      },
      "comment": {
        "color": "#898ea4"
      },
      "prolog": {
        "color": "#898ea4"
      },
      "doctype": {
        "color": "#898ea4"
      },
      "cdata": {
        "color": "#898ea4"
      },
      "punctuation": {
        "color": "#5e6687"
      },
      "namespace": {
        "Opacity": ".7"
      },
      "operator": {
        "color": "#c76b29"
      },
      "boolean": {
        "color": "#c76b29"
      },
      "number": {
        "color": "#c76b29"
      },
      "property": {
        "color": "#c08b30"
      },
      "tag": {
        "color": "#3d8fd1"
      },
      "string": {
        "color": "#22a2c9"
      },
      "selector": {
        "color": "#6679cc"
      },
      "attr-name": {
        "color": "#c76b29"
      },
      "entity": {
        "color": "#22a2c9",
        "cursor": "help"
      },
      "url": {
        "color": "#22a2c9"
      },
      ".language-css .token.string": {
        "color": "#22a2c9"
      },
      ".style .token.string": {
        "color": "#22a2c9"
      },
      "attr-value": {
        "color": "#ac9739"
      },
      "keyword": {
        "color": "#ac9739"
      },
      "control": {
        "color": "#ac9739"
      },
      "directive": {
        "color": "#ac9739"
      },
      "unit": {
        "color": "#ac9739"
      },
      "statement": {
        "color": "#22a2c9"
      },
      "regex": {
        "color": "#22a2c9"
      },
      "atrule": {
        "color": "#22a2c9"
      },
      "placeholder": {
        "color": "#3d8fd1"
      },
      "variable": {
        "color": "#3d8fd1"
      },
      "deleted": {
        "textDecoration": "line-through"
      },
      "inserted": {
        "borderBottom": "1px dotted #202746",
        "textDecoration": "none"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "important": {
        "fontWeight": "bold",
        "color": "#c94922"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "pre > code.highlight": {
        "Outline": "0.4em solid #c94922",
        "OutlineOffset": ".4em"
      },
      ".line-numbers.line-numbers .line-numbers-rows": {
        "borderRightColor": "#dfe2f1"
      },
      ".line-numbers .line-numbers-rows > span:before": {
        "color": "#979db4"
      },
      ".line-highlight.line-highlight": {
        "background": "linear-gradient(to right, rgba(107, 115, 148, 0.2) 70%, rgba(107, 115, 148, 0))"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/cb.js
var require_cb = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/cb.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "#fff",
        "textShadow": "0 1px 1px #000",
        "fontFamily": 'Menlo, Monaco, "Courier New", monospace',
        "direction": "ltr",
        "textAlign": "left",
        "wordSpacing": "normal",
        "whiteSpace": "pre",
        "wordWrap": "normal",
        "lineHeight": "1.4",
        "background": "none",
        "border": "0",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "#fff",
        "textShadow": "0 1px 1px #000",
        "fontFamily": 'Menlo, Monaco, "Courier New", monospace',
        "direction": "ltr",
        "textAlign": "left",
        "wordSpacing": "normal",
        "whiteSpace": "pre",
        "wordWrap": "normal",
        "lineHeight": "1.4",
        "background": "#222",
        "border": "0",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "15px",
        "margin": "1em 0",
        "overflow": "auto",
        "MozBorderRadius": "8px",
        "WebkitBorderRadius": "8px",
        "borderRadius": "8px"
      },
      'pre[class*="language-"] code': {
        "float": "left",
        "padding": "0 15px 0 0"
      },
      ':not(pre) > code[class*="language-"]': {
        "background": "#222",
        "padding": "5px 10px",
        "lineHeight": "1",
        "MozBorderRadius": "3px",
        "WebkitBorderRadius": "3px",
        "borderRadius": "3px"
      },
      "comment": {
        "color": "#797979"
      },
      "prolog": {
        "color": "#797979"
      },
      "doctype": {
        "color": "#797979"
      },
      "cdata": {
        "color": "#797979"
      },
      "selector": {
        "color": "#fff"
      },
      "operator": {
        "color": "#fff"
      },
      "punctuation": {
        "color": "#fff"
      },
      "namespace": {
        "Opacity": ".7"
      },
      "tag": {
        "color": "#ffd893"
      },
      "boolean": {
        "color": "#ffd893"
      },
      "atrule": {
        "color": "#B0C975"
      },
      "attr-value": {
        "color": "#B0C975"
      },
      "hex": {
        "color": "#B0C975"
      },
      "string": {
        "color": "#B0C975"
      },
      "property": {
        "color": "#c27628"
      },
      "entity": {
        "color": "#c27628",
        "cursor": "help"
      },
      "url": {
        "color": "#c27628"
      },
      "attr-name": {
        "color": "#c27628"
      },
      "keyword": {
        "color": "#c27628"
      },
      "regex": {
        "color": "#9B71C6"
      },
      "function": {
        "color": "#e5a638"
      },
      "constant": {
        "color": "#e5a638"
      },
      "variable": {
        "color": "#fdfba8"
      },
      "number": {
        "color": "#8799B0"
      },
      "important": {
        "color": "#E45734"
      },
      "deliminator": {
        "color": "#E45734"
      },
      ".line-highlight.line-highlight": {
        "background": "rgba(255, 255, 255, .2)"
      },
      ".line-highlight.line-highlight:before": {
        "top": ".3em",
        "backgroundColor": "rgba(255, 255, 255, .3)",
        "color": "#fff",
        "MozBorderRadius": "8px",
        "WebkitBorderRadius": "8px",
        "borderRadius": "8px"
      },
      ".line-highlight.line-highlight[data-end]:after": {
        "top": ".3em",
        "backgroundColor": "rgba(255, 255, 255, .3)",
        "color": "#fff",
        "MozBorderRadius": "8px",
        "WebkitBorderRadius": "8px",
        "borderRadius": "8px"
      },
      ".line-numbers .line-numbers-rows > span": {
        "borderRight": "3px #d9d336 solid"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/coldark-cold.js
var require_coldark_cold = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/coldark-cold.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "#111b27",
        "background": "none",
        "fontFamily": 'Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace',
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "#111b27",
        "background": "#e3eaf2",
        "fontFamily": 'Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace',
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": "0.5em 0",
        "overflow": "auto"
      },
      'pre[class*="language-"]::-moz-selection': {
        "background": "#8da1b9"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "background": "#8da1b9"
      },
      'code[class*="language-"]::-moz-selection': {
        "background": "#8da1b9"
      },
      'code[class*="language-"] ::-moz-selection': {
        "background": "#8da1b9"
      },
      'pre[class*="language-"]::selection': {
        "background": "#8da1b9"
      },
      'pre[class*="language-"] ::selection': {
        "background": "#8da1b9"
      },
      'code[class*="language-"]::selection': {
        "background": "#8da1b9"
      },
      'code[class*="language-"] ::selection': {
        "background": "#8da1b9"
      },
      ':not(pre) > code[class*="language-"]': {
        "background": "#e3eaf2",
        "padding": "0.1em 0.3em",
        "borderRadius": "0.3em",
        "whiteSpace": "normal"
      },
      "comment": {
        "color": "#3c526d"
      },
      "prolog": {
        "color": "#3c526d"
      },
      "doctype": {
        "color": "#3c526d"
      },
      "cdata": {
        "color": "#3c526d"
      },
      "punctuation": {
        "color": "#111b27"
      },
      "delimiter.important": {
        "color": "#006d6d",
        "fontWeight": "inherit"
      },
      "selector.parent": {
        "color": "#006d6d"
      },
      "tag": {
        "color": "#006d6d"
      },
      "tag.punctuation": {
        "color": "#006d6d"
      },
      "attr-name": {
        "color": "#755f00"
      },
      "boolean": {
        "color": "#755f00"
      },
      "boolean.important": {
        "color": "#755f00"
      },
      "number": {
        "color": "#755f00"
      },
      "constant": {
        "color": "#755f00"
      },
      "selector.attribute": {
        "color": "#755f00"
      },
      "class-name": {
        "color": "#005a8e"
      },
      "key": {
        "color": "#005a8e"
      },
      "parameter": {
        "color": "#005a8e"
      },
      "property": {
        "color": "#005a8e"
      },
      "property-access": {
        "color": "#005a8e"
      },
      "variable": {
        "color": "#005a8e"
      },
      "attr-value": {
        "color": "#116b00"
      },
      "inserted": {
        "color": "#116b00"
      },
      "color": {
        "color": "#116b00"
      },
      "selector.value": {
        "color": "#116b00"
      },
      "string": {
        "color": "#116b00"
      },
      "string.url-link": {
        "color": "#116b00"
      },
      "builtin": {
        "color": "#af00af"
      },
      "keyword-array": {
        "color": "#af00af"
      },
      "package": {
        "color": "#af00af"
      },
      "regex": {
        "color": "#af00af"
      },
      "function": {
        "color": "#7c00aa"
      },
      "selector.class": {
        "color": "#7c00aa"
      },
      "selector.id": {
        "color": "#7c00aa"
      },
      "atrule.rule": {
        "color": "#a04900"
      },
      "combinator": {
        "color": "#a04900"
      },
      "keyword": {
        "color": "#a04900"
      },
      "operator": {
        "color": "#a04900"
      },
      "pseudo-class": {
        "color": "#a04900"
      },
      "pseudo-element": {
        "color": "#a04900"
      },
      "selector": {
        "color": "#a04900"
      },
      "unit": {
        "color": "#a04900"
      },
      "deleted": {
        "color": "#c22f2e"
      },
      "important": {
        "color": "#c22f2e",
        "fontWeight": "bold"
      },
      "keyword-this": {
        "color": "#005a8e",
        "fontWeight": "bold"
      },
      "this": {
        "color": "#005a8e",
        "fontWeight": "bold"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "entity": {
        "cursor": "help"
      },
      ".language-markdown .token.title": {
        "color": "#005a8e",
        "fontWeight": "bold"
      },
      ".language-markdown .token.title .token.punctuation": {
        "color": "#005a8e",
        "fontWeight": "bold"
      },
      ".language-markdown .token.blockquote.punctuation": {
        "color": "#af00af"
      },
      ".language-markdown .token.code": {
        "color": "#006d6d"
      },
      ".language-markdown .token.hr.punctuation": {
        "color": "#005a8e"
      },
      ".language-markdown .token.url > .token.content": {
        "color": "#116b00"
      },
      ".language-markdown .token.url-link": {
        "color": "#755f00"
      },
      ".language-markdown .token.list.punctuation": {
        "color": "#af00af"
      },
      ".language-markdown .token.table-header": {
        "color": "#111b27"
      },
      ".language-json .token.operator": {
        "color": "#111b27"
      },
      ".language-scss .token.variable": {
        "color": "#006d6d"
      },
      "token.tab:not(:empty):before": {
        "color": "#3c526d"
      },
      "token.cr:before": {
        "color": "#3c526d"
      },
      "token.lf:before": {
        "color": "#3c526d"
      },
      "token.space:before": {
        "color": "#3c526d"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a": {
        "color": "#e3eaf2",
        "background": "#005a8e"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button": {
        "color": "#e3eaf2",
        "background": "#005a8e"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a:hover": {
        "color": "#e3eaf2",
        "background": "#005a8eda",
        "textDecoration": "none"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a:focus": {
        "color": "#e3eaf2",
        "background": "#005a8eda",
        "textDecoration": "none"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button:hover": {
        "color": "#e3eaf2",
        "background": "#005a8eda",
        "textDecoration": "none"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button:focus": {
        "color": "#e3eaf2",
        "background": "#005a8eda",
        "textDecoration": "none"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span": {
        "color": "#e3eaf2",
        "background": "#3c526d"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span:hover": {
        "color": "#e3eaf2",
        "background": "#3c526d"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span:focus": {
        "color": "#e3eaf2",
        "background": "#3c526d"
      },
      ".line-highlight.line-highlight": {
        "background": "linear-gradient(to right, #8da1b92f 70%, #8da1b925)"
      },
      ".line-highlight.line-highlight:before": {
        "backgroundColor": "#3c526d",
        "color": "#e3eaf2",
        "boxShadow": "0 1px #8da1b9"
      },
      ".line-highlight.line-highlight[data-end]:after": {
        "backgroundColor": "#3c526d",
        "color": "#e3eaf2",
        "boxShadow": "0 1px #8da1b9"
      },
      "pre[id].linkable-line-numbers.linkable-line-numbers span.line-numbers-rows > span:hover:before": {
        "backgroundColor": "#3c526d1f"
      },
      ".line-numbers.line-numbers .line-numbers-rows": {
        "borderRight": "1px solid #8da1b97a",
        "background": "#d0dae77a"
      },
      ".line-numbers .line-numbers-rows > span:before": {
        "color": "#3c526dda"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-1": {
        "color": "#755f00"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-5": {
        "color": "#755f00"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-9": {
        "color": "#755f00"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-2": {
        "color": "#af00af"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-6": {
        "color": "#af00af"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-10": {
        "color": "#af00af"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-3": {
        "color": "#005a8e"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-7": {
        "color": "#005a8e"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-11": {
        "color": "#005a8e"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-4": {
        "color": "#7c00aa"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-8": {
        "color": "#7c00aa"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-12": {
        "color": "#7c00aa"
      },
      "pre.diff-highlight > code .token.token.deleted:not(.prefix)": {
        "backgroundColor": "#c22f2e1f"
      },
      "pre > code.diff-highlight .token.token.deleted:not(.prefix)": {
        "backgroundColor": "#c22f2e1f"
      },
      "pre.diff-highlight > code .token.token.inserted:not(.prefix)": {
        "backgroundColor": "#116b001f"
      },
      "pre > code.diff-highlight .token.token.inserted:not(.prefix)": {
        "backgroundColor": "#116b001f"
      },
      ".command-line .command-line-prompt": {
        "borderRight": "1px solid #8da1b97a"
      },
      ".command-line .command-line-prompt > span:before": {
        "color": "#3c526dda"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/coldark-dark.js
var require_coldark_dark = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/coldark-dark.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "#e3eaf2",
        "background": "none",
        "fontFamily": 'Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace',
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "#e3eaf2",
        "background": "#111b27",
        "fontFamily": 'Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace',
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": "0.5em 0",
        "overflow": "auto"
      },
      'pre[class*="language-"]::-moz-selection': {
        "background": "#3c526d"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "background": "#3c526d"
      },
      'code[class*="language-"]::-moz-selection': {
        "background": "#3c526d"
      },
      'code[class*="language-"] ::-moz-selection': {
        "background": "#3c526d"
      },
      'pre[class*="language-"]::selection': {
        "background": "#3c526d"
      },
      'pre[class*="language-"] ::selection': {
        "background": "#3c526d"
      },
      'code[class*="language-"]::selection': {
        "background": "#3c526d"
      },
      'code[class*="language-"] ::selection': {
        "background": "#3c526d"
      },
      ':not(pre) > code[class*="language-"]': {
        "background": "#111b27",
        "padding": "0.1em 0.3em",
        "borderRadius": "0.3em",
        "whiteSpace": "normal"
      },
      "comment": {
        "color": "#8da1b9"
      },
      "prolog": {
        "color": "#8da1b9"
      },
      "doctype": {
        "color": "#8da1b9"
      },
      "cdata": {
        "color": "#8da1b9"
      },
      "punctuation": {
        "color": "#e3eaf2"
      },
      "delimiter.important": {
        "color": "#66cccc",
        "fontWeight": "inherit"
      },
      "selector.parent": {
        "color": "#66cccc"
      },
      "tag": {
        "color": "#66cccc"
      },
      "tag.punctuation": {
        "color": "#66cccc"
      },
      "attr-name": {
        "color": "#e6d37a"
      },
      "boolean": {
        "color": "#e6d37a"
      },
      "boolean.important": {
        "color": "#e6d37a"
      },
      "number": {
        "color": "#e6d37a"
      },
      "constant": {
        "color": "#e6d37a"
      },
      "selector.attribute": {
        "color": "#e6d37a"
      },
      "class-name": {
        "color": "#6cb8e6"
      },
      "key": {
        "color": "#6cb8e6"
      },
      "parameter": {
        "color": "#6cb8e6"
      },
      "property": {
        "color": "#6cb8e6"
      },
      "property-access": {
        "color": "#6cb8e6"
      },
      "variable": {
        "color": "#6cb8e6"
      },
      "attr-value": {
        "color": "#91d076"
      },
      "inserted": {
        "color": "#91d076"
      },
      "color": {
        "color": "#91d076"
      },
      "selector.value": {
        "color": "#91d076"
      },
      "string": {
        "color": "#91d076"
      },
      "string.url-link": {
        "color": "#91d076"
      },
      "builtin": {
        "color": "#f4adf4"
      },
      "keyword-array": {
        "color": "#f4adf4"
      },
      "package": {
        "color": "#f4adf4"
      },
      "regex": {
        "color": "#f4adf4"
      },
      "function": {
        "color": "#c699e3"
      },
      "selector.class": {
        "color": "#c699e3"
      },
      "selector.id": {
        "color": "#c699e3"
      },
      "atrule.rule": {
        "color": "#e9ae7e"
      },
      "combinator": {
        "color": "#e9ae7e"
      },
      "keyword": {
        "color": "#e9ae7e"
      },
      "operator": {
        "color": "#e9ae7e"
      },
      "pseudo-class": {
        "color": "#e9ae7e"
      },
      "pseudo-element": {
        "color": "#e9ae7e"
      },
      "selector": {
        "color": "#e9ae7e"
      },
      "unit": {
        "color": "#e9ae7e"
      },
      "deleted": {
        "color": "#cd6660"
      },
      "important": {
        "color": "#cd6660",
        "fontWeight": "bold"
      },
      "keyword-this": {
        "color": "#6cb8e6",
        "fontWeight": "bold"
      },
      "this": {
        "color": "#6cb8e6",
        "fontWeight": "bold"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "entity": {
        "cursor": "help"
      },
      ".language-markdown .token.title": {
        "color": "#6cb8e6",
        "fontWeight": "bold"
      },
      ".language-markdown .token.title .token.punctuation": {
        "color": "#6cb8e6",
        "fontWeight": "bold"
      },
      ".language-markdown .token.blockquote.punctuation": {
        "color": "#f4adf4"
      },
      ".language-markdown .token.code": {
        "color": "#66cccc"
      },
      ".language-markdown .token.hr.punctuation": {
        "color": "#6cb8e6"
      },
      ".language-markdown .token.url .token.content": {
        "color": "#91d076"
      },
      ".language-markdown .token.url-link": {
        "color": "#e6d37a"
      },
      ".language-markdown .token.list.punctuation": {
        "color": "#f4adf4"
      },
      ".language-markdown .token.table-header": {
        "color": "#e3eaf2"
      },
      ".language-json .token.operator": {
        "color": "#e3eaf2"
      },
      ".language-scss .token.variable": {
        "color": "#66cccc"
      },
      "token.tab:not(:empty):before": {
        "color": "#8da1b9"
      },
      "token.cr:before": {
        "color": "#8da1b9"
      },
      "token.lf:before": {
        "color": "#8da1b9"
      },
      "token.space:before": {
        "color": "#8da1b9"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a": {
        "color": "#111b27",
        "background": "#6cb8e6"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button": {
        "color": "#111b27",
        "background": "#6cb8e6"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a:hover": {
        "color": "#111b27",
        "background": "#6cb8e6da",
        "textDecoration": "none"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a:focus": {
        "color": "#111b27",
        "background": "#6cb8e6da",
        "textDecoration": "none"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button:hover": {
        "color": "#111b27",
        "background": "#6cb8e6da",
        "textDecoration": "none"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button:focus": {
        "color": "#111b27",
        "background": "#6cb8e6da",
        "textDecoration": "none"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span": {
        "color": "#111b27",
        "background": "#8da1b9"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span:hover": {
        "color": "#111b27",
        "background": "#8da1b9"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span:focus": {
        "color": "#111b27",
        "background": "#8da1b9"
      },
      ".line-highlight.line-highlight": {
        "background": "linear-gradient(to right, #3c526d5f 70%, #3c526d55)"
      },
      ".line-highlight.line-highlight:before": {
        "backgroundColor": "#8da1b9",
        "color": "#111b27",
        "boxShadow": "0 1px #3c526d"
      },
      ".line-highlight.line-highlight[data-end]:after": {
        "backgroundColor": "#8da1b9",
        "color": "#111b27",
        "boxShadow": "0 1px #3c526d"
      },
      "pre[id].linkable-line-numbers.linkable-line-numbers span.line-numbers-rows > span:hover:before": {
        "backgroundColor": "#8da1b918"
      },
      ".line-numbers.line-numbers .line-numbers-rows": {
        "borderRight": "1px solid #0b121b",
        "background": "#0b121b7a"
      },
      ".line-numbers .line-numbers-rows > span:before": {
        "color": "#8da1b9da"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-1": {
        "color": "#e6d37a"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-5": {
        "color": "#e6d37a"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-9": {
        "color": "#e6d37a"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-2": {
        "color": "#f4adf4"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-6": {
        "color": "#f4adf4"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-10": {
        "color": "#f4adf4"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-3": {
        "color": "#6cb8e6"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-7": {
        "color": "#6cb8e6"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-11": {
        "color": "#6cb8e6"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-4": {
        "color": "#c699e3"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-8": {
        "color": "#c699e3"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-12": {
        "color": "#c699e3"
      },
      "pre.diff-highlight > code .token.token.deleted:not(.prefix)": {
        "backgroundColor": "#cd66601f"
      },
      "pre > code.diff-highlight .token.token.deleted:not(.prefix)": {
        "backgroundColor": "#cd66601f"
      },
      "pre.diff-highlight > code .token.token.inserted:not(.prefix)": {
        "backgroundColor": "#91d0761f"
      },
      "pre > code.diff-highlight .token.token.inserted:not(.prefix)": {
        "backgroundColor": "#91d0761f"
      },
      ".command-line .command-line-prompt": {
        "borderRight": "1px solid #0b121b"
      },
      ".command-line .command-line-prompt > span:before": {
        "color": "#8da1b9da"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/coy-without-shadows.js
var require_coy_without_shadows = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/coy-without-shadows.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "black",
        "background": "none",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "black",
        "background": "none",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "position": "relative",
        "borderLeft": "10px solid #358ccb",
        "boxShadow": "-1px 0 0 0 #358ccb, 0 0 0 1px #dfdfdf",
        "backgroundColor": "#fdfdfd",
        "backgroundImage": "linear-gradient(transparent 50%, rgba(69, 142, 209, 0.04) 50%)",
        "backgroundSize": "3em 3em",
        "backgroundOrigin": "content-box",
        "backgroundAttachment": "local",
        "margin": ".5em 0",
        "padding": "0 1em"
      },
      'pre[class*="language-"] > code': {
        "display": "block"
      },
      ':not(pre) > code[class*="language-"]': {
        "position": "relative",
        "padding": ".2em",
        "borderRadius": "0.3em",
        "color": "#c92c2c",
        "border": "1px solid rgba(0, 0, 0, 0.1)",
        "display": "inline",
        "whiteSpace": "normal",
        "backgroundColor": "#fdfdfd",
        "WebkitBoxSizing": "border-box",
        "MozBoxSizing": "border-box",
        "boxSizing": "border-box"
      },
      "comment": {
        "color": "#7D8B99"
      },
      "block-comment": {
        "color": "#7D8B99"
      },
      "prolog": {
        "color": "#7D8B99"
      },
      "doctype": {
        "color": "#7D8B99"
      },
      "cdata": {
        "color": "#7D8B99"
      },
      "punctuation": {
        "color": "#5F6364"
      },
      "property": {
        "color": "#c92c2c"
      },
      "tag": {
        "color": "#c92c2c"
      },
      "boolean": {
        "color": "#c92c2c"
      },
      "number": {
        "color": "#c92c2c"
      },
      "function-name": {
        "color": "#c92c2c"
      },
      "constant": {
        "color": "#c92c2c"
      },
      "symbol": {
        "color": "#c92c2c"
      },
      "deleted": {
        "color": "#c92c2c"
      },
      "selector": {
        "color": "#2f9c0a"
      },
      "attr-name": {
        "color": "#2f9c0a"
      },
      "string": {
        "color": "#2f9c0a"
      },
      "char": {
        "color": "#2f9c0a"
      },
      "function": {
        "color": "#2f9c0a"
      },
      "builtin": {
        "color": "#2f9c0a"
      },
      "inserted": {
        "color": "#2f9c0a"
      },
      "operator": {
        "color": "#a67f59",
        "background": "rgba(255, 255, 255, 0.5)"
      },
      "entity": {
        "color": "#a67f59",
        "background": "rgba(255, 255, 255, 0.5)",
        "cursor": "help"
      },
      "url": {
        "color": "#a67f59",
        "background": "rgba(255, 255, 255, 0.5)"
      },
      "variable": {
        "color": "#a67f59",
        "background": "rgba(255, 255, 255, 0.5)"
      },
      "atrule": {
        "color": "#1990b8"
      },
      "attr-value": {
        "color": "#1990b8"
      },
      "keyword": {
        "color": "#1990b8"
      },
      "class-name": {
        "color": "#1990b8"
      },
      "regex": {
        "color": "#e90"
      },
      "important": {
        "color": "#e90",
        "fontWeight": "normal"
      },
      ".language-css .token.string": {
        "color": "#a67f59",
        "background": "rgba(255, 255, 255, 0.5)"
      },
      ".style .token.string": {
        "color": "#a67f59",
        "background": "rgba(255, 255, 255, 0.5)"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "namespace": {
        "Opacity": ".7"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/darcula.js
var require_darcula = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/darcula.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "#a9b7c6",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', monospace",
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "#a9b7c6",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', monospace",
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto",
        "background": "#2b2b2b"
      },
      'pre[class*="language-"]::-moz-selection': {
        "color": "inherit",
        "background": "rgba(33, 66, 131, .85)"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "color": "inherit",
        "background": "rgba(33, 66, 131, .85)"
      },
      'code[class*="language-"]::-moz-selection': {
        "color": "inherit",
        "background": "rgba(33, 66, 131, .85)"
      },
      'code[class*="language-"] ::-moz-selection': {
        "color": "inherit",
        "background": "rgba(33, 66, 131, .85)"
      },
      'pre[class*="language-"]::selection': {
        "color": "inherit",
        "background": "rgba(33, 66, 131, .85)"
      },
      'pre[class*="language-"] ::selection': {
        "color": "inherit",
        "background": "rgba(33, 66, 131, .85)"
      },
      'code[class*="language-"]::selection': {
        "color": "inherit",
        "background": "rgba(33, 66, 131, .85)"
      },
      'code[class*="language-"] ::selection': {
        "color": "inherit",
        "background": "rgba(33, 66, 131, .85)"
      },
      ':not(pre) > code[class*="language-"]': {
        "background": "#2b2b2b",
        "padding": ".1em",
        "borderRadius": ".3em"
      },
      "comment": {
        "color": "#808080"
      },
      "prolog": {
        "color": "#808080"
      },
      "cdata": {
        "color": "#808080"
      },
      "delimiter": {
        "color": "#cc7832"
      },
      "boolean": {
        "color": "#cc7832"
      },
      "keyword": {
        "color": "#cc7832"
      },
      "selector": {
        "color": "#cc7832"
      },
      "important": {
        "color": "#cc7832"
      },
      "atrule": {
        "color": "#cc7832"
      },
      "operator": {
        "color": "#a9b7c6"
      },
      "punctuation": {
        "color": "#a9b7c6"
      },
      "attr-name": {
        "color": "#a9b7c6"
      },
      "tag": {
        "color": "#e8bf6a"
      },
      "tag.punctuation": {
        "color": "#e8bf6a"
      },
      "doctype": {
        "color": "#e8bf6a"
      },
      "builtin": {
        "color": "#e8bf6a"
      },
      "entity": {
        "color": "#6897bb"
      },
      "number": {
        "color": "#6897bb"
      },
      "symbol": {
        "color": "#6897bb"
      },
      "property": {
        "color": "#9876aa"
      },
      "constant": {
        "color": "#9876aa"
      },
      "variable": {
        "color": "#9876aa"
      },
      "string": {
        "color": "#6a8759"
      },
      "char": {
        "color": "#6a8759"
      },
      "attr-value": {
        "color": "#a5c261"
      },
      "attr-value.punctuation": {
        "color": "#a5c261"
      },
      "attr-value.punctuation:first-child": {
        "color": "#a9b7c6"
      },
      "url": {
        "color": "#287bde",
        "textDecoration": "underline"
      },
      "function": {
        "color": "#ffc66d"
      },
      "regex": {
        "background": "#364135"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "inserted": {
        "background": "#294436"
      },
      "deleted": {
        "background": "#484a4a"
      },
      "code.language-css .token.property": {
        "color": "#a9b7c6"
      },
      "code.language-css .token.property + .token.punctuation": {
        "color": "#a9b7c6"
      },
      "code.language-css .token.id": {
        "color": "#ffc66d"
      },
      "code.language-css .token.selector > .token.class": {
        "color": "#ffc66d"
      },
      "code.language-css .token.selector > .token.attribute": {
        "color": "#ffc66d"
      },
      "code.language-css .token.selector > .token.pseudo-class": {
        "color": "#ffc66d"
      },
      "code.language-css .token.selector > .token.pseudo-element": {
        "color": "#ffc66d"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/dracula.js
var require_dracula = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/dracula.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "#f8f8f2",
        "background": "none",
        "textShadow": "0 1px rgba(0, 0, 0, 0.3)",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "#f8f8f2",
        "background": "#282a36",
        "textShadow": "0 1px rgba(0, 0, 0, 0.3)",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto",
        "borderRadius": "0.3em"
      },
      ':not(pre) > code[class*="language-"]': {
        "background": "#282a36",
        "padding": ".1em",
        "borderRadius": ".3em",
        "whiteSpace": "normal"
      },
      "comment": {
        "color": "#6272a4"
      },
      "prolog": {
        "color": "#6272a4"
      },
      "doctype": {
        "color": "#6272a4"
      },
      "cdata": {
        "color": "#6272a4"
      },
      "punctuation": {
        "color": "#f8f8f2"
      },
      ".namespace": {
        "Opacity": ".7"
      },
      "property": {
        "color": "#ff79c6"
      },
      "tag": {
        "color": "#ff79c6"
      },
      "constant": {
        "color": "#ff79c6"
      },
      "symbol": {
        "color": "#ff79c6"
      },
      "deleted": {
        "color": "#ff79c6"
      },
      "boolean": {
        "color": "#bd93f9"
      },
      "number": {
        "color": "#bd93f9"
      },
      "selector": {
        "color": "#50fa7b"
      },
      "attr-name": {
        "color": "#50fa7b"
      },
      "string": {
        "color": "#50fa7b"
      },
      "char": {
        "color": "#50fa7b"
      },
      "builtin": {
        "color": "#50fa7b"
      },
      "inserted": {
        "color": "#50fa7b"
      },
      "operator": {
        "color": "#f8f8f2"
      },
      "entity": {
        "color": "#f8f8f2",
        "cursor": "help"
      },
      "url": {
        "color": "#f8f8f2"
      },
      ".language-css .token.string": {
        "color": "#f8f8f2"
      },
      ".style .token.string": {
        "color": "#f8f8f2"
      },
      "variable": {
        "color": "#f8f8f2"
      },
      "atrule": {
        "color": "#f1fa8c"
      },
      "attr-value": {
        "color": "#f1fa8c"
      },
      "function": {
        "color": "#f1fa8c"
      },
      "class-name": {
        "color": "#f1fa8c"
      },
      "keyword": {
        "color": "#8be9fd"
      },
      "regex": {
        "color": "#ffb86c"
      },
      "important": {
        "color": "#ffb86c",
        "fontWeight": "bold"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/duotone-dark.js
var require_duotone_dark = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/duotone-dark.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "fontFamily": 'Consolas, Menlo, Monaco, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", "Courier New", Courier, monospace',
        "fontSize": "14px",
        "lineHeight": "1.375",
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "background": "#2a2734",
        "color": "#9a86fd"
      },
      'pre[class*="language-"]': {
        "fontFamily": 'Consolas, Menlo, Monaco, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", "Courier New", Courier, monospace',
        "fontSize": "14px",
        "lineHeight": "1.375",
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "background": "#2a2734",
        "color": "#9a86fd",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto"
      },
      'pre > code[class*="language-"]': {
        "fontSize": "1em"
      },
      'pre[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "#6a51e6"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "#6a51e6"
      },
      'code[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "#6a51e6"
      },
      'code[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "#6a51e6"
      },
      'pre[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#6a51e6"
      },
      'pre[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "#6a51e6"
      },
      'code[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#6a51e6"
      },
      'code[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "#6a51e6"
      },
      ':not(pre) > code[class*="language-"]': {
        "padding": ".1em",
        "borderRadius": ".3em"
      },
      "comment": {
        "color": "#6c6783"
      },
      "prolog": {
        "color": "#6c6783"
      },
      "doctype": {
        "color": "#6c6783"
      },
      "cdata": {
        "color": "#6c6783"
      },
      "punctuation": {
        "color": "#6c6783"
      },
      "namespace": {
        "Opacity": ".7"
      },
      "tag": {
        "color": "#e09142"
      },
      "operator": {
        "color": "#e09142"
      },
      "number": {
        "color": "#e09142"
      },
      "property": {
        "color": "#9a86fd"
      },
      "function": {
        "color": "#9a86fd"
      },
      "tag-id": {
        "color": "#eeebff"
      },
      "selector": {
        "color": "#eeebff"
      },
      "atrule-id": {
        "color": "#eeebff"
      },
      "code.language-javascript": {
        "color": "#c4b9fe"
      },
      "attr-name": {
        "color": "#c4b9fe"
      },
      "code.language-css": {
        "color": "#ffcc99"
      },
      "code.language-scss": {
        "color": "#ffcc99"
      },
      "boolean": {
        "color": "#ffcc99"
      },
      "string": {
        "color": "#ffcc99"
      },
      "entity": {
        "color": "#ffcc99",
        "cursor": "help"
      },
      "url": {
        "color": "#ffcc99"
      },
      ".language-css .token.string": {
        "color": "#ffcc99"
      },
      ".language-scss .token.string": {
        "color": "#ffcc99"
      },
      ".style .token.string": {
        "color": "#ffcc99"
      },
      "attr-value": {
        "color": "#ffcc99"
      },
      "keyword": {
        "color": "#ffcc99"
      },
      "control": {
        "color": "#ffcc99"
      },
      "directive": {
        "color": "#ffcc99"
      },
      "unit": {
        "color": "#ffcc99"
      },
      "statement": {
        "color": "#ffcc99"
      },
      "regex": {
        "color": "#ffcc99"
      },
      "atrule": {
        "color": "#ffcc99"
      },
      "placeholder": {
        "color": "#ffcc99"
      },
      "variable": {
        "color": "#ffcc99"
      },
      "deleted": {
        "textDecoration": "line-through"
      },
      "inserted": {
        "borderBottom": "1px dotted #eeebff",
        "textDecoration": "none"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "important": {
        "fontWeight": "bold",
        "color": "#c4b9fe"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "pre > code.highlight": {
        "Outline": ".4em solid #8a75f5",
        "OutlineOffset": ".4em"
      },
      ".line-numbers.line-numbers .line-numbers-rows": {
        "borderRightColor": "#2c2937"
      },
      ".line-numbers .line-numbers-rows > span:before": {
        "color": "#3c3949"
      },
      ".line-highlight.line-highlight": {
        "background": "linear-gradient(to right, rgba(224, 145, 66, 0.2) 70%, rgba(224, 145, 66, 0))"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/duotone-earth.js
var require_duotone_earth = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/duotone-earth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "fontFamily": 'Consolas, Menlo, Monaco, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", "Courier New", Courier, monospace',
        "fontSize": "14px",
        "lineHeight": "1.375",
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "background": "#322d29",
        "color": "#88786d"
      },
      'pre[class*="language-"]': {
        "fontFamily": 'Consolas, Menlo, Monaco, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", "Courier New", Courier, monospace',
        "fontSize": "14px",
        "lineHeight": "1.375",
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "background": "#322d29",
        "color": "#88786d",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto"
      },
      'pre > code[class*="language-"]': {
        "fontSize": "1em"
      },
      'pre[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "#6f5849"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "#6f5849"
      },
      'code[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "#6f5849"
      },
      'code[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "#6f5849"
      },
      'pre[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#6f5849"
      },
      'pre[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "#6f5849"
      },
      'code[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#6f5849"
      },
      'code[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "#6f5849"
      },
      ':not(pre) > code[class*="language-"]': {
        "padding": ".1em",
        "borderRadius": ".3em"
      },
      "comment": {
        "color": "#6a5f58"
      },
      "prolog": {
        "color": "#6a5f58"
      },
      "doctype": {
        "color": "#6a5f58"
      },
      "cdata": {
        "color": "#6a5f58"
      },
      "punctuation": {
        "color": "#6a5f58"
      },
      "namespace": {
        "Opacity": ".7"
      },
      "tag": {
        "color": "#bfa05a"
      },
      "operator": {
        "color": "#bfa05a"
      },
      "number": {
        "color": "#bfa05a"
      },
      "property": {
        "color": "#88786d"
      },
      "function": {
        "color": "#88786d"
      },
      "tag-id": {
        "color": "#fff3eb"
      },
      "selector": {
        "color": "#fff3eb"
      },
      "atrule-id": {
        "color": "#fff3eb"
      },
      "code.language-javascript": {
        "color": "#a48774"
      },
      "attr-name": {
        "color": "#a48774"
      },
      "code.language-css": {
        "color": "#fcc440"
      },
      "code.language-scss": {
        "color": "#fcc440"
      },
      "boolean": {
        "color": "#fcc440"
      },
      "string": {
        "color": "#fcc440"
      },
      "entity": {
        "color": "#fcc440",
        "cursor": "help"
      },
      "url": {
        "color": "#fcc440"
      },
      ".language-css .token.string": {
        "color": "#fcc440"
      },
      ".language-scss .token.string": {
        "color": "#fcc440"
      },
      ".style .token.string": {
        "color": "#fcc440"
      },
      "attr-value": {
        "color": "#fcc440"
      },
      "keyword": {
        "color": "#fcc440"
      },
      "control": {
        "color": "#fcc440"
      },
      "directive": {
        "color": "#fcc440"
      },
      "unit": {
        "color": "#fcc440"
      },
      "statement": {
        "color": "#fcc440"
      },
      "regex": {
        "color": "#fcc440"
      },
      "atrule": {
        "color": "#fcc440"
      },
      "placeholder": {
        "color": "#fcc440"
      },
      "variable": {
        "color": "#fcc440"
      },
      "deleted": {
        "textDecoration": "line-through"
      },
      "inserted": {
        "borderBottom": "1px dotted #fff3eb",
        "textDecoration": "none"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "important": {
        "fontWeight": "bold",
        "color": "#a48774"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "pre > code.highlight": {
        "Outline": ".4em solid #816d5f",
        "OutlineOffset": ".4em"
      },
      ".line-numbers.line-numbers .line-numbers-rows": {
        "borderRightColor": "#35302b"
      },
      ".line-numbers .line-numbers-rows > span:before": {
        "color": "#46403d"
      },
      ".line-highlight.line-highlight": {
        "background": "linear-gradient(to right, rgba(191, 160, 90, 0.2) 70%, rgba(191, 160, 90, 0))"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/duotone-forest.js
var require_duotone_forest = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/duotone-forest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "fontFamily": 'Consolas, Menlo, Monaco, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", "Courier New", Courier, monospace',
        "fontSize": "14px",
        "lineHeight": "1.375",
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "background": "#2a2d2a",
        "color": "#687d68"
      },
      'pre[class*="language-"]': {
        "fontFamily": 'Consolas, Menlo, Monaco, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", "Courier New", Courier, monospace',
        "fontSize": "14px",
        "lineHeight": "1.375",
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "background": "#2a2d2a",
        "color": "#687d68",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto"
      },
      'pre > code[class*="language-"]': {
        "fontSize": "1em"
      },
      'pre[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "#435643"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "#435643"
      },
      'code[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "#435643"
      },
      'code[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "#435643"
      },
      'pre[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#435643"
      },
      'pre[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "#435643"
      },
      'code[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#435643"
      },
      'code[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "#435643"
      },
      ':not(pre) > code[class*="language-"]': {
        "padding": ".1em",
        "borderRadius": ".3em"
      },
      "comment": {
        "color": "#535f53"
      },
      "prolog": {
        "color": "#535f53"
      },
      "doctype": {
        "color": "#535f53"
      },
      "cdata": {
        "color": "#535f53"
      },
      "punctuation": {
        "color": "#535f53"
      },
      "namespace": {
        "Opacity": ".7"
      },
      "tag": {
        "color": "#a2b34d"
      },
      "operator": {
        "color": "#a2b34d"
      },
      "number": {
        "color": "#a2b34d"
      },
      "property": {
        "color": "#687d68"
      },
      "function": {
        "color": "#687d68"
      },
      "tag-id": {
        "color": "#f0fff0"
      },
      "selector": {
        "color": "#f0fff0"
      },
      "atrule-id": {
        "color": "#f0fff0"
      },
      "code.language-javascript": {
        "color": "#b3d6b3"
      },
      "attr-name": {
        "color": "#b3d6b3"
      },
      "code.language-css": {
        "color": "#e5fb79"
      },
      "code.language-scss": {
        "color": "#e5fb79"
      },
      "boolean": {
        "color": "#e5fb79"
      },
      "string": {
        "color": "#e5fb79"
      },
      "entity": {
        "color": "#e5fb79",
        "cursor": "help"
      },
      "url": {
        "color": "#e5fb79"
      },
      ".language-css .token.string": {
        "color": "#e5fb79"
      },
      ".language-scss .token.string": {
        "color": "#e5fb79"
      },
      ".style .token.string": {
        "color": "#e5fb79"
      },
      "attr-value": {
        "color": "#e5fb79"
      },
      "keyword": {
        "color": "#e5fb79"
      },
      "control": {
        "color": "#e5fb79"
      },
      "directive": {
        "color": "#e5fb79"
      },
      "unit": {
        "color": "#e5fb79"
      },
      "statement": {
        "color": "#e5fb79"
      },
      "regex": {
        "color": "#e5fb79"
      },
      "atrule": {
        "color": "#e5fb79"
      },
      "placeholder": {
        "color": "#e5fb79"
      },
      "variable": {
        "color": "#e5fb79"
      },
      "deleted": {
        "textDecoration": "line-through"
      },
      "inserted": {
        "borderBottom": "1px dotted #f0fff0",
        "textDecoration": "none"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "important": {
        "fontWeight": "bold",
        "color": "#b3d6b3"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "pre > code.highlight": {
        "Outline": ".4em solid #5c705c",
        "OutlineOffset": ".4em"
      },
      ".line-numbers.line-numbers .line-numbers-rows": {
        "borderRightColor": "#2c302c"
      },
      ".line-numbers .line-numbers-rows > span:before": {
        "color": "#3b423b"
      },
      ".line-highlight.line-highlight": {
        "background": "linear-gradient(to right, rgba(162, 179, 77, 0.2) 70%, rgba(162, 179, 77, 0))"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/duotone-light.js
var require_duotone_light = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/duotone-light.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "fontFamily": 'Consolas, Menlo, Monaco, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", "Courier New", Courier, monospace',
        "fontSize": "14px",
        "lineHeight": "1.375",
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "background": "#faf8f5",
        "color": "#728fcb"
      },
      'pre[class*="language-"]': {
        "fontFamily": 'Consolas, Menlo, Monaco, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", "Courier New", Courier, monospace',
        "fontSize": "14px",
        "lineHeight": "1.375",
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "background": "#faf8f5",
        "color": "#728fcb",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto"
      },
      'pre > code[class*="language-"]': {
        "fontSize": "1em"
      },
      'pre[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "#faf8f5"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "#faf8f5"
      },
      'code[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "#faf8f5"
      },
      'code[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "#faf8f5"
      },
      'pre[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#faf8f5"
      },
      'pre[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "#faf8f5"
      },
      'code[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#faf8f5"
      },
      'code[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "#faf8f5"
      },
      ':not(pre) > code[class*="language-"]': {
        "padding": ".1em",
        "borderRadius": ".3em"
      },
      "comment": {
        "color": "#b6ad9a"
      },
      "prolog": {
        "color": "#b6ad9a"
      },
      "doctype": {
        "color": "#b6ad9a"
      },
      "cdata": {
        "color": "#b6ad9a"
      },
      "punctuation": {
        "color": "#b6ad9a"
      },
      "namespace": {
        "Opacity": ".7"
      },
      "tag": {
        "color": "#063289"
      },
      "operator": {
        "color": "#063289"
      },
      "number": {
        "color": "#063289"
      },
      "property": {
        "color": "#b29762"
      },
      "function": {
        "color": "#b29762"
      },
      "tag-id": {
        "color": "#2d2006"
      },
      "selector": {
        "color": "#2d2006"
      },
      "atrule-id": {
        "color": "#2d2006"
      },
      "code.language-javascript": {
        "color": "#896724"
      },
      "attr-name": {
        "color": "#896724"
      },
      "code.language-css": {
        "color": "#728fcb"
      },
      "code.language-scss": {
        "color": "#728fcb"
      },
      "boolean": {
        "color": "#728fcb"
      },
      "string": {
        "color": "#728fcb"
      },
      "entity": {
        "color": "#728fcb",
        "cursor": "help"
      },
      "url": {
        "color": "#728fcb"
      },
      ".language-css .token.string": {
        "color": "#728fcb"
      },
      ".language-scss .token.string": {
        "color": "#728fcb"
      },
      ".style .token.string": {
        "color": "#728fcb"
      },
      "attr-value": {
        "color": "#728fcb"
      },
      "keyword": {
        "color": "#728fcb"
      },
      "control": {
        "color": "#728fcb"
      },
      "directive": {
        "color": "#728fcb"
      },
      "unit": {
        "color": "#728fcb"
      },
      "statement": {
        "color": "#728fcb"
      },
      "regex": {
        "color": "#728fcb"
      },
      "atrule": {
        "color": "#728fcb"
      },
      "placeholder": {
        "color": "#93abdc"
      },
      "variable": {
        "color": "#93abdc"
      },
      "deleted": {
        "textDecoration": "line-through"
      },
      "inserted": {
        "borderBottom": "1px dotted #2d2006",
        "textDecoration": "none"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "important": {
        "fontWeight": "bold",
        "color": "#896724"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "pre > code.highlight": {
        "Outline": ".4em solid #896724",
        "OutlineOffset": ".4em"
      },
      ".line-numbers.line-numbers .line-numbers-rows": {
        "borderRightColor": "#ece8de"
      },
      ".line-numbers .line-numbers-rows > span:before": {
        "color": "#cdc4b1"
      },
      ".line-highlight.line-highlight": {
        "background": "linear-gradient(to right, rgba(45, 32, 6, 0.2) 70%, rgba(45, 32, 6, 0))"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/duotone-sea.js
var require_duotone_sea = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/duotone-sea.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "fontFamily": 'Consolas, Menlo, Monaco, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", "Courier New", Courier, monospace',
        "fontSize": "14px",
        "lineHeight": "1.375",
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "background": "#1d262f",
        "color": "#57718e"
      },
      'pre[class*="language-"]': {
        "fontFamily": 'Consolas, Menlo, Monaco, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", "Courier New", Courier, monospace',
        "fontSize": "14px",
        "lineHeight": "1.375",
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "background": "#1d262f",
        "color": "#57718e",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto"
      },
      'pre > code[class*="language-"]': {
        "fontSize": "1em"
      },
      'pre[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "#004a9e"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "#004a9e"
      },
      'code[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "#004a9e"
      },
      'code[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "#004a9e"
      },
      'pre[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#004a9e"
      },
      'pre[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "#004a9e"
      },
      'code[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#004a9e"
      },
      'code[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "#004a9e"
      },
      ':not(pre) > code[class*="language-"]': {
        "padding": ".1em",
        "borderRadius": ".3em"
      },
      "comment": {
        "color": "#4a5f78"
      },
      "prolog": {
        "color": "#4a5f78"
      },
      "doctype": {
        "color": "#4a5f78"
      },
      "cdata": {
        "color": "#4a5f78"
      },
      "punctuation": {
        "color": "#4a5f78"
      },
      "namespace": {
        "Opacity": ".7"
      },
      "tag": {
        "color": "#0aa370"
      },
      "operator": {
        "color": "#0aa370"
      },
      "number": {
        "color": "#0aa370"
      },
      "property": {
        "color": "#57718e"
      },
      "function": {
        "color": "#57718e"
      },
      "tag-id": {
        "color": "#ebf4ff"
      },
      "selector": {
        "color": "#ebf4ff"
      },
      "atrule-id": {
        "color": "#ebf4ff"
      },
      "code.language-javascript": {
        "color": "#7eb6f6"
      },
      "attr-name": {
        "color": "#7eb6f6"
      },
      "code.language-css": {
        "color": "#47ebb4"
      },
      "code.language-scss": {
        "color": "#47ebb4"
      },
      "boolean": {
        "color": "#47ebb4"
      },
      "string": {
        "color": "#47ebb4"
      },
      "entity": {
        "color": "#47ebb4",
        "cursor": "help"
      },
      "url": {
        "color": "#47ebb4"
      },
      ".language-css .token.string": {
        "color": "#47ebb4"
      },
      ".language-scss .token.string": {
        "color": "#47ebb4"
      },
      ".style .token.string": {
        "color": "#47ebb4"
      },
      "attr-value": {
        "color": "#47ebb4"
      },
      "keyword": {
        "color": "#47ebb4"
      },
      "control": {
        "color": "#47ebb4"
      },
      "directive": {
        "color": "#47ebb4"
      },
      "unit": {
        "color": "#47ebb4"
      },
      "statement": {
        "color": "#47ebb4"
      },
      "regex": {
        "color": "#47ebb4"
      },
      "atrule": {
        "color": "#47ebb4"
      },
      "placeholder": {
        "color": "#47ebb4"
      },
      "variable": {
        "color": "#47ebb4"
      },
      "deleted": {
        "textDecoration": "line-through"
      },
      "inserted": {
        "borderBottom": "1px dotted #ebf4ff",
        "textDecoration": "none"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "important": {
        "fontWeight": "bold",
        "color": "#7eb6f6"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "pre > code.highlight": {
        "Outline": ".4em solid #34659d",
        "OutlineOffset": ".4em"
      },
      ".line-numbers.line-numbers .line-numbers-rows": {
        "borderRightColor": "#1f2932"
      },
      ".line-numbers .line-numbers-rows > span:before": {
        "color": "#2c3847"
      },
      ".line-highlight.line-highlight": {
        "background": "linear-gradient(to right, rgba(10, 163, 112, 0.2) 70%, rgba(10, 163, 112, 0))"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/duotone-space.js
var require_duotone_space = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/duotone-space.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "fontFamily": 'Consolas, Menlo, Monaco, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", "Courier New", Courier, monospace',
        "fontSize": "14px",
        "lineHeight": "1.375",
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "background": "#24242e",
        "color": "#767693"
      },
      'pre[class*="language-"]': {
        "fontFamily": 'Consolas, Menlo, Monaco, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", "Courier New", Courier, monospace',
        "fontSize": "14px",
        "lineHeight": "1.375",
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "background": "#24242e",
        "color": "#767693",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto"
      },
      'pre > code[class*="language-"]': {
        "fontSize": "1em"
      },
      'pre[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "#5151e6"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "#5151e6"
      },
      'code[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "#5151e6"
      },
      'code[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "#5151e6"
      },
      'pre[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#5151e6"
      },
      'pre[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "#5151e6"
      },
      'code[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#5151e6"
      },
      'code[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "#5151e6"
      },
      ':not(pre) > code[class*="language-"]': {
        "padding": ".1em",
        "borderRadius": ".3em"
      },
      "comment": {
        "color": "#5b5b76"
      },
      "prolog": {
        "color": "#5b5b76"
      },
      "doctype": {
        "color": "#5b5b76"
      },
      "cdata": {
        "color": "#5b5b76"
      },
      "punctuation": {
        "color": "#5b5b76"
      },
      "namespace": {
        "Opacity": ".7"
      },
      "tag": {
        "color": "#dd672c"
      },
      "operator": {
        "color": "#dd672c"
      },
      "number": {
        "color": "#dd672c"
      },
      "property": {
        "color": "#767693"
      },
      "function": {
        "color": "#767693"
      },
      "tag-id": {
        "color": "#ebebff"
      },
      "selector": {
        "color": "#ebebff"
      },
      "atrule-id": {
        "color": "#ebebff"
      },
      "code.language-javascript": {
        "color": "#aaaaca"
      },
      "attr-name": {
        "color": "#aaaaca"
      },
      "code.language-css": {
        "color": "#fe8c52"
      },
      "code.language-scss": {
        "color": "#fe8c52"
      },
      "boolean": {
        "color": "#fe8c52"
      },
      "string": {
        "color": "#fe8c52"
      },
      "entity": {
        "color": "#fe8c52",
        "cursor": "help"
      },
      "url": {
        "color": "#fe8c52"
      },
      ".language-css .token.string": {
        "color": "#fe8c52"
      },
      ".language-scss .token.string": {
        "color": "#fe8c52"
      },
      ".style .token.string": {
        "color": "#fe8c52"
      },
      "attr-value": {
        "color": "#fe8c52"
      },
      "keyword": {
        "color": "#fe8c52"
      },
      "control": {
        "color": "#fe8c52"
      },
      "directive": {
        "color": "#fe8c52"
      },
      "unit": {
        "color": "#fe8c52"
      },
      "statement": {
        "color": "#fe8c52"
      },
      "regex": {
        "color": "#fe8c52"
      },
      "atrule": {
        "color": "#fe8c52"
      },
      "placeholder": {
        "color": "#fe8c52"
      },
      "variable": {
        "color": "#fe8c52"
      },
      "deleted": {
        "textDecoration": "line-through"
      },
      "inserted": {
        "borderBottom": "1px dotted #ebebff",
        "textDecoration": "none"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "important": {
        "fontWeight": "bold",
        "color": "#aaaaca"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "pre > code.highlight": {
        "Outline": ".4em solid #7676f4",
        "OutlineOffset": ".4em"
      },
      ".line-numbers.line-numbers .line-numbers-rows": {
        "borderRightColor": "#262631"
      },
      ".line-numbers .line-numbers-rows > span:before": {
        "color": "#393949"
      },
      ".line-highlight.line-highlight": {
        "background": "linear-gradient(to right, rgba(221, 103, 44, 0.2) 70%, rgba(221, 103, 44, 0))"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/ghcolors.js
var require_ghcolors = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/ghcolors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "#393A34",
        "fontFamily": '"Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace',
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "fontSize": ".9em",
        "lineHeight": "1.2em",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "#393A34",
        "fontFamily": '"Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace',
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "fontSize": ".9em",
        "lineHeight": "1.2em",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto",
        "border": "1px solid #dddddd",
        "backgroundColor": "white"
      },
      'pre > code[class*="language-"]': {
        "fontSize": "1em"
      },
      'pre[class*="language-"]::-moz-selection': {
        "background": "#b3d4fc"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "background": "#b3d4fc"
      },
      'code[class*="language-"]::-moz-selection': {
        "background": "#b3d4fc"
      },
      'code[class*="language-"] ::-moz-selection': {
        "background": "#b3d4fc"
      },
      'pre[class*="language-"]::selection': {
        "background": "#b3d4fc"
      },
      'pre[class*="language-"] ::selection': {
        "background": "#b3d4fc"
      },
      'code[class*="language-"]::selection': {
        "background": "#b3d4fc"
      },
      'code[class*="language-"] ::selection': {
        "background": "#b3d4fc"
      },
      ':not(pre) > code[class*="language-"]': {
        "padding": ".2em",
        "paddingTop": "1px",
        "paddingBottom": "1px",
        "background": "#f8f8f8",
        "border": "1px solid #dddddd"
      },
      "comment": {
        "color": "#999988",
        "fontStyle": "italic"
      },
      "prolog": {
        "color": "#999988",
        "fontStyle": "italic"
      },
      "doctype": {
        "color": "#999988",
        "fontStyle": "italic"
      },
      "cdata": {
        "color": "#999988",
        "fontStyle": "italic"
      },
      "namespace": {
        "Opacity": ".7"
      },
      "string": {
        "color": "#e3116c"
      },
      "attr-value": {
        "color": "#e3116c"
      },
      "punctuation": {
        "color": "#393A34"
      },
      "operator": {
        "color": "#393A34"
      },
      "entity": {
        "color": "#36acaa"
      },
      "url": {
        "color": "#36acaa"
      },
      "symbol": {
        "color": "#36acaa"
      },
      "number": {
        "color": "#36acaa"
      },
      "boolean": {
        "color": "#36acaa"
      },
      "variable": {
        "color": "#36acaa"
      },
      "constant": {
        "color": "#36acaa"
      },
      "property": {
        "color": "#36acaa"
      },
      "regex": {
        "color": "#36acaa"
      },
      "inserted": {
        "color": "#36acaa"
      },
      "atrule": {
        "color": "#00a4db"
      },
      "keyword": {
        "color": "#00a4db"
      },
      "attr-name": {
        "color": "#00a4db"
      },
      ".language-autohotkey .token.selector": {
        "color": "#00a4db"
      },
      "function": {
        "color": "#9a050f",
        "fontWeight": "bold"
      },
      "deleted": {
        "color": "#9a050f"
      },
      ".language-autohotkey .token.tag": {
        "color": "#9a050f"
      },
      "tag": {
        "color": "#00009f"
      },
      "selector": {
        "color": "#00009f"
      },
      ".language-autohotkey .token.keyword": {
        "color": "#00009f"
      },
      "important": {
        "fontWeight": "bold"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/gruvbox-dark.js
var require_gruvbox_dark = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/gruvbox-dark.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "#ebdbb2",
        "fontFamily": 'Consolas, Monaco, "Andale Mono", monospace',
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "#ebdbb2",
        "fontFamily": 'Consolas, Monaco, "Andale Mono", monospace',
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": "0.5em 0",
        "overflow": "auto",
        "background": "#1d2021"
      },
      'pre[class*="language-"]::-moz-selection': {
        "color": "#fbf1c7",
        "background": "#7c6f64"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "color": "#fbf1c7",
        "background": "#7c6f64"
      },
      'code[class*="language-"]::-moz-selection': {
        "color": "#fbf1c7",
        "background": "#7c6f64"
      },
      'code[class*="language-"] ::-moz-selection': {
        "color": "#fbf1c7",
        "background": "#7c6f64"
      },
      'pre[class*="language-"]::selection': {
        "color": "#fbf1c7",
        "background": "#7c6f64"
      },
      'pre[class*="language-"] ::selection': {
        "color": "#fbf1c7",
        "background": "#7c6f64"
      },
      'code[class*="language-"]::selection': {
        "color": "#fbf1c7",
        "background": "#7c6f64"
      },
      'code[class*="language-"] ::selection': {
        "color": "#fbf1c7",
        "background": "#7c6f64"
      },
      ':not(pre) > code[class*="language-"]': {
        "background": "#1d2021",
        "padding": "0.1em",
        "borderRadius": "0.3em"
      },
      "comment": {
        "color": "#a89984"
      },
      "prolog": {
        "color": "#a89984"
      },
      "cdata": {
        "color": "#a89984"
      },
      "delimiter": {
        "color": "#fb4934"
      },
      "boolean": {
        "color": "#fb4934"
      },
      "keyword": {
        "color": "#fb4934"
      },
      "selector": {
        "color": "#fb4934"
      },
      "important": {
        "color": "#fb4934"
      },
      "atrule": {
        "color": "#fb4934"
      },
      "operator": {
        "color": "#a89984"
      },
      "punctuation": {
        "color": "#a89984"
      },
      "attr-name": {
        "color": "#a89984"
      },
      "tag": {
        "color": "#fabd2f"
      },
      "tag.punctuation": {
        "color": "#fabd2f"
      },
      "doctype": {
        "color": "#fabd2f"
      },
      "builtin": {
        "color": "#fabd2f"
      },
      "entity": {
        "color": "#d3869b"
      },
      "number": {
        "color": "#d3869b"
      },
      "symbol": {
        "color": "#d3869b"
      },
      "property": {
        "color": "#fb4934"
      },
      "constant": {
        "color": "#fb4934"
      },
      "variable": {
        "color": "#fb4934"
      },
      "string": {
        "color": "#b8bb26"
      },
      "char": {
        "color": "#b8bb26"
      },
      "attr-value": {
        "color": "#a89984"
      },
      "attr-value.punctuation": {
        "color": "#a89984"
      },
      "url": {
        "color": "#b8bb26",
        "textDecoration": "underline"
      },
      "function": {
        "color": "#fabd2f"
      },
      "regex": {
        "background": "#b8bb26"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "inserted": {
        "background": "#a89984"
      },
      "deleted": {
        "background": "#fb4934"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/gruvbox-light.js
var require_gruvbox_light = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/gruvbox-light.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "#3c3836",
        "fontFamily": 'Consolas, Monaco, "Andale Mono", monospace',
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "#3c3836",
        "fontFamily": 'Consolas, Monaco, "Andale Mono", monospace',
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": "0.5em 0",
        "overflow": "auto",
        "background": "#f9f5d7"
      },
      'pre[class*="language-"]::-moz-selection': {
        "color": "#282828",
        "background": "#a89984"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "color": "#282828",
        "background": "#a89984"
      },
      'code[class*="language-"]::-moz-selection': {
        "color": "#282828",
        "background": "#a89984"
      },
      'code[class*="language-"] ::-moz-selection': {
        "color": "#282828",
        "background": "#a89984"
      },
      'pre[class*="language-"]::selection': {
        "color": "#282828",
        "background": "#a89984"
      },
      'pre[class*="language-"] ::selection': {
        "color": "#282828",
        "background": "#a89984"
      },
      'code[class*="language-"]::selection': {
        "color": "#282828",
        "background": "#a89984"
      },
      'code[class*="language-"] ::selection': {
        "color": "#282828",
        "background": "#a89984"
      },
      ':not(pre) > code[class*="language-"]': {
        "background": "#f9f5d7",
        "padding": "0.1em",
        "borderRadius": "0.3em"
      },
      "comment": {
        "color": "#7c6f64"
      },
      "prolog": {
        "color": "#7c6f64"
      },
      "cdata": {
        "color": "#7c6f64"
      },
      "delimiter": {
        "color": "#9d0006"
      },
      "boolean": {
        "color": "#9d0006"
      },
      "keyword": {
        "color": "#9d0006"
      },
      "selector": {
        "color": "#9d0006"
      },
      "important": {
        "color": "#9d0006"
      },
      "atrule": {
        "color": "#9d0006"
      },
      "operator": {
        "color": "#7c6f64"
      },
      "punctuation": {
        "color": "#7c6f64"
      },
      "attr-name": {
        "color": "#7c6f64"
      },
      "tag": {
        "color": "#b57614"
      },
      "tag.punctuation": {
        "color": "#b57614"
      },
      "doctype": {
        "color": "#b57614"
      },
      "builtin": {
        "color": "#b57614"
      },
      "entity": {
        "color": "#8f3f71"
      },
      "number": {
        "color": "#8f3f71"
      },
      "symbol": {
        "color": "#8f3f71"
      },
      "property": {
        "color": "#9d0006"
      },
      "constant": {
        "color": "#9d0006"
      },
      "variable": {
        "color": "#9d0006"
      },
      "string": {
        "color": "#797403"
      },
      "char": {
        "color": "#797403"
      },
      "attr-value": {
        "color": "#7c6f64"
      },
      "attr-value.punctuation": {
        "color": "#7c6f64"
      },
      "url": {
        "color": "#797403",
        "textDecoration": "underline"
      },
      "function": {
        "color": "#b57614"
      },
      "regex": {
        "background": "#797403"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "inserted": {
        "background": "#7c6f64"
      },
      "deleted": {
        "background": "#9d0006"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/holi-theme.js
var require_holi_theme = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/holi-theme.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      "code[class*='language-']": {
        "color": "#d6e7ff",
        "background": "#030314",
        "textShadow": "none",
        "fontFamily": 'Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace',
        "fontSize": "1em",
        "lineHeight": "1.5",
        "letterSpacing": ".2px",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "textAlign": "left",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      "pre[class*='language-']": {
        "color": "#d6e7ff",
        "background": "#030314",
        "textShadow": "none",
        "fontFamily": 'Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace',
        "fontSize": "1em",
        "lineHeight": "1.5",
        "letterSpacing": ".2px",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "textAlign": "left",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "border": "1px solid #2a4555",
        "borderRadius": "5px",
        "padding": "1.5em 1em",
        "margin": "1em 0",
        "overflow": "auto"
      },
      "pre[class*='language-']::-moz-selection": {
        "color": "inherit",
        "background": "#1d3b54",
        "textShadow": "none"
      },
      "pre[class*='language-'] ::-moz-selection": {
        "color": "inherit",
        "background": "#1d3b54",
        "textShadow": "none"
      },
      "code[class*='language-']::-moz-selection": {
        "color": "inherit",
        "background": "#1d3b54",
        "textShadow": "none"
      },
      "code[class*='language-'] ::-moz-selection": {
        "color": "inherit",
        "background": "#1d3b54",
        "textShadow": "none"
      },
      "pre[class*='language-']::selection": {
        "color": "inherit",
        "background": "#1d3b54",
        "textShadow": "none"
      },
      "pre[class*='language-'] ::selection": {
        "color": "inherit",
        "background": "#1d3b54",
        "textShadow": "none"
      },
      "code[class*='language-']::selection": {
        "color": "inherit",
        "background": "#1d3b54",
        "textShadow": "none"
      },
      "code[class*='language-'] ::selection": {
        "color": "inherit",
        "background": "#1d3b54",
        "textShadow": "none"
      },
      ":not(pre) > code[class*='language-']": {
        "color": "#f0f6f6",
        "background": "#2a4555",
        "padding": "0.2em 0.3em",
        "borderRadius": "0.2em",
        "boxDecorationBreak": "clone"
      },
      "comment": {
        "color": "#446e69"
      },
      "prolog": {
        "color": "#446e69"
      },
      "doctype": {
        "color": "#446e69"
      },
      "cdata": {
        "color": "#446e69"
      },
      "punctuation": {
        "color": "#d6b007"
      },
      "property": {
        "color": "#d6e7ff"
      },
      "tag": {
        "color": "#d6e7ff"
      },
      "boolean": {
        "color": "#d6e7ff"
      },
      "number": {
        "color": "#d6e7ff"
      },
      "constant": {
        "color": "#d6e7ff"
      },
      "symbol": {
        "color": "#d6e7ff"
      },
      "deleted": {
        "color": "#d6e7ff"
      },
      "selector": {
        "color": "#e60067"
      },
      "attr-name": {
        "color": "#e60067"
      },
      "builtin": {
        "color": "#e60067"
      },
      "inserted": {
        "color": "#e60067"
      },
      "string": {
        "color": "#49c6ec"
      },
      "char": {
        "color": "#49c6ec"
      },
      "operator": {
        "color": "#ec8e01",
        "background": "transparent"
      },
      "entity": {
        "color": "#ec8e01",
        "background": "transparent"
      },
      "url": {
        "color": "#ec8e01",
        "background": "transparent"
      },
      ".language-css .token.string": {
        "color": "#ec8e01",
        "background": "transparent"
      },
      ".style .token.string": {
        "color": "#ec8e01",
        "background": "transparent"
      },
      "atrule": {
        "color": "#0fe468"
      },
      "attr-value": {
        "color": "#0fe468"
      },
      "keyword": {
        "color": "#0fe468"
      },
      "function": {
        "color": "#78f3e9"
      },
      "class-name": {
        "color": "#78f3e9"
      },
      "regex": {
        "color": "#d6e7ff"
      },
      "important": {
        "color": "#d6e7ff"
      },
      "variable": {
        "color": "#d6e7ff"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/hopscotch.js
var require_hopscotch = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/hopscotch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "fontFamily": '"Fira Mono", Menlo, Monaco, "Lucida Console", "Courier New", Courier, monospace',
        "fontSize": "16px",
        "lineHeight": "1.375",
        "direction": "ltr",
        "textAlign": "left",
        "wordSpacing": "normal",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "whiteSpace": "pre-wrap",
        "wordBreak": "break-all",
        "wordWrap": "break-word",
        "background": "#322931",
        "color": "#b9b5b8"
      },
      'pre[class*="language-"]': {
        "fontFamily": '"Fira Mono", Menlo, Monaco, "Lucida Console", "Courier New", Courier, monospace',
        "fontSize": "16px",
        "lineHeight": "1.375",
        "direction": "ltr",
        "textAlign": "left",
        "wordSpacing": "normal",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "whiteSpace": "pre-wrap",
        "wordBreak": "break-all",
        "wordWrap": "break-word",
        "background": "#322931",
        "color": "#b9b5b8",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto"
      },
      'pre > code[class*="language-"]': {
        "fontSize": "1em"
      },
      ':not(pre) > code[class*="language-"]': {
        "padding": ".1em",
        "borderRadius": ".3em"
      },
      "comment": {
        "color": "#797379"
      },
      "prolog": {
        "color": "#797379"
      },
      "doctype": {
        "color": "#797379"
      },
      "cdata": {
        "color": "#797379"
      },
      "punctuation": {
        "color": "#b9b5b8"
      },
      ".namespace": {
        "Opacity": ".7"
      },
      "null": {
        "color": "#fd8b19"
      },
      "operator": {
        "color": "#fd8b19"
      },
      "boolean": {
        "color": "#fd8b19"
      },
      "number": {
        "color": "#fd8b19"
      },
      "property": {
        "color": "#fdcc59"
      },
      "tag": {
        "color": "#1290bf"
      },
      "string": {
        "color": "#149b93"
      },
      "selector": {
        "color": "#c85e7c"
      },
      "attr-name": {
        "color": "#fd8b19"
      },
      "entity": {
        "color": "#149b93",
        "cursor": "help"
      },
      "url": {
        "color": "#149b93"
      },
      ".language-css .token.string": {
        "color": "#149b93"
      },
      ".style .token.string": {
        "color": "#149b93"
      },
      "attr-value": {
        "color": "#8fc13e"
      },
      "keyword": {
        "color": "#8fc13e"
      },
      "control": {
        "color": "#8fc13e"
      },
      "directive": {
        "color": "#8fc13e"
      },
      "unit": {
        "color": "#8fc13e"
      },
      "statement": {
        "color": "#149b93"
      },
      "regex": {
        "color": "#149b93"
      },
      "atrule": {
        "color": "#149b93"
      },
      "placeholder": {
        "color": "#1290bf"
      },
      "variable": {
        "color": "#1290bf"
      },
      "important": {
        "color": "#dd464c",
        "fontWeight": "bold"
      },
      "pre > code.highlight": {
        "Outline": ".4em solid red",
        "OutlineOffset": ".4em"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/lucario.js
var require_lucario = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/lucario.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "#f8f8f2",
        "background": "none",
        "textShadow": "0 1px rgba(0, 0, 0, 0.3)",
        "fontFamily": "Monaco, Consolas, 'Andale Mono', 'Ubuntu Mono', monospace",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "#f8f8f2",
        "background": "#263E52",
        "textShadow": "0 1px rgba(0, 0, 0, 0.3)",
        "fontFamily": "Monaco, Consolas, 'Andale Mono', 'Ubuntu Mono', monospace",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto",
        "borderRadius": "0.3em"
      },
      ':not(pre) > code[class*="language-"]': {
        "background": "#263E52",
        "padding": ".1em",
        "borderRadius": ".3em",
        "whiteSpace": "normal"
      },
      "comment": {
        "color": "#5c98cd"
      },
      "prolog": {
        "color": "#5c98cd"
      },
      "doctype": {
        "color": "#5c98cd"
      },
      "cdata": {
        "color": "#5c98cd"
      },
      "punctuation": {
        "color": "#f8f8f2"
      },
      ".namespace": {
        "Opacity": ".7"
      },
      "property": {
        "color": "#F05E5D"
      },
      "tag": {
        "color": "#F05E5D"
      },
      "constant": {
        "color": "#F05E5D"
      },
      "symbol": {
        "color": "#F05E5D"
      },
      "deleted": {
        "color": "#F05E5D"
      },
      "boolean": {
        "color": "#BC94F9"
      },
      "number": {
        "color": "#BC94F9"
      },
      "selector": {
        "color": "#FCFCD6"
      },
      "attr-name": {
        "color": "#FCFCD6"
      },
      "string": {
        "color": "#FCFCD6"
      },
      "char": {
        "color": "#FCFCD6"
      },
      "builtin": {
        "color": "#FCFCD6"
      },
      "inserted": {
        "color": "#FCFCD6"
      },
      "operator": {
        "color": "#f8f8f2"
      },
      "entity": {
        "color": "#f8f8f2",
        "cursor": "help"
      },
      "url": {
        "color": "#f8f8f2"
      },
      ".language-css .token.string": {
        "color": "#f8f8f2"
      },
      ".style .token.string": {
        "color": "#f8f8f2"
      },
      "variable": {
        "color": "#f8f8f2"
      },
      "atrule": {
        "color": "#66D8EF"
      },
      "attr-value": {
        "color": "#66D8EF"
      },
      "function": {
        "color": "#66D8EF"
      },
      "class-name": {
        "color": "#66D8EF"
      },
      "keyword": {
        "color": "#6EB26E"
      },
      "regex": {
        "color": "#F05E5D"
      },
      "important": {
        "color": "#F05E5D",
        "fontWeight": "bold"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/material-dark.js
var require_material_dark = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/material-dark.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "color": "#eee",
        "background": "#2f2f2f",
        "fontFamily": "Roboto Mono, monospace",
        "fontSize": "1em",
        "lineHeight": "1.5em",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "color": "#eee",
        "background": "#2f2f2f",
        "fontFamily": "Roboto Mono, monospace",
        "fontSize": "1em",
        "lineHeight": "1.5em",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "overflow": "auto",
        "position": "relative",
        "margin": "0.5em 0",
        "padding": "1.25em 1em"
      },
      'code[class*="language-"]::-moz-selection': {
        "background": "#363636"
      },
      'pre[class*="language-"]::-moz-selection': {
        "background": "#363636"
      },
      'code[class*="language-"] ::-moz-selection': {
        "background": "#363636"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "background": "#363636"
      },
      'code[class*="language-"]::selection': {
        "background": "#363636"
      },
      'pre[class*="language-"]::selection': {
        "background": "#363636"
      },
      'code[class*="language-"] ::selection': {
        "background": "#363636"
      },
      'pre[class*="language-"] ::selection': {
        "background": "#363636"
      },
      ':not(pre) > code[class*="language-"]': {
        "whiteSpace": "normal",
        "borderRadius": "0.2em",
        "padding": "0.1em"
      },
      ".language-css > code": {
        "color": "#fd9170"
      },
      ".language-sass > code": {
        "color": "#fd9170"
      },
      ".language-scss > code": {
        "color": "#fd9170"
      },
      '[class*="language-"] .namespace': {
        "Opacity": "0.7"
      },
      "atrule": {
        "color": "#c792ea"
      },
      "attr-name": {
        "color": "#ffcb6b"
      },
      "attr-value": {
        "color": "#a5e844"
      },
      "attribute": {
        "color": "#a5e844"
      },
      "boolean": {
        "color": "#c792ea"
      },
      "builtin": {
        "color": "#ffcb6b"
      },
      "cdata": {
        "color": "#80cbc4"
      },
      "char": {
        "color": "#80cbc4"
      },
      "class": {
        "color": "#ffcb6b"
      },
      "class-name": {
        "color": "#f2ff00"
      },
      "comment": {
        "color": "#616161"
      },
      "constant": {
        "color": "#c792ea"
      },
      "deleted": {
        "color": "#ff6666"
      },
      "doctype": {
        "color": "#616161"
      },
      "entity": {
        "color": "#ff6666"
      },
      "function": {
        "color": "#c792ea"
      },
      "hexcode": {
        "color": "#f2ff00"
      },
      "id": {
        "color": "#c792ea",
        "fontWeight": "bold"
      },
      "important": {
        "color": "#c792ea",
        "fontWeight": "bold"
      },
      "inserted": {
        "color": "#80cbc4"
      },
      "keyword": {
        "color": "#c792ea"
      },
      "number": {
        "color": "#fd9170"
      },
      "operator": {
        "color": "#89ddff"
      },
      "prolog": {
        "color": "#616161"
      },
      "property": {
        "color": "#80cbc4"
      },
      "pseudo-class": {
        "color": "#a5e844"
      },
      "pseudo-element": {
        "color": "#a5e844"
      },
      "punctuation": {
        "color": "#89ddff"
      },
      "regex": {
        "color": "#f2ff00"
      },
      "selector": {
        "color": "#ff6666"
      },
      "string": {
        "color": "#a5e844"
      },
      "symbol": {
        "color": "#c792ea"
      },
      "tag": {
        "color": "#ff6666"
      },
      "unit": {
        "color": "#fd9170"
      },
      "url": {
        "color": "#ff6666"
      },
      "variable": {
        "color": "#ff6666"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/material-light.js
var require_material_light = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/material-light.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "color": "#90a4ae",
        "background": "#fafafa",
        "fontFamily": "Roboto Mono, monospace",
        "fontSize": "1em",
        "lineHeight": "1.5em",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "color": "#90a4ae",
        "background": "#fafafa",
        "fontFamily": "Roboto Mono, monospace",
        "fontSize": "1em",
        "lineHeight": "1.5em",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "overflow": "auto",
        "position": "relative",
        "margin": "0.5em 0",
        "padding": "1.25em 1em"
      },
      'code[class*="language-"]::-moz-selection': {
        "background": "#cceae7",
        "color": "#263238"
      },
      'pre[class*="language-"]::-moz-selection': {
        "background": "#cceae7",
        "color": "#263238"
      },
      'code[class*="language-"] ::-moz-selection': {
        "background": "#cceae7",
        "color": "#263238"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "background": "#cceae7",
        "color": "#263238"
      },
      'code[class*="language-"]::selection': {
        "background": "#cceae7",
        "color": "#263238"
      },
      'pre[class*="language-"]::selection': {
        "background": "#cceae7",
        "color": "#263238"
      },
      'code[class*="language-"] ::selection': {
        "background": "#cceae7",
        "color": "#263238"
      },
      'pre[class*="language-"] ::selection': {
        "background": "#cceae7",
        "color": "#263238"
      },
      ':not(pre) > code[class*="language-"]': {
        "whiteSpace": "normal",
        "borderRadius": "0.2em",
        "padding": "0.1em"
      },
      ".language-css > code": {
        "color": "#f76d47"
      },
      ".language-sass > code": {
        "color": "#f76d47"
      },
      ".language-scss > code": {
        "color": "#f76d47"
      },
      '[class*="language-"] .namespace': {
        "Opacity": "0.7"
      },
      "atrule": {
        "color": "#7c4dff"
      },
      "attr-name": {
        "color": "#39adb5"
      },
      "attr-value": {
        "color": "#f6a434"
      },
      "attribute": {
        "color": "#f6a434"
      },
      "boolean": {
        "color": "#7c4dff"
      },
      "builtin": {
        "color": "#39adb5"
      },
      "cdata": {
        "color": "#39adb5"
      },
      "char": {
        "color": "#39adb5"
      },
      "class": {
        "color": "#39adb5"
      },
      "class-name": {
        "color": "#6182b8"
      },
      "comment": {
        "color": "#aabfc9"
      },
      "constant": {
        "color": "#7c4dff"
      },
      "deleted": {
        "color": "#e53935"
      },
      "doctype": {
        "color": "#aabfc9"
      },
      "entity": {
        "color": "#e53935"
      },
      "function": {
        "color": "#7c4dff"
      },
      "hexcode": {
        "color": "#f76d47"
      },
      "id": {
        "color": "#7c4dff",
        "fontWeight": "bold"
      },
      "important": {
        "color": "#7c4dff",
        "fontWeight": "bold"
      },
      "inserted": {
        "color": "#39adb5"
      },
      "keyword": {
        "color": "#7c4dff"
      },
      "number": {
        "color": "#f76d47"
      },
      "operator": {
        "color": "#39adb5"
      },
      "prolog": {
        "color": "#aabfc9"
      },
      "property": {
        "color": "#39adb5"
      },
      "pseudo-class": {
        "color": "#f6a434"
      },
      "pseudo-element": {
        "color": "#f6a434"
      },
      "punctuation": {
        "color": "#39adb5"
      },
      "regex": {
        "color": "#6182b8"
      },
      "selector": {
        "color": "#e53935"
      },
      "string": {
        "color": "#f6a434"
      },
      "symbol": {
        "color": "#7c4dff"
      },
      "tag": {
        "color": "#e53935"
      },
      "unit": {
        "color": "#f76d47"
      },
      "url": {
        "color": "#e53935"
      },
      "variable": {
        "color": "#e53935"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/material-oceanic.js
var require_material_oceanic = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/material-oceanic.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "color": "#c3cee3",
        "background": "#263238",
        "fontFamily": "Roboto Mono, monospace",
        "fontSize": "1em",
        "lineHeight": "1.5em",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "color": "#c3cee3",
        "background": "#263238",
        "fontFamily": "Roboto Mono, monospace",
        "fontSize": "1em",
        "lineHeight": "1.5em",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "overflow": "auto",
        "position": "relative",
        "margin": "0.5em 0",
        "padding": "1.25em 1em"
      },
      'code[class*="language-"]::-moz-selection': {
        "background": "#363636"
      },
      'pre[class*="language-"]::-moz-selection': {
        "background": "#363636"
      },
      'code[class*="language-"] ::-moz-selection': {
        "background": "#363636"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "background": "#363636"
      },
      'code[class*="language-"]::selection': {
        "background": "#363636"
      },
      'pre[class*="language-"]::selection': {
        "background": "#363636"
      },
      'code[class*="language-"] ::selection': {
        "background": "#363636"
      },
      'pre[class*="language-"] ::selection': {
        "background": "#363636"
      },
      ':not(pre) > code[class*="language-"]': {
        "whiteSpace": "normal",
        "borderRadius": "0.2em",
        "padding": "0.1em"
      },
      ".language-css > code": {
        "color": "#fd9170"
      },
      ".language-sass > code": {
        "color": "#fd9170"
      },
      ".language-scss > code": {
        "color": "#fd9170"
      },
      '[class*="language-"] .namespace': {
        "Opacity": "0.7"
      },
      "atrule": {
        "color": "#c792ea"
      },
      "attr-name": {
        "color": "#ffcb6b"
      },
      "attr-value": {
        "color": "#c3e88d"
      },
      "attribute": {
        "color": "#c3e88d"
      },
      "boolean": {
        "color": "#c792ea"
      },
      "builtin": {
        "color": "#ffcb6b"
      },
      "cdata": {
        "color": "#80cbc4"
      },
      "char": {
        "color": "#80cbc4"
      },
      "class": {
        "color": "#ffcb6b"
      },
      "class-name": {
        "color": "#f2ff00"
      },
      "color": {
        "color": "#f2ff00"
      },
      "comment": {
        "color": "#546e7a"
      },
      "constant": {
        "color": "#c792ea"
      },
      "deleted": {
        "color": "#f07178"
      },
      "doctype": {
        "color": "#546e7a"
      },
      "entity": {
        "color": "#f07178"
      },
      "function": {
        "color": "#c792ea"
      },
      "hexcode": {
        "color": "#f2ff00"
      },
      "id": {
        "color": "#c792ea",
        "fontWeight": "bold"
      },
      "important": {
        "color": "#c792ea",
        "fontWeight": "bold"
      },
      "inserted": {
        "color": "#80cbc4"
      },
      "keyword": {
        "color": "#c792ea",
        "fontStyle": "italic"
      },
      "number": {
        "color": "#fd9170"
      },
      "operator": {
        "color": "#89ddff"
      },
      "prolog": {
        "color": "#546e7a"
      },
      "property": {
        "color": "#80cbc4"
      },
      "pseudo-class": {
        "color": "#c3e88d"
      },
      "pseudo-element": {
        "color": "#c3e88d"
      },
      "punctuation": {
        "color": "#89ddff"
      },
      "regex": {
        "color": "#f2ff00"
      },
      "selector": {
        "color": "#f07178"
      },
      "string": {
        "color": "#c3e88d"
      },
      "symbol": {
        "color": "#c792ea"
      },
      "tag": {
        "color": "#f07178"
      },
      "unit": {
        "color": "#f07178"
      },
      "url": {
        "color": "#fd9170"
      },
      "variable": {
        "color": "#f07178"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/night-owl.js
var require_night_owl = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/night-owl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "#d6deeb",
        "fontFamily": 'Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace',
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "fontSize": "1em",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "white",
        "fontFamily": 'Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace',
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "fontSize": "1em",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": "0.5em 0",
        "overflow": "auto",
        "background": "#011627"
      },
      'pre[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "rgba(29, 59, 83, 0.99)"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "rgba(29, 59, 83, 0.99)"
      },
      'code[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "rgba(29, 59, 83, 0.99)"
      },
      'code[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "rgba(29, 59, 83, 0.99)"
      },
      'pre[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "rgba(29, 59, 83, 0.99)"
      },
      'pre[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "rgba(29, 59, 83, 0.99)"
      },
      'code[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "rgba(29, 59, 83, 0.99)"
      },
      'code[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "rgba(29, 59, 83, 0.99)"
      },
      ':not(pre) > code[class*="language-"]': {
        "color": "white",
        "background": "#011627",
        "padding": "0.1em",
        "borderRadius": "0.3em",
        "whiteSpace": "normal"
      },
      "comment": {
        "color": "rgb(99, 119, 119)",
        "fontStyle": "italic"
      },
      "prolog": {
        "color": "rgb(99, 119, 119)",
        "fontStyle": "italic"
      },
      "cdata": {
        "color": "rgb(99, 119, 119)",
        "fontStyle": "italic"
      },
      "punctuation": {
        "color": "rgb(199, 146, 234)"
      },
      ".namespace": {
        "color": "rgb(178, 204, 214)"
      },
      "deleted": {
        "color": "rgba(239, 83, 80, 0.56)",
        "fontStyle": "italic"
      },
      "symbol": {
        "color": "rgb(128, 203, 196)"
      },
      "property": {
        "color": "rgb(128, 203, 196)"
      },
      "tag": {
        "color": "rgb(127, 219, 202)"
      },
      "operator": {
        "color": "rgb(127, 219, 202)"
      },
      "keyword": {
        "color": "rgb(127, 219, 202)"
      },
      "boolean": {
        "color": "rgb(255, 88, 116)"
      },
      "number": {
        "color": "rgb(247, 140, 108)"
      },
      "constant": {
        "color": "rgb(130, 170, 255)"
      },
      "function": {
        "color": "rgb(130, 170, 255)"
      },
      "builtin": {
        "color": "rgb(130, 170, 255)"
      },
      "char": {
        "color": "rgb(130, 170, 255)"
      },
      "selector": {
        "color": "rgb(199, 146, 234)",
        "fontStyle": "italic"
      },
      "doctype": {
        "color": "rgb(199, 146, 234)",
        "fontStyle": "italic"
      },
      "attr-name": {
        "color": "rgb(173, 219, 103)",
        "fontStyle": "italic"
      },
      "inserted": {
        "color": "rgb(173, 219, 103)",
        "fontStyle": "italic"
      },
      "string": {
        "color": "rgb(173, 219, 103)"
      },
      "url": {
        "color": "rgb(173, 219, 103)"
      },
      "entity": {
        "color": "rgb(173, 219, 103)"
      },
      ".language-css .token.string": {
        "color": "rgb(173, 219, 103)"
      },
      ".style .token.string": {
        "color": "rgb(173, 219, 103)"
      },
      "class-name": {
        "color": "rgb(255, 203, 139)"
      },
      "atrule": {
        "color": "rgb(255, 203, 139)"
      },
      "attr-value": {
        "color": "rgb(255, 203, 139)"
      },
      "regex": {
        "color": "rgb(214, 222, 235)"
      },
      "important": {
        "color": "rgb(214, 222, 235)",
        "fontWeight": "bold"
      },
      "variable": {
        "color": "rgb(214, 222, 235)"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/nord.js
var require_nord = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/nord.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "#f8f8f2",
        "background": "none",
        "fontFamily": `"Fira Code", Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace`,
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "#f8f8f2",
        "background": "#2E3440",
        "fontFamily": `"Fira Code", Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace`,
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto",
        "borderRadius": "0.3em"
      },
      ':not(pre) > code[class*="language-"]': {
        "background": "#2E3440",
        "padding": ".1em",
        "borderRadius": ".3em",
        "whiteSpace": "normal"
      },
      "comment": {
        "color": "#636f88"
      },
      "prolog": {
        "color": "#636f88"
      },
      "doctype": {
        "color": "#636f88"
      },
      "cdata": {
        "color": "#636f88"
      },
      "punctuation": {
        "color": "#81A1C1"
      },
      ".namespace": {
        "Opacity": ".7"
      },
      "property": {
        "color": "#81A1C1"
      },
      "tag": {
        "color": "#81A1C1"
      },
      "constant": {
        "color": "#81A1C1"
      },
      "symbol": {
        "color": "#81A1C1"
      },
      "deleted": {
        "color": "#81A1C1"
      },
      "number": {
        "color": "#B48EAD"
      },
      "boolean": {
        "color": "#81A1C1"
      },
      "selector": {
        "color": "#A3BE8C"
      },
      "attr-name": {
        "color": "#A3BE8C"
      },
      "string": {
        "color": "#A3BE8C"
      },
      "char": {
        "color": "#A3BE8C"
      },
      "builtin": {
        "color": "#A3BE8C"
      },
      "inserted": {
        "color": "#A3BE8C"
      },
      "operator": {
        "color": "#81A1C1"
      },
      "entity": {
        "color": "#81A1C1",
        "cursor": "help"
      },
      "url": {
        "color": "#81A1C1"
      },
      ".language-css .token.string": {
        "color": "#81A1C1"
      },
      ".style .token.string": {
        "color": "#81A1C1"
      },
      "variable": {
        "color": "#81A1C1"
      },
      "atrule": {
        "color": "#88C0D0"
      },
      "attr-value": {
        "color": "#88C0D0"
      },
      "function": {
        "color": "#88C0D0"
      },
      "class-name": {
        "color": "#88C0D0"
      },
      "keyword": {
        "color": "#81A1C1"
      },
      "regex": {
        "color": "#EBCB8B"
      },
      "important": {
        "color": "#EBCB8B",
        "fontWeight": "bold"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/one-dark.js
var require_one_dark = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/one-dark.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "background": "hsl(220, 13%, 18%)",
        "color": "hsl(220, 14%, 71%)",
        "textShadow": "0 1px rgba(0, 0, 0, 0.3)",
        "fontFamily": '"Fira Code", "Fira Mono", Menlo, Consolas, "DejaVu Sans Mono", monospace',
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "2",
        "OTabSize": "2",
        "tabSize": "2",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "background": "hsl(220, 13%, 18%)",
        "color": "hsl(220, 14%, 71%)",
        "textShadow": "0 1px rgba(0, 0, 0, 0.3)",
        "fontFamily": '"Fira Code", "Fira Mono", Menlo, Consolas, "DejaVu Sans Mono", monospace',
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "2",
        "OTabSize": "2",
        "tabSize": "2",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": "0.5em 0",
        "overflow": "auto",
        "borderRadius": "0.3em"
      },
      'code[class*="language-"]::-moz-selection': {
        "background": "hsl(220, 13%, 28%)",
        "color": "inherit",
        "textShadow": "none"
      },
      'code[class*="language-"] *::-moz-selection': {
        "background": "hsl(220, 13%, 28%)",
        "color": "inherit",
        "textShadow": "none"
      },
      'pre[class*="language-"] *::-moz-selection': {
        "background": "hsl(220, 13%, 28%)",
        "color": "inherit",
        "textShadow": "none"
      },
      'code[class*="language-"]::selection': {
        "background": "hsl(220, 13%, 28%)",
        "color": "inherit",
        "textShadow": "none"
      },
      'code[class*="language-"] *::selection': {
        "background": "hsl(220, 13%, 28%)",
        "color": "inherit",
        "textShadow": "none"
      },
      'pre[class*="language-"] *::selection': {
        "background": "hsl(220, 13%, 28%)",
        "color": "inherit",
        "textShadow": "none"
      },
      ':not(pre) > code[class*="language-"]': {
        "padding": "0.2em 0.3em",
        "borderRadius": "0.3em",
        "whiteSpace": "normal"
      },
      "comment": {
        "color": "hsl(220, 10%, 40%)",
        "fontStyle": "italic"
      },
      "prolog": {
        "color": "hsl(220, 10%, 40%)"
      },
      "cdata": {
        "color": "hsl(220, 10%, 40%)"
      },
      "doctype": {
        "color": "hsl(220, 14%, 71%)"
      },
      "punctuation": {
        "color": "hsl(220, 14%, 71%)"
      },
      "entity": {
        "color": "hsl(220, 14%, 71%)",
        "cursor": "help"
      },
      "attr-name": {
        "color": "hsl(29, 54%, 61%)"
      },
      "class-name": {
        "color": "hsl(29, 54%, 61%)"
      },
      "boolean": {
        "color": "hsl(29, 54%, 61%)"
      },
      "constant": {
        "color": "hsl(29, 54%, 61%)"
      },
      "number": {
        "color": "hsl(29, 54%, 61%)"
      },
      "atrule": {
        "color": "hsl(29, 54%, 61%)"
      },
      "keyword": {
        "color": "hsl(286, 60%, 67%)"
      },
      "property": {
        "color": "hsl(355, 65%, 65%)"
      },
      "tag": {
        "color": "hsl(355, 65%, 65%)"
      },
      "symbol": {
        "color": "hsl(355, 65%, 65%)"
      },
      "deleted": {
        "color": "hsl(355, 65%, 65%)"
      },
      "important": {
        "color": "hsl(355, 65%, 65%)"
      },
      "selector": {
        "color": "hsl(95, 38%, 62%)"
      },
      "string": {
        "color": "hsl(95, 38%, 62%)"
      },
      "char": {
        "color": "hsl(95, 38%, 62%)"
      },
      "builtin": {
        "color": "hsl(95, 38%, 62%)"
      },
      "inserted": {
        "color": "hsl(95, 38%, 62%)"
      },
      "regex": {
        "color": "hsl(95, 38%, 62%)"
      },
      "attr-value": {
        "color": "hsl(95, 38%, 62%)"
      },
      "attr-value > .token.punctuation": {
        "color": "hsl(95, 38%, 62%)"
      },
      "variable": {
        "color": "hsl(207, 82%, 66%)"
      },
      "operator": {
        "color": "hsl(207, 82%, 66%)"
      },
      "function": {
        "color": "hsl(207, 82%, 66%)"
      },
      "url": {
        "color": "hsl(187, 47%, 55%)"
      },
      "attr-value > .token.punctuation.attr-equals": {
        "color": "hsl(220, 14%, 71%)"
      },
      "special-attr > .token.attr-value > .token.value.css": {
        "color": "hsl(220, 14%, 71%)"
      },
      ".language-css .token.selector": {
        "color": "hsl(355, 65%, 65%)"
      },
      ".language-css .token.property": {
        "color": "hsl(220, 14%, 71%)"
      },
      ".language-css .token.function": {
        "color": "hsl(187, 47%, 55%)"
      },
      ".language-css .token.url > .token.function": {
        "color": "hsl(187, 47%, 55%)"
      },
      ".language-css .token.url > .token.string.url": {
        "color": "hsl(95, 38%, 62%)"
      },
      ".language-css .token.important": {
        "color": "hsl(286, 60%, 67%)"
      },
      ".language-css .token.atrule .token.rule": {
        "color": "hsl(286, 60%, 67%)"
      },
      ".language-javascript .token.operator": {
        "color": "hsl(286, 60%, 67%)"
      },
      ".language-javascript .token.template-string > .token.interpolation > .token.interpolation-punctuation.punctuation": {
        "color": "hsl(5, 48%, 51%)"
      },
      ".language-json .token.operator": {
        "color": "hsl(220, 14%, 71%)"
      },
      ".language-json .token.null.keyword": {
        "color": "hsl(29, 54%, 61%)"
      },
      ".language-markdown .token.url": {
        "color": "hsl(220, 14%, 71%)"
      },
      ".language-markdown .token.url > .token.operator": {
        "color": "hsl(220, 14%, 71%)"
      },
      ".language-markdown .token.url-reference.url > .token.string": {
        "color": "hsl(220, 14%, 71%)"
      },
      ".language-markdown .token.url > .token.content": {
        "color": "hsl(207, 82%, 66%)"
      },
      ".language-markdown .token.url > .token.url": {
        "color": "hsl(187, 47%, 55%)"
      },
      ".language-markdown .token.url-reference.url": {
        "color": "hsl(187, 47%, 55%)"
      },
      ".language-markdown .token.blockquote.punctuation": {
        "color": "hsl(220, 10%, 40%)",
        "fontStyle": "italic"
      },
      ".language-markdown .token.hr.punctuation": {
        "color": "hsl(220, 10%, 40%)",
        "fontStyle": "italic"
      },
      ".language-markdown .token.code-snippet": {
        "color": "hsl(95, 38%, 62%)"
      },
      ".language-markdown .token.bold .token.content": {
        "color": "hsl(29, 54%, 61%)"
      },
      ".language-markdown .token.italic .token.content": {
        "color": "hsl(286, 60%, 67%)"
      },
      ".language-markdown .token.strike .token.content": {
        "color": "hsl(355, 65%, 65%)"
      },
      ".language-markdown .token.strike .token.punctuation": {
        "color": "hsl(355, 65%, 65%)"
      },
      ".language-markdown .token.list.punctuation": {
        "color": "hsl(355, 65%, 65%)"
      },
      ".language-markdown .token.title.important > .token.punctuation": {
        "color": "hsl(355, 65%, 65%)"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "namespace": {
        "Opacity": "0.8"
      },
      "token.tab:not(:empty):before": {
        "color": "hsla(220, 14%, 71%, 0.15)",
        "textShadow": "none"
      },
      "token.cr:before": {
        "color": "hsla(220, 14%, 71%, 0.15)",
        "textShadow": "none"
      },
      "token.lf:before": {
        "color": "hsla(220, 14%, 71%, 0.15)",
        "textShadow": "none"
      },
      "token.space:before": {
        "color": "hsla(220, 14%, 71%, 0.15)",
        "textShadow": "none"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item": {
        "marginRight": "0.4em"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button": {
        "background": "hsl(220, 13%, 26%)",
        "color": "hsl(220, 9%, 55%)",
        "padding": "0.1em 0.4em",
        "borderRadius": "0.3em"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a": {
        "background": "hsl(220, 13%, 26%)",
        "color": "hsl(220, 9%, 55%)",
        "padding": "0.1em 0.4em",
        "borderRadius": "0.3em"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span": {
        "background": "hsl(220, 13%, 26%)",
        "color": "hsl(220, 9%, 55%)",
        "padding": "0.1em 0.4em",
        "borderRadius": "0.3em"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button:hover": {
        "background": "hsl(220, 13%, 28%)",
        "color": "hsl(220, 14%, 71%)"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button:focus": {
        "background": "hsl(220, 13%, 28%)",
        "color": "hsl(220, 14%, 71%)"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a:hover": {
        "background": "hsl(220, 13%, 28%)",
        "color": "hsl(220, 14%, 71%)"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a:focus": {
        "background": "hsl(220, 13%, 28%)",
        "color": "hsl(220, 14%, 71%)"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span:hover": {
        "background": "hsl(220, 13%, 28%)",
        "color": "hsl(220, 14%, 71%)"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span:focus": {
        "background": "hsl(220, 13%, 28%)",
        "color": "hsl(220, 14%, 71%)"
      },
      ".line-highlight.line-highlight": {
        "background": "hsla(220, 100%, 80%, 0.04)"
      },
      ".line-highlight.line-highlight:before": {
        "background": "hsl(220, 13%, 26%)",
        "color": "hsl(220, 14%, 71%)",
        "padding": "0.1em 0.6em",
        "borderRadius": "0.3em",
        "boxShadow": "0 2px 0 0 rgba(0, 0, 0, 0.2)"
      },
      ".line-highlight.line-highlight[data-end]:after": {
        "background": "hsl(220, 13%, 26%)",
        "color": "hsl(220, 14%, 71%)",
        "padding": "0.1em 0.6em",
        "borderRadius": "0.3em",
        "boxShadow": "0 2px 0 0 rgba(0, 0, 0, 0.2)"
      },
      "pre[id].linkable-line-numbers.linkable-line-numbers span.line-numbers-rows > span:hover:before": {
        "backgroundColor": "hsla(220, 100%, 80%, 0.04)"
      },
      ".line-numbers.line-numbers .line-numbers-rows": {
        "borderRightColor": "hsla(220, 14%, 71%, 0.15)"
      },
      ".command-line .command-line-prompt": {
        "borderRightColor": "hsla(220, 14%, 71%, 0.15)"
      },
      ".line-numbers .line-numbers-rows > span:before": {
        "color": "hsl(220, 14%, 45%)"
      },
      ".command-line .command-line-prompt > span:before": {
        "color": "hsl(220, 14%, 45%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-1": {
        "color": "hsl(355, 65%, 65%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-5": {
        "color": "hsl(355, 65%, 65%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-9": {
        "color": "hsl(355, 65%, 65%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-2": {
        "color": "hsl(95, 38%, 62%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-6": {
        "color": "hsl(95, 38%, 62%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-10": {
        "color": "hsl(95, 38%, 62%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-3": {
        "color": "hsl(207, 82%, 66%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-7": {
        "color": "hsl(207, 82%, 66%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-11": {
        "color": "hsl(207, 82%, 66%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-4": {
        "color": "hsl(286, 60%, 67%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-8": {
        "color": "hsl(286, 60%, 67%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-12": {
        "color": "hsl(286, 60%, 67%)"
      },
      "pre.diff-highlight > code .token.token.deleted:not(.prefix)": {
        "backgroundColor": "hsla(353, 100%, 66%, 0.15)"
      },
      "pre > code.diff-highlight .token.token.deleted:not(.prefix)": {
        "backgroundColor": "hsla(353, 100%, 66%, 0.15)"
      },
      "pre.diff-highlight > code .token.token.deleted:not(.prefix)::-moz-selection": {
        "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
      },
      "pre.diff-highlight > code .token.token.deleted:not(.prefix) *::-moz-selection": {
        "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
      },
      "pre > code.diff-highlight .token.token.deleted:not(.prefix)::-moz-selection": {
        "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
      },
      "pre > code.diff-highlight .token.token.deleted:not(.prefix) *::-moz-selection": {
        "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
      },
      "pre.diff-highlight > code .token.token.deleted:not(.prefix)::selection": {
        "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
      },
      "pre.diff-highlight > code .token.token.deleted:not(.prefix) *::selection": {
        "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
      },
      "pre > code.diff-highlight .token.token.deleted:not(.prefix)::selection": {
        "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
      },
      "pre > code.diff-highlight .token.token.deleted:not(.prefix) *::selection": {
        "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
      },
      "pre.diff-highlight > code .token.token.inserted:not(.prefix)": {
        "backgroundColor": "hsla(137, 100%, 55%, 0.15)"
      },
      "pre > code.diff-highlight .token.token.inserted:not(.prefix)": {
        "backgroundColor": "hsla(137, 100%, 55%, 0.15)"
      },
      "pre.diff-highlight > code .token.token.inserted:not(.prefix)::-moz-selection": {
        "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
      },
      "pre.diff-highlight > code .token.token.inserted:not(.prefix) *::-moz-selection": {
        "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
      },
      "pre > code.diff-highlight .token.token.inserted:not(.prefix)::-moz-selection": {
        "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
      },
      "pre > code.diff-highlight .token.token.inserted:not(.prefix) *::-moz-selection": {
        "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
      },
      "pre.diff-highlight > code .token.token.inserted:not(.prefix)::selection": {
        "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
      },
      "pre.diff-highlight > code .token.token.inserted:not(.prefix) *::selection": {
        "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
      },
      "pre > code.diff-highlight .token.token.inserted:not(.prefix)::selection": {
        "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
      },
      "pre > code.diff-highlight .token.token.inserted:not(.prefix) *::selection": {
        "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
      },
      ".prism-previewer.prism-previewer:before": {
        "borderColor": "hsl(224, 13%, 17%)"
      },
      ".prism-previewer-gradient.prism-previewer-gradient div": {
        "borderColor": "hsl(224, 13%, 17%)",
        "borderRadius": "0.3em"
      },
      ".prism-previewer-color.prism-previewer-color:before": {
        "borderRadius": "0.3em"
      },
      ".prism-previewer-easing.prism-previewer-easing:before": {
        "borderRadius": "0.3em"
      },
      ".prism-previewer.prism-previewer:after": {
        "borderTopColor": "hsl(224, 13%, 17%)"
      },
      ".prism-previewer-flipped.prism-previewer-flipped.after": {
        "borderBottomColor": "hsl(224, 13%, 17%)"
      },
      ".prism-previewer-angle.prism-previewer-angle:before": {
        "background": "hsl(219, 13%, 22%)"
      },
      ".prism-previewer-time.prism-previewer-time:before": {
        "background": "hsl(219, 13%, 22%)"
      },
      ".prism-previewer-easing.prism-previewer-easing": {
        "background": "hsl(219, 13%, 22%)"
      },
      ".prism-previewer-angle.prism-previewer-angle circle": {
        "stroke": "hsl(220, 14%, 71%)",
        "strokeOpacity": "1"
      },
      ".prism-previewer-time.prism-previewer-time circle": {
        "stroke": "hsl(220, 14%, 71%)",
        "strokeOpacity": "1"
      },
      ".prism-previewer-easing.prism-previewer-easing circle": {
        "stroke": "hsl(220, 14%, 71%)",
        "fill": "transparent"
      },
      ".prism-previewer-easing.prism-previewer-easing path": {
        "stroke": "hsl(220, 14%, 71%)"
      },
      ".prism-previewer-easing.prism-previewer-easing line": {
        "stroke": "hsl(220, 14%, 71%)"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/one-light.js
var require_one_light = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/one-light.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "background": "hsl(230, 1%, 98%)",
        "color": "hsl(230, 8%, 24%)",
        "fontFamily": '"Fira Code", "Fira Mono", Menlo, Consolas, "DejaVu Sans Mono", monospace',
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "2",
        "OTabSize": "2",
        "tabSize": "2",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "background": "hsl(230, 1%, 98%)",
        "color": "hsl(230, 8%, 24%)",
        "fontFamily": '"Fira Code", "Fira Mono", Menlo, Consolas, "DejaVu Sans Mono", monospace',
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "2",
        "OTabSize": "2",
        "tabSize": "2",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": "0.5em 0",
        "overflow": "auto",
        "borderRadius": "0.3em"
      },
      'code[class*="language-"]::-moz-selection': {
        "background": "hsl(230, 1%, 90%)",
        "color": "inherit"
      },
      'code[class*="language-"] *::-moz-selection': {
        "background": "hsl(230, 1%, 90%)",
        "color": "inherit"
      },
      'pre[class*="language-"] *::-moz-selection': {
        "background": "hsl(230, 1%, 90%)",
        "color": "inherit"
      },
      'code[class*="language-"]::selection': {
        "background": "hsl(230, 1%, 90%)",
        "color": "inherit"
      },
      'code[class*="language-"] *::selection': {
        "background": "hsl(230, 1%, 90%)",
        "color": "inherit"
      },
      'pre[class*="language-"] *::selection': {
        "background": "hsl(230, 1%, 90%)",
        "color": "inherit"
      },
      ':not(pre) > code[class*="language-"]': {
        "padding": "0.2em 0.3em",
        "borderRadius": "0.3em",
        "whiteSpace": "normal"
      },
      "comment": {
        "color": "hsl(230, 4%, 64%)",
        "fontStyle": "italic"
      },
      "prolog": {
        "color": "hsl(230, 4%, 64%)"
      },
      "cdata": {
        "color": "hsl(230, 4%, 64%)"
      },
      "doctype": {
        "color": "hsl(230, 8%, 24%)"
      },
      "punctuation": {
        "color": "hsl(230, 8%, 24%)"
      },
      "entity": {
        "color": "hsl(230, 8%, 24%)",
        "cursor": "help"
      },
      "attr-name": {
        "color": "hsl(35, 99%, 36%)"
      },
      "class-name": {
        "color": "hsl(35, 99%, 36%)"
      },
      "boolean": {
        "color": "hsl(35, 99%, 36%)"
      },
      "constant": {
        "color": "hsl(35, 99%, 36%)"
      },
      "number": {
        "color": "hsl(35, 99%, 36%)"
      },
      "atrule": {
        "color": "hsl(35, 99%, 36%)"
      },
      "keyword": {
        "color": "hsl(301, 63%, 40%)"
      },
      "property": {
        "color": "hsl(5, 74%, 59%)"
      },
      "tag": {
        "color": "hsl(5, 74%, 59%)"
      },
      "symbol": {
        "color": "hsl(5, 74%, 59%)"
      },
      "deleted": {
        "color": "hsl(5, 74%, 59%)"
      },
      "important": {
        "color": "hsl(5, 74%, 59%)"
      },
      "selector": {
        "color": "hsl(119, 34%, 47%)"
      },
      "string": {
        "color": "hsl(119, 34%, 47%)"
      },
      "char": {
        "color": "hsl(119, 34%, 47%)"
      },
      "builtin": {
        "color": "hsl(119, 34%, 47%)"
      },
      "inserted": {
        "color": "hsl(119, 34%, 47%)"
      },
      "regex": {
        "color": "hsl(119, 34%, 47%)"
      },
      "attr-value": {
        "color": "hsl(119, 34%, 47%)"
      },
      "attr-value > .token.punctuation": {
        "color": "hsl(119, 34%, 47%)"
      },
      "variable": {
        "color": "hsl(221, 87%, 60%)"
      },
      "operator": {
        "color": "hsl(221, 87%, 60%)"
      },
      "function": {
        "color": "hsl(221, 87%, 60%)"
      },
      "url": {
        "color": "hsl(198, 99%, 37%)"
      },
      "attr-value > .token.punctuation.attr-equals": {
        "color": "hsl(230, 8%, 24%)"
      },
      "special-attr > .token.attr-value > .token.value.css": {
        "color": "hsl(230, 8%, 24%)"
      },
      ".language-css .token.selector": {
        "color": "hsl(5, 74%, 59%)"
      },
      ".language-css .token.property": {
        "color": "hsl(230, 8%, 24%)"
      },
      ".language-css .token.function": {
        "color": "hsl(198, 99%, 37%)"
      },
      ".language-css .token.url > .token.function": {
        "color": "hsl(198, 99%, 37%)"
      },
      ".language-css .token.url > .token.string.url": {
        "color": "hsl(119, 34%, 47%)"
      },
      ".language-css .token.important": {
        "color": "hsl(301, 63%, 40%)"
      },
      ".language-css .token.atrule .token.rule": {
        "color": "hsl(301, 63%, 40%)"
      },
      ".language-javascript .token.operator": {
        "color": "hsl(301, 63%, 40%)"
      },
      ".language-javascript .token.template-string > .token.interpolation > .token.interpolation-punctuation.punctuation": {
        "color": "hsl(344, 84%, 43%)"
      },
      ".language-json .token.operator": {
        "color": "hsl(230, 8%, 24%)"
      },
      ".language-json .token.null.keyword": {
        "color": "hsl(35, 99%, 36%)"
      },
      ".language-markdown .token.url": {
        "color": "hsl(230, 8%, 24%)"
      },
      ".language-markdown .token.url > .token.operator": {
        "color": "hsl(230, 8%, 24%)"
      },
      ".language-markdown .token.url-reference.url > .token.string": {
        "color": "hsl(230, 8%, 24%)"
      },
      ".language-markdown .token.url > .token.content": {
        "color": "hsl(221, 87%, 60%)"
      },
      ".language-markdown .token.url > .token.url": {
        "color": "hsl(198, 99%, 37%)"
      },
      ".language-markdown .token.url-reference.url": {
        "color": "hsl(198, 99%, 37%)"
      },
      ".language-markdown .token.blockquote.punctuation": {
        "color": "hsl(230, 4%, 64%)",
        "fontStyle": "italic"
      },
      ".language-markdown .token.hr.punctuation": {
        "color": "hsl(230, 4%, 64%)",
        "fontStyle": "italic"
      },
      ".language-markdown .token.code-snippet": {
        "color": "hsl(119, 34%, 47%)"
      },
      ".language-markdown .token.bold .token.content": {
        "color": "hsl(35, 99%, 36%)"
      },
      ".language-markdown .token.italic .token.content": {
        "color": "hsl(301, 63%, 40%)"
      },
      ".language-markdown .token.strike .token.content": {
        "color": "hsl(5, 74%, 59%)"
      },
      ".language-markdown .token.strike .token.punctuation": {
        "color": "hsl(5, 74%, 59%)"
      },
      ".language-markdown .token.list.punctuation": {
        "color": "hsl(5, 74%, 59%)"
      },
      ".language-markdown .token.title.important > .token.punctuation": {
        "color": "hsl(5, 74%, 59%)"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "namespace": {
        "Opacity": "0.8"
      },
      "token.tab:not(:empty):before": {
        "color": "hsla(230, 8%, 24%, 0.2)"
      },
      "token.cr:before": {
        "color": "hsla(230, 8%, 24%, 0.2)"
      },
      "token.lf:before": {
        "color": "hsla(230, 8%, 24%, 0.2)"
      },
      "token.space:before": {
        "color": "hsla(230, 8%, 24%, 0.2)"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item": {
        "marginRight": "0.4em"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button": {
        "background": "hsl(230, 1%, 90%)",
        "color": "hsl(230, 6%, 44%)",
        "padding": "0.1em 0.4em",
        "borderRadius": "0.3em"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a": {
        "background": "hsl(230, 1%, 90%)",
        "color": "hsl(230, 6%, 44%)",
        "padding": "0.1em 0.4em",
        "borderRadius": "0.3em"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span": {
        "background": "hsl(230, 1%, 90%)",
        "color": "hsl(230, 6%, 44%)",
        "padding": "0.1em 0.4em",
        "borderRadius": "0.3em"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button:hover": {
        "background": "hsl(230, 1%, 78%)",
        "color": "hsl(230, 8%, 24%)"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button:focus": {
        "background": "hsl(230, 1%, 78%)",
        "color": "hsl(230, 8%, 24%)"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a:hover": {
        "background": "hsl(230, 1%, 78%)",
        "color": "hsl(230, 8%, 24%)"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a:focus": {
        "background": "hsl(230, 1%, 78%)",
        "color": "hsl(230, 8%, 24%)"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span:hover": {
        "background": "hsl(230, 1%, 78%)",
        "color": "hsl(230, 8%, 24%)"
      },
      "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span:focus": {
        "background": "hsl(230, 1%, 78%)",
        "color": "hsl(230, 8%, 24%)"
      },
      ".line-highlight.line-highlight": {
        "background": "hsla(230, 8%, 24%, 0.05)"
      },
      ".line-highlight.line-highlight:before": {
        "background": "hsl(230, 1%, 90%)",
        "color": "hsl(230, 8%, 24%)",
        "padding": "0.1em 0.6em",
        "borderRadius": "0.3em",
        "boxShadow": "0 2px 0 0 rgba(0, 0, 0, 0.2)"
      },
      ".line-highlight.line-highlight[data-end]:after": {
        "background": "hsl(230, 1%, 90%)",
        "color": "hsl(230, 8%, 24%)",
        "padding": "0.1em 0.6em",
        "borderRadius": "0.3em",
        "boxShadow": "0 2px 0 0 rgba(0, 0, 0, 0.2)"
      },
      "pre[id].linkable-line-numbers.linkable-line-numbers span.line-numbers-rows > span:hover:before": {
        "backgroundColor": "hsla(230, 8%, 24%, 0.05)"
      },
      ".line-numbers.line-numbers .line-numbers-rows": {
        "borderRightColor": "hsla(230, 8%, 24%, 0.2)"
      },
      ".command-line .command-line-prompt": {
        "borderRightColor": "hsla(230, 8%, 24%, 0.2)"
      },
      ".line-numbers .line-numbers-rows > span:before": {
        "color": "hsl(230, 1%, 62%)"
      },
      ".command-line .command-line-prompt > span:before": {
        "color": "hsl(230, 1%, 62%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-1": {
        "color": "hsl(5, 74%, 59%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-5": {
        "color": "hsl(5, 74%, 59%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-9": {
        "color": "hsl(5, 74%, 59%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-2": {
        "color": "hsl(119, 34%, 47%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-6": {
        "color": "hsl(119, 34%, 47%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-10": {
        "color": "hsl(119, 34%, 47%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-3": {
        "color": "hsl(221, 87%, 60%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-7": {
        "color": "hsl(221, 87%, 60%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-11": {
        "color": "hsl(221, 87%, 60%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-4": {
        "color": "hsl(301, 63%, 40%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-8": {
        "color": "hsl(301, 63%, 40%)"
      },
      ".rainbow-braces .token.token.punctuation.brace-level-12": {
        "color": "hsl(301, 63%, 40%)"
      },
      "pre.diff-highlight > code .token.token.deleted:not(.prefix)": {
        "backgroundColor": "hsla(353, 100%, 66%, 0.15)"
      },
      "pre > code.diff-highlight .token.token.deleted:not(.prefix)": {
        "backgroundColor": "hsla(353, 100%, 66%, 0.15)"
      },
      "pre.diff-highlight > code .token.token.deleted:not(.prefix)::-moz-selection": {
        "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
      },
      "pre.diff-highlight > code .token.token.deleted:not(.prefix) *::-moz-selection": {
        "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
      },
      "pre > code.diff-highlight .token.token.deleted:not(.prefix)::-moz-selection": {
        "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
      },
      "pre > code.diff-highlight .token.token.deleted:not(.prefix) *::-moz-selection": {
        "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
      },
      "pre.diff-highlight > code .token.token.deleted:not(.prefix)::selection": {
        "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
      },
      "pre.diff-highlight > code .token.token.deleted:not(.prefix) *::selection": {
        "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
      },
      "pre > code.diff-highlight .token.token.deleted:not(.prefix)::selection": {
        "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
      },
      "pre > code.diff-highlight .token.token.deleted:not(.prefix) *::selection": {
        "backgroundColor": "hsla(353, 95%, 66%, 0.25)"
      },
      "pre.diff-highlight > code .token.token.inserted:not(.prefix)": {
        "backgroundColor": "hsla(137, 100%, 55%, 0.15)"
      },
      "pre > code.diff-highlight .token.token.inserted:not(.prefix)": {
        "backgroundColor": "hsla(137, 100%, 55%, 0.15)"
      },
      "pre.diff-highlight > code .token.token.inserted:not(.prefix)::-moz-selection": {
        "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
      },
      "pre.diff-highlight > code .token.token.inserted:not(.prefix) *::-moz-selection": {
        "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
      },
      "pre > code.diff-highlight .token.token.inserted:not(.prefix)::-moz-selection": {
        "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
      },
      "pre > code.diff-highlight .token.token.inserted:not(.prefix) *::-moz-selection": {
        "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
      },
      "pre.diff-highlight > code .token.token.inserted:not(.prefix)::selection": {
        "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
      },
      "pre.diff-highlight > code .token.token.inserted:not(.prefix) *::selection": {
        "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
      },
      "pre > code.diff-highlight .token.token.inserted:not(.prefix)::selection": {
        "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
      },
      "pre > code.diff-highlight .token.token.inserted:not(.prefix) *::selection": {
        "backgroundColor": "hsla(135, 73%, 55%, 0.25)"
      },
      ".prism-previewer.prism-previewer:before": {
        "borderColor": "hsl(0, 0, 95%)"
      },
      ".prism-previewer-gradient.prism-previewer-gradient div": {
        "borderColor": "hsl(0, 0, 95%)",
        "borderRadius": "0.3em"
      },
      ".prism-previewer-color.prism-previewer-color:before": {
        "borderRadius": "0.3em"
      },
      ".prism-previewer-easing.prism-previewer-easing:before": {
        "borderRadius": "0.3em"
      },
      ".prism-previewer.prism-previewer:after": {
        "borderTopColor": "hsl(0, 0, 95%)"
      },
      ".prism-previewer-flipped.prism-previewer-flipped.after": {
        "borderBottomColor": "hsl(0, 0, 95%)"
      },
      ".prism-previewer-angle.prism-previewer-angle:before": {
        "background": "hsl(0, 0%, 100%)"
      },
      ".prism-previewer-time.prism-previewer-time:before": {
        "background": "hsl(0, 0%, 100%)"
      },
      ".prism-previewer-easing.prism-previewer-easing": {
        "background": "hsl(0, 0%, 100%)"
      },
      ".prism-previewer-angle.prism-previewer-angle circle": {
        "stroke": "hsl(230, 8%, 24%)",
        "strokeOpacity": "1"
      },
      ".prism-previewer-time.prism-previewer-time circle": {
        "stroke": "hsl(230, 8%, 24%)",
        "strokeOpacity": "1"
      },
      ".prism-previewer-easing.prism-previewer-easing circle": {
        "stroke": "hsl(230, 8%, 24%)",
        "fill": "transparent"
      },
      ".prism-previewer-easing.prism-previewer-easing path": {
        "stroke": "hsl(230, 8%, 24%)"
      },
      ".prism-previewer-easing.prism-previewer-easing line": {
        "stroke": "hsl(230, 8%, 24%)"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/pojoaque.js
var require_pojoaque = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/pojoaque.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "whiteSpace": "pre-wrap",
        "wordBreak": "break-all",
        "wordWrap": "break-word",
        "fontFamily": 'Menlo, Monaco, "Courier New", monospace',
        "fontSize": "15px",
        "lineHeight": "1.5",
        "color": "#dccf8f",
        "textShadow": "0"
      },
      'pre[class*="language-"]': {
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "whiteSpace": "pre-wrap",
        "wordBreak": "break-all",
        "wordWrap": "break-word",
        "fontFamily": 'Menlo, Monaco, "Courier New", monospace',
        "fontSize": "15px",
        "lineHeight": "1.5",
        "color": "#DCCF8F",
        "textShadow": "0",
        "borderRadius": "5px",
        "border": "1px solid #000",
        "background": "#181914 url('data:image/jpeg;base64,/9j/4AAQSkZJRgABAgAAZABkAAD/7AARRHVja3kAAQAEAAAAMAAA/+4ADkFkb2JlAGTAAAAAAf/bAIQACQYGBgcGCQcHCQ0IBwgNDwsJCQsPEQ4ODw4OERENDg4ODg0RERQUFhQUERoaHBwaGiYmJiYmKysrKysrKysrKwEJCAgJCgkMCgoMDwwODA8TDg4ODhMVDg4PDg4VGhMRERERExoXGhYWFhoXHR0aGh0dJCQjJCQrKysrKysrKysr/8AAEQgAjACMAwEiAAIRAQMRAf/EAF4AAQEBAAAAAAAAAAAAAAAAAAABBwEBAQAAAAAAAAAAAAAAAAAAAAIQAAEDAwIHAQEAAAAAAAAAAADwAREhYaExkUFRcYGxwdHh8REBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8AyGFEjHaBS2fDDs2zkhKmBKktb7km+ZwwCnXPkLVmCTMItj6AXFxRS465/BTnkAJvkLkJe+7AKKoi2AtRS2zuAWsCb5GOlBN8gKfmuGHZ8MFqIth3ALmFoFwbwKWyAlTAp17uKqBvgBD8sM4fTjhvAhkzhaRkBMKBrfs7jGPIpzy7gFrAqnC0C0gB0EWwBDW2cBVQwm+QtPpa3wBO3sVvszCnLAhkzgL5/RLf13cLQd8/AGlu0Cb5HTx9KuAEieGJEdcehS3eRTp2ATdt3CpIm+QtZwAhROXFeb7swp/ahaM3kBE/jSIUBc/AWrgBN8uNFAl+b7sAXFxFn2YLUU5Ns7gFX8C4ib+hN8gFWXwK3bZglxEJm+gKdciLPsFV/TClsgJUwKJ5FVA7tvIFrfZhVfGJDcsCKaYgAqv6YRbE+RWOWBtu7+AL3yRalXLyKqAIIfk+zARbDgFyEsncYwJvlgFRW+GEWntIi2P0BooyFxcNr8Ep3+ANLbMO+QyhvbiqdgC0kVvgUUiLYgBS2QtPbiVI1/sgOmG9uO+Y8DW+7jS2zAOnj6O2BndwuIAUtkdRN8gFoK3wwXMQyZwHVbClsuNLd4E3yAUR6FVDBR+BafQGt93LVMxJTv8ABts4CVLhcfYWsCb5kC9/BHdU8CLYFY5bMAd+eX9MGthhpbA1vu4B7+RKkaW2Yq4AQtVBBFsAJU/AuIXBhN8gGWnstefhiZyWvLAEnbYS1uzSFP6Jvn4Baxx70JKkQojLib5AVTey1jjgkKJGO0AKWyOm7N7cSpgSpAdPH0Tfd/gp1z5C1ZgKqN9J2wFxcUUuAFLZAm+QC0Fb4YUVRFsAOvj4KW2dwtYE3yAWk/wS/PLMKfmuGHZ8MAXF/Ja32Yi5haAKWz4Ydm2cSpgU693Atb7km+Zwwh+WGcPpxw3gAkzCLY+iYUDW/Z3Adc/gpzyFrAqnALkJe+7DoItgAtRS2zuKqGE3yAx0oJvkdvYrfZmALURbDuL5/RLf13cAuDeBS2RpbtAm+QFVA3wR+3fUtFHoBDJnC0jIXH0HWsgMY8inPLuOkd9chp4z20ALQLSA8cI9jYAIa2zjzjBd8gRafS1vgiUho/kAKcsCGTOGWvoOpkAtB3z8Hm8x2Ff5ADp4+lXAlIvcmwH/2Q==') repeat left top",
        "padding": "12px",
        "overflow": "auto"
      },
      'pre > code[class*="language-"]': {
        "fontSize": "1em"
      },
      ':not(pre) > code[class*="language-"]': {
        "borderRadius": "5px",
        "border": "1px solid #000",
        "color": "#DCCF8F",
        "background": "#181914 url('data:image/jpeg;base64,/9j/4AAQSkZJRgABAgAAZABkAAD/7AARRHVja3kAAQAEAAAAMAAA/+4ADkFkb2JlAGTAAAAAAf/bAIQACQYGBgcGCQcHCQ0IBwgNDwsJCQsPEQ4ODw4OERENDg4ODg0RERQUFhQUERoaHBwaGiYmJiYmKysrKysrKysrKwEJCAgJCgkMCgoMDwwODA8TDg4ODhMVDg4PDg4VGhMRERERExoXGhYWFhoXHR0aGh0dJCQjJCQrKysrKysrKysr/8AAEQgAjACMAwEiAAIRAQMRAf/EAF4AAQEBAAAAAAAAAAAAAAAAAAABBwEBAQAAAAAAAAAAAAAAAAAAAAIQAAEDAwIHAQEAAAAAAAAAAADwAREhYaExkUFRcYGxwdHh8REBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8AyGFEjHaBS2fDDs2zkhKmBKktb7km+ZwwCnXPkLVmCTMItj6AXFxRS465/BTnkAJvkLkJe+7AKKoi2AtRS2zuAWsCb5GOlBN8gKfmuGHZ8MFqIth3ALmFoFwbwKWyAlTAp17uKqBvgBD8sM4fTjhvAhkzhaRkBMKBrfs7jGPIpzy7gFrAqnC0C0gB0EWwBDW2cBVQwm+QtPpa3wBO3sVvszCnLAhkzgL5/RLf13cLQd8/AGlu0Cb5HTx9KuAEieGJEdcehS3eRTp2ATdt3CpIm+QtZwAhROXFeb7swp/ahaM3kBE/jSIUBc/AWrgBN8uNFAl+b7sAXFxFn2YLUU5Ns7gFX8C4ib+hN8gFWXwK3bZglxEJm+gKdciLPsFV/TClsgJUwKJ5FVA7tvIFrfZhVfGJDcsCKaYgAqv6YRbE+RWOWBtu7+AL3yRalXLyKqAIIfk+zARbDgFyEsncYwJvlgFRW+GEWntIi2P0BooyFxcNr8Ep3+ANLbMO+QyhvbiqdgC0kVvgUUiLYgBS2QtPbiVI1/sgOmG9uO+Y8DW+7jS2zAOnj6O2BndwuIAUtkdRN8gFoK3wwXMQyZwHVbClsuNLd4E3yAUR6FVDBR+BafQGt93LVMxJTv8ABts4CVLhcfYWsCb5kC9/BHdU8CLYFY5bMAd+eX9MGthhpbA1vu4B7+RKkaW2Yq4AQtVBBFsAJU/AuIXBhN8gGWnstefhiZyWvLAEnbYS1uzSFP6Jvn4Baxx70JKkQojLib5AVTey1jjgkKJGO0AKWyOm7N7cSpgSpAdPH0Tfd/gp1z5C1ZgKqN9J2wFxcUUuAFLZAm+QC0Fb4YUVRFsAOvj4KW2dwtYE3yAWk/wS/PLMKfmuGHZ8MAXF/Ja32Yi5haAKWz4Ydm2cSpgU693Atb7km+Zwwh+WGcPpxw3gAkzCLY+iYUDW/Z3Adc/gpzyFrAqnALkJe+7DoItgAtRS2zuKqGE3yAx0oJvkdvYrfZmALURbDuL5/RLf13cAuDeBS2RpbtAm+QFVA3wR+3fUtFHoBDJnC0jIXH0HWsgMY8inPLuOkd9chp4z20ALQLSA8cI9jYAIa2zjzjBd8gRafS1vgiUho/kAKcsCGTOGWvoOpkAtB3z8Hm8x2Ff5ADp4+lXAlIvcmwH/2Q==') repeat left top",
        "padding": "2px 6px"
      },
      "namespace": {
        "Opacity": ".7"
      },
      "comment": {
        "color": "#586e75",
        "fontStyle": "italic"
      },
      "prolog": {
        "color": "#586e75",
        "fontStyle": "italic"
      },
      "doctype": {
        "color": "#586e75",
        "fontStyle": "italic"
      },
      "cdata": {
        "color": "#586e75",
        "fontStyle": "italic"
      },
      "number": {
        "color": "#b89859"
      },
      "string": {
        "color": "#468966"
      },
      "char": {
        "color": "#468966"
      },
      "builtin": {
        "color": "#468966"
      },
      "inserted": {
        "color": "#468966"
      },
      "attr-name": {
        "color": "#b89859"
      },
      "operator": {
        "color": "#dccf8f"
      },
      "entity": {
        "color": "#dccf8f",
        "cursor": "help"
      },
      "url": {
        "color": "#dccf8f"
      },
      ".language-css .token.string": {
        "color": "#dccf8f"
      },
      ".style .token.string": {
        "color": "#dccf8f"
      },
      "selector": {
        "color": "#859900"
      },
      "regex": {
        "color": "#859900"
      },
      "atrule": {
        "color": "#cb4b16"
      },
      "keyword": {
        "color": "#cb4b16"
      },
      "attr-value": {
        "color": "#468966"
      },
      "function": {
        "color": "#b58900"
      },
      "variable": {
        "color": "#b58900"
      },
      "placeholder": {
        "color": "#b58900"
      },
      "property": {
        "color": "#b89859"
      },
      "tag": {
        "color": "#ffb03b"
      },
      "boolean": {
        "color": "#b89859"
      },
      "constant": {
        "color": "#b89859"
      },
      "symbol": {
        "color": "#b89859"
      },
      "important": {
        "color": "#dc322f"
      },
      "statement": {
        "color": "#dc322f"
      },
      "deleted": {
        "color": "#dc322f"
      },
      "punctuation": {
        "color": "#dccf8f"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/shades-of-purple.js
var require_shades_of_purple = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/shades-of-purple.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      "code[class*='language-']": {
        "color": "#9efeff",
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "fontFamily": "'Operator Mono', 'Fira Code', Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontWeight": "400",
        "fontSize": "17px",
        "lineHeight": "25px",
        "letterSpacing": "0.5px",
        "textShadow": "0 1px #222245"
      },
      "pre[class*='language-']": {
        "color": "#9efeff",
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "fontFamily": "'Operator Mono', 'Fira Code', Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontWeight": "400",
        "fontSize": "17px",
        "lineHeight": "25px",
        "letterSpacing": "0.5px",
        "textShadow": "0 1px #222245",
        "padding": "2em",
        "margin": "0.5em 0",
        "overflow": "auto",
        "background": "#1e1e3f"
      },
      "pre[class*='language-']::-moz-selection": {
        "color": "inherit",
        "background": "#a599e9"
      },
      "pre[class*='language-'] ::-moz-selection": {
        "color": "inherit",
        "background": "#a599e9"
      },
      "code[class*='language-']::-moz-selection": {
        "color": "inherit",
        "background": "#a599e9"
      },
      "code[class*='language-'] ::-moz-selection": {
        "color": "inherit",
        "background": "#a599e9"
      },
      "pre[class*='language-']::selection": {
        "color": "inherit",
        "background": "#a599e9"
      },
      "pre[class*='language-'] ::selection": {
        "color": "inherit",
        "background": "#a599e9"
      },
      "code[class*='language-']::selection": {
        "color": "inherit",
        "background": "#a599e9"
      },
      "code[class*='language-'] ::selection": {
        "color": "inherit",
        "background": "#a599e9"
      },
      ":not(pre) > code[class*='language-']": {
        "background": "#1e1e3f",
        "padding": "0.1em",
        "borderRadius": "0.3em"
      },
      "": {
        "fontWeight": "400"
      },
      "comment": {
        "color": "#b362ff"
      },
      "prolog": {
        "color": "#b362ff"
      },
      "cdata": {
        "color": "#b362ff"
      },
      "delimiter": {
        "color": "#ff9d00"
      },
      "keyword": {
        "color": "#ff9d00"
      },
      "selector": {
        "color": "#ff9d00"
      },
      "important": {
        "color": "#ff9d00"
      },
      "atrule": {
        "color": "#ff9d00"
      },
      "operator": {
        "color": "rgb(255, 180, 84)",
        "background": "none"
      },
      "attr-name": {
        "color": "rgb(255, 180, 84)"
      },
      "punctuation": {
        "color": "#ffffff"
      },
      "boolean": {
        "color": "rgb(255, 98, 140)"
      },
      "tag": {
        "color": "rgb(255, 157, 0)"
      },
      "tag.punctuation": {
        "color": "rgb(255, 157, 0)"
      },
      "doctype": {
        "color": "rgb(255, 157, 0)"
      },
      "builtin": {
        "color": "rgb(255, 157, 0)"
      },
      "entity": {
        "color": "#6897bb",
        "background": "none"
      },
      "symbol": {
        "color": "#6897bb"
      },
      "number": {
        "color": "#ff628c"
      },
      "property": {
        "color": "#ff628c"
      },
      "constant": {
        "color": "#ff628c"
      },
      "variable": {
        "color": "#ff628c"
      },
      "string": {
        "color": "#a5ff90"
      },
      "char": {
        "color": "#a5ff90"
      },
      "attr-value": {
        "color": "#a5c261"
      },
      "attr-value.punctuation": {
        "color": "#a5c261"
      },
      "attr-value.punctuation:first-child": {
        "color": "#a9b7c6"
      },
      "url": {
        "color": "#287bde",
        "textDecoration": "underline",
        "background": "none"
      },
      "function": {
        "color": "rgb(250, 208, 0)"
      },
      "regex": {
        "background": "#364135"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "inserted": {
        "background": "#00ff00"
      },
      "deleted": {
        "background": "#ff000d"
      },
      "code.language-css .token.property": {
        "color": "#a9b7c6"
      },
      "code.language-css .token.property + .token.punctuation": {
        "color": "#a9b7c6"
      },
      "code.language-css .token.id": {
        "color": "#ffc66d"
      },
      "code.language-css .token.selector > .token.class": {
        "color": "#ffc66d"
      },
      "code.language-css .token.selector > .token.attribute": {
        "color": "#ffc66d"
      },
      "code.language-css .token.selector > .token.pseudo-class": {
        "color": "#ffc66d"
      },
      "code.language-css .token.selector > .token.pseudo-element": {
        "color": "#ffc66d"
      },
      "class-name": {
        "color": "#fb94ff"
      },
      ".language-css .token.string": {
        "background": "none"
      },
      ".style .token.string": {
        "background": "none"
      },
      ".line-highlight.line-highlight": {
        "marginTop": "36px",
        "background": "linear-gradient(to right, rgba(179, 98, 255, 0.17), transparent)"
      },
      ".line-highlight.line-highlight:before": {
        "content": "''"
      },
      ".line-highlight.line-highlight[data-end]:after": {
        "content": "''"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/solarized-dark-atom.js
var require_solarized_dark_atom = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/solarized-dark-atom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "#839496",
        "textShadow": "0 1px rgba(0, 0, 0, 0.3)",
        "fontFamily": "Inconsolata, Monaco, Consolas, 'Courier New', Courier, monospace",
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "#839496",
        "textShadow": "0 1px rgba(0, 0, 0, 0.3)",
        "fontFamily": "Inconsolata, Monaco, Consolas, 'Courier New', Courier, monospace",
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto",
        "borderRadius": "0.3em",
        "background": "#002b36"
      },
      ':not(pre) > code[class*="language-"]': {
        "background": "#002b36",
        "padding": ".1em",
        "borderRadius": ".3em"
      },
      "comment": {
        "color": "#586e75"
      },
      "prolog": {
        "color": "#586e75"
      },
      "doctype": {
        "color": "#586e75"
      },
      "cdata": {
        "color": "#586e75"
      },
      "punctuation": {
        "color": "#93a1a1"
      },
      ".namespace": {
        "Opacity": ".7"
      },
      "property": {
        "color": "#268bd2"
      },
      "keyword": {
        "color": "#268bd2"
      },
      "tag": {
        "color": "#268bd2"
      },
      "class-name": {
        "color": "#FFFFB6",
        "textDecoration": "underline"
      },
      "boolean": {
        "color": "#b58900"
      },
      "constant": {
        "color": "#b58900"
      },
      "symbol": {
        "color": "#dc322f"
      },
      "deleted": {
        "color": "#dc322f"
      },
      "number": {
        "color": "#859900"
      },
      "selector": {
        "color": "#859900"
      },
      "attr-name": {
        "color": "#859900"
      },
      "string": {
        "color": "#859900"
      },
      "char": {
        "color": "#859900"
      },
      "builtin": {
        "color": "#859900"
      },
      "inserted": {
        "color": "#859900"
      },
      "variable": {
        "color": "#268bd2"
      },
      "operator": {
        "color": "#EDEDED"
      },
      "function": {
        "color": "#268bd2"
      },
      "regex": {
        "color": "#E9C062"
      },
      "important": {
        "color": "#fd971f",
        "fontWeight": "bold"
      },
      "entity": {
        "color": "#FFFFB6",
        "cursor": "help"
      },
      "url": {
        "color": "#96CBFE"
      },
      ".language-css .token.string": {
        "color": "#87C38A"
      },
      ".style .token.string": {
        "color": "#87C38A"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "atrule": {
        "color": "#F9EE98"
      },
      "attr-value": {
        "color": "#F9EE98"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/synthwave84.js
var require_synthwave84 = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/synthwave84.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "#f92aad",
        "textShadow": "0 0 2px #100c0f, 0 0 5px #dc078e33, 0 0 10px #fff3",
        "background": "none",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "#f92aad",
        "textShadow": "0 0 2px #100c0f, 0 0 5px #dc078e33, 0 0 10px #fff3",
        "background": "none",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto",
        "backgroundColor": "transparent !important",
        "backgroundImage": "linear-gradient(to bottom, #2a2139 75%, #34294f)"
      },
      ':not(pre) > code[class*="language-"]': {
        "backgroundColor": "transparent !important",
        "backgroundImage": "linear-gradient(to bottom, #2a2139 75%, #34294f)",
        "padding": ".1em",
        "borderRadius": ".3em",
        "whiteSpace": "normal"
      },
      "comment": {
        "color": "#8e8e8e"
      },
      "block-comment": {
        "color": "#8e8e8e"
      },
      "prolog": {
        "color": "#8e8e8e"
      },
      "doctype": {
        "color": "#8e8e8e"
      },
      "cdata": {
        "color": "#8e8e8e"
      },
      "punctuation": {
        "color": "#ccc"
      },
      "tag": {
        "color": "#e2777a"
      },
      "attr-name": {
        "color": "#e2777a"
      },
      "namespace": {
        "color": "#e2777a"
      },
      "number": {
        "color": "#e2777a"
      },
      "unit": {
        "color": "#e2777a"
      },
      "hexcode": {
        "color": "#e2777a"
      },
      "deleted": {
        "color": "#e2777a"
      },
      "property": {
        "color": "#72f1b8",
        "textShadow": "0 0 2px #100c0f, 0 0 10px #257c5575, 0 0 35px #21272475"
      },
      "selector": {
        "color": "#72f1b8",
        "textShadow": "0 0 2px #100c0f, 0 0 10px #257c5575, 0 0 35px #21272475"
      },
      "function-name": {
        "color": "#6196cc"
      },
      "boolean": {
        "color": "#fdfdfd",
        "textShadow": "0 0 2px #001716, 0 0 3px #03edf975, 0 0 5px #03edf975, 0 0 8px #03edf975"
      },
      "selector.id": {
        "color": "#fdfdfd",
        "textShadow": "0 0 2px #001716, 0 0 3px #03edf975, 0 0 5px #03edf975, 0 0 8px #03edf975"
      },
      "function": {
        "color": "#fdfdfd",
        "textShadow": "0 0 2px #001716, 0 0 3px #03edf975, 0 0 5px #03edf975, 0 0 8px #03edf975"
      },
      "class-name": {
        "color": "#fff5f6",
        "textShadow": "0 0 2px #000, 0 0 10px #fc1f2c75, 0 0 5px #fc1f2c75, 0 0 25px #fc1f2c75"
      },
      "constant": {
        "color": "#f92aad",
        "textShadow": "0 0 2px #100c0f, 0 0 5px #dc078e33, 0 0 10px #fff3"
      },
      "symbol": {
        "color": "#f92aad",
        "textShadow": "0 0 2px #100c0f, 0 0 5px #dc078e33, 0 0 10px #fff3"
      },
      "important": {
        "color": "#f4eee4",
        "textShadow": "0 0 2px #393a33, 0 0 8px #f39f0575, 0 0 2px #f39f0575",
        "fontWeight": "bold"
      },
      "atrule": {
        "color": "#f4eee4",
        "textShadow": "0 0 2px #393a33, 0 0 8px #f39f0575, 0 0 2px #f39f0575"
      },
      "keyword": {
        "color": "#f4eee4",
        "textShadow": "0 0 2px #393a33, 0 0 8px #f39f0575, 0 0 2px #f39f0575"
      },
      "selector.class": {
        "color": "#f4eee4",
        "textShadow": "0 0 2px #393a33, 0 0 8px #f39f0575, 0 0 2px #f39f0575"
      },
      "builtin": {
        "color": "#f4eee4",
        "textShadow": "0 0 2px #393a33, 0 0 8px #f39f0575, 0 0 2px #f39f0575"
      },
      "string": {
        "color": "#f87c32"
      },
      "char": {
        "color": "#f87c32"
      },
      "attr-value": {
        "color": "#f87c32"
      },
      "regex": {
        "color": "#f87c32"
      },
      "variable": {
        "color": "#f87c32"
      },
      "operator": {
        "color": "#67cdcc"
      },
      "entity": {
        "color": "#67cdcc",
        "cursor": "help"
      },
      "url": {
        "color": "#67cdcc"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "inserted": {
        "color": "green"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/vs.js
var require_vs = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/vs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "#393A34",
        "fontFamily": '"Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace',
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "fontSize": ".9em",
        "lineHeight": "1.2em",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "#393A34",
        "fontFamily": '"Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace',
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "fontSize": ".9em",
        "lineHeight": "1.2em",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto",
        "border": "1px solid #dddddd",
        "backgroundColor": "white"
      },
      'pre > code[class*="language-"]': {
        "fontSize": "1em"
      },
      'pre[class*="language-"]::-moz-selection': {
        "background": "#C1DEF1"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "background": "#C1DEF1"
      },
      'code[class*="language-"]::-moz-selection': {
        "background": "#C1DEF1"
      },
      'code[class*="language-"] ::-moz-selection': {
        "background": "#C1DEF1"
      },
      'pre[class*="language-"]::selection': {
        "background": "#C1DEF1"
      },
      'pre[class*="language-"] ::selection': {
        "background": "#C1DEF1"
      },
      'code[class*="language-"]::selection': {
        "background": "#C1DEF1"
      },
      'code[class*="language-"] ::selection': {
        "background": "#C1DEF1"
      },
      ':not(pre) > code[class*="language-"]': {
        "padding": ".2em",
        "paddingTop": "1px",
        "paddingBottom": "1px",
        "background": "#f8f8f8",
        "border": "1px solid #dddddd"
      },
      "comment": {
        "color": "#008000",
        "fontStyle": "italic"
      },
      "prolog": {
        "color": "#008000",
        "fontStyle": "italic"
      },
      "doctype": {
        "color": "#008000",
        "fontStyle": "italic"
      },
      "cdata": {
        "color": "#008000",
        "fontStyle": "italic"
      },
      "namespace": {
        "Opacity": ".7"
      },
      "string": {
        "color": "#A31515"
      },
      "punctuation": {
        "color": "#393A34"
      },
      "operator": {
        "color": "#393A34"
      },
      "url": {
        "color": "#36acaa"
      },
      "symbol": {
        "color": "#36acaa"
      },
      "number": {
        "color": "#36acaa"
      },
      "boolean": {
        "color": "#36acaa"
      },
      "variable": {
        "color": "#36acaa"
      },
      "constant": {
        "color": "#36acaa"
      },
      "inserted": {
        "color": "#36acaa"
      },
      "atrule": {
        "color": "#0000ff"
      },
      "keyword": {
        "color": "#0000ff"
      },
      "attr-value": {
        "color": "#0000ff"
      },
      ".language-autohotkey .token.selector": {
        "color": "#0000ff"
      },
      ".language-json .token.boolean": {
        "color": "#0000ff"
      },
      ".language-json .token.number": {
        "color": "#0000ff"
      },
      'code[class*="language-css"]': {
        "color": "#0000ff"
      },
      "function": {
        "color": "#393A34"
      },
      "deleted": {
        "color": "#9a050f"
      },
      ".language-autohotkey .token.tag": {
        "color": "#9a050f"
      },
      "selector": {
        "color": "#800000"
      },
      ".language-autohotkey .token.keyword": {
        "color": "#00009f"
      },
      "important": {
        "color": "#e90",
        "fontWeight": "bold"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "class-name": {
        "color": "#2B91AF"
      },
      ".language-json .token.property": {
        "color": "#2B91AF"
      },
      "tag": {
        "color": "#800000"
      },
      "attr-name": {
        "color": "#ff0000"
      },
      "property": {
        "color": "#ff0000"
      },
      "regex": {
        "color": "#ff0000"
      },
      "entity": {
        "color": "#ff0000"
      },
      "directive.tag.tag": {
        "background": "#ffff00",
        "color": "#393A34"
      },
      ".line-numbers.line-numbers .line-numbers-rows": {
        "borderRightColor": "#a5a5a5"
      },
      ".line-numbers .line-numbers-rows > span:before": {
        "color": "#2B91AF"
      },
      ".line-highlight.line-highlight": {
        "background": "linear-gradient(to right, rgba(193, 222, 241, 0.2) 70%, rgba(221, 222, 241, 0))"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/vsc-dark-plus.js
var require_vsc_dark_plus = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/vsc-dark-plus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'pre[class*="language-"]': {
        "color": "#d4d4d4",
        "fontSize": "13px",
        "textShadow": "none",
        "fontFamily": 'Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace',
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto",
        "background": "#1e1e1e"
      },
      'code[class*="language-"]': {
        "color": "#d4d4d4",
        "fontSize": "13px",
        "textShadow": "none",
        "fontFamily": 'Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace',
        "direction": "ltr",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#264F78"
      },
      'code[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#264F78"
      },
      'pre[class*="language-"] *::selection': {
        "textShadow": "none",
        "background": "#264F78"
      },
      'code[class*="language-"] *::selection': {
        "textShadow": "none",
        "background": "#264F78"
      },
      ':not(pre) > code[class*="language-"]': {
        "padding": ".1em .3em",
        "borderRadius": ".3em",
        "color": "#db4c69",
        "background": "#1e1e1e"
      },
      ".namespace": {
        "Opacity": ".7"
      },
      "doctype.doctype-tag": {
        "color": "#569CD6"
      },
      "doctype.name": {
        "color": "#9cdcfe"
      },
      "comment": {
        "color": "#6a9955"
      },
      "prolog": {
        "color": "#6a9955"
      },
      "punctuation": {
        "color": "#d4d4d4"
      },
      ".language-html .language-css .token.punctuation": {
        "color": "#d4d4d4"
      },
      ".language-html .language-javascript .token.punctuation": {
        "color": "#d4d4d4"
      },
      "property": {
        "color": "#9cdcfe"
      },
      "tag": {
        "color": "#569cd6"
      },
      "boolean": {
        "color": "#569cd6"
      },
      "number": {
        "color": "#b5cea8"
      },
      "constant": {
        "color": "#9cdcfe"
      },
      "symbol": {
        "color": "#b5cea8"
      },
      "inserted": {
        "color": "#b5cea8"
      },
      "unit": {
        "color": "#b5cea8"
      },
      "selector": {
        "color": "#d7ba7d"
      },
      "attr-name": {
        "color": "#9cdcfe"
      },
      "string": {
        "color": "#ce9178"
      },
      "char": {
        "color": "#ce9178"
      },
      "builtin": {
        "color": "#ce9178"
      },
      "deleted": {
        "color": "#ce9178"
      },
      ".language-css .token.string.url": {
        "textDecoration": "underline"
      },
      "operator": {
        "color": "#d4d4d4"
      },
      "entity": {
        "color": "#569cd6"
      },
      "operator.arrow": {
        "color": "#569CD6"
      },
      "atrule": {
        "color": "#ce9178"
      },
      "atrule.rule": {
        "color": "#c586c0"
      },
      "atrule.url": {
        "color": "#9cdcfe"
      },
      "atrule.url.function": {
        "color": "#dcdcaa"
      },
      "atrule.url.punctuation": {
        "color": "#d4d4d4"
      },
      "keyword": {
        "color": "#569CD6"
      },
      "keyword.module": {
        "color": "#c586c0"
      },
      "keyword.control-flow": {
        "color": "#c586c0"
      },
      "function": {
        "color": "#dcdcaa"
      },
      "function.maybe-class-name": {
        "color": "#dcdcaa"
      },
      "regex": {
        "color": "#d16969"
      },
      "important": {
        "color": "#569cd6"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "class-name": {
        "color": "#4ec9b0"
      },
      "maybe-class-name": {
        "color": "#4ec9b0"
      },
      "console": {
        "color": "#9cdcfe"
      },
      "parameter": {
        "color": "#9cdcfe"
      },
      "interpolation": {
        "color": "#9cdcfe"
      },
      "punctuation.interpolation-punctuation": {
        "color": "#569cd6"
      },
      "variable": {
        "color": "#9cdcfe"
      },
      "imports.maybe-class-name": {
        "color": "#9cdcfe"
      },
      "exports.maybe-class-name": {
        "color": "#9cdcfe"
      },
      "escape": {
        "color": "#d7ba7d"
      },
      "tag.punctuation": {
        "color": "#808080"
      },
      "cdata": {
        "color": "#808080"
      },
      "attr-value": {
        "color": "#ce9178"
      },
      "attr-value.punctuation": {
        "color": "#ce9178"
      },
      "attr-value.punctuation.attr-equals": {
        "color": "#d4d4d4"
      },
      "namespace": {
        "color": "#4ec9b0"
      },
      'pre[class*="language-javascript"]': {
        "color": "#9cdcfe"
      },
      'code[class*="language-javascript"]': {
        "color": "#9cdcfe"
      },
      'pre[class*="language-jsx"]': {
        "color": "#9cdcfe"
      },
      'code[class*="language-jsx"]': {
        "color": "#9cdcfe"
      },
      'pre[class*="language-typescript"]': {
        "color": "#9cdcfe"
      },
      'code[class*="language-typescript"]': {
        "color": "#9cdcfe"
      },
      'pre[class*="language-tsx"]': {
        "color": "#9cdcfe"
      },
      'code[class*="language-tsx"]': {
        "color": "#9cdcfe"
      },
      'pre[class*="language-css"]': {
        "color": "#ce9178"
      },
      'code[class*="language-css"]': {
        "color": "#ce9178"
      },
      'pre[class*="language-html"]': {
        "color": "#d4d4d4"
      },
      'code[class*="language-html"]': {
        "color": "#d4d4d4"
      },
      ".language-regex .token.anchor": {
        "color": "#dcdcaa"
      },
      ".language-html .token.punctuation": {
        "color": "#808080"
      },
      'pre[class*="language-"] > code[class*="language-"]': {
        "position": "relative",
        "zIndex": "1"
      },
      ".line-highlight.line-highlight": {
        "background": "#f7ebc6",
        "boxShadow": "inset 5px 0 0 #f7d87c",
        "zIndex": "0"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/xonokai.js
var require_xonokai = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/xonokai.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "MozTabSize": "2",
        "OTabSize": "2",
        "tabSize": "2",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "whiteSpace": "pre-wrap",
        "wordWrap": "normal",
        "fontFamily": 'Menlo, Monaco, "Courier New", monospace',
        "fontSize": "14px",
        "color": "#76d9e6",
        "textShadow": "none"
      },
      'pre[class*="language-"]': {
        "MozTabSize": "2",
        "OTabSize": "2",
        "tabSize": "2",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "whiteSpace": "pre-wrap",
        "wordWrap": "normal",
        "fontFamily": 'Menlo, Monaco, "Courier New", monospace',
        "fontSize": "14px",
        "color": "#76d9e6",
        "textShadow": "none",
        "background": "#2a2a2a",
        "padding": "15px",
        "borderRadius": "4px",
        "border": "1px solid #e1e1e8",
        "overflow": "auto",
        "position": "relative"
      },
      'pre > code[class*="language-"]': {
        "fontSize": "1em"
      },
      ':not(pre) > code[class*="language-"]': {
        "background": "#2a2a2a",
        "padding": "0.15em 0.2em 0.05em",
        "borderRadius": ".3em",
        "border": "0.13em solid #7a6652",
        "boxShadow": "1px 1px 0.3em -0.1em #000 inset"
      },
      'pre[class*="language-"] code': {
        "whiteSpace": "pre",
        "display": "block"
      },
      "namespace": {
        "Opacity": ".7"
      },
      "comment": {
        "color": "#6f705e"
      },
      "prolog": {
        "color": "#6f705e"
      },
      "doctype": {
        "color": "#6f705e"
      },
      "cdata": {
        "color": "#6f705e"
      },
      "operator": {
        "color": "#a77afe"
      },
      "boolean": {
        "color": "#a77afe"
      },
      "number": {
        "color": "#a77afe"
      },
      "attr-name": {
        "color": "#e6d06c"
      },
      "string": {
        "color": "#e6d06c"
      },
      "entity": {
        "color": "#e6d06c",
        "cursor": "help"
      },
      "url": {
        "color": "#e6d06c"
      },
      ".language-css .token.string": {
        "color": "#e6d06c"
      },
      ".style .token.string": {
        "color": "#e6d06c"
      },
      "selector": {
        "color": "#a6e22d"
      },
      "inserted": {
        "color": "#a6e22d"
      },
      "atrule": {
        "color": "#ef3b7d"
      },
      "attr-value": {
        "color": "#ef3b7d"
      },
      "keyword": {
        "color": "#ef3b7d"
      },
      "important": {
        "color": "#ef3b7d",
        "fontWeight": "bold"
      },
      "deleted": {
        "color": "#ef3b7d"
      },
      "regex": {
        "color": "#76d9e6"
      },
      "statement": {
        "color": "#76d9e6",
        "fontWeight": "bold"
      },
      "placeholder": {
        "color": "#fff"
      },
      "variable": {
        "color": "#fff"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "punctuation": {
        "color": "#bebec5"
      },
      "italic": {
        "fontStyle": "italic"
      },
      "code.language-markup": {
        "color": "#f9f9f9"
      },
      "code.language-markup .token.tag": {
        "color": "#ef3b7d"
      },
      "code.language-markup .token.attr-name": {
        "color": "#a6e22d"
      },
      "code.language-markup .token.attr-value": {
        "color": "#e6d06c"
      },
      "code.language-markup .token.style": {
        "color": "#76d9e6"
      },
      "code.language-markup .token.script": {
        "color": "#76d9e6"
      },
      "code.language-markup .token.script .token.keyword": {
        "color": "#76d9e6"
      },
      ".line-highlight.line-highlight": {
        "padding": "0",
        "background": "rgba(255, 255, 255, 0.08)"
      },
      ".line-highlight.line-highlight:before": {
        "padding": "0.2em 0.5em",
        "backgroundColor": "rgba(255, 255, 255, 0.4)",
        "color": "black",
        "height": "1em",
        "lineHeight": "1em",
        "boxShadow": "0 1px 1px rgba(255, 255, 255, 0.7)"
      },
      ".line-highlight.line-highlight[data-end]:after": {
        "padding": "0.2em 0.5em",
        "backgroundColor": "rgba(255, 255, 255, 0.4)",
        "color": "black",
        "height": "1em",
        "lineHeight": "1em",
        "boxShadow": "0 1px 1px rgba(255, 255, 255, 0.7)"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/z-touch.js
var require_z_touch = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/z-touch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      'code[class*="language-"]': {
        "color": "#22da17",
        "fontFamily": "monospace",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "lineHeight": "25px",
        "fontSize": "18px",
        "margin": "5px 0"
      },
      'pre[class*="language-"]': {
        "color": "white",
        "fontFamily": "monospace",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "lineHeight": "25px",
        "fontSize": "18px",
        "margin": "0.5em 0",
        "background": "#0a143c",
        "padding": "1em",
        "overflow": "auto"
      },
      'pre[class*="language-"] *': {
        "fontFamily": "monospace"
      },
      ':not(pre) > code[class*="language-"]': {
        "color": "white",
        "background": "#0a143c",
        "padding": "0.1em",
        "borderRadius": "0.3em",
        "whiteSpace": "normal"
      },
      'pre[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "rgba(29, 59, 83, 0.99)"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "rgba(29, 59, 83, 0.99)"
      },
      'code[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "rgba(29, 59, 83, 0.99)"
      },
      'code[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "rgba(29, 59, 83, 0.99)"
      },
      'pre[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "rgba(29, 59, 83, 0.99)"
      },
      'pre[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "rgba(29, 59, 83, 0.99)"
      },
      'code[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "rgba(29, 59, 83, 0.99)"
      },
      'code[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "rgba(29, 59, 83, 0.99)"
      },
      "comment": {
        "color": "rgb(99, 119, 119)",
        "fontStyle": "italic"
      },
      "prolog": {
        "color": "rgb(99, 119, 119)",
        "fontStyle": "italic"
      },
      "cdata": {
        "color": "rgb(99, 119, 119)",
        "fontStyle": "italic"
      },
      "punctuation": {
        "color": "rgb(199, 146, 234)"
      },
      ".namespace": {
        "color": "rgb(178, 204, 214)"
      },
      "deleted": {
        "color": "rgba(239, 83, 80, 0.56)",
        "fontStyle": "italic"
      },
      "symbol": {
        "color": "rgb(128, 203, 196)"
      },
      "property": {
        "color": "rgb(128, 203, 196)"
      },
      "tag": {
        "color": "rgb(127, 219, 202)"
      },
      "operator": {
        "color": "rgb(127, 219, 202)"
      },
      "keyword": {
        "color": "rgb(127, 219, 202)"
      },
      "boolean": {
        "color": "rgb(255, 88, 116)"
      },
      "number": {
        "color": "rgb(247, 140, 108)"
      },
      "constant": {
        "color": "rgb(34 183 199)"
      },
      "function": {
        "color": "rgb(34 183 199)"
      },
      "builtin": {
        "color": "rgb(34 183 199)"
      },
      "char": {
        "color": "rgb(34 183 199)"
      },
      "selector": {
        "color": "rgb(199, 146, 234)",
        "fontStyle": "italic"
      },
      "doctype": {
        "color": "rgb(199, 146, 234)",
        "fontStyle": "italic"
      },
      "attr-name": {
        "color": "rgb(173, 219, 103)",
        "fontStyle": "italic"
      },
      "inserted": {
        "color": "rgb(173, 219, 103)",
        "fontStyle": "italic"
      },
      "string": {
        "color": "rgb(173, 219, 103)"
      },
      "url": {
        "color": "rgb(173, 219, 103)"
      },
      "entity": {
        "color": "rgb(173, 219, 103)"
      },
      ".language-css .token.string": {
        "color": "rgb(173, 219, 103)"
      },
      ".style .token.string": {
        "color": "rgb(173, 219, 103)"
      },
      "class-name": {
        "color": "rgb(255, 203, 139)"
      },
      "atrule": {
        "color": "rgb(255, 203, 139)"
      },
      "attr-value": {
        "color": "rgb(255, 203, 139)"
      },
      "regex": {
        "color": "rgb(214, 222, 235)"
      },
      "important": {
        "color": "rgb(214, 222, 235)",
        "fontWeight": "bold"
      },
      "variable": {
        "color": "rgb(214, 222, 235)"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-syntax-highlighter/dist/cjs/styles/prism/index.js
var require_prism2 = __commonJS({
  "node_modules/react-syntax-highlighter/dist/cjs/styles/prism/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "a11yDark", {
      enumerable: true,
      get: function get2() {
        return _a11yDark["default"];
      }
    });
    Object.defineProperty(exports, "atomDark", {
      enumerable: true,
      get: function get2() {
        return _atomDark["default"];
      }
    });
    Object.defineProperty(exports, "base16AteliersulphurpoolLight", {
      enumerable: true,
      get: function get2() {
        return _base16Ateliersulphurpool["default"];
      }
    });
    Object.defineProperty(exports, "cb", {
      enumerable: true,
      get: function get2() {
        return _cb["default"];
      }
    });
    Object.defineProperty(exports, "coldarkCold", {
      enumerable: true,
      get: function get2() {
        return _coldarkCold["default"];
      }
    });
    Object.defineProperty(exports, "coldarkDark", {
      enumerable: true,
      get: function get2() {
        return _coldarkDark["default"];
      }
    });
    Object.defineProperty(exports, "coy", {
      enumerable: true,
      get: function get2() {
        return _coy["default"];
      }
    });
    Object.defineProperty(exports, "coyWithoutShadows", {
      enumerable: true,
      get: function get2() {
        return _coyWithoutShadows["default"];
      }
    });
    Object.defineProperty(exports, "darcula", {
      enumerable: true,
      get: function get2() {
        return _darcula["default"];
      }
    });
    Object.defineProperty(exports, "dark", {
      enumerable: true,
      get: function get2() {
        return _dark["default"];
      }
    });
    Object.defineProperty(exports, "dracula", {
      enumerable: true,
      get: function get2() {
        return _dracula["default"];
      }
    });
    Object.defineProperty(exports, "duotoneDark", {
      enumerable: true,
      get: function get2() {
        return _duotoneDark["default"];
      }
    });
    Object.defineProperty(exports, "duotoneEarth", {
      enumerable: true,
      get: function get2() {
        return _duotoneEarth["default"];
      }
    });
    Object.defineProperty(exports, "duotoneForest", {
      enumerable: true,
      get: function get2() {
        return _duotoneForest["default"];
      }
    });
    Object.defineProperty(exports, "duotoneLight", {
      enumerable: true,
      get: function get2() {
        return _duotoneLight["default"];
      }
    });
    Object.defineProperty(exports, "duotoneSea", {
      enumerable: true,
      get: function get2() {
        return _duotoneSea["default"];
      }
    });
    Object.defineProperty(exports, "duotoneSpace", {
      enumerable: true,
      get: function get2() {
        return _duotoneSpace["default"];
      }
    });
    Object.defineProperty(exports, "funky", {
      enumerable: true,
      get: function get2() {
        return _funky["default"];
      }
    });
    Object.defineProperty(exports, "ghcolors", {
      enumerable: true,
      get: function get2() {
        return _ghcolors["default"];
      }
    });
    Object.defineProperty(exports, "gruvboxDark", {
      enumerable: true,
      get: function get2() {
        return _gruvboxDark["default"];
      }
    });
    Object.defineProperty(exports, "gruvboxLight", {
      enumerable: true,
      get: function get2() {
        return _gruvboxLight["default"];
      }
    });
    Object.defineProperty(exports, "holiTheme", {
      enumerable: true,
      get: function get2() {
        return _holiTheme["default"];
      }
    });
    Object.defineProperty(exports, "hopscotch", {
      enumerable: true,
      get: function get2() {
        return _hopscotch["default"];
      }
    });
    Object.defineProperty(exports, "lucario", {
      enumerable: true,
      get: function get2() {
        return _lucario["default"];
      }
    });
    Object.defineProperty(exports, "materialDark", {
      enumerable: true,
      get: function get2() {
        return _materialDark["default"];
      }
    });
    Object.defineProperty(exports, "materialLight", {
      enumerable: true,
      get: function get2() {
        return _materialLight["default"];
      }
    });
    Object.defineProperty(exports, "materialOceanic", {
      enumerable: true,
      get: function get2() {
        return _materialOceanic["default"];
      }
    });
    Object.defineProperty(exports, "nightOwl", {
      enumerable: true,
      get: function get2() {
        return _nightOwl["default"];
      }
    });
    Object.defineProperty(exports, "nord", {
      enumerable: true,
      get: function get2() {
        return _nord["default"];
      }
    });
    Object.defineProperty(exports, "okaidia", {
      enumerable: true,
      get: function get2() {
        return _okaidia["default"];
      }
    });
    Object.defineProperty(exports, "oneDark", {
      enumerable: true,
      get: function get2() {
        return _oneDark["default"];
      }
    });
    Object.defineProperty(exports, "oneLight", {
      enumerable: true,
      get: function get2() {
        return _oneLight["default"];
      }
    });
    Object.defineProperty(exports, "pojoaque", {
      enumerable: true,
      get: function get2() {
        return _pojoaque["default"];
      }
    });
    Object.defineProperty(exports, "prism", {
      enumerable: true,
      get: function get2() {
        return _prism["default"];
      }
    });
    Object.defineProperty(exports, "shadesOfPurple", {
      enumerable: true,
      get: function get2() {
        return _shadesOfPurple["default"];
      }
    });
    Object.defineProperty(exports, "solarizedDarkAtom", {
      enumerable: true,
      get: function get2() {
        return _solarizedDarkAtom["default"];
      }
    });
    Object.defineProperty(exports, "solarizedlight", {
      enumerable: true,
      get: function get2() {
        return _solarizedlight["default"];
      }
    });
    Object.defineProperty(exports, "synthwave84", {
      enumerable: true,
      get: function get2() {
        return _synthwave["default"];
      }
    });
    Object.defineProperty(exports, "tomorrow", {
      enumerable: true,
      get: function get2() {
        return _tomorrow["default"];
      }
    });
    Object.defineProperty(exports, "twilight", {
      enumerable: true,
      get: function get2() {
        return _twilight["default"];
      }
    });
    Object.defineProperty(exports, "vs", {
      enumerable: true,
      get: function get2() {
        return _vs["default"];
      }
    });
    Object.defineProperty(exports, "vscDarkPlus", {
      enumerable: true,
      get: function get2() {
        return _vscDarkPlus["default"];
      }
    });
    Object.defineProperty(exports, "xonokai", {
      enumerable: true,
      get: function get2() {
        return _xonokai["default"];
      }
    });
    Object.defineProperty(exports, "zTouch", {
      enumerable: true,
      get: function get2() {
        return _zTouch["default"];
      }
    });
    var _coy = _interopRequireDefault(require_coy());
    var _dark = _interopRequireDefault(require_dark());
    var _funky = _interopRequireDefault(require_funky());
    var _okaidia = _interopRequireDefault(require_okaidia());
    var _solarizedlight = _interopRequireDefault(require_solarizedlight());
    var _tomorrow = _interopRequireDefault(require_tomorrow());
    var _twilight = _interopRequireDefault(require_twilight());
    var _prism = _interopRequireDefault(require_prism());
    var _a11yDark = _interopRequireDefault(require_a11y_dark());
    var _atomDark = _interopRequireDefault(require_atom_dark());
    var _base16Ateliersulphurpool = _interopRequireDefault(require_base16_ateliersulphurpool_light());
    var _cb = _interopRequireDefault(require_cb());
    var _coldarkCold = _interopRequireDefault(require_coldark_cold());
    var _coldarkDark = _interopRequireDefault(require_coldark_dark());
    var _coyWithoutShadows = _interopRequireDefault(require_coy_without_shadows());
    var _darcula = _interopRequireDefault(require_darcula());
    var _dracula = _interopRequireDefault(require_dracula());
    var _duotoneDark = _interopRequireDefault(require_duotone_dark());
    var _duotoneEarth = _interopRequireDefault(require_duotone_earth());
    var _duotoneForest = _interopRequireDefault(require_duotone_forest());
    var _duotoneLight = _interopRequireDefault(require_duotone_light());
    var _duotoneSea = _interopRequireDefault(require_duotone_sea());
    var _duotoneSpace = _interopRequireDefault(require_duotone_space());
    var _ghcolors = _interopRequireDefault(require_ghcolors());
    var _gruvboxDark = _interopRequireDefault(require_gruvbox_dark());
    var _gruvboxLight = _interopRequireDefault(require_gruvbox_light());
    var _holiTheme = _interopRequireDefault(require_holi_theme());
    var _hopscotch = _interopRequireDefault(require_hopscotch());
    var _lucario = _interopRequireDefault(require_lucario());
    var _materialDark = _interopRequireDefault(require_material_dark());
    var _materialLight = _interopRequireDefault(require_material_light());
    var _materialOceanic = _interopRequireDefault(require_material_oceanic());
    var _nightOwl = _interopRequireDefault(require_night_owl());
    var _nord = _interopRequireDefault(require_nord());
    var _oneDark = _interopRequireDefault(require_one_dark());
    var _oneLight = _interopRequireDefault(require_one_light());
    var _pojoaque = _interopRequireDefault(require_pojoaque());
    var _shadesOfPurple = _interopRequireDefault(require_shades_of_purple());
    var _solarizedDarkAtom = _interopRequireDefault(require_solarized_dark_atom());
    var _synthwave = _interopRequireDefault(require_synthwave84());
    var _vs = _interopRequireDefault(require_vs());
    var _vscDarkPlus = _interopRequireDefault(require_vsc_dark_plus());
    var _xonokai = _interopRequireDefault(require_xonokai());
    var _zTouch = _interopRequireDefault(require_z_touch());
  }
});

// node_modules/lodash.includes/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.includes/index.js"(exports, module) {
    var INFINITY2 = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeParseInt = parseInt;
    function arrayMap(array, iteratee) {
      var index4 = -1, length2 = array ? array.length : 0, result = Array(length2);
      while (++index4 < length2) {
        result[index4] = iteratee(array[index4], index4, array);
      }
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length2 = array.length, index4 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index4-- : ++index4 < length2) {
        if (predicate(array[index4], index4, array)) {
          return index4;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index4 = fromIndex - 1, length2 = array.length;
      while (++index4 < length2) {
        if (array[index4] === value) {
          return index4;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseTimes(n, iteratee) {
      var index4 = -1, result = Array(n);
      while (++index4 < n) {
        result[index4] = iteratee(index4);
      }
      return result;
    }
    function baseValues(object2, props) {
      return arrayMap(props, function(key) {
        return object2[key];
      });
    }
    function overArg(func2, transform) {
      return function(arg) {
        return func2(transform(arg));
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray3(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length2 = result.length, skipIndexes = !!length2;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length2)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty2.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function isIndex(value, length2) {
      length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
      return !!length2 && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger2(fromIndex) : 0;
      var length2 = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length2 + fromIndex, 0);
      }
      return isString2(collection) ? fromIndex <= length2 && collection.indexOf(value, fromIndex) > -1 : !!length2 && baseIndexOf(collection, value, fromIndex) > -1;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray3 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike2(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject4(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject4(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike2(value) {
      return !!value && typeof value == "object";
    }
    function isString2(value) {
      return typeof value == "string" || !isArray3(value) && isObjectLike2(value) && objectToString.call(value) == stringTag;
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike2(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY2 || value === -INFINITY2) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger2(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject4(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject4(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function keys2(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    function values(object2) {
      return object2 ? baseValues(object2, keys2(object2)) : [];
    }
    module.exports = includes;
  }
});

// node_modules/lodash.find/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.find/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var INFINITY2 = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reTrim = /^\s+|\s+$/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e4) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arraySome(array, predicate) {
      var index4 = -1, length2 = array ? array.length : 0;
      while (++index4 < length2) {
        if (predicate(array[index4], index4, array)) {
          return true;
        }
      }
      return false;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length2 = array.length, index4 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index4-- : ++index4 < length2) {
        if (predicate(array[index4], index4, array)) {
          return index4;
        }
      }
      return -1;
    }
    function baseProperty(key) {
      return function(object2) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    function baseTimes(n, iteratee) {
      var index4 = -1, result = Array(n);
      while (++index4 < n) {
        result[index4] = iteratee(index4);
      }
      return result;
    }
    function baseUnary(func2) {
      return function(value) {
        return func2(value);
      };
    }
    function getValue(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e4) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index4 = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index4] = [key, value];
      });
      return result;
    }
    function overArg(func2, transform) {
      return function(arg) {
        return func2(transform(arg));
      };
    }
    function setToArray(set2) {
      var index4 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index4] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol;
    var Uint8Array = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index4 = -1, length2 = entries ? entries.length : 0;
      this.clear();
      while (++index4 < length2) {
        var entry = entries[index4];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index4 = -1, length2 = entries ? entries.length : 0;
      this.clear();
      while (++index4 < length2) {
        var entry = entries[index4];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index4 = assocIndexOf(data, key);
      if (index4 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index4 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index4, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index4 = assocIndexOf(data, key);
      return index4 < 0 ? void 0 : data[index4][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index4 = assocIndexOf(data, key);
      if (index4 < 0) {
        data.push([key, value]);
      } else {
        data[index4][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index4 = -1, length2 = entries ? entries.length : 0;
      this.clear();
      while (++index4 < length2) {
        var entry = entries[index4];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index4 = -1, length2 = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index4 < length2) {
        this.add(values[index4]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray3(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length2 = result.length, skipIndexes = !!length2;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length2)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length2 = array.length;
      while (length2--) {
        if (eq(array[length2][0], key)) {
          return length2;
        }
      }
      return -1;
    }
    function baseGet(object2, path) {
      path = isKey(path, object2) ? [path] : castPath(path);
      var index4 = 0, length2 = path.length;
      while (object2 != null && index4 < length2) {
        object2 = object2[toKey(path[index4++])];
      }
      return index4 && index4 == length2 ? object2 : void 0;
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseHasIn(object2, key) {
      return object2 != null && key in Object(object2);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject4(value) && !isObjectLike2(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    function baseIsEqualDeep(object2, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray3(object2), othIsArr = isArray3(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag2(object2);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag2(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object2), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object2) ? equalArrays2(object2, other, equalFunc, customizer, bitmask, stack) : equalByTag(object2, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object2, other, equalFunc, customizer, bitmask, stack);
    }
    function baseIsMatch(object2, source, matchData, customizer) {
      var index4 = matchData.length, length2 = index4, noCustomizer = !customizer;
      if (object2 == null) {
        return !length2;
      }
      object2 = Object(object2);
      while (index4--) {
        var data = matchData[index4];
        if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
          return false;
        }
      }
      while (++index4 < length2) {
        data = matchData[index4];
        var key = data[0], objValue = object2[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object2)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object2, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseIsNative(value) {
      if (!isObject4(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray3(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty2.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object2) {
        return object2 === source || baseIsMatch(object2, source, matchData);
      };
    }
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object2) {
        var objValue = get2(object2, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    function basePropertyDeep(path) {
      return function(object2) {
        return baseGet(object2, path);
      };
    }
    function baseToString2(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
    }
    function castPath(value) {
      return isArray3(value) ? value : stringToPath(value);
    }
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = baseIteratee(predicate, 3);
          collection = keys2(collection);
          predicate = function(key) {
            return iteratee(iterable[key], key, iterable);
          };
        }
        var index4 = findIndexFunc(collection, predicate, fromIndex);
        return index4 > -1 ? iterable[iteratee ? collection[index4] : index4] : void 0;
      };
    }
    function equalArrays2(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index4 = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index4 < arrLength) {
        var arrValue = array[index4], othValue = other[index4];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index4, other, array, stack) : customizer(arrValue, othValue, index4, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object2, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array(object2), new Uint8Array(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object2, +other);
        case errorTag:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag:
          return object2 == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object2, other);
          var result = equalArrays2(convert(object2), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object2);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object2, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys2(object2), objLength = objProps.length, othProps = keys2(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index4 = objLength;
      while (index4--) {
        var key = objProps[index4];
        if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object2);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object2, other);
      stack.set(other, object2);
      var skipCtor = isPartial;
      while (++index4 < objLength) {
        key = objProps[index4];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object2);
      stack["delete"](other);
      return result;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getMatchData(object2) {
      var result = keys2(object2), length2 = result.length;
      while (length2--) {
        var key = result[length2], value = object2[key];
        result[length2] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function getNative(object2, key) {
      var value = getValue(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getTag2 = baseGetTag;
    if (DataView && getTag2(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag2(new Map2()) != mapTag || Promise2 && getTag2(Promise2.resolve()) != promiseTag || Set2 && getTag2(new Set2()) != setTag || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag) {
      getTag2 = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function hasPath(object2, path, hasFunc) {
      path = isKey(path, object2) ? [path] : castPath(path);
      var result, index4 = -1, length2 = path.length;
      while (++index4 < length2) {
        var key = toKey(path[index4]);
        if (!(result = object2 != null && hasFunc(object2, key))) {
          break;
        }
        object2 = object2[key];
      }
      if (result) {
        return result;
      }
      var length2 = object2 ? object2.length : 0;
      return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray3(object2) || isArguments(object2));
    }
    function isIndex(value, length2) {
      length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
      return !!length2 && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    function isKey(value, object2) {
      if (isArray3(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func2) {
      return !!maskSrcKey && maskSrcKey in func2;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isStrictComparable(value) {
      return value === value && !isObject4(value);
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object2) {
        if (object2 == null) {
          return false;
        }
        return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
      };
    }
    var stringToPath = memoize2(function(string3) {
      string3 = toString3(string3);
      var result = [];
      if (reLeadingDot.test(string3)) {
        result.push("");
      }
      string3.replace(rePropName, function(match3, number2, quote, string4) {
        result.push(quote ? string4.replace(reEscapeChar, "$1") : number2 || match3);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
    }
    function toSource(func2) {
      if (func2 != null) {
        try {
          return funcToString.call(func2);
        } catch (e4) {
        }
        try {
          return func2 + "";
        } catch (e4) {
        }
      }
      return "";
    }
    function findIndex2(array, predicate, fromIndex) {
      var length2 = array ? array.length : 0;
      if (!length2) {
        return -1;
      }
      var index4 = fromIndex == null ? 0 : toInteger2(fromIndex);
      if (index4 < 0) {
        index4 = nativeMax(length2 + index4, 0);
      }
      return baseFindIndex(array, baseIteratee(predicate, 3), index4);
    }
    var find2 = createFind(findIndex2);
    function memoize2(func2, resolver) {
      if (typeof func2 != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func2.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize2.Cache || MapCache)();
      return memoized;
    }
    memoize2.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray3 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike2(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject4(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject4(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike2(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike2(value) && objectToString.call(value) == symbolTag;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY2 || value === -INFINITY2) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger2(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject4(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject4(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function toString3(value) {
      return value == null ? "" : baseToString2(value);
    }
    function get2(object2, path, defaultValue) {
      var result = object2 == null ? void 0 : baseGet(object2, path);
      return result === void 0 ? defaultValue : result;
    }
    function hasIn(object2, path) {
      return object2 != null && hasPath(object2, path, baseHasIn);
    }
    function keys2(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    function identity(value) {
      return value;
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module.exports = find2;
  }
});

// node_modules/@neo4j-ndl/react/lib/esm/accordion/Accordion.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());

// node_modules/@neo4j-ndl/react/lib/esm/_common/defaultImports.js
var import_classnames = __toESM(require_classnames());
var classNames = import_classnames.default;

// node_modules/@neo4j-ndl/react/lib/esm/accordion/Accordion.js
var import_react2 = __toESM(require_react());

// node_modules/@neo4j-ndl/react/lib/esm/helpers/debounce.js
function debounce(func2, wait2 = 166) {
  let timeout;
  function debounced(...args) {
    const later = () => {
      func2.apply(this, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait2);
  }
  debounced.clear = () => {
    clearTimeout(timeout);
  };
  return debounced;
}

// node_modules/@neo4j-ndl/react/lib/esm/helpers/forwardRef.js
var import_react = __toESM(require_react());
var forwardRef = import_react.forwardRef;

// node_modules/@neo4j-ndl/react/lib/esm/typography/Typography.js
var import_jsx_runtime = __toESM(require_jsx_runtime());

// node_modules/@neo4j-ndl/react/lib/esm/typography/types.js
var TypographyDefaultMapping = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  "subheading-large": "span",
  "subheading-medium": "span",
  "subheading-small": "span",
  "body-large": "span",
  "body-medium": "span",
  "body-small": "span",
  code: "code",
  label: "span"
};

// node_modules/@neo4j-ndl/react/lib/esm/typography/Typography.js
var __rest = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var Typography = (props) => {
  const { className = "", variant, as } = props, restProps = __rest(props, ["className", "variant", "as"]);
  const classes = classNames(`n-${variant}`, className);
  const Component4 = as || TypographyDefaultMapping[variant];
  return (0, import_jsx_runtime.jsx)(Component4, Object.assign({}, restProps, { className: classes }));
};

// node_modules/@neo4j-ndl/react/lib/esm/accordion/Accordion.js
var __rest2 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var getAccordionItem = (activeElement2, accordionElement, iterator) => {
  var _a2;
  const accordionItemElement = activeElement2.parentElement;
  let newItemElement = iterator(accordionElement, accordionItemElement);
  let childItemElement = null;
  for (let i2 = 0; i2 < 10; i2++) {
    if (!newItemElement) {
      return null;
    }
    const role = (_a2 = newItemElement.firstElementChild) === null || _a2 === void 0 ? void 0 : _a2.getAttribute("role");
    if (role === "heading") {
      childItemElement = newItemElement;
      break;
    }
    newItemElement = iterator(accordionElement, newItemElement);
  }
  return childItemElement;
};
var nextElement = (accordionElement, currentElement) => {
  var _a2, _b;
  if (currentElement === accordionElement || !(currentElement === null || currentElement === void 0 ? void 0 : currentElement.nextElementSibling)) {
    const nextItem = accordionElement.firstChild;
    const firstAccordionItemHeaderElement = (_a2 = accordionElement === null || accordionElement === void 0 ? void 0 : accordionElement.firstElementChild) === null || _a2 === void 0 ? void 0 : _a2.firstElementChild;
    return (firstAccordionItemHeaderElement === null || firstAccordionItemHeaderElement === void 0 ? void 0 : firstAccordionItemHeaderElement.className.includes("ndl-accordion-item-header-disabled")) ? nextElement(accordionElement, nextItem) : nextItem;
  } else if (currentElement === null || currentElement === void 0 ? void 0 : currentElement.nextElementSibling) {
    const nextItem = currentElement.nextElementSibling;
    return ((_b = currentElement.nextElementSibling.firstElementChild) === null || _b === void 0 ? void 0 : _b.className.includes("ndl-accordion-item-header-disabled")) ? nextElement(accordionElement, nextItem) : nextItem;
  }
  return null;
};
var previousElement = (accordionElement, currentElement) => {
  var _a2, _b;
  if (currentElement === accordionElement || !(currentElement === null || currentElement === void 0 ? void 0 : currentElement.previousElementSibling)) {
    const prevItem = accordionElement.lastElementChild;
    const lastAccordionItemHeaderElement = (_a2 = accordionElement === null || accordionElement === void 0 ? void 0 : accordionElement.lastElementChild) === null || _a2 === void 0 ? void 0 : _a2.firstElementChild;
    return (lastAccordionItemHeaderElement === null || lastAccordionItemHeaderElement === void 0 ? void 0 : lastAccordionItemHeaderElement.className.includes("ndl-accordion-item-header-disabled")) ? previousElement(accordionElement, prevItem) : prevItem;
  } else if (currentElement === null || currentElement === void 0 ? void 0 : currentElement.previousElementSibling) {
    const prevItem = currentElement.previousElementSibling;
    return ((_b = currentElement.previousElementSibling.firstElementChild) === null || _b === void 0 ? void 0 : _b.className.includes("ndl-accordion-item-header-disabled")) ? previousElement(accordionElement, prevItem) : prevItem;
  }
  return null;
};
var AccordionContext = (0, import_react2.createContext)(null);
var useAccordionContext = () => {
  const context = (0, import_react2.useContext)(AccordionContext);
  if (context === null) {
    throw new Error("Accordion used without context");
  }
  return context;
};
var AccordionComponent = forwardRef(function AccordionComponent2(_a2, ref) {
  var { as = "div", children, className, multiple, onChange: onChange2 } = _a2, restProps = __rest2(_a2, ["as", "children", "className", "multiple", "onChange"]);
  const accordionRef = (0, import_react2.useRef)(null);
  const handleKeyDown = (event) => {
    const accordionElement = accordionRef.current;
    if (!accordionElement) {
      return;
    }
    const activeElement2 = document.activeElement;
    if (event.key == "ArrowDown") {
      event.preventDefault();
      event.stopPropagation();
      const newFocusedElement = getAccordionItem(activeElement2, accordionElement, nextElement);
      const newHeader = newFocusedElement === null || newFocusedElement === void 0 ? void 0 : newFocusedElement.firstElementChild;
      newHeader.focus();
    } else if (event.key == "ArrowUp") {
      event.preventDefault();
      event.stopPropagation();
      const newFocusedElement = getAccordionItem(activeElement2, accordionElement, previousElement);
      const newHeader = newFocusedElement === null || newFocusedElement === void 0 ? void 0 : newFocusedElement.firstElementChild;
      newHeader.focus();
    } else if (event.key == " " || event.key == "Enter") {
      event.preventDefault();
      event.stopPropagation();
      const buttonElement = activeElement2.getElementsByClassName("ndl-accordion-item-header-button")[0];
      buttonElement.click();
    }
  };
  (0, import_react2.useImperativeHandle)(ref, () => accordionRef.current);
  const classes = classNames("ndl-accordion", className);
  const Component4 = as;
  const _b = restProps, { expandedItemIds } = _b, isMultipleRootProps = __rest2(_b, ["expandedItemIds"]);
  const _c = restProps, { expandedItemId } = _c, isNotMultipleRootProps = __rest2(_c, ["expandedItemId"]);
  const rootProps = multiple ? isMultipleRootProps : isNotMultipleRootProps;
  const contextValue = multiple ? {
    onChange: onChange2,
    multiple,
    expandedItemIds
  } : {
    onChange: onChange2,
    multiple,
    expandedItemId
  };
  return (0, import_jsx_runtime2.jsx)(Component4, Object.assign({}, rootProps, { className: classes, ref: accordionRef, onKeyDown: handleKeyDown, children: (0, import_jsx_runtime2.jsx)(AccordionContext.Provider, { value: contextValue, children }) }));
});
AccordionComponent.displayName = "Accordion";
var createItemId = (type, id) => `ndl-accordionitem${type}id-${id}`;
var AccordionItem = (_a2) => {
  var { itemId, children, title, className = "", arrowPosition = "right", disabled = false, onExpandedChange } = _a2, restProps = __rest2(_a2, ["itemId", "children", "title", "className", "arrowPosition", "disabled", "onExpandedChange"]);
  const contentRef = (0, import_react2.useRef)(null);
  const innerContentRef = (0, import_react2.useRef)(null);
  const itemElementId = createItemId("item", itemId);
  const headerElementId = createItemId("header", itemId);
  const buttonElementId = createItemId("button", itemId);
  const panelElementId = createItemId("panel", itemId);
  const context = useAccordionContext();
  const { multiple } = context;
  const isExpanded = multiple ? context.expandedItemIds.includes(itemId) : context.expandedItemId === itemId;
  const handleOnClick = (0, import_react2.useCallback)(() => {
    var _a3, _b;
    if (disabled)
      return;
    if (onExpandedChange !== void 0)
      onExpandedChange(!isExpanded);
    if (multiple) {
      const { expandedItemIds, onChange: onChange2 } = context;
      if (isExpanded) {
        const newArray = expandedItemIds.filter((activeId) => activeId !== itemId);
        onChange2(newArray);
      } else if (!isExpanded) {
        const newArray = [...expandedItemIds];
        newArray.push(itemId);
        onChange2(newArray);
      }
    } else {
      const { onChange: onChange2 } = context;
      if (isExpanded) {
        onChange2(null);
      } else if (!isExpanded) {
        onChange2(itemId);
      }
    }
    (_b = (_a3 = document.activeElement) === null || _a3 === void 0 ? void 0 : _a3.parentElement) === null || _b === void 0 ? void 0 : _b.focus();
  }, [isExpanded, multiple, disabled, itemId, onExpandedChange, context]);
  const classes = classNames("ndl-accordion-item", className, {
    "ndl-accordion-item-disabled": disabled
  });
  const headerClasses = classNames("ndl-accordion-item-header", {
    "ndl-accordion-item-header-disabled": disabled
  });
  const iconClasses = classNames("ndl-accordion-item-header-icon-wrapper", {
    "ndl-accordion-item-header-icon-wrapper-right": arrowPosition === "right"
  });
  const buttonClasses = classNames("ndl-accordion-item-header-button", {
    "ndl-accordion-item-header-button-disabled": disabled
  });
  const titleClasses = classNames("ndl-accordion-item-header-button-title", {
    "ndl-accordion-item-header-button-title": disabled,
    "ndl-accordion-item-header-button-title-right": arrowPosition === "right"
  });
  const contentClasses = classNames("ndl-accordion-item-content", {
    "ndl-accordion-item-content-expanded": isExpanded,
    "ndl-accordion-item-content-right": arrowPosition === "right"
  });
  const headerTitle = (0, import_jsx_runtime2.jsx)("span", { className: titleClasses, children: title });
  return (0, import_jsx_runtime2.jsxs)("div", Object.assign({}, restProps, { className: classes, id: itemElementId, children: [(0, import_jsx_runtime2.jsx)(Typography, { variant: "subheading-medium", className: headerClasses, role: "heading", tabIndex: disabled ? -1 : 0, id: headerElementId, "aria-level": "2", children: (0, import_jsx_runtime2.jsx)("button", { id: buttonElementId, onClick: handleOnClick, className: buttonClasses, "aria-expanded": isExpanded, "aria-disabled": disabled, "aria-label": title, "aria-controls": panelElementId, tabIndex: -1, children: (0, import_jsx_runtime2.jsxs)("span", { className: iconClasses, children: [headerTitle, (0, import_jsx_runtime2.jsx)(import_ChevronDownIcon.default, { className: classNames("ndl-accordion-item-header-icon", {
    "-n-rotate-180": isExpanded
  }) })] }) }) }), (0, import_jsx_runtime2.jsx)("div", { id: panelElementId, ref: contentRef, className: contentClasses, "aria-hidden": !isExpanded, "aria-labelledby": buttonElementId, role: "region", children: (0, import_jsx_runtime2.jsx)("div", { ref: innerContentRef, className: "ndl-accordion-item-content-inner", children: (0, import_jsx_runtime2.jsx)(Typography, { variant: "body-medium", className: "n-text-palette-neutral-text-weak", as: "div", children }) }) })] }));
};
AccordionItem.displayName = "Accordion.Item";
var Accordion = Object.assign(AccordionComponent, { Item: AccordionItem });

// node_modules/@neo4j-ndl/react/lib/esm/button/Button.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var import_react5 = __toESM(require_react());

// node_modules/@neo4j-ndl/react/lib/esm/loading-spinner/LoadingSpinner.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var import_react3 = __toESM(require_react());
var __rest3 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var LoadingSpinner = import_react3.default.forwardRef(function LoadingSpinner2(props, ref) {
  const { size: size3 = "small", className } = props, restProps = __rest3(props, ["size", "className"]);
  const classes = classNames("ndl-spin-wrapper", className, {
    "ndl-small": size3 === "small",
    "ndl-medium": size3 === "medium",
    "ndl-large": size3 === "large"
  });
  return (0, import_jsx_runtime3.jsx)("div", Object.assign({ className: classes, role: "status", "aria-label": "Loading content", "aria-live": "polite" }, restProps, { ref, children: (0, import_jsx_runtime3.jsx)("div", { className: "ndl-spin" }) }));
});
var LoadingSpinner_default = LoadingSpinner;

// node_modules/@neo4j-ndl/react/lib/esm/_common/utils.js
var import_react4 = __toESM(require_react());
var removeNewlines = (input) => input.replace(/(\r\n|\n|\r)/gm, "");
var removeSpaces = (input) => input.replace(/\s+/g, " ").trim();
var needleWarningMessage = (message) => console.warn(`[ Needle]:  ${message}`);
var getScrollbarSize = (doc2) => {
  const documentWidth = doc2.documentElement.clientWidth;
  return Math.abs(window.innerWidth - documentWidth);
};
var getPaddingRight = (element) => parseInt(window.getComputedStyle(element).paddingRight, 10) || 0;
var useDocumentScrollToggle = () => {
  const bodyPadding = (0, import_react4.useRef)(0);
  return (0, import_react4.useCallback)((disable, doc2 = document) => {
    if (disable) {
      const existingPaddingRight = getPaddingRight(doc2.body);
      bodyPadding.current = existingPaddingRight;
      const newPaddingRight = existingPaddingRight + getScrollbarSize(doc2);
      doc2.body.style.overflow = "hidden";
      doc2.body.style.paddingRight = `${newPaddingRight}px`;
    } else {
      doc2.body.style.overflow = "";
      doc2.body.style.paddingRight = `${bodyPadding.current}px`;
    }
  }, []);
};
var useOnClickOutside = (ref, handler) => {
  (0, import_react4.useEffect)(() => {
    const listener = (event) => {
      const el = ref === null || ref === void 0 ? void 0 : ref.current;
      if (!el || el.contains((event === null || event === void 0 ? void 0 : event.target) || null)) {
        return;
      }
      handler(event);
    };
    document.addEventListener("mousedown", listener);
    document.addEventListener("touchstart", listener);
    return () => {
      document.removeEventListener("mousedown", listener);
      document.removeEventListener("touchstart", listener);
    };
  }, [ref, handler]);
};
var randomId = (length2) => Math.random().toString(36).slice(2, length2 + 2);
function isRefObject(obj) {
  return obj && typeof obj === "object" && "current" in obj;
}

// node_modules/@neo4j-ndl/react/lib/esm/button/Button.js
var __rest4 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var Button = import_react5.default.forwardRef(function Button2(_a2, ref) {
  var { children, as, type = "button", loading = false, color = "primary", disabled = false, fill = "filled", size: size3 = "medium", className, onClick, floating = false, tabIndex = 0 } = _a2, restProps = __rest4(_a2, ["children", "as", "type", "loading", "color", "disabled", "fill", "size", "className", "onClick", "floating", "tabIndex"]);
  let Component4 = as || "button";
  if (!as && restProps.href) {
    Component4 = "a";
  }
  const interactable = !disabled && !loading;
  const classes = classNames("ndl-btn", {
    "ndl-small": size3 === "small",
    "ndl-medium": size3 === "medium",
    "ndl-large": size3 === "large",
    "ndl-filled": fill === "filled",
    "ndl-outlined": fill === "outlined",
    "ndl-text": fill === "text",
    "ndl-disabled": disabled,
    "ndl-loading": loading,
    "ndl-floating-btn": floating,
    /** Now check button is outlined or filled */
    /**
     * Notice:
     * "Hover" here does not exist for "warning" and "success"
     * and is custom for Neutral
     */
    [`
      ${color === "neutral" ? `n-bg-palette-${color}-bg-strongest` : `n-bg-palette-${color}-bg-strong`}
      ${interactable && `hover:n-bg-palette-${color}-hover-strong
         active:n-bg-palette-${color}-pressed-strong`}
      `]: fill === "filled",
    [`
      n-text-palette-${color}-text
      ${interactable && `hover:n-bg-palette-${color}-hover-weak
        active:n-bg-palette-${color}-pressed-weak`}
      n-border-palette-${color}-bg-strong
      `]: fill === "outlined" && color !== "neutral",
    /**
     * Neutral needs overriding as it doesn't follow
     * the same principles with colored variations
     */
    [`
    n-text-palette-neutral-text-weak
      n-bg-palette-${color}-weak
      ${interactable && `hover:n-bg-palette-${color}-bg-default`}
      n-border-palette-neutral-border-strong
      active:n-bg-palette-neutral-pressed
      `]: fill === "outlined" && color === "neutral",
    [`
      n-text-palette-${color}-text
      ${interactable && `hover:n-bg-palette-${color}-hover-weak
         active:n-bg-palette-${color}-pressed-weak
      `}
      `]: fill === "text" && color !== "neutral",
    [`	
     n-text-palette-neutral-text-weak
      ${interactable && `hover:n-bg-palette-neutral-bg-default`}
      `]: fill === "text" && color == "neutral"
  });
  const sanitisedClasses = removeSpaces(removeNewlines(classes));
  const handleClick = (e4) => {
    if (!interactable) {
      e4.preventDefault();
      e4.stopPropagation();
      return;
    }
    if (onClick) {
      onClick(e4);
    }
  };
  return (0, import_jsx_runtime4.jsxs)(
    Component4,
    Object.assign({}, restProps, Component4 === "button" ? { type } : {}, { onClick: handleClick, disabled: !interactable, className: [sanitisedClasses, className].join(" "), ref, tabIndex: !interactable ? -1 : tabIndex, children: [loading ? (0, import_jsx_runtime4.jsx)(LoadingSpinner_default, { className: "n-my-auto n-mr-1", size: "small" }) : null, children] })
  );
});

// node_modules/@neo4j-ndl/react/lib/esm/button/IconButton.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var import_react6 = __toESM(require_react());
var __rest5 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var IconButton = import_react6.default.forwardRef(function Button3(_a2, ref) {
  var { children, as, type = "button", loading = false, disabled = false, size: size3 = "medium", className, onClick, grouped, floating = false, danger, clean, active = false } = _a2, restProps = __rest5(_a2, ["children", "as", "type", "loading", "disabled", "size", "className", "onClick", "grouped", "floating", "danger", "clean", "active"]);
  let Component4 = as || "button";
  if (!as && restProps.href) {
    Component4 = "a";
  }
  const interactable = !disabled && !loading;
  const classes = classNames(`ndl-icon-btn ${className}`, {
    "ndl-small": size3 === "small",
    "ndl-medium": size3 === "medium",
    "ndl-large": size3 === "large",
    "ndl-grouped": grouped,
    "ndl-disabled": disabled,
    "ndl-loading": loading,
    "ndl-floating": floating,
    "ndl-danger": danger,
    "ndl-clean": clean,
    "ndl-active": active
  });
  if (clean && floating) {
    needleWarningMessage("Can't have 'clean' and 'floating' props true at the same time");
  }
  if (!restProps["aria-label"]) {
    needleWarningMessage("Icon buttons do not have text, be sure to include an aria-label for screen readers link: https://dequeuniversity.com/rules/axe/4.4/button-name?application=axeAPI");
  }
  const handleClick = (e4) => {
    if (!interactable) {
      e4.preventDefault();
      e4.stopPropagation();
      return;
    }
    if (onClick) {
      onClick(e4);
    } else if (!restProps.href) {
      console.error("onClick was not provided");
    }
  };
  return (0, import_jsx_runtime5.jsx)(
    Component4,
    Object.assign({}, restProps, Component4 === "button" ? { type } : {}, { onClick: handleClick, disabled: !interactable, className: classes, ref, children: loading ? (0, import_jsx_runtime5.jsx)(LoadingSpinner_default, { size: "small" }) : (0, import_jsx_runtime5.jsx)("div", { className: "ndl-icon", children }) })
  );
});

// node_modules/@neo4j-ndl/react/lib/esm/button/IconButtonArray.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var import_react7 = __toESM(require_react());
var __rest6 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var IconButtonArray = import_react7.default.forwardRef(function Button4(_a2, ref) {
  var { children, as, className, floating = false, orientation = "horizontal" } = _a2, restProps = __rest6(_a2, ["children", "as", "className", "floating", "orientation"]);
  const Component4 = as || "div";
  const classes = classNames("ndl-icon-btn-array", {
    "n-flex-row": orientation === "horizontal",
    "n-flex-col": orientation === "vertical",
    "ndl-array-floating": floating,
    [`${className}`]: className
  });
  return (0, import_jsx_runtime6.jsx)(Component4, Object.assign({}, restProps, { className: classes, ref, children }));
});

// node_modules/@neo4j-ndl/react/lib/esm/label/Label.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var import_react8 = __toESM(require_react());
var __rest7 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var Label = import_react8.default.forwardRef(function Label2(_a2, ref) {
  var { color = "default", children, className, fill = "filled", withIcon = false } = _a2, restProps = __rest7(_a2, ["color", "children", "className", "fill", "withIcon"]);
  let baseClasses;
  let icon;
  if (!withIcon && fill === "clean") {
    console.error("Label without icon is not allowed");
  }
  const mappedColor = color === "info" ? "primary" : color;
  if (withIcon) {
    const isFilled = fill === "filled";
    if (mappedColor === "default") {
      const fillColor = isFilled ? "currentColor" : "rgb(var(--theme-palette-neutral-bg-status))";
      icon = (0, import_jsx_runtime7.jsx)(Square_default, { color: fillColor });
    } else if (mappedColor === "primary") {
      const fillColor = isFilled ? "currentColor" : "rgb(var(--theme-palette-primary-bg-status))";
      icon = (0, import_jsx_runtime7.jsx)(Circle_default, { color: fillColor });
    } else if (mappedColor === "success") {
      const fillColor = isFilled ? "currentColor" : "rgb(var(--theme-palette-success-bg-status))";
      icon = (0, import_jsx_runtime7.jsx)(Circle_default, { color: fillColor });
    } else if (mappedColor === "danger") {
      const fillColor = isFilled ? "currentColor" : "rgb(var(--theme-palette-danger-bg-status))";
      icon = (0, import_jsx_runtime7.jsx)(Rhombus_default, { color: fillColor });
    } else if (mappedColor === "warning") {
      const fillColor = isFilled ? "currentColor" : "rgb(var(--theme-palette-warning-bg-status))";
      icon = (0, import_jsx_runtime7.jsx)(Triangle_default, { color: fillColor });
    }
  }
  if (mappedColor === "default") {
    baseClasses = classNames({
      [`n-bg-palette-neutral-bg-strongest n-text-palette-neutral-text-inverse`]: fill === "filled",
      // TODO: There currently is no token for border theme color neutral 60, needs to be added.
      [` n-text-palette-neutral-text-weak n-border-palette-neutral-border-strong`]: fill === "outlined",
      [`n-bg-palette-neutral-bg-default n-text-palette-neutral-text-weak n-border-palette-neutral-border-strong`]: fill === "semi-filled",
      [`n-text-palette-neutral-text-weaker`]: fill === "clean"
    });
  } else {
    baseClasses = classNames({
      [`n-bg-palette-${mappedColor}-bg-strong n-text-palette-neutral-text-inverse`]: fill === "filled",
      [`n-text-palette-${mappedColor}-text n-border-palette-${mappedColor}-border-strong`]: fill === "outlined",
      [`n-bg-palette-${mappedColor}-bg-weak n-text-palette-${mappedColor}-text n-border-palette-${mappedColor}-border-weak`]: fill === "semi-filled",
      [`n-text-palette-neutral-text-default`]: fill === "clean"
    });
  }
  const classes = classNames("ndl-label", baseClasses, className, {
    "ndl-filled": fill === "filled",
    "ndl-clean": fill === "clean",
    "ndl-outlined": fill === "outlined",
    "ndl-semi-filled": fill === "semi-filled"
  });
  return (0, import_jsx_runtime7.jsx)("span", Object.assign({ role: "status", "aria-label": "label", className: classes }, restProps, { ref, children: (0, import_jsx_runtime7.jsxs)("div", { className: "ndl-label-content", children: [icon, (0, import_jsx_runtime7.jsx)("span", {
    // To enable native tooltip on hover if the children is a string
    title: typeof children === "string" ? children : "label",
    className: "ndl-label-text",
    children
  })] }) }));
});
var Label_default = Label;

// node_modules/@neo4j-ndl/react/lib/esm/banner/Banner.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var import_react9 = __toESM(require_react());
var __rest8 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var getStatusIcon = (iconType) => {
  let iconComponent;
  switch (iconType) {
    case "success":
      iconComponent = (0, import_jsx_runtime8.jsx)(import_CheckCircleIcon2.default, {});
      break;
    case "warning":
      iconComponent = (0, import_jsx_runtime8.jsx)(import_ExclamationTriangleIcon2.default, {});
      break;
    case "danger":
      iconComponent = (0, import_jsx_runtime8.jsx)(import_ExclamationCircleIcon2.default, {});
      break;
    default:
      iconComponent = (0, import_jsx_runtime8.jsx)(import_InformationCircleIcon2.default, {});
  }
  return (0, import_jsx_runtime8.jsx)("div", { className: "ndl-banner-icon ndl-banner-status-icon", children: iconComponent });
};
var BannerActions = (_a2) => {
  var { label } = _a2, restProps = __rest8(_a2, ["label"]);
  return (0, import_jsx_runtime8.jsx)("a", Object.assign({}, restProps, { children: label }));
};
var Banner = import_react9.default.forwardRef(function Banner2(_a2, ref) {
  var { type = "info", icon = false, title, name: name2, actions = [], floating = false, description = null, onClose, className = "", children = null, closeable = false } = _a2, rest = __rest8(_a2, ["type", "icon", "title", "name", "actions", "floating", "description", "onClose", "className", "children", "closeable"]);
  (0, import_react9.useEffect)(() => {
    if (typeof title !== "string" && !name2 && closeable) {
      needleWarningMessage("Banner Component expected `name` prop when title is not a string: https://dequeuniversity.com/rules/axe/4.2/aria-dialog-name?application=axeAPI");
    }
  }, [title, name2, closeable]);
  if (typeof title === "string" && !name2) {
    name2 = title;
  }
  const classes = classNames("ndl-banner", {
    "ndl-with-description": description,
    "ndl-neutral": type === "neutral",
    "ndl-info": type === "info",
    "ndl-success": type === "success",
    "ndl-warning": type === "warning",
    "ndl-danger": type === "danger",
    "ndl-floating": floating,
    [className]: className && className !== ""
  });
  const handleClose2 = (e4) => {
    if (onClose && typeof onClose === "function") {
      onClose(e4);
    }
  };
  const hasIcon = icon && type !== "neutral";
  return (0, import_jsx_runtime8.jsxs)("div", Object.assign({ className: classes, role: closeable ? "alertdialog" : "alert" }, rest, { title: name2, ref, children: [hasIcon && getStatusIcon(type), (0, import_jsx_runtime8.jsxs)("div", { className: "ndl-banner-content", children: [title && (0, import_jsx_runtime8.jsx)("h6", { className: "ndl-banner-title", children: title }), (description || children) && (0, import_jsx_runtime8.jsx)("div", { className: "ndl-banner-description", children: children || description }), actions && actions.length > 0 && (0, import_jsx_runtime8.jsx)("div", { className: "ndl-banner-actions", children: actions.map((action, index4) => (0, import_jsx_runtime8.jsx)(BannerActions, Object.assign({}, action), index4)) })] }), closeable && (0, import_jsx_runtime8.jsx)("div", { tabIndex: 0, role: "button", className: "ndl-banner-icon ndl-close-icon", onKeyDown: handleClose2, onClick: handleClose2, "aria-label": "close-banner", children: (0, import_jsx_runtime8.jsx)(import_XMarkIcon.default, {}) })] }));
});
var BannerNamespace = Object.assign(Banner, { Actions: BannerActions });
BannerNamespace.displayName = "Banner";

// node_modules/@neo4j-ndl/react/lib/esm/tip/Tooltip.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var import_react11 = __toESM(require_react());

// node_modules/@neo4j-ndl/react/lib/esm/theme/ThemeProvider.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var import_react10 = __toESM(require_react());
var __rest9 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var ThemeContext = (0, import_react10.createContext)(void 0);
var useNeedleTheme = () => {
  let theme2 = (0, import_react10.useContext)(ThemeContext);
  if (theme2 === void 0)
    theme2 = "light";
  return {
    theme: theme2,
    themeClassName: `ndl-theme-${theme2}`
  };
};
var NeedleThemeProvider = ({ theme: theme2 = "light", children, wrapperProps }) => {
  const clonedChildren = (0, import_react10.useMemo)(() => {
    const _a2 = wrapperProps || {}, { isWrappingChildren, className } = _a2, restWrapperProps = __rest9(_a2, ["isWrappingChildren", "className"]);
    const props = Object.assign(Object.assign({}, restWrapperProps), { className: classNames(className, `ndl-theme-${theme2}`) });
    if (isWrappingChildren !== true) {
      return import_react10.default.Children.map(children, (child) => {
        return import_react10.default.cloneElement(child, Object.assign(Object.assign({}, props), { className: classNames(child.props.className, props.className) }));
      });
    } else {
      return (0, import_jsx_runtime9.jsx)("span", Object.assign({}, props, { className: classNames("ndl-theme-wrapper", props.className), children }));
    }
  }, [wrapperProps, theme2, children]);
  return (0, import_jsx_runtime9.jsx)(ThemeContext.Provider, { value: theme2, children: clonedChildren });
};

// node_modules/@neo4j-ndl/react/lib/esm/tip/Tooltip.js
var __rest10 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var Tooltip = import_react11.default.forwardRef(function Tooltip2(_a2, ref) {
  var { arrowPosition, children, className } = _a2, restProps = __rest10(_a2, ["arrowPosition", "children", "className"]);
  const { themeClassName } = useNeedleTheme();
  const wrapperClasses = classNames("ndl-tooltip-wrapper", themeClassName, className);
  const triangleClasses = classNames("ndl-tooltip-triangle", {
    "ndl-top": arrowPosition === "top",
    "ndl-bottom": arrowPosition === "bottom",
    "ndl-left": arrowPosition === "left",
    "ndl-right": arrowPosition === "right",
    "ndl-top-left": arrowPosition === "top-left",
    "ndl-top-right": arrowPosition === "top-right"
  });
  return (0, import_jsx_runtime10.jsxs)("div", Object.assign({}, restProps, { role: "tooltip", className: wrapperClasses, ref, children: [children, (0, import_jsx_runtime10.jsx)("div", { className: triangleClasses })] }));
});
var Tooltip_default = Tooltip;

// node_modules/@neo4j-ndl/react/lib/esm/tip/Tip.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime());

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length2 = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length2] > rects.floating[length2]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt2 = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt2;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref4, placement, rtl) {
  let {
    reference: reference2,
    floating
  } = _ref4;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference2.x + reference2.width / 2 - floating.width / 2;
  const commonY = reference2.y + reference2.height / 2 - floating.height / 2;
  const commonAlign = reference2[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference2.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case "right":
      coords = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference2.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference2.x,
        y: reference2.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference2, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2
  } = config2;
  const validMiddleware = middleware2.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference: reference2,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y3
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name: name2,
      fn: fn2
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn2({
      x: x2,
      y: y3,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference: reference2,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y3 = nextY != null ? nextY : y3;
    middlewareData = {
      ...middlewareData,
      [name2]: {
        ...middlewareData[name2],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference: reference2,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y3
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
      continue;
    }
  }
  return {
    x: x2,
    y: y3,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options2) {
  var _await$platform$isEle;
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    x: x2,
    y: y3,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options2, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x: x2,
    y: y3
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var flip = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "flip",
    options: options2,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options2, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements3 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements3[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d3) => d3.overflows[0] <= 0).sort((a3, b2) => a3.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d3) => [d3.placement, d3.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a3, b2) => a3[1] - b2[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options2) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options2, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options2) {
  if (options2 === void 0) {
    options2 = 0;
  }
  return {
    name: "offset",
    options: options2,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y3,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options2);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y3 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function getNodeName(node3) {
  if (isNode(node3)) {
    return (node3.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node3) {
  var _node$ownerDocument;
  return (node3 == null || (_node$ownerDocument = node3.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node3) {
  var _ref4;
  return (_ref4 = (isNode(node3) ? node3.ownerDocument : node3.document) || window.document) == null ? void 0 : _ref4.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit2 = isWebKit();
  const css5 = getComputedStyle2(element);
  return css5.transform !== "none" || css5.perspective !== "none" || (css5.containerType ? css5.containerType !== "normal" : false) || !webkit2 && (css5.backdropFilter ? css5.backdropFilter !== "none" : false) || !webkit2 && (css5.filter ? css5.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css5.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css5.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node3) {
  return ["html", "body", "#document"].includes(getNodeName(node3));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node3) {
  if (getNodeName(node3) === "html") {
    return node3;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node3.assignedSlot || // DOM Element detected.
    node3.parentNode || // ShadowRoot detected.
    isShadowRoot(node3) && node3.host || // Fallback.
    getDocumentElement(node3)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node3) {
  const parentNode = getParentNode(node3);
  if (isLastTraversableNode(parentNode)) {
    return node3.ownerDocument ? node3.ownerDocument.body : node3.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node3, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node3);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node3.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css5 = getComputedStyle2(element);
  let width = parseFloat(css5.width) || 0;
  let height = parseFloat(css5.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x2 = ($ ? round(rect.width) : rect.width) / width;
  let y3 = ($ ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y3 || !Number.isFinite(y3)) {
    y3 = 1;
  }
  return {
    x: x2,
    y: y3
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y3 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css5 = getComputedStyle2(currentIFrame);
      const left2 = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css5.paddingLeft)) * iframeScale.x;
      const top3 = iframeRect.top + (currentIFrame.clientTop + parseFloat(css5.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y3 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left2;
      y3 += top3;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y3
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref4) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref4;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y3 = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y3
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y3 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y3 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y3
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top3 = clientRect.top + element.clientTop;
  const left2 = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left2 * scale.x;
  const y3 = top3 * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y3
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref4) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref4;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const window2 = getWindow(element);
  if (!isHTMLElement(element)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
var getElementRects = async function(_ref4) {
  let {
    reference: reference2,
    floating,
    strategy
  } = _ref4;
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  return {
    reference: getRectRelativeToOffsetParent(reference2, await getOffsetParentFn(floating), strategy),
    floating: {
      x: 0,
      y: 0,
      ...await getDimensionsFn(floating)
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId2;
  const root = getDocumentElement(element);
  function cleanup() {
    clearTimeout(timeoutId2);
    io && io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left: left2,
      top: top3,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top3);
    const insetRight = floor(root.clientWidth - (left2 + width));
    const insetBottom = floor(root.clientHeight - (top3 + height));
    const insetLeft = floor(left2);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options2 = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId2 = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options2,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e4) {
      io = new IntersectionObserver(handleObserve, options2);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference2, floating, update, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options2;
  const referenceEl = unwrapElement(reference2);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref4) => {
      let [firstEntry] = _ref4;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          resizeObserver && resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference2) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference2);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo && cleanupIo();
    resizeObserver && resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var flip2 = flip;
var computePosition2 = (reference2, floating, options2) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options2
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference2, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React9 = __toESM(require_react(), 1);
var import_react12 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var index = typeof document !== "undefined" ? import_react12.useLayoutEffect : import_react12.useEffect;
function deepEqual(a3, b2) {
  if (a3 === b2) {
    return true;
  }
  if (typeof a3 !== typeof b2) {
    return false;
  }
  if (typeof a3 === "function" && a3.toString() === b2.toString()) {
    return true;
  }
  let length2, i2, keys2;
  if (a3 && b2 && typeof a3 == "object") {
    if (Array.isArray(a3)) {
      length2 = a3.length;
      if (length2 != b2.length)
        return false;
      for (i2 = length2; i2-- !== 0; ) {
        if (!deepEqual(a3[i2], b2[i2])) {
          return false;
        }
      }
      return true;
    }
    keys2 = Object.keys(a3);
    length2 = keys2.length;
    if (length2 !== Object.keys(b2).length) {
      return false;
    }
    for (i2 = length2; i2-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys2[i2])) {
        return false;
      }
    }
    for (i2 = length2; i2-- !== 0; ) {
      const key = keys2[i2];
      if (key === "_owner" && a3.$$typeof) {
        continue;
      }
      if (!deepEqual(a3[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a3 !== a3 && b2 !== b2;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React9.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options2;
  const [data, setData] = React9.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React9.useState(middleware2);
  if (!deepEqual(latestMiddleware, middleware2)) {
    setLatestMiddleware(middleware2);
  }
  const [_reference, _setReference] = React9.useState(null);
  const [_floating, _setFloating] = React9.useState(null);
  const setReference = React9.useCallback((node3) => {
    if (node3 != referenceRef.current) {
      referenceRef.current = node3;
      _setReference(node3);
    }
  }, [_setReference]);
  const setFloating = React9.useCallback((node3) => {
    if (node3 !== floatingRef.current) {
      floatingRef.current = node3;
      _setFloating(node3);
    }
  }, [_setFloating]);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React9.useRef(null);
  const floatingRef = React9.useRef(null);
  const dataRef = React9.useRef(data);
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const update = React9.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config2 = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config2.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config2).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React9.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      } else {
        update();
      }
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef]);
  const refs = React9.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React9.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React9.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x2 = roundByDPR(elements.floating, data.x);
    const y3 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x2 + "px, " + y3 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x2,
      top: y3
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React9.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}

// node_modules/@floating-ui/react/dist/floating-ui.react.mjs
var React10 = __toESM(require_react(), 1);
var import_react13 = __toESM(require_react(), 1);

// node_modules/@floating-ui/react/node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs
function getNodeName2(node3) {
  if (isNode2(node3)) {
    return (node3.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow2(node3) {
  var _node$ownerDocument;
  return (node3 == null ? void 0 : (_node$ownerDocument = node3.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement2(node3) {
  var _ref4;
  return (_ref4 = (isNode2(node3) ? node3.ownerDocument : node3.document) || window.document) == null ? void 0 : _ref4.documentElement;
}
function isNode2(value) {
  return value instanceof Node || value instanceof getWindow2(value).Node;
}
function isElement2(value) {
  return value instanceof Element || value instanceof getWindow2(value).Element;
}
function isHTMLElement2(value) {
  return value instanceof HTMLElement || value instanceof getWindow2(value).HTMLElement;
}
function isShadowRoot2(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow2(value).ShadowRoot;
}
function isLastTraversableNode2(node3) {
  return ["html", "body", "#document"].includes(getNodeName2(node3));
}
function getComputedStyle3(element) {
  return getWindow2(element).getComputedStyle(element);
}
function getParentNode2(node3) {
  if (getNodeName2(node3) === "html") {
    return node3;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node3.assignedSlot || // DOM Element detected.
    node3.parentNode || // ShadowRoot detected.
    isShadowRoot2(node3) && node3.host || // Fallback.
    getDocumentElement2(node3)
  );
  return isShadowRoot2(result) ? result.host : result;
}

// node_modules/@floating-ui/react/node_modules/@floating-ui/utils/react/dist/floating-ui.utils.react.mjs
function activeElement(doc2) {
  let activeElement2 = doc2.activeElement;
  while (((_activeElement = activeElement2) == null ? void 0 : (_activeElement$shadow = _activeElement.shadowRoot) == null ? void 0 : _activeElement$shadow.activeElement) != null) {
    var _activeElement, _activeElement$shadow;
    activeElement2 = activeElement2.shadowRoot.activeElement;
  }
  return activeElement2;
}
function contains(parent, child) {
  if (!parent || !child) {
    return false;
  }
  const rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  }
  if (rootNode && isShadowRoot2(rootNode)) {
    let next2 = child;
    while (next2) {
      if (parent === next2) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    }
  }
  return false;
}
function getPlatform() {
  const uaData = navigator.userAgentData;
  if (uaData != null && uaData.platform) {
    return uaData.platform;
  }
  return navigator.platform;
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    return uaData.brands.map((_ref4) => {
      let {
        brand,
        version
      } = _ref4;
      return brand + "/" + version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isVirtualClick(event) {
  if (event.mozInputSource === 0 && event.isTrusted) {
    return true;
  }
  const androidRe = /Android/i;
  if ((androidRe.test(getPlatform()) || androidRe.test(getUserAgent())) && event.pointerType) {
    return event.type === "click" && event.buttons === 1;
  }
  return event.detail === 0 && !event.pointerType;
}
function isVirtualPointerEvent(event) {
  return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType !== "mouse" || // iOS VoiceOver returns 0.333 for width/height.
  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0;
}
function isSafari() {
  return /apple/i.test(navigator.vendor);
}
function isMouseLikePointerType(pointerType, strict) {
  const values = ["mouse", "pen"];
  if (!strict) {
    values.push("", void 0);
  }
  return values.includes(pointerType);
}
function isReactEvent(event) {
  return "nativeEvent" in event;
}
function isRootElement(element) {
  return element.matches("html,body");
}
function getDocument(node3) {
  return (node3 == null ? void 0 : node3.ownerDocument) || document;
}
function isEventTargetWithin(event, node3) {
  if (node3 == null) {
    return false;
  }
  if ("composedPath" in event) {
    return event.composedPath().includes(node3);
  }
  const e4 = event;
  return e4.target != null && node3.contains(e4.target);
}
function getTarget(event) {
  if ("composedPath" in event) {
    return event.composedPath()[0];
  }
  return event.target;
}
var TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function isTypeableElement(element) {
  return isHTMLElement2(element) && element.matches(TYPEABLE_SELECTOR);
}
function stopEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}

// node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var isInert = function isInert2(node3, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt = node3 === null || node3 === void 0 ? void 0 : (_node$getAttribute = node3.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node3, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result = inert || lookUp && node3 && isInert2(node3.parentNode);
  return result;
};
var isContentEditable = function isContentEditable2(node3) {
  var _node$getAttribute2;
  var attValue = node3 === null || node3 === void 0 ? void 0 : (_node$getAttribute2 = node3.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node3, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el, includeContainer, filter) {
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options2) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      continue;
    }
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content2 = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content2, true, options2);
      if (options2.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options2.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options2.getShadowRoot === "function" && options2.getShadowRoot(element);
      var validShadowRoot = !isInert(shadowRoot, false) && (!options2.shadowRootFilter || options2.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options2);
        if (options2.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var hasTabIndex = function hasTabIndex2(node3) {
  return !isNaN(parseInt(node3.getAttribute("tabindex"), 10));
};
var getTabIndex = function getTabIndex2(node3) {
  if (!node3) {
    throw new Error("No node provided");
  }
  if (node3.tabIndex < 0) {
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node3.tagName) || isContentEditable(node3)) && !hasTabIndex(node3)) {
      return 0;
    }
  }
  return node3.tabIndex;
};
var getSortOrderTabIndex = function getSortOrderTabIndex2(node3, isScope) {
  var tabIndex = getTabIndex(node3);
  if (tabIndex < 0 && isScope && !hasTabIndex(node3)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a3, b2) {
  return a3.tabIndex === b2.tabIndex ? a3.documentOrder - b2.documentOrder : a3.tabIndex - b2.tabIndex;
};
var isInput = function isInput2(node3) {
  return node3.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node3) {
  return isInput(node3) && node3.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node3) {
  var r2 = node3.tagName === "DETAILS" && Array.prototype.slice.apply(node3.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r2;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i2 = 0; i2 < nodes.length; i2++) {
    if (nodes[i2].checked && nodes[i2].form === form) {
      return nodes[i2];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node3) {
  if (!node3.name) {
    return true;
  }
  var radioScope = node3.form || getRootNode(node3);
  var queryRadios = function queryRadios2(name2) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name2 + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node3.name));
  } else {
    try {
      radioSet = queryRadios(node3.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node3.form);
  return !checked || checked === node3;
};
var isRadio = function isRadio2(node3) {
  return isInput(node3) && node3.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node3) {
  return isRadio(node3) && !isTabbableRadio(node3);
};
var isNodeAttached = function isNodeAttached2(node3) {
  var _nodeRoot;
  var nodeRoot = node3 && getRootNode(node3);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node3) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node3 !== null && node3 !== void 0 && (_node$ownerDocument = node3.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node3));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node3) {
  var _node$getBoundingClie = node3.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node3, _ref4) {
  var displayCheck = _ref4.displayCheck, getShadowRoot = _ref4.getShadowRoot;
  if (getComputedStyle(node3).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node3, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node3.parentElement : node3;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node3;
      while (node3) {
        var parentElement = node3.parentElement;
        var rootNode = getRootNode(node3);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node3);
        } else if (node3.assignedSlot) {
          node3 = node3.assignedSlot;
        } else if (!parentElement && rootNode !== node3.ownerDocument) {
          node3 = rootNode.host;
        } else {
          node3 = parentElement;
        }
      }
      node3 = originalNode;
    }
    if (isNodeAttached(node3)) {
      return !node3.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node3);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node3) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node3.tagName)) {
    var parentNode = node3.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i2 = 0; i2 < parentNode.children.length; i2++) {
          var child = parentNode.children.item(i2);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node3);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options2, node3) {
  if (node3.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node3) || isHiddenInput(node3) || isHidden(node3, options2) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node3) || isDisabledFromFieldset(node3)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options2, node3) {
  if (isNonTabbableRadio(node3) || getTabIndex(node3) < 0 || !isNodeMatchingSelectorFocusable(options2, node3)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i2) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i2,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(container, options2) {
  options2 = options2 || {};
  var candidates;
  if (options2.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options2.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options2),
      flatten: false,
      getShadowRoot: options2.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container, options2.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options2));
  }
  return sortByOrder(candidates);
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");

// node_modules/@floating-ui/react/dist/floating-ui.react.mjs
var import_react_dom3 = __toESM(require_react_dom(), 1);
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var index2 = typeof document !== "undefined" ? import_react13.useLayoutEffect : import_react13.useEffect;
var serverHandoffComplete = false;
var count = 0;
var genId = () => "floating-ui-" + count++;
function useFloatingId() {
  const [id, setId] = React10.useState(() => serverHandoffComplete ? genId() : void 0);
  index2(() => {
    if (id == null) {
      setId(genId());
    }
  }, []);
  React10.useEffect(() => {
    if (!serverHandoffComplete) {
      serverHandoffComplete = true;
    }
  }, []);
  return id;
}
var useReactId = React10["useId".toString()];
var useId = useReactId || useFloatingId;
var FloatingArrow = React10.forwardRef(function FloatingArrow2(_ref4, ref) {
  let {
    context: {
      placement,
      elements: {
        floating
      },
      middlewareData: {
        arrow: arrow5
      }
    },
    width = 14,
    height = 7,
    tipRadius = 0,
    strokeWidth = 0,
    staticOffset,
    stroke,
    d: d3,
    style: {
      transform,
      ...restStyle
    } = {},
    ...rest
  } = _ref4;
  if (true) {
    if (!ref) {
      console.warn("Floating UI: The `ref` prop is required for the `FloatingArrow`", "component.");
    }
  }
  const clipPathId = useId();
  if (!floating) {
    return null;
  }
  strokeWidth *= 2;
  const halfStrokeWidth = strokeWidth / 2;
  const svgX = width / 2 * (tipRadius / -8 + 1);
  const svgY = height / 2 * tipRadius / 4;
  const [side, alignment] = placement.split("-");
  const isRTL2 = platform.isRTL(floating);
  const isCustomShape = !!d3;
  const isVerticalSide = side === "top" || side === "bottom";
  const yOffsetProp = staticOffset && alignment === "end" ? "bottom" : "top";
  let xOffsetProp = staticOffset && alignment === "end" ? "right" : "left";
  if (staticOffset && isRTL2) {
    xOffsetProp = alignment === "end" ? "left" : "right";
  }
  const arrowX = (arrow5 == null ? void 0 : arrow5.x) != null ? staticOffset || arrow5.x : "";
  const arrowY = (arrow5 == null ? void 0 : arrow5.y) != null ? staticOffset || arrow5.y : "";
  const dValue = d3 || "M0,0" + (" H" + width) + (" L" + (width - svgX) + "," + (height - svgY)) + (" Q" + width / 2 + "," + height + " " + svgX + "," + (height - svgY)) + " Z";
  const rotation = {
    top: isCustomShape ? "rotate(180deg)" : "",
    left: isCustomShape ? "rotate(90deg)" : "rotate(-90deg)",
    bottom: isCustomShape ? "" : "rotate(180deg)",
    right: isCustomShape ? "rotate(-90deg)" : "rotate(90deg)"
  }[side];
  return React10.createElement("svg", _extends({}, rest, {
    "aria-hidden": true,
    ref,
    width: isCustomShape ? width : width + strokeWidth,
    height: width,
    viewBox: "0 0 " + width + " " + (height > width ? height : width),
    style: {
      position: "absolute",
      pointerEvents: "none",
      [xOffsetProp]: arrowX,
      [yOffsetProp]: arrowY,
      [side]: isVerticalSide || isCustomShape ? "100%" : "calc(100% - " + strokeWidth / 2 + "px)",
      transform: "" + rotation + (transform != null ? transform : ""),
      ...restStyle
    }
  }), strokeWidth > 0 && React10.createElement("path", {
    clipPath: "url(#" + clipPathId + ")",
    fill: "none",
    stroke,
    strokeWidth: strokeWidth + (d3 ? 0 : 1),
    d: dValue
  }), React10.createElement("path", {
    stroke: strokeWidth && !d3 ? rest.fill : "none",
    d: dValue
  }), React10.createElement("clipPath", {
    id: clipPathId
  }, React10.createElement("rect", {
    x: -halfStrokeWidth,
    y: halfStrokeWidth * (isCustomShape ? -1 : 1),
    width: width + strokeWidth,
    height: width
  })));
});
function createPubSub() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map.get(event)) == null ? void 0 : _map$get.forEach((handler) => handler(data));
    },
    on(event, listener) {
      map.set(event, [...map.get(event) || [], listener]);
    },
    off(event, listener) {
      var _map$get2;
      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter((l) => l !== listener)) || []);
    }
  };
}
var FloatingNodeContext = React10.createContext(null);
var FloatingTreeContext = React10.createContext(null);
var useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = React10.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
};
var useFloatingTree = () => React10.useContext(FloatingTreeContext);
function createAttribute(name2) {
  return "data-floating-ui-" + name2;
}
function useLatestRef2(value) {
  const ref = (0, import_react13.useRef)(value);
  index2(() => {
    ref.current = value;
  });
  return ref;
}
var safePolygonIdentifier = createAttribute("safe-polygon");
function getDelay(value, prop, pointerType) {
  if (pointerType && !isMouseLikePointerType(pointerType)) {
    return 0;
  }
  if (typeof value === "number") {
    return value;
  }
  return value == null ? void 0 : value[prop];
}
function useHover(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    dataRef,
    events,
    elements: {
      domReference,
      floating
    },
    refs
  } = context;
  const {
    enabled = true,
    delay = 0,
    handleClose: handleClose2 = null,
    mouseOnly = false,
    restMs = 0,
    move = true
  } = props;
  const tree = useFloatingTree();
  const parentId = useFloatingParentNodeId();
  const handleCloseRef = useLatestRef2(handleClose2);
  const delayRef = useLatestRef2(delay);
  const pointerTypeRef = React10.useRef();
  const timeoutRef = React10.useRef();
  const handlerRef = React10.useRef();
  const restTimeoutRef = React10.useRef();
  const blockMouseMoveRef = React10.useRef(true);
  const performedPointerEventsMutationRef = React10.useRef(false);
  const unbindMouseMoveRef = React10.useRef(() => {
  });
  const isHoverOpen = React10.useCallback(() => {
    var _dataRef$current$open;
    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;
    return (type == null ? void 0 : type.includes("mouse")) && type !== "mousedown";
  }, [dataRef]);
  React10.useEffect(() => {
    if (!enabled) {
      return;
    }
    function onDismiss() {
      clearTimeout(timeoutRef.current);
      clearTimeout(restTimeoutRef.current);
      blockMouseMoveRef.current = true;
    }
    events.on("dismiss", onDismiss);
    return () => {
      events.off("dismiss", onDismiss);
    };
  }, [enabled, events]);
  React10.useEffect(() => {
    if (!enabled || !handleCloseRef.current || !open) {
      return;
    }
    function onLeave(event) {
      if (isHoverOpen()) {
        onOpenChange(false, event);
      }
    }
    const html = getDocument(floating).documentElement;
    html.addEventListener("mouseleave", onLeave);
    return () => {
      html.removeEventListener("mouseleave", onLeave);
    };
  }, [floating, open, onOpenChange, enabled, handleCloseRef, dataRef, isHoverOpen]);
  const closeWithDelay = React10.useCallback(function(event, runElseBranch) {
    if (runElseBranch === void 0) {
      runElseBranch = true;
    }
    const closeDelay = getDelay(delayRef.current, "close", pointerTypeRef.current);
    if (closeDelay && !handlerRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = setTimeout(() => onOpenChange(false, event), closeDelay);
    } else if (runElseBranch) {
      clearTimeout(timeoutRef.current);
      onOpenChange(false, event);
    }
  }, [delayRef, onOpenChange]);
  const cleanupMouseMoveHandler = React10.useCallback(() => {
    unbindMouseMoveRef.current();
    handlerRef.current = void 0;
  }, []);
  const clearPointerEvents = React10.useCallback(() => {
    if (performedPointerEventsMutationRef.current) {
      const body = getDocument(refs.floating.current).body;
      body.style.pointerEvents = "";
      body.removeAttribute(safePolygonIdentifier);
      performedPointerEventsMutationRef.current = false;
    }
  }, [refs]);
  React10.useEffect(() => {
    if (!enabled) {
      return;
    }
    function isClickLikeOpenEvent() {
      return dataRef.current.openEvent ? ["click", "mousedown"].includes(dataRef.current.openEvent.type) : false;
    }
    function onMouseEnter(event) {
      clearTimeout(timeoutRef.current);
      blockMouseMoveRef.current = false;
      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, "open") === 0) {
        return;
      }
      const openDelay = getDelay(delayRef.current, "open", pointerTypeRef.current);
      if (openDelay) {
        timeoutRef.current = setTimeout(() => {
          onOpenChange(true, event);
        }, openDelay);
      } else {
        onOpenChange(true, event);
      }
    }
    function onMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        return;
      }
      unbindMouseMoveRef.current();
      const doc2 = getDocument(floating);
      clearTimeout(restTimeoutRef.current);
      if (handleCloseRef.current) {
        if (!open) {
          clearTimeout(timeoutRef.current);
        }
        handlerRef.current = handleCloseRef.current({
          ...context,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents();
            cleanupMouseMoveHandler();
            closeWithDelay(event);
          }
        });
        const handler = handlerRef.current;
        doc2.addEventListener("mousemove", handler);
        unbindMouseMoveRef.current = () => {
          doc2.removeEventListener("mousemove", handler);
        };
        return;
      }
      const shouldClose = pointerTypeRef.current === "touch" ? !contains(floating, event.relatedTarget) : true;
      if (shouldClose) {
        closeWithDelay(event);
      }
    }
    function onScrollMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        return;
      }
      handleCloseRef.current == null ? void 0 : handleCloseRef.current({
        ...context,
        tree,
        x: event.clientX,
        y: event.clientY,
        onClose() {
          clearPointerEvents();
          cleanupMouseMoveHandler();
          closeWithDelay(event);
        }
      })(event);
    }
    if (isElement2(domReference)) {
      const ref = domReference;
      open && ref.addEventListener("mouseleave", onScrollMouseLeave);
      floating == null ? void 0 : floating.addEventListener("mouseleave", onScrollMouseLeave);
      move && ref.addEventListener("mousemove", onMouseEnter, {
        once: true
      });
      ref.addEventListener("mouseenter", onMouseEnter);
      ref.addEventListener("mouseleave", onMouseLeave);
      return () => {
        open && ref.removeEventListener("mouseleave", onScrollMouseLeave);
        floating == null ? void 0 : floating.removeEventListener("mouseleave", onScrollMouseLeave);
        move && ref.removeEventListener("mousemove", onMouseEnter);
        ref.removeEventListener("mouseenter", onMouseEnter);
        ref.removeEventListener("mouseleave", onMouseLeave);
      };
    }
  }, [domReference, floating, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, tree, delayRef, handleCloseRef, dataRef]);
  index2(() => {
    var _handleCloseRef$curre;
    if (!enabled) {
      return;
    }
    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {
      const body = getDocument(floating).body;
      body.setAttribute(safePolygonIdentifier, "");
      body.style.pointerEvents = "none";
      performedPointerEventsMutationRef.current = true;
      if (isElement2(domReference) && floating) {
        var _tree$nodesRef$curren, _tree$nodesRef$curren2;
        const ref = domReference;
        const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find((node3) => node3.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.elements.floating;
        if (parentFloating) {
          parentFloating.style.pointerEvents = "";
        }
        ref.style.pointerEvents = "auto";
        floating.style.pointerEvents = "auto";
        return () => {
          ref.style.pointerEvents = "";
          floating.style.pointerEvents = "";
        };
      }
    }
  }, [enabled, open, parentId, floating, domReference, tree, handleCloseRef, dataRef, isHoverOpen]);
  index2(() => {
    if (!open) {
      pointerTypeRef.current = void 0;
      cleanupMouseMoveHandler();
      clearPointerEvents();
    }
  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);
  React10.useEffect(() => {
    return () => {
      cleanupMouseMoveHandler();
      clearTimeout(timeoutRef.current);
      clearTimeout(restTimeoutRef.current);
      clearPointerEvents();
    };
  }, [enabled, domReference, cleanupMouseMoveHandler, clearPointerEvents]);
  return React10.useMemo(() => {
    if (!enabled) {
      return {};
    }
    function setPointerRef(event) {
      pointerTypeRef.current = event.pointerType;
    }
    return {
      reference: {
        onPointerDown: setPointerRef,
        onPointerEnter: setPointerRef,
        onMouseMove(event) {
          if (open || restMs === 0) {
            return;
          }
          clearTimeout(restTimeoutRef.current);
          restTimeoutRef.current = setTimeout(() => {
            if (!blockMouseMoveRef.current) {
              onOpenChange(true, event.nativeEvent);
            }
          }, restMs);
        }
      },
      floating: {
        onMouseEnter() {
          clearTimeout(timeoutRef.current);
        },
        onMouseLeave(event) {
          events.emit("dismiss", {
            type: "mouseLeave",
            data: {
              returnFocus: false
            }
          });
          closeWithDelay(event.nativeEvent, false);
        }
      }
    };
  }, [events, enabled, restMs, open, onOpenChange, closeWithDelay]);
}
var FloatingDelayGroupContext = React10.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: () => {
  },
  setState: () => {
  },
  isInstantPhase: false
});
var rafId = 0;
function enqueueFocus(el, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    preventScroll = false,
    cancelPrevious = true,
    sync = false
  } = options2;
  cancelPrevious && cancelAnimationFrame(rafId);
  const exec = () => el == null ? void 0 : el.focus({
    preventScroll
  });
  if (sync) {
    exec();
  } else {
    rafId = requestAnimationFrame(exec);
  }
}
function getAncestors(nodes, id) {
  var _nodes$find;
  let allAncestors = [];
  let currentParentId = (_nodes$find = nodes.find((node3) => node3.id === id)) == null ? void 0 : _nodes$find.parentId;
  while (currentParentId) {
    const currentNode = nodes.find((node3) => node3.id === currentParentId);
    currentParentId = currentNode == null ? void 0 : currentNode.parentId;
    if (currentNode) {
      allAncestors = allAncestors.concat(currentNode);
    }
  }
  return allAncestors;
}
function getChildren(nodes, id) {
  let allChildren = nodes.filter((node3) => {
    var _node$context;
    return node3.parentId === id && ((_node$context = node3.context) == null ? void 0 : _node$context.open);
  });
  let currentChildren = allChildren;
  while (currentChildren.length) {
    currentChildren = nodes.filter((node3) => {
      var _currentChildren;
      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some((n) => {
        var _node$context2;
        return node3.parentId === n.id && ((_node$context2 = node3.context) == null ? void 0 : _node$context2.open);
      });
    });
    allChildren = allChildren.concat(currentChildren);
  }
  return allChildren;
}
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledElementsSet = /* @__PURE__ */ new WeakSet();
var markerMap = {};
var lockCount = 0;
var supportsInert = () => typeof HTMLElement !== "undefined" && "inert" in HTMLElement.prototype;
var unwrapHost = (node3) => node3 && (node3.host || unwrapHost(node3.parentNode));
var correctElements = (parent, targets) => targets.map((target) => {
  if (parent.contains(target)) {
    return target;
  }
  const correctedTarget = unwrapHost(target);
  if (parent.contains(correctedTarget)) {
    return correctedTarget;
  }
  return null;
}).filter((x2) => x2 != null);
function applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {
  const markerName = "data-floating-ui-inert";
  const controlAttribute = inert ? "inert" : ariaHidden ? "aria-hidden" : null;
  const avoidElements = correctElements(body, uncorrectedAvoidElements);
  const elementsToKeep = /* @__PURE__ */ new Set();
  const elementsToStop = new Set(avoidElements);
  const hiddenElements = [];
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  const markerCounter = markerMap[markerName];
  avoidElements.forEach(keep);
  deep(body);
  elementsToKeep.clear();
  function keep(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    el.parentNode && keep(el.parentNode);
  }
  function deep(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, (node3) => {
      if (elementsToKeep.has(node3)) {
        deep(node3);
      } else {
        const attr = controlAttribute ? node3.getAttribute(controlAttribute) : null;
        const alreadyHidden = attr !== null && attr !== "false";
        const counterValue = (counterMap.get(node3) || 0) + 1;
        const markerValue = (markerCounter.get(node3) || 0) + 1;
        counterMap.set(node3, counterValue);
        markerCounter.set(node3, markerValue);
        hiddenElements.push(node3);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledElementsSet.add(node3);
        }
        if (markerValue === 1) {
          node3.setAttribute(markerName, "");
        }
        if (!alreadyHidden && controlAttribute) {
          node3.setAttribute(controlAttribute, "true");
        }
      }
    });
  }
  lockCount++;
  return () => {
    hiddenElements.forEach((element) => {
      const counterValue = (counterMap.get(element) || 0) - 1;
      const markerValue = (markerCounter.get(element) || 0) - 1;
      counterMap.set(element, counterValue);
      markerCounter.set(element, markerValue);
      if (!counterValue) {
        if (!uncontrolledElementsSet.has(element) && controlAttribute) {
          element.removeAttribute(controlAttribute);
        }
        uncontrolledElementsSet.delete(element);
      }
      if (!markerValue) {
        element.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledElementsSet = /* @__PURE__ */ new WeakSet();
      markerMap = {};
    }
  };
}
function markOthers(avoidElements, ariaHidden, inert) {
  if (ariaHidden === void 0) {
    ariaHidden = false;
  }
  if (inert === void 0) {
    inert = false;
  }
  const body = getDocument(avoidElements[0]).body;
  return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll("[aria-live]"))), body, ariaHidden, inert);
}
var getTabbableOptions = () => ({
  getShadowRoot: true,
  displayCheck: (
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver === "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
  )
});
function getTabbableIn(container, direction) {
  const allTabbable = tabbable(container, getTabbableOptions());
  if (direction === "prev") {
    allTabbable.reverse();
  }
  const activeIndex = allTabbable.indexOf(activeElement(getDocument(container)));
  const nextTabbableElements = allTabbable.slice(activeIndex + 1);
  return nextTabbableElements[0];
}
function getNextTabbable() {
  return getTabbableIn(document.body, "next");
}
function getPreviousTabbable() {
  return getTabbableIn(document.body, "prev");
}
function isOutsideEvent(event, container) {
  const containerElement = container || event.currentTarget;
  const relatedTarget = event.relatedTarget;
  return !relatedTarget || !contains(containerElement, relatedTarget);
}
function disableFocusInside(container) {
  const tabbableElements = tabbable(container, getTabbableOptions());
  tabbableElements.forEach((element) => {
    element.dataset.tabindex = element.getAttribute("tabindex") || "";
    element.setAttribute("tabindex", "-1");
  });
}
function enableFocusInside(container) {
  const elements = container.querySelectorAll("[data-tabindex]");
  elements.forEach((element) => {
    const tabindex = element.dataset.tabindex;
    delete element.dataset.tabindex;
    if (tabindex) {
      element.setAttribute("tabindex", tabindex);
    } else {
      element.removeAttribute("tabindex");
    }
  });
}
var HIDDEN_STYLES = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
var timeoutId;
function setActiveElementOnTab(event) {
  if (event.key === "Tab") {
    event.target;
    clearTimeout(timeoutId);
  }
}
var FocusGuard = React10.forwardRef(function FocusGuard2(props, ref) {
  const [role, setRole] = React10.useState();
  index2(() => {
    if (isSafari()) {
      setRole("button");
    }
    document.addEventListener("keydown", setActiveElementOnTab);
    return () => {
      document.removeEventListener("keydown", setActiveElementOnTab);
    };
  }, []);
  const restProps = {
    ref,
    tabIndex: 0,
    // Role is only for VoiceOver
    role,
    "aria-hidden": role ? void 0 : true,
    [createAttribute("focus-guard")]: "",
    style: HIDDEN_STYLES
  };
  return React10.createElement("span", _extends({}, props, restProps));
});
var PortalContext = React10.createContext(null);
function useFloatingPortalNode(_temp) {
  let {
    id,
    root
  } = _temp === void 0 ? {} : _temp;
  const [portalNode, setPortalNode] = React10.useState(null);
  const uniqueId = useId();
  const portalContext = usePortalContext();
  const data = React10.useMemo(() => ({
    id,
    root,
    portalContext,
    uniqueId
  }), [id, root, portalContext, uniqueId]);
  const dataRef = React10.useRef();
  index2(() => {
    return () => {
      portalNode == null ? void 0 : portalNode.remove();
    };
  }, [portalNode, data]);
  index2(() => {
    if (dataRef.current === data)
      return;
    dataRef.current = data;
    const {
      id: id2,
      root: root2,
      portalContext: portalContext2,
      uniqueId: uniqueId2
    } = data;
    const existingIdRoot = id2 ? document.getElementById(id2) : null;
    const attr = createAttribute("portal");
    if (existingIdRoot) {
      const subRoot = document.createElement("div");
      subRoot.id = uniqueId2;
      subRoot.setAttribute(attr, "");
      existingIdRoot.appendChild(subRoot);
      setPortalNode(subRoot);
    } else {
      let container = root2 || (portalContext2 == null ? void 0 : portalContext2.portalNode);
      if (container && !isElement2(container))
        container = container.current;
      container = container || document.body;
      let idWrapper = null;
      if (id2) {
        idWrapper = document.createElement("div");
        idWrapper.id = id2;
        container.appendChild(idWrapper);
      }
      const subRoot = document.createElement("div");
      subRoot.id = uniqueId2;
      subRoot.setAttribute(attr, "");
      container = idWrapper || container;
      container.appendChild(subRoot);
      setPortalNode(subRoot);
    }
  }, [data]);
  return portalNode;
}
function FloatingPortal(_ref4) {
  let {
    children,
    id,
    root = null,
    preserveTabOrder = true
  } = _ref4;
  const portalNode = useFloatingPortalNode({
    id,
    root
  });
  const [focusManagerState, setFocusManagerState] = React10.useState(null);
  const beforeOutsideRef = React10.useRef(null);
  const afterOutsideRef = React10.useRef(null);
  const beforeInsideRef = React10.useRef(null);
  const afterInsideRef = React10.useRef(null);
  const shouldRenderGuards = (
    // The FocusManager and therefore floating element are currently open/
    // rendered.
    !!focusManagerState && // Guards are only for non-modal focus management.
    !focusManagerState.modal && // Don't render if unmount is transitioning.
    focusManagerState.open && preserveTabOrder && !!(root || portalNode)
  );
  React10.useEffect(() => {
    if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {
      return;
    }
    function onFocus4(event) {
      if (portalNode && isOutsideEvent(event)) {
        const focusing = event.type === "focusin";
        const manageFocus = focusing ? enableFocusInside : disableFocusInside;
        manageFocus(portalNode);
      }
    }
    portalNode.addEventListener("focusin", onFocus4, true);
    portalNode.addEventListener("focusout", onFocus4, true);
    return () => {
      portalNode.removeEventListener("focusin", onFocus4, true);
      portalNode.removeEventListener("focusout", onFocus4, true);
    };
  }, [portalNode, preserveTabOrder, focusManagerState == null ? void 0 : focusManagerState.modal]);
  return React10.createElement(PortalContext.Provider, {
    value: React10.useMemo(() => ({
      preserveTabOrder,
      beforeOutsideRef,
      afterOutsideRef,
      beforeInsideRef,
      afterInsideRef,
      portalNode,
      setFocusManagerState
    }), [preserveTabOrder, portalNode])
  }, shouldRenderGuards && portalNode && React10.createElement(FocusGuard, {
    "data-type": "outside",
    ref: beforeOutsideRef,
    onFocus: (event) => {
      if (isOutsideEvent(event, portalNode)) {
        var _beforeInsideRef$curr;
        (_beforeInsideRef$curr = beforeInsideRef.current) == null ? void 0 : _beforeInsideRef$curr.focus();
      } else {
        const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);
        prevTabbable == null ? void 0 : prevTabbable.focus();
      }
    }
  }), shouldRenderGuards && portalNode && React10.createElement("span", {
    "aria-owns": portalNode.id,
    style: HIDDEN_STYLES
  }), portalNode && (0, import_react_dom3.createPortal)(children, portalNode), shouldRenderGuards && portalNode && React10.createElement(FocusGuard, {
    "data-type": "outside",
    ref: afterOutsideRef,
    onFocus: (event) => {
      if (isOutsideEvent(event, portalNode)) {
        var _afterInsideRef$curre;
        (_afterInsideRef$curre = afterInsideRef.current) == null ? void 0 : _afterInsideRef$curre.focus();
      } else {
        const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);
        nextTabbable == null ? void 0 : nextTabbable.focus();
        (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent));
      }
    }
  }));
}
var usePortalContext = () => React10.useContext(PortalContext);
var VisuallyHiddenDismiss = React10.forwardRef(function VisuallyHiddenDismiss2(props, ref) {
  return React10.createElement("button", _extends({}, props, {
    type: "button",
    ref,
    tabIndex: -1,
    style: HIDDEN_STYLES
  }));
});
function FloatingFocusManager(props) {
  const {
    context,
    children,
    disabled = false,
    order: order2 = ["content"],
    guards: _guards = true,
    initialFocus = 0,
    returnFocus = true,
    modal = true,
    visuallyHiddenDismiss = false,
    closeOnFocusOut = true
  } = props;
  const {
    open,
    refs,
    nodeId,
    onOpenChange,
    events,
    dataRef,
    elements: {
      domReference,
      floating
    }
  } = context;
  const guards = supportsInert() ? _guards : true;
  const orderRef = useLatestRef2(order2);
  const initialFocusRef = useLatestRef2(initialFocus);
  const returnFocusRef = useLatestRef2(returnFocus);
  const tree = useFloatingTree();
  const portalContext = usePortalContext();
  const ignoreInitialFocus = typeof initialFocus === "number" && initialFocus < 0;
  const startDismissButtonRef = React10.useRef(null);
  const endDismissButtonRef = React10.useRef(null);
  const preventReturnFocusRef = React10.useRef(false);
  const previouslyFocusedElementRef = React10.useRef(null);
  const isPointerDownRef = React10.useRef(false);
  const isInsidePortal = portalContext != null;
  const isTypeableCombobox = domReference && domReference.getAttribute("role") === "combobox" && isTypeableElement(domReference);
  const getTabbableContent = React10.useCallback(function(container) {
    if (container === void 0) {
      container = floating;
    }
    return container ? tabbable(container, getTabbableOptions()) : [];
  }, [floating]);
  const getTabbableElements = React10.useCallback((container) => {
    const content2 = getTabbableContent(container);
    return orderRef.current.map((type) => {
      if (domReference && type === "reference") {
        return domReference;
      }
      if (floating && type === "floating") {
        return floating;
      }
      return content2;
    }).filter(Boolean).flat();
  }, [domReference, floating, orderRef, getTabbableContent]);
  React10.useEffect(() => {
    if (disabled || !modal)
      return;
    function onKeyDown(event) {
      if (event.key === "Tab") {
        if (contains(floating, activeElement(getDocument(floating))) && getTabbableContent().length === 0 && !isTypeableCombobox) {
          stopEvent(event);
        }
        const els = getTabbableElements();
        const target = getTarget(event);
        if (orderRef.current[0] === "reference" && target === domReference) {
          stopEvent(event);
          if (event.shiftKey) {
            enqueueFocus(els[els.length - 1]);
          } else {
            enqueueFocus(els[1]);
          }
        }
        if (orderRef.current[1] === "floating" && target === floating && event.shiftKey) {
          stopEvent(event);
          enqueueFocus(els[0]);
        }
      }
    }
    const doc2 = getDocument(floating);
    doc2.addEventListener("keydown", onKeyDown);
    return () => {
      doc2.removeEventListener("keydown", onKeyDown);
    };
  }, [disabled, domReference, floating, modal, orderRef, refs, isTypeableCombobox, getTabbableContent, getTabbableElements]);
  React10.useEffect(() => {
    if (disabled || !closeOnFocusOut)
      return;
    function handlePointerDown() {
      isPointerDownRef.current = true;
      setTimeout(() => {
        isPointerDownRef.current = false;
      });
    }
    function handleFocusOutside(event) {
      const relatedTarget = event.relatedTarget;
      queueMicrotask(() => {
        const movedToUnrelatedNode = !(contains(domReference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute("focus-guard")) || tree && (getChildren(tree.nodesRef.current, nodeId).find((node3) => {
          var _node$context, _node$context2;
          return contains((_node$context = node3.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || contains((_node$context2 = node3.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);
        }) || getAncestors(tree.nodesRef.current, nodeId).find((node3) => {
          var _node$context3, _node$context4;
          return ((_node$context3 = node3.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node3.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;
        })));
        if (relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current && // Fix React 18 Strict Mode returnFocus due to double rendering.
        relatedTarget !== previouslyFocusedElementRef.current) {
          preventReturnFocusRef.current = true;
          onOpenChange(false, event);
        }
      });
    }
    if (floating && isHTMLElement2(domReference)) {
      domReference.addEventListener("focusout", handleFocusOutside);
      domReference.addEventListener("pointerdown", handlePointerDown);
      !modal && floating.addEventListener("focusout", handleFocusOutside);
      return () => {
        domReference.removeEventListener("focusout", handleFocusOutside);
        domReference.removeEventListener("pointerdown", handlePointerDown);
        !modal && floating.removeEventListener("focusout", handleFocusOutside);
      };
    }
  }, [disabled, domReference, floating, modal, nodeId, tree, portalContext, onOpenChange, closeOnFocusOut]);
  React10.useEffect(() => {
    var _portalContext$portal;
    if (disabled)
      return;
    const portalNodes = Array.from((portalContext == null ? void 0 : (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll("[" + createAttribute("portal") + "]")) || []);
    if (floating) {
      const insideElements = [floating, ...portalNodes, startDismissButtonRef.current, endDismissButtonRef.current, orderRef.current.includes("reference") || isTypeableCombobox ? domReference : null].filter((x2) => x2 != null);
      const cleanup = modal ? markOthers(insideElements, guards, !guards) : markOthers(insideElements);
      return () => {
        cleanup();
      };
    }
  }, [disabled, domReference, floating, modal, orderRef, portalContext, isTypeableCombobox, guards]);
  index2(() => {
    if (disabled || !floating)
      return;
    const doc2 = getDocument(floating);
    const previouslyFocusedElement = activeElement(doc2);
    queueMicrotask(() => {
      const focusableElements = getTabbableElements(floating);
      const initialFocusValue = initialFocusRef.current;
      const elToFocus = (typeof initialFocusValue === "number" ? focusableElements[initialFocusValue] : initialFocusValue.current) || floating;
      const focusAlreadyInsideFloatingEl = contains(floating, previouslyFocusedElement);
      if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {
        enqueueFocus(elToFocus, {
          preventScroll: elToFocus === floating
        });
      }
    });
  }, [disabled, open, floating, ignoreInitialFocus, getTabbableElements, initialFocusRef]);
  index2(() => {
    if (disabled || !floating)
      return;
    let preventReturnFocusScroll = false;
    const doc2 = getDocument(floating);
    const previouslyFocusedElement = activeElement(doc2);
    const contextData = dataRef.current;
    previouslyFocusedElementRef.current = previouslyFocusedElement;
    function onDismiss(payload) {
      if (payload.type === "escapeKey" && refs.domReference.current) {
        previouslyFocusedElementRef.current = refs.domReference.current;
      }
      if (["referencePress", "escapeKey"].includes(payload.type)) {
        return;
      }
      const returnFocus2 = payload.data.returnFocus;
      if (typeof returnFocus2 === "object") {
        preventReturnFocusRef.current = false;
        preventReturnFocusScroll = returnFocus2.preventScroll;
      } else {
        preventReturnFocusRef.current = !returnFocus2;
      }
    }
    events.on("dismiss", onDismiss);
    return () => {
      events.off("dismiss", onDismiss);
      const activeEl = activeElement(doc2);
      const shouldFocusReference = contains(floating, activeEl) || tree && getChildren(tree.nodesRef.current, nodeId).some((node3) => {
        var _node$context5;
        return contains((_node$context5 = node3.context) == null ? void 0 : _node$context5.elements.floating, activeEl);
      }) || contextData.openEvent && ["click", "mousedown"].includes(contextData.openEvent.type);
      if (shouldFocusReference && refs.domReference.current) {
        previouslyFocusedElementRef.current = refs.domReference.current;
      }
      if (
        // eslint-disable-next-line react-hooks/exhaustive-deps
        returnFocusRef.current && isHTMLElement2(previouslyFocusedElementRef.current) && !preventReturnFocusRef.current
      ) {
        enqueueFocus(previouslyFocusedElementRef.current, {
          // When dismissing nested floating elements, by the time the rAF has
          // executed, the menus will all have been unmounted. When they try
          // to get focused, the calls get ignored  leaving the root
          // reference focused as desired.
          cancelPrevious: false,
          preventScroll: preventReturnFocusScroll
        });
      }
    };
  }, [disabled, floating, returnFocusRef, dataRef, refs, events, tree, nodeId]);
  index2(() => {
    if (disabled || !portalContext)
      return;
    portalContext.setFocusManagerState({
      modal,
      closeOnFocusOut,
      open,
      onOpenChange,
      refs
    });
    return () => {
      portalContext.setFocusManagerState(null);
    };
  }, [disabled, portalContext, modal, open, onOpenChange, refs, closeOnFocusOut]);
  index2(() => {
    if (disabled)
      return;
    if (floating && typeof MutationObserver === "function") {
      const handleMutation = () => {
        const tabIndex = floating.getAttribute("tabindex");
        if (orderRef.current.includes("floating") || activeElement(getDocument(floating)) !== refs.domReference.current && getTabbableContent().length === 0) {
          if (tabIndex !== "0") {
            floating.setAttribute("tabindex", "0");
          }
        } else if (tabIndex !== "-1") {
          floating.setAttribute("tabindex", "-1");
        }
      };
      handleMutation();
      const observer = new MutationObserver(handleMutation);
      observer.observe(floating, {
        childList: true,
        subtree: true,
        attributes: true
      });
      return () => {
        observer.disconnect();
      };
    }
  }, [disabled, floating, refs, orderRef, getTabbableContent]);
  function renderDismissButton(location) {
    if (disabled || !visuallyHiddenDismiss || !modal) {
      return null;
    }
    return React10.createElement(VisuallyHiddenDismiss, {
      ref: location === "start" ? startDismissButtonRef : endDismissButtonRef,
      onClick: (event) => onOpenChange(false, event.nativeEvent)
    }, typeof visuallyHiddenDismiss === "string" ? visuallyHiddenDismiss : "Dismiss");
  }
  const shouldRenderGuards = !disabled && guards && !isTypeableCombobox && (isInsidePortal || modal);
  return React10.createElement(React10.Fragment, null, shouldRenderGuards && React10.createElement(FocusGuard, {
    "data-type": "inside",
    ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,
    onFocus: (event) => {
      if (modal) {
        const els = getTabbableElements();
        enqueueFocus(order2[0] === "reference" ? els[0] : els[els.length - 1]);
      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {
        preventReturnFocusRef.current = false;
        if (isOutsideEvent(event, portalContext.portalNode)) {
          const nextTabbable = getNextTabbable() || domReference;
          nextTabbable == null ? void 0 : nextTabbable.focus();
        } else {
          var _portalContext$before;
          (_portalContext$before = portalContext.beforeOutsideRef.current) == null ? void 0 : _portalContext$before.focus();
        }
      }
    }
  }), !isTypeableCombobox && renderDismissButton("start"), children, renderDismissButton("end"), shouldRenderGuards && React10.createElement(FocusGuard, {
    "data-type": "inside",
    ref: portalContext == null ? void 0 : portalContext.afterInsideRef,
    onFocus: (event) => {
      if (modal) {
        enqueueFocus(getTabbableElements()[0]);
      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {
        if (closeOnFocusOut) {
          preventReturnFocusRef.current = true;
        }
        if (isOutsideEvent(event, portalContext.portalNode)) {
          const prevTabbable = getPreviousTabbable() || domReference;
          prevTabbable == null ? void 0 : prevTabbable.focus();
        } else {
          var _portalContext$afterO;
          (_portalContext$afterO = portalContext.afterOutsideRef.current) == null ? void 0 : _portalContext$afterO.focus();
        }
      }
    }
  }));
}
var FloatingListContext = React10.createContext({
  register: () => {
  },
  unregister: () => {
  },
  map: /* @__PURE__ */ new Map(),
  elementsRef: {
    current: []
  }
});
var identifier = createAttribute("scroll-lock");
var FloatingOverlay = React10.forwardRef(function FloatingOverlay2(_ref4, ref) {
  let {
    lockScroll = false,
    ...rest
  } = _ref4;
  index2(() => {
    var _window$visualViewpor, _window$visualViewpor2;
    if (!lockScroll) {
      return;
    }
    const alreadyLocked = document.body.hasAttribute(identifier);
    if (alreadyLocked) {
      return;
    }
    document.body.setAttribute(identifier, "");
    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;
    const paddingProp = scrollbarX ? "paddingLeft" : "paddingRight";
    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    if (!/iP(hone|ad|od)|iOS/.test(getPlatform())) {
      Object.assign(document.body.style, {
        overflow: "hidden",
        [paddingProp]: scrollbarWidth + "px"
      });
      return () => {
        document.body.removeAttribute(identifier);
        Object.assign(document.body.style, {
          overflow: "",
          [paddingProp]: ""
        });
      };
    }
    const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;
    const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;
    const scrollX = window.pageXOffset;
    const scrollY = window.pageYOffset;
    Object.assign(document.body.style, {
      position: "fixed",
      overflow: "hidden",
      top: -(scrollY - Math.floor(offsetTop)) + "px",
      left: -(scrollX - Math.floor(offsetLeft)) + "px",
      right: "0",
      [paddingProp]: scrollbarWidth + "px"
    });
    return () => {
      Object.assign(document.body.style, {
        position: "",
        overflow: "",
        top: "",
        left: "",
        right: "",
        [paddingProp]: ""
      });
      document.body.removeAttribute(identifier);
      window.scrollTo(scrollX, scrollY);
    };
  }, [lockScroll]);
  return React10.createElement("div", _extends({
    ref
  }, rest, {
    style: {
      position: "fixed",
      overflow: "auto",
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...rest.style
    }
  }));
});
function isButtonTarget(event) {
  return isHTMLElement2(event.target) && event.target.tagName === "BUTTON";
}
function isSpaceIgnored(element) {
  return isTypeableElement(element);
}
function useClick(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    dataRef,
    elements: {
      domReference
    }
  } = context;
  const {
    enabled = true,
    event: eventOption = "click",
    toggle = true,
    ignoreMouse = false,
    keyboardHandlers = true
  } = props;
  const pointerTypeRef = React10.useRef();
  const didKeyDownRef = React10.useRef(false);
  return React10.useMemo(() => {
    if (!enabled)
      return {};
    return {
      reference: {
        onPointerDown(event) {
          pointerTypeRef.current = event.pointerType;
        },
        onMouseDown(event) {
          if (event.button !== 0) {
            return;
          }
          if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {
            return;
          }
          if (eventOption === "click") {
            return;
          }
          if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === "mousedown" : true)) {
            onOpenChange(false, event.nativeEvent);
          } else {
            event.preventDefault();
            onOpenChange(true, event.nativeEvent);
          }
        },
        onClick(event) {
          if (eventOption === "mousedown" && pointerTypeRef.current) {
            pointerTypeRef.current = void 0;
            return;
          }
          if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {
            return;
          }
          if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === "click" : true)) {
            onOpenChange(false, event.nativeEvent);
          } else {
            onOpenChange(true, event.nativeEvent);
          }
        },
        onKeyDown(event) {
          pointerTypeRef.current = void 0;
          if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {
            return;
          }
          if (event.key === " " && !isSpaceIgnored(domReference)) {
            event.preventDefault();
            didKeyDownRef.current = true;
          }
          if (event.key === "Enter") {
            if (open && toggle) {
              onOpenChange(false, event.nativeEvent);
            } else {
              onOpenChange(true, event.nativeEvent);
            }
          }
        },
        onKeyUp(event) {
          if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {
            return;
          }
          if (event.key === " " && didKeyDownRef.current) {
            didKeyDownRef.current = false;
            if (open && toggle) {
              onOpenChange(false, event.nativeEvent);
            } else {
              onOpenChange(true, event.nativeEvent);
            }
          }
        }
      }
    };
  }, [enabled, dataRef, eventOption, ignoreMouse, keyboardHandlers, domReference, toggle, open, onOpenChange]);
}
var useInsertionEffect = React10["useInsertionEffect".toString()];
var useSafeInsertionEffect = useInsertionEffect || ((fn2) => fn2());
function useEffectEvent(callback) {
  const ref = React10.useRef(() => {
    if (true) {
      throw new Error("Cannot call an event handler while rendering.");
    }
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return React10.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
var bubbleHandlerKeys = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
};
var captureHandlerKeys = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
};
var normalizeBubblesProp = (bubbles) => {
  var _bubbles$escapeKey, _bubbles$outsidePress;
  return {
    escapeKeyBubbles: typeof bubbles === "boolean" ? bubbles : (_bubbles$escapeKey = bubbles == null ? void 0 : bubbles.escapeKey) != null ? _bubbles$escapeKey : false,
    outsidePressBubbles: typeof bubbles === "boolean" ? bubbles : (_bubbles$outsidePress = bubbles == null ? void 0 : bubbles.outsidePress) != null ? _bubbles$outsidePress : true
  };
};
function useDismiss(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    events,
    nodeId,
    elements: {
      reference: reference2,
      domReference,
      floating
    },
    dataRef
  } = context;
  const {
    enabled = true,
    escapeKey = true,
    outsidePress: unstable_outsidePress = true,
    outsidePressEvent = "pointerdown",
    referencePress = false,
    referencePressEvent = "pointerdown",
    ancestorScroll = false,
    bubbles
  } = props;
  const tree = useFloatingTree();
  const nested = useFloatingParentNodeId() != null;
  const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === "function" ? unstable_outsidePress : () => false);
  const outsidePress = typeof unstable_outsidePress === "function" ? outsidePressFn : unstable_outsidePress;
  const insideReactTreeRef = React10.useRef(false);
  const {
    escapeKeyBubbles,
    outsidePressBubbles
  } = normalizeBubblesProp(bubbles);
  const closeOnEscapeKeyDown = useEffectEvent((event) => {
    if (!open || !enabled || !escapeKey || event.key !== "Escape") {
      return;
    }
    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
    if (!escapeKeyBubbles) {
      event.stopPropagation();
      if (children.length > 0) {
        let shouldDismiss = true;
        children.forEach((child) => {
          var _child$context;
          if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {
            shouldDismiss = false;
            return;
          }
        });
        if (!shouldDismiss) {
          return;
        }
      }
    }
    events.emit("dismiss", {
      type: "escapeKey",
      data: {
        returnFocus: {
          preventScroll: false
        }
      }
    });
    onOpenChange(false, isReactEvent(event) ? event.nativeEvent : event);
  });
  const closeOnPressOutside = useEffectEvent((event) => {
    const insideReactTree = insideReactTreeRef.current;
    insideReactTreeRef.current = false;
    if (insideReactTree) {
      return;
    }
    if (typeof outsidePress === "function" && !outsidePress(event)) {
      return;
    }
    const target = getTarget(event);
    const inertSelector = "[" + createAttribute("inert") + "]";
    const markers = getDocument(floating).querySelectorAll(inertSelector);
    let targetRootAncestor = isElement2(target) ? target : null;
    while (targetRootAncestor && !isLastTraversableNode2(targetRootAncestor)) {
      const nextParent = getParentNode2(targetRootAncestor);
      if (nextParent === getDocument(floating).body || !isElement2(nextParent)) {
        break;
      } else {
        targetRootAncestor = nextParent;
      }
    }
    if (markers.length && isElement2(target) && !isRootElement(target) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !contains(target, floating) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(markers).every((marker) => !contains(targetRootAncestor, marker))) {
      return;
    }
    if (isHTMLElement2(target) && floating) {
      const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;
      const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;
      let xCond = canScrollY && event.offsetX > target.clientWidth;
      if (canScrollY) {
        const isRTL2 = getComputedStyle3(target).direction === "rtl";
        if (isRTL2) {
          xCond = event.offsetX <= target.offsetWidth - target.clientWidth;
        }
      }
      if (xCond || canScrollX && event.offsetY > target.clientHeight) {
        return;
      }
    }
    const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some((node3) => {
      var _node$context;
      return isEventTargetWithin(event, (_node$context = node3.context) == null ? void 0 : _node$context.elements.floating);
    });
    if (isEventTargetWithin(event, floating) || isEventTargetWithin(event, domReference) || targetIsInsideChildren) {
      return;
    }
    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];
    if (children.length > 0) {
      let shouldDismiss = true;
      children.forEach((child) => {
        var _child$context2;
        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {
          shouldDismiss = false;
          return;
        }
      });
      if (!shouldDismiss) {
        return;
      }
    }
    events.emit("dismiss", {
      type: "outsidePress",
      data: {
        returnFocus: nested ? {
          preventScroll: true
        } : isVirtualClick(event) || isVirtualPointerEvent(event)
      }
    });
    onOpenChange(false, event);
  });
  React10.useEffect(() => {
    if (!open || !enabled) {
      return;
    }
    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;
    dataRef.current.__outsidePressBubbles = outsidePressBubbles;
    function onScroll(event) {
      onOpenChange(false, event);
    }
    const doc2 = getDocument(floating);
    escapeKey && doc2.addEventListener("keydown", closeOnEscapeKeyDown);
    outsidePress && doc2.addEventListener(outsidePressEvent, closeOnPressOutside);
    let ancestors = [];
    if (ancestorScroll) {
      if (isElement2(domReference)) {
        ancestors = getOverflowAncestors(domReference);
      }
      if (isElement2(floating)) {
        ancestors = ancestors.concat(getOverflowAncestors(floating));
      }
      if (!isElement2(reference2) && reference2 && reference2.contextElement) {
        ancestors = ancestors.concat(getOverflowAncestors(reference2.contextElement));
      }
    }
    ancestors = ancestors.filter((ancestor) => {
      var _doc$defaultView;
      return ancestor !== ((_doc$defaultView = doc2.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);
    });
    ancestors.forEach((ancestor) => {
      ancestor.addEventListener("scroll", onScroll, {
        passive: true
      });
    });
    return () => {
      escapeKey && doc2.removeEventListener("keydown", closeOnEscapeKeyDown);
      outsidePress && doc2.removeEventListener(outsidePressEvent, closeOnPressOutside);
      ancestors.forEach((ancestor) => {
        ancestor.removeEventListener("scroll", onScroll);
      });
    };
  }, [dataRef, floating, domReference, reference2, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, closeOnPressOutside]);
  React10.useEffect(() => {
    insideReactTreeRef.current = false;
  }, [outsidePress, outsidePressEvent]);
  return React10.useMemo(() => {
    if (!enabled) {
      return {};
    }
    return {
      reference: {
        onKeyDown: closeOnEscapeKeyDown,
        [bubbleHandlerKeys[referencePressEvent]]: (event) => {
          if (referencePress) {
            events.emit("dismiss", {
              type: "referencePress",
              data: {
                returnFocus: false
              }
            });
            onOpenChange(false, event.nativeEvent);
          }
        }
      },
      floating: {
        onKeyDown: closeOnEscapeKeyDown,
        [captureHandlerKeys[outsidePressEvent]]: () => {
          insideReactTreeRef.current = true;
        }
      }
    };
  }, [enabled, events, referencePress, outsidePressEvent, referencePressEvent, onOpenChange, closeOnEscapeKeyDown]);
}
var devMessageSet;
if (true) {
  devMessageSet = /* @__PURE__ */ new Set();
}
function useFloating2(options2) {
  var _options$elements2;
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    open = false,
    onOpenChange: unstable_onOpenChange,
    nodeId
  } = options2;
  if (true) {
    var _options$elements;
    const err = "Floating UI: Cannot pass a virtual element to the `elements.reference` option, as it must be a real DOM element. Use `refs.setPositionReference` instead.";
    if ((_options$elements = options2.elements) != null && _options$elements.reference && !isElement2(options2.elements.reference)) {
      var _devMessageSet;
      if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(err))) {
        var _devMessageSet2;
        (_devMessageSet2 = devMessageSet) == null ? void 0 : _devMessageSet2.add(err);
        console.error(err);
      }
    }
  }
  const [_domReference, setDomReference] = React10.useState(null);
  const domReference = ((_options$elements2 = options2.elements) == null ? void 0 : _options$elements2.reference) || _domReference;
  const position2 = useFloating(options2);
  const tree = useFloatingTree();
  const onOpenChange = useEffectEvent((open2, event) => {
    if (open2) {
      dataRef.current.openEvent = event;
    }
    unstable_onOpenChange == null ? void 0 : unstable_onOpenChange(open2, event);
  });
  const domReferenceRef = React10.useRef(null);
  const dataRef = React10.useRef({});
  const events = React10.useState(() => createPubSub())[0];
  const floatingId = useId();
  const setPositionReference = React10.useCallback((node3) => {
    const positionReference = isElement2(node3) ? {
      getBoundingClientRect: () => node3.getBoundingClientRect(),
      contextElement: node3
    } : node3;
    position2.refs.setReference(positionReference);
  }, [position2.refs]);
  const setReference = React10.useCallback((node3) => {
    if (isElement2(node3) || node3 === null) {
      domReferenceRef.current = node3;
      setDomReference(node3);
    }
    if (isElement2(position2.refs.reference.current) || position2.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node3 !== null && !isElement2(node3)) {
      position2.refs.setReference(node3);
    }
  }, [position2.refs]);
  const refs = React10.useMemo(() => ({
    ...position2.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position2.refs, setReference, setPositionReference]);
  const elements = React10.useMemo(() => ({
    ...position2.elements,
    domReference
  }), [position2.elements, domReference]);
  const context = React10.useMemo(() => ({
    ...position2,
    refs,
    elements,
    dataRef,
    nodeId,
    floatingId,
    events,
    open,
    onOpenChange
  }), [position2, nodeId, floatingId, events, open, onOpenChange, refs, elements]);
  index2(() => {
    const node3 = tree == null ? void 0 : tree.nodesRef.current.find((node4) => node4.id === nodeId);
    if (node3) {
      node3.context = context;
    }
  });
  return React10.useMemo(() => ({
    ...position2,
    context,
    refs,
    elements
  }), [position2, refs, elements, context]);
}
function useFocus(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    onOpenChange,
    dataRef,
    events,
    refs,
    elements: {
      floating,
      domReference
    }
  } = context;
  const {
    enabled = true,
    keyboardOnly = true
  } = props;
  const pointerTypeRef = React10.useRef("");
  const blockFocusRef = React10.useRef(false);
  const timeoutRef = React10.useRef();
  React10.useEffect(() => {
    if (!enabled) {
      return;
    }
    const doc2 = getDocument(floating);
    const win = doc2.defaultView || window;
    function onBlur3() {
      if (!open && isHTMLElement2(domReference) && domReference === activeElement(getDocument(domReference))) {
        blockFocusRef.current = true;
      }
    }
    win.addEventListener("blur", onBlur3);
    return () => {
      win.removeEventListener("blur", onBlur3);
    };
  }, [floating, domReference, open, enabled]);
  React10.useEffect(() => {
    if (!enabled) {
      return;
    }
    function onDismiss(payload) {
      if (payload.type === "referencePress" || payload.type === "escapeKey") {
        blockFocusRef.current = true;
      }
    }
    events.on("dismiss", onDismiss);
    return () => {
      events.off("dismiss", onDismiss);
    };
  }, [events, enabled]);
  React10.useEffect(() => {
    return () => {
      clearTimeout(timeoutRef.current);
    };
  }, []);
  return React10.useMemo(() => {
    if (!enabled) {
      return {};
    }
    return {
      reference: {
        onPointerDown(_ref4) {
          let {
            pointerType
          } = _ref4;
          pointerTypeRef.current = pointerType;
          blockFocusRef.current = !!(pointerType && keyboardOnly);
        },
        onMouseLeave() {
          blockFocusRef.current = false;
        },
        onFocus(event) {
          var _dataRef$current$open;
          if (blockFocusRef.current) {
            return;
          }
          if (event.type === "focus" && ((_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type) === "mousedown" && isEventTargetWithin(dataRef.current.openEvent, domReference)) {
            return;
          }
          onOpenChange(true, event.nativeEvent);
        },
        onBlur(event) {
          blockFocusRef.current = false;
          const relatedTarget = event.relatedTarget;
          const movedToFocusGuard = isElement2(relatedTarget) && relatedTarget.hasAttribute(createAttribute("focus-guard")) && relatedTarget.getAttribute("data-type") === "outside";
          timeoutRef.current = setTimeout(() => {
            if (contains(refs.floating.current, relatedTarget) || contains(domReference, relatedTarget) || movedToFocusGuard) {
              return;
            }
            onOpenChange(false, event.nativeEvent);
          });
        }
      }
    };
  }, [enabled, keyboardOnly, domReference, refs, dataRef, onOpenChange]);
}
function mergeProps(userProps, propsList, elementKey) {
  const map = /* @__PURE__ */ new Map();
  return {
    ...elementKey === "floating" && {
      tabIndex: -1
    },
    ...userProps,
    ...propsList.map((value) => value ? value[elementKey] : null).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach((_ref4) => {
        let [key, value] = _ref4;
        if (key.indexOf("on") === 0) {
          if (!map.has(key)) {
            map.set(key, []);
          }
          if (typeof value === "function") {
            var _map$get;
            (_map$get = map.get(key)) == null ? void 0 : _map$get.push(value);
            acc[key] = function() {
              var _map$get2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn2) => fn2(...args)).find((val) => val !== void 0);
            };
          }
        } else {
          acc[key] = value;
        }
      });
      return acc;
    }, {})
  };
}
function useInteractions(propsList) {
  if (propsList === void 0) {
    propsList = [];
  }
  const deps = propsList;
  const getReferenceProps = React10.useCallback(
    (userProps) => mergeProps(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    deps
  );
  const getFloatingProps = React10.useCallback(
    (userProps) => mergeProps(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    deps
  );
  const getItemProps = React10.useCallback(
    (userProps) => mergeProps(userProps, propsList, "item"),
    // Granularly check for `item` changes, because the `getItemProps` getter
    // should be as referentially stable as possible since it may be passed as
    // a prop to many components. All `item` key values must therefore be
    // memoized.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    propsList.map((key) => key == null ? void 0 : key.item)
  );
  return React10.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
function useMergeRefs(refs) {
  return React10.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (value) => {
      refs.forEach((ref) => {
        if (typeof ref === "function") {
          ref(value);
        } else if (ref != null) {
          ref.current = value;
        }
      });
    };
  }, refs);
}
function useRole(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open,
    floatingId
  } = context;
  const {
    enabled = true,
    role = "dialog"
  } = props;
  const referenceId = useId();
  return React10.useMemo(() => {
    const floatingProps = {
      id: floatingId,
      role
    };
    if (!enabled) {
      return {};
    }
    if (role === "tooltip") {
      return {
        reference: {
          "aria-describedby": open ? floatingId : void 0
        },
        floating: floatingProps
      };
    }
    return {
      reference: {
        "aria-expanded": open ? "true" : "false",
        "aria-haspopup": role === "alertdialog" ? "dialog" : role,
        "aria-controls": open ? floatingId : void 0,
        ...role === "listbox" && {
          role: "combobox"
        },
        ...role === "menu" && {
          id: referenceId
        }
      },
      floating: {
        ...floatingProps,
        ...role === "menu" && {
          "aria-labelledby": referenceId
        }
      }
    };
  }, [enabled, role, open, floatingId, referenceId]);
}

// node_modules/@neo4j-ndl/react/lib/esm/_common/ConditionalWrap.js
var ConditionalWrap = ({ condition, wrap, children }) => condition ? wrap(children) : children;
var ConditionalWrap_default = ConditionalWrap;

// node_modules/@neo4j-ndl/react/lib/esm/tip/Tip.js
var import_react16 = __toESM(require_react());
var __rest11 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var PLACEMENTS = ["top", "bottom", "left", "right"];
var calculateArrow = (placement) => {
  switch (placement) {
    case "bottom":
      return "top";
    case "left":
      return "right";
    case "right":
      return "left";
    case "top":
    default:
      return "bottom";
  }
};
function useTip({ allowedPlacements = PLACEMENTS, isOpen: controlledOpen, isDisabled = false, onOpenChange: setControlledOpen, type = "tooltip" } = {}) {
  const [uncontrolledOpen, setUncontrolledOpen] = import_react16.default.useState(false);
  const open = isDisabled === true ? false : controlledOpen !== null && controlledOpen !== void 0 ? controlledOpen : uncontrolledOpen;
  const setOpen = setControlledOpen !== null && setControlledOpen !== void 0 ? setControlledOpen : setUncontrolledOpen;
  const data = useFloating2({
    placement: allowedPlacements[0],
    open,
    onOpenChange: setOpen,
    whileElementsMounted: autoUpdate,
    middleware: [
      offset(10),
      flip2({
        fallbackAxisSideDirection: "start",
        fallbackPlacements: allowedPlacements
      })
    ]
  });
  const context = data.context;
  const hover = useHover(context, {
    move: false,
    enabled: type == "tooltip",
    delay: {
      open: parseInt(tokens.transitions.values.duration.slow.replace("ms", "")),
      // Strip the 'ms' from the duration token, need to provide pure ms durations
      close: parseInt(tokens.transitions.values.duration.quick.replace("ms", ""))
    }
  });
  const focus = useFocus(context, {
    enabled: type == "tooltip"
  });
  const dismiss = useDismiss(context, {
    enabled: type == "tooltip"
  });
  const click = useClick(context, {
    enabled: type == "toggletip"
  });
  const role = useRole(context, { role: "tooltip" });
  const interactions = useInteractions([hover, focus, dismiss, role, click]);
  return import_react16.default.useMemo(() => Object.assign(Object.assign({
    open,
    setOpen,
    type
  }, interactions), data), [open, setOpen, interactions, data, type]);
}
var TooltipContext = import_react16.default.createContext(null);
var useTipContext = () => {
  const context = import_react16.default.useContext(TooltipContext);
  if (context == null) {
    throw new Error("Tip components must be wrapped in <Tip />");
  }
  return context;
};
function Tip(_a2) {
  var { children } = _a2, options2 = __rest11(_a2, ["children"]);
  const tooltip = useTip(Object.assign({}, options2));
  return (0, import_jsx_runtime11.jsx)(TooltipContext.Provider, { value: tooltip, children });
}
var Trigger = import_react16.default.forwardRef(function Trigger2(_a2, propRef) {
  var { children, hasButtonWrapper = false } = _a2, restProps = __rest11(_a2, ["children", "hasButtonWrapper"]);
  const context = useTipContext();
  const childrenRef = children.ref;
  const ref = useMergeRefs([context.refs.setReference, propRef, childrenRef]);
  if (!hasButtonWrapper && import_react16.default.isValidElement(children)) {
    return import_react16.default.cloneElement(children, context.getReferenceProps(Object.assign(Object.assign(Object.assign({ ref }, restProps), children.props), { "data-state": context.open ? "open" : "closed" })));
  }
  return (0, import_jsx_runtime11.jsx)("button", Object.assign({ ref, "data-state": context.open ? "open" : "closed" }, context.getReferenceProps(restProps), { children }));
});
var Content = import_react16.default.forwardRef(function Content2(_a2, propRef) {
  var { style, isPortaled = true, portalProps = {}, className, children } = _a2, restProps = __rest11(_a2, ["style", "isPortaled", "portalProps", "className", "children"]);
  const { open, type, context, getFloatingProps, placement } = useTipContext();
  const ref = useMergeRefs([context.refs.setFloating, propRef]);
  if (!open)
    return null;
  const floatingProps = getFloatingProps(Object.assign(Object.assign({}, restProps), {
    className: classNames("ndl-tip ndl-tooltip-wrapper", className, {
      "ndl-toggletip": type === "toggletip"
    })
  }));
  return (0, import_jsx_runtime11.jsx)(ConditionalWrap_default, { condition: isPortaled, wrap: (wrapChildren) => (0, import_jsx_runtime11.jsx)(FloatingPortal, Object.assign({ preserveTabOrder: true }, portalProps, { children: wrapChildren })), children: (0, import_jsx_runtime11.jsx)(FloatingFocusManager, { context, disabled: type === "tooltip", children: (0, import_jsx_runtime11.jsx)(Tooltip_default, Object.assign({ ref }, floatingProps, { arrowPosition: calculateArrow(placement), style: Object.assign(Object.assign({ zIndex: tokens.zIndex.alias.tooltip }, context.floatingStyles), style), children })) }) });
});
var Header = import_react16.default.forwardRef(function Content3(_a2, ref) {
  var { isCloseable = true } = _a2, restProps = __rest11(_a2, ["isCloseable"]);
  const { open, setOpen } = useTipContext();
  if (!open)
    return null;
  return (0, import_jsx_runtime11.jsxs)("div", Object.assign({ className: "ndl-toggletip-header" }, restProps, { ref, children: [(0, import_jsx_runtime11.jsx)(Typography, { variant: "h6", children: restProps.children }), isCloseable && (0, import_jsx_runtime11.jsx)(IconButton, { clean: true, tabIndex: 0, role: "button", size: "small", className: "ndl-toggletip-close-icon", onKeyDown: (event) => {
    if (event.key === "Enter" || event.key === "Space") {
      setOpen(false, event.nativeEvent);
    }
  }, onClick: (event) => {
    setOpen(false, event.nativeEvent);
  }, "aria-label": "close-toggletip", "data-testid": "ndl-close-toggletip", children: (0, import_jsx_runtime11.jsx)(import_XMarkIcon.default, {}) })] }));
});
var Body = import_react16.default.forwardRef(function Body2(_a2, ref) {
  var restProps = __rest11(_a2, []);
  const { open } = useTipContext();
  if (!open)
    return null;
  return (0, import_jsx_runtime11.jsx)("div", Object.assign({}, restProps, { ref }));
});
var Actions = import_react16.default.forwardRef(function Actions2(_a2, ref) {
  var restProps = __rest11(_a2, []);
  const { open } = useTipContext();
  const classes = classNames("ndl-toggletip-actions", restProps.className);
  if (!open)
    return null;
  return (0, import_jsx_runtime11.jsx)("div", Object.assign({}, restProps, { className: classes, ref }));
});
var Action = (_a2) => {
  var { className } = _a2, restProps = __rest11(_a2, ["className"]);
  const { open } = useTipContext();
  const classes = classNames("ndl-toggletip-action", className);
  if (!open)
    return null;
  return (0, import_jsx_runtime11.jsx)(Typography, Object.assign({ as: "button" }, restProps, { tabIndex: 0, variant: "label", className: classes }));
};
Tip.Content = Content;
Tip.Trigger = Trigger;
Tip.Header = Header;
Tip.Body = Body;
Tip.Actions = Actions;
Tip.Action = Action;

// node_modules/@neo4j-ndl/react/lib/esm/checkbox/Checkbox.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
var import_react18 = __toESM(require_react());

// node_modules/@neo4j-ndl/react/lib/esm/_common/input/RadioAndCheckboxWrapper.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
var import_react17 = __toESM(require_react());
var __rest12 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var customLabelAndNoAriaLabelWarningMessage = "aria label not detected when using a custom label, be sure to include an aria label for screen readers link: https://dequeuniversity.com/rules/axe/4.2/label?application=axeAPI";
var RadioAndCheckboxWrapper = (props, ref) => {
  const { label, fluid, labelBefore, type = "text", "aria-label": ariaLabel } = props, otherInputProps = __rest12(props, ["label", "fluid", "labelBefore", "type", "aria-label"]);
  const isLabel = label !== void 0 && typeof label === "string";
  const isCustomLabel = label && typeof label !== "string";
  const hasCustomLabelAndNoAriaLabel = isCustomLabel && !ariaLabel;
  (0, import_react17.useMemo)(() => {
    if (!label && !ariaLabel) {
      needleWarningMessage(`${type} without a label does not have an aria label, be sure to include an aria label for screen readers link: https://dequeuniversity.com/rules/axe/4.2/label?application=axeAPI`);
    }
    if (hasCustomLabelAndNoAriaLabel) {
      needleWarningMessage(customLabelAndNoAriaLabelWarningMessage);
    }
  }, [ariaLabel, label, type, hasCustomLabelAndNoAriaLabel]);
  const containerWrappingClasses = classNames(`ndl-form-item ndl-type-${type}`, {
    "ndl-disabled": otherInputProps.disabled
  });
  const labelWrappingClasses = classNames(`ndl-form-item-label`, {
    "ndl-fluid": fluid,
    "ndl-label-before": labelBefore
  });
  return (0, import_jsx_runtime12.jsx)("div", { className: containerWrappingClasses, children: (0, import_jsx_runtime12.jsxs)("label", { className: labelWrappingClasses, children: [(0, import_jsx_runtime12.jsx)("input", Object.assign({ "aria-label": ariaLabel }, otherInputProps, { ref, type })), isLabel ? (0, import_jsx_runtime12.jsx)("span", { title: label, className: "ndl-form-label-text", children: label }) : label] }) });
};
var RadioAndCheckboxWrapper_default = (0, import_react17.forwardRef)(RadioAndCheckboxWrapper);

// node_modules/@neo4j-ndl/react/lib/esm/checkbox/Checkbox.js
var __rest13 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var Checkbox = import_react18.default.forwardRef((_a2, ref) => {
  var { "aria-label": ariaLabel, label } = _a2, restProps = __rest13(_a2, ["aria-label", "label"]);
  if (!ariaLabel && !label) {
    console.warn("To be accessible the input component requires either `aria-label` or `label` prop: https://dequeuniversity.com/rules/axe/4.2/label?application=axeAPI");
  }
  return (0, import_jsx_runtime13.jsx)(RadioAndCheckboxWrapper_default, Object.assign({}, restProps, { label, "aria-label": ariaLabel, ref, type: "checkbox", role: "checkbox" }));
});
Checkbox.displayName = "Checkbox";
var Checkbox_default = Checkbox;

// node_modules/@neo4j-ndl/react/lib/esm/switch/Switch.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var import_react19 = __toESM(require_react());
var Switch = import_react19.default.forwardRef(function Switch2(props, ref) {
  return (0, import_jsx_runtime14.jsx)(RadioAndCheckboxWrapper_default, Object.assign({}, props, { ref, type: "checkbox", role: "switch" }));
});
var Switch_default = Switch;

// node_modules/@neo4j-ndl/react/lib/esm/radio/Radio.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
var import_react20 = __toESM(require_react());
var Radio = import_react20.default.forwardRef(function Radio2(props, ref) {
  return (0, import_jsx_runtime15.jsx)(RadioAndCheckboxWrapper_default, Object.assign({}, props, { type: "radio", role: "radio", ref }));
});
var Radio_default = Radio;

// node_modules/@neo4j-ndl/react/lib/esm/context-menu/ContextMenu.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
var import_react28 = __toESM(require_react());

// node_modules/@neo4j-ndl/react/lib/esm/popover/Popover.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
var import_react26 = __toESM(require_react());

// node_modules/@neo4j-ndl/react/lib/esm/portal/Portal.js
var import_react_dom4 = __toESM(require_react_dom());
var Portal = ({ children, container = document.body }) => {
  return (0, import_react_dom4.createPortal)(children, container);
};

// node_modules/@neo4j-ndl/react/lib/esm/_common/messages.js
var customLabelAndNoAriaLabelWarningMessage2 = "aria label not detected when using a custom label, be sure to include an aria label for screen readers link: https://dequeuniversity.com/rules/axe/4.2/label?application=axeAPI";
var anchorElNotSetWarningMessage = "anchorEl property reference is null. This component might not work as expected.";

// node_modules/@neo4j-ndl/react/lib/esm/_common/coditionalWrap.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
var ConditionalWrap2 = ({ condition, wrapper, children }) => {
  return condition ? (0, import_jsx_runtime16.jsx)(import_jsx_runtime16.Fragment, { children: wrapper(children) }) : (0, import_jsx_runtime16.jsx)(import_jsx_runtime16.Fragment, { children });
};

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}

// node_modules/react-focus-lock/dist/es2015/Combination.js
var React23 = __toESM(require_react());

// node_modules/react-focus-lock/dist/es2015/Lock.js
var React20 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());

// node_modules/focus-lock/dist/es2015/constants.js
var FOCUS_GROUP = "data-focus-lock";
var FOCUS_DISABLED = "data-focus-lock-disabled";
var FOCUS_ALLOW = "data-no-focus-lock";
var FOCUS_AUTO = "data-autofocus-inside";
var FOCUS_NO_AUTOFOCUS = "data-no-autofocus";

// node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react21 = __toESM(require_react());
function useCallbackRef(initialValue, callback) {
  var ref = (0, import_react21.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// node_modules/use-callback-ref/dist/es2015/useMergeRef.js
var React15 = __toESM(require_react());
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs2(refs, defaultValue) {
  var callbackRef = useCallbackRef(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  React15.useLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}

// node_modules/react-focus-lock/dist/es2015/Lock.js
var import_react24 = __toESM(require_react());

// node_modules/react-focus-lock/dist/es2015/FocusGuard.js
var React16 = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
var hiddenGuard = {
  width: "1px",
  height: "0px",
  padding: 0,
  overflow: "hidden",
  position: "fixed",
  top: "1px",
  left: "1px"
};
var InFocusGuard = function InFocusGuard2(_ref4) {
  var children = _ref4.children;
  return React16.createElement(React16.Fragment, null, React16.createElement("div", {
    key: "guard-first",
    "data-focus-guard": true,
    "data-focus-auto-guard": true,
    style: hiddenGuard
  }), children, children && React16.createElement("div", {
    key: "guard-last",
    "data-focus-guard": true,
    "data-focus-auto-guard": true,
    style: hiddenGuard
  }));
};
InFocusGuard.propTypes = true ? {
  children: import_prop_types.default.node
} : {};
InFocusGuard.defaultProps = {
  children: null
};

// node_modules/use-sidecar/dist/es2015/hoc.js
init_tslib_es6();
var React17 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/hook.js
var import_react22 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/medium.js
init_tslib_es6();
function ItoI(a3) {
  return a3;
}
function innerCreateMedium(defaults3, middleware2) {
  if (middleware2 === void 0) {
    middleware2 = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults3;
    },
    useMedium: function(data) {
      var item = middleware2(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x2) {
          return cb(x2);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x2) {
          pendingQueue.push(x2);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createMedium(defaults3, middleware2) {
  if (middleware2 === void 0) {
    middleware2 = ItoI;
  }
  return innerCreateMedium(defaults3, middleware2);
}
function createSidecarMedium(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options2);
  return medium;
}

// node_modules/use-sidecar/dist/es2015/renderProp.js
init_tslib_es6();
var React18 = __toESM(require_react());
var import_react23 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/exports.js
init_tslib_es6();
var React19 = __toESM(require_react());
var SideCar = function(_a2) {
  var sideCar2 = _a2.sideCar, rest = __rest14(_a2, ["sideCar"]);
  if (!sideCar2) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar2.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React19.createElement(Target, __assign({}, rest));
};
SideCar.isSideCarExport = true;

// node_modules/react-focus-lock/dist/es2015/medium.js
var mediumFocus = createMedium({}, function(_ref4) {
  var target = _ref4.target, currentTarget = _ref4.currentTarget;
  return {
    target,
    currentTarget
  };
});
var mediumBlur = createMedium();
var mediumEffect = createMedium();
var mediumSidecar = createSidecarMedium({
  async: true
  // focus-lock sidecar is not required on the server
  // however, it might be required for JSDOM tests
  // ssr: true,
});

// node_modules/react-focus-lock/dist/es2015/Lock.js
var emptyArray = [];
var FocusLock = React20.forwardRef(function FocusLockUI(props, parentRef) {
  var _extends22;
  var _React$useState = React20.useState(), realObserved = _React$useState[0], setObserved = _React$useState[1];
  var observed = React20.useRef();
  var isActive = React20.useRef(false);
  var originalFocusedElement = React20.useRef(null);
  var children = props.children, disabled = props.disabled, noFocusGuards = props.noFocusGuards, persistentFocus = props.persistentFocus, crossFrame = props.crossFrame, autoFocus = props.autoFocus, allowTextSelection = props.allowTextSelection, group = props.group, className = props.className, whiteList = props.whiteList, hasPositiveIndices = props.hasPositiveIndices, _props$shards = props.shards, shards = _props$shards === void 0 ? emptyArray : _props$shards, _props$as = props.as, Container = _props$as === void 0 ? "div" : _props$as, _props$lockProps = props.lockProps, containerProps = _props$lockProps === void 0 ? {} : _props$lockProps, SideCar2 = props.sideCar, shouldReturnFocus = props.returnFocus, focusOptions = props.focusOptions, onActivationCallback = props.onActivation, onDeactivationCallback = props.onDeactivation;
  var _React$useState2 = React20.useState({}), id = _React$useState2[0];
  var onActivation = React20.useCallback(function() {
    originalFocusedElement.current = originalFocusedElement.current || document && document.activeElement;
    if (observed.current && onActivationCallback) {
      onActivationCallback(observed.current);
    }
    isActive.current = true;
  }, [onActivationCallback]);
  var onDeactivation = React20.useCallback(function() {
    isActive.current = false;
    if (onDeactivationCallback) {
      onDeactivationCallback(observed.current);
    }
  }, [onDeactivationCallback]);
  (0, import_react24.useEffect)(function() {
    if (!disabled) {
      originalFocusedElement.current = null;
    }
  }, []);
  var returnFocus = React20.useCallback(function(allowDefer) {
    var returnFocusTo = originalFocusedElement.current;
    if (returnFocusTo && returnFocusTo.focus) {
      var howToReturnFocus = typeof shouldReturnFocus === "function" ? shouldReturnFocus(returnFocusTo) : shouldReturnFocus;
      if (howToReturnFocus) {
        var returnFocusOptions = typeof howToReturnFocus === "object" ? howToReturnFocus : void 0;
        originalFocusedElement.current = null;
        if (allowDefer) {
          Promise.resolve().then(function() {
            return returnFocusTo.focus(returnFocusOptions);
          });
        } else {
          returnFocusTo.focus(returnFocusOptions);
        }
      }
    }
  }, [shouldReturnFocus]);
  var onFocus4 = React20.useCallback(function(event) {
    if (isActive.current) {
      mediumFocus.useMedium(event);
    }
  }, []);
  var onBlur3 = mediumBlur.useMedium;
  var setObserveNode = React20.useCallback(function(newObserved) {
    if (observed.current !== newObserved) {
      observed.current = newObserved;
      setObserved(newObserved);
    }
  }, []);
  if (true) {
    if (typeof allowTextSelection !== "undefined") {
      console.warn("React-Focus-Lock: allowTextSelection is deprecated and enabled by default");
    }
    React20.useEffect(function() {
      if (!observed.current && typeof Container !== "string") {
        console.error("FocusLock: could not obtain ref to internal node");
      }
    }, []);
  }
  var lockProps = _extends2((_extends22 = {}, _extends22[FOCUS_DISABLED] = disabled && "disabled", _extends22[FOCUS_GROUP] = group, _extends22), containerProps);
  var hasLeadingGuards = noFocusGuards !== true;
  var hasTailingGuards = hasLeadingGuards && noFocusGuards !== "tail";
  var mergedRef = useMergeRefs2([parentRef, setObserveNode]);
  return React20.createElement(React20.Fragment, null, hasLeadingGuards && [
    // nearest focus guard
    React20.createElement("div", {
      key: "guard-first",
      "data-focus-guard": true,
      tabIndex: disabled ? -1 : 0,
      style: hiddenGuard
    }),
    // first tabbed element guard
    hasPositiveIndices ? React20.createElement("div", {
      key: "guard-nearest",
      "data-focus-guard": true,
      tabIndex: disabled ? -1 : 1,
      style: hiddenGuard
    }) : null
  ], !disabled && React20.createElement(SideCar2, {
    id,
    sideCar: mediumSidecar,
    observed: realObserved,
    disabled,
    persistentFocus,
    crossFrame,
    autoFocus,
    whiteList,
    shards,
    onActivation,
    onDeactivation,
    returnFocus,
    focusOptions
  }), React20.createElement(Container, _extends2({
    ref: mergedRef
  }, lockProps, {
    className,
    onBlur: onBlur3,
    onFocus: onFocus4
  }), children), hasTailingGuards && React20.createElement("div", {
    "data-focus-guard": true,
    tabIndex: disabled ? -1 : 0,
    style: hiddenGuard
  }));
});
FocusLock.propTypes = true ? {
  children: import_prop_types2.node,
  disabled: import_prop_types2.bool,
  returnFocus: (0, import_prop_types2.oneOfType)([import_prop_types2.bool, import_prop_types2.object, import_prop_types2.func]),
  focusOptions: import_prop_types2.object,
  noFocusGuards: import_prop_types2.bool,
  hasPositiveIndices: import_prop_types2.bool,
  allowTextSelection: import_prop_types2.bool,
  autoFocus: import_prop_types2.bool,
  persistentFocus: import_prop_types2.bool,
  crossFrame: import_prop_types2.bool,
  group: import_prop_types2.string,
  className: import_prop_types2.string,
  whiteList: import_prop_types2.func,
  shards: (0, import_prop_types2.arrayOf)(import_prop_types2.any),
  as: (0, import_prop_types2.oneOfType)([import_prop_types2.string, import_prop_types2.func, import_prop_types2.object]),
  lockProps: import_prop_types2.object,
  onActivation: import_prop_types2.func,
  onDeactivation: import_prop_types2.func,
  sideCar: import_prop_types2.any.isRequired
} : {};
FocusLock.defaultProps = {
  children: void 0,
  disabled: false,
  returnFocus: false,
  focusOptions: void 0,
  noFocusGuards: false,
  autoFocus: true,
  persistentFocus: false,
  crossFrame: true,
  hasPositiveIndices: void 0,
  allowTextSelection: void 0,
  group: void 0,
  className: void 0,
  whiteList: void 0,
  shards: void 0,
  as: "div",
  lockProps: {},
  onActivation: void 0,
  onDeactivation: void 0
};
var Lock_default = FocusLock;

// node_modules/react-focus-lock/dist/es2015/Trap.js
var React22 = __toESM(require_react());
var import_prop_types3 = __toESM(require_prop_types());

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf3(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}

// node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t4, r2) {
  if ("object" != _typeof(t4) || !t4)
    return t4;
  var e4 = t4[Symbol.toPrimitive];
  if (void 0 !== e4) {
    var i2 = e4.call(t4, r2 || "default");
    if ("object" != _typeof(i2))
      return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t4);
}

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t4) {
  var i2 = toPrimitive(t4, "string");
  return "symbol" == _typeof(i2) ? i2 : String(i2);
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

// node_modules/react-clientside-effect/lib/index.es.js
var import_react25 = __toESM(require_react());
function withSideEffect(reducePropsToState2, handleStateChangeOnClient2) {
  if (true) {
    if (typeof reducePropsToState2 !== "function") {
      throw new Error("Expected reducePropsToState to be a function.");
    }
    if (typeof handleStateChangeOnClient2 !== "function") {
      throw new Error("Expected handleStateChangeOnClient to be a function.");
    }
  }
  function getDisplayName(WrappedComponent) {
    return WrappedComponent.displayName || WrappedComponent.name || "Component";
  }
  return function wrap(WrappedComponent) {
    if (true) {
      if (typeof WrappedComponent !== "function") {
        throw new Error("Expected WrappedComponent to be a React component.");
      }
    }
    var mountedInstances = [];
    var state;
    function emitChange() {
      state = reducePropsToState2(mountedInstances.map(function(instance) {
        return instance.props;
      }));
      handleStateChangeOnClient2(state);
    }
    var SideEffect = function(_PureComponent) {
      _inheritsLoose(SideEffect2, _PureComponent);
      function SideEffect2() {
        return _PureComponent.apply(this, arguments) || this;
      }
      SideEffect2.peek = function peek2() {
        return state;
      };
      var _proto = SideEffect2.prototype;
      _proto.componentDidMount = function componentDidMount() {
        mountedInstances.push(this);
        emitChange();
      };
      _proto.componentDidUpdate = function componentDidUpdate() {
        emitChange();
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        var index4 = mountedInstances.indexOf(this);
        mountedInstances.splice(index4, 1);
        emitChange();
      };
      _proto.render = function render2() {
        return import_react25.default.createElement(WrappedComponent, this.props);
      };
      return SideEffect2;
    }(import_react25.PureComponent);
    _defineProperty(SideEffect, "displayName", "SideEffect(" + getDisplayName(WrappedComponent) + ")");
    return SideEffect;
  };
}
var index_es_default = withSideEffect;

// node_modules/focus-lock/dist/es2015/utils/array.js
var toArray = function(a3) {
  var ret = Array(a3.length);
  for (var i2 = 0; i2 < a3.length; ++i2) {
    ret[i2] = a3[i2];
  }
  return ret;
};
var asArray = function(a3) {
  return Array.isArray(a3) ? a3 : [a3];
};
var getFirst = function(a3) {
  return Array.isArray(a3) ? a3[0] : a3;
};

// node_modules/focus-lock/dist/es2015/utils/is.js
var isElementHidden = function(node3) {
  if (node3.nodeType !== Node.ELEMENT_NODE) {
    return false;
  }
  var computedStyle = window.getComputedStyle(node3, null);
  if (!computedStyle || !computedStyle.getPropertyValue) {
    return false;
  }
  return computedStyle.getPropertyValue("display") === "none" || computedStyle.getPropertyValue("visibility") === "hidden";
};
var getParentNode3 = function(node3) {
  return node3.parentNode && node3.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    node3.parentNode.host
  ) : node3.parentNode;
};
var isTopNode = function(node3) {
  return node3 === document || node3 && node3.nodeType === Node.DOCUMENT_NODE;
};
var isVisibleUncached = function(node3, checkParent) {
  return !node3 || isTopNode(node3) || !isElementHidden(node3) && checkParent(getParentNode3(node3));
};
var isVisibleCached = function(visibilityCache, node3) {
  var cached = visibilityCache.get(node3);
  if (cached !== void 0) {
    return cached;
  }
  var result = isVisibleUncached(node3, isVisibleCached.bind(void 0, visibilityCache));
  visibilityCache.set(node3, result);
  return result;
};
var isAutoFocusAllowedUncached = function(node3, checkParent) {
  return node3 && !isTopNode(node3) ? isAutoFocusAllowed(node3) ? checkParent(getParentNode3(node3)) : false : true;
};
var isAutoFocusAllowedCached = function(cache, node3) {
  var cached = cache.get(node3);
  if (cached !== void 0) {
    return cached;
  }
  var result = isAutoFocusAllowedUncached(node3, isAutoFocusAllowedCached.bind(void 0, cache));
  cache.set(node3, result);
  return result;
};
var getDataset = function(node3) {
  return node3.dataset;
};
var isHTMLButtonElement = function(node3) {
  return node3.tagName === "BUTTON";
};
var isHTMLInputElement = function(node3) {
  return node3.tagName === "INPUT";
};
var isRadioElement = function(node3) {
  return isHTMLInputElement(node3) && node3.type === "radio";
};
var notHiddenInput = function(node3) {
  return !((isHTMLInputElement(node3) || isHTMLButtonElement(node3)) && (node3.type === "hidden" || node3.disabled));
};
var isAutoFocusAllowed = function(node3) {
  var attribute = node3.getAttribute(FOCUS_NO_AUTOFOCUS);
  return ![true, "true", ""].includes(attribute);
};
var isGuard = function(node3) {
  var _a2;
  return Boolean(node3 && ((_a2 = getDataset(node3)) === null || _a2 === void 0 ? void 0 : _a2.focusGuard));
};
var isNotAGuard = function(node3) {
  return !isGuard(node3);
};
var isDefined = function(x2) {
  return Boolean(x2);
};

// node_modules/focus-lock/dist/es2015/utils/tabOrder.js
var tabSort = function(a3, b2) {
  var tabDiff = a3.tabIndex - b2.tabIndex;
  var indexDiff = a3.index - b2.index;
  if (tabDiff) {
    if (!a3.tabIndex) {
      return 1;
    }
    if (!b2.tabIndex) {
      return -1;
    }
  }
  return tabDiff || indexDiff;
};
var orderByTabIndex = function(nodes, filterNegative, keepGuards) {
  return toArray(nodes).map(function(node3, index4) {
    return {
      node: node3,
      index: index4,
      tabIndex: keepGuards && node3.tabIndex === -1 ? (node3.dataset || {}).focusGuard ? 0 : -1 : node3.tabIndex
    };
  }).filter(function(data) {
    return !filterNegative || data.tabIndex >= 0;
  }).sort(tabSort);
};

// node_modules/focus-lock/dist/es2015/utils/tabbables.js
var tabbables = [
  "button:enabled",
  "select:enabled",
  "textarea:enabled",
  "input:enabled",
  // elements with explicit roles will also use explicit tabindex
  // '[role="button"]',
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  "[tabindex]",
  "[contenteditable]",
  "[autofocus]"
];

// node_modules/focus-lock/dist/es2015/utils/tabUtils.js
var queryTabbables = tabbables.join(",");
var queryGuardTabbables = "".concat(queryTabbables, ", [data-focus-guard]");
var getFocusablesWithShadowDom = function(parent, withGuards) {
  return toArray((parent.shadowRoot || parent).children).reduce(function(acc, child) {
    return acc.concat(child.matches(withGuards ? queryGuardTabbables : queryTabbables) ? [child] : [], getFocusablesWithShadowDom(child));
  }, []);
};
var getFocusablesWithIFrame = function(parent, withGuards) {
  var _a2;
  if (parent instanceof HTMLIFrameElement && ((_a2 = parent.contentDocument) === null || _a2 === void 0 ? void 0 : _a2.body)) {
    return getFocusables([parent.contentDocument.body], withGuards);
  }
  return [parent];
};
var getFocusables = function(parents, withGuards) {
  return parents.reduce(function(acc, parent) {
    var _a2;
    var focusableWithShadowDom = getFocusablesWithShadowDom(parent, withGuards);
    var focusableWithIframes = (_a2 = []).concat.apply(_a2, focusableWithShadowDom.map(function(node3) {
      return getFocusablesWithIFrame(node3, withGuards);
    }));
    return acc.concat(
      // add all tabbables inside and within shadow DOMs in DOM order
      focusableWithIframes,
      // add if node is tabbable itself
      parent.parentNode ? toArray(parent.parentNode.querySelectorAll(queryTabbables)).filter(function(node3) {
        return node3 === parent;
      }) : []
    );
  }, []);
};
var getParentAutofocusables = function(parent) {
  var parentFocus = parent.querySelectorAll("[".concat(FOCUS_AUTO, "]"));
  return toArray(parentFocus).map(function(node3) {
    return getFocusables([node3]);
  }).reduce(function(acc, nodes) {
    return acc.concat(nodes);
  }, []);
};

// node_modules/focus-lock/dist/es2015/utils/DOMutils.js
var filterFocusable = function(nodes, visibilityCache) {
  return toArray(nodes).filter(function(node3) {
    return isVisibleCached(visibilityCache, node3);
  }).filter(function(node3) {
    return notHiddenInput(node3);
  });
};
var filterAutoFocusable = function(nodes, cache) {
  if (cache === void 0) {
    cache = /* @__PURE__ */ new Map();
  }
  return toArray(nodes).filter(function(node3) {
    return isAutoFocusAllowedCached(cache, node3);
  });
};
var getTabbableNodes = function(topNodes, visibilityCache, withGuards) {
  return orderByTabIndex(filterFocusable(getFocusables(topNodes, withGuards), visibilityCache), true, withGuards);
};
var getFocusableNodes = function(topNodes, visibilityCache) {
  return orderByTabIndex(filterFocusable(getFocusables(topNodes), visibilityCache), false);
};
var parentAutofocusables = function(topNode, visibilityCache) {
  return filterFocusable(getParentAutofocusables(topNode), visibilityCache);
};
var contains2 = function(scope, element) {
  if (scope.shadowRoot) {
    return contains2(scope.shadowRoot, element);
  } else {
    if (Object.getPrototypeOf(scope).contains !== void 0 && Object.getPrototypeOf(scope).contains.call(scope, element)) {
      return true;
    }
    return toArray(scope.children).some(function(child) {
      var _a2;
      if (child instanceof HTMLIFrameElement) {
        var iframeBody = (_a2 = child.contentDocument) === null || _a2 === void 0 ? void 0 : _a2.body;
        if (iframeBody) {
          return contains2(iframeBody, element);
        }
        return false;
      }
      return contains2(child, element);
    });
  }
};

// node_modules/focus-lock/dist/es2015/utils/all-affected.js
var filterNested = function(nodes) {
  var contained = /* @__PURE__ */ new Set();
  var l = nodes.length;
  for (var i2 = 0; i2 < l; i2 += 1) {
    for (var j = i2 + 1; j < l; j += 1) {
      var position2 = nodes[i2].compareDocumentPosition(nodes[j]);
      if ((position2 & Node.DOCUMENT_POSITION_CONTAINED_BY) > 0) {
        contained.add(j);
      }
      if ((position2 & Node.DOCUMENT_POSITION_CONTAINS) > 0) {
        contained.add(i2);
      }
    }
  }
  return nodes.filter(function(_, index4) {
    return !contained.has(index4);
  });
};
var getTopParent = function(node3) {
  return node3.parentNode ? getTopParent(node3.parentNode) : node3;
};
var getAllAffectedNodes = function(node3) {
  var nodes = asArray(node3);
  return nodes.filter(Boolean).reduce(function(acc, currentNode) {
    var group = currentNode.getAttribute(FOCUS_GROUP);
    acc.push.apply(acc, group ? filterNested(toArray(getTopParent(currentNode).querySelectorAll("[".concat(FOCUS_GROUP, '="').concat(group, '"]:not([').concat(FOCUS_DISABLED, '="disabled"])')))) : [currentNode]);
    return acc;
  }, []);
};

// node_modules/focus-lock/dist/es2015/utils/safe.js
var safeProbe = function(cb) {
  try {
    return cb();
  } catch (e4) {
    return void 0;
  }
};

// node_modules/focus-lock/dist/es2015/utils/getActiveElement.js
var getActiveElement = function(inDocument) {
  if (inDocument === void 0) {
    inDocument = document;
  }
  if (!inDocument || !inDocument.activeElement) {
    return void 0;
  }
  var activeElement2 = inDocument.activeElement;
  return activeElement2.shadowRoot ? getActiveElement(activeElement2.shadowRoot) : activeElement2 instanceof HTMLIFrameElement && safeProbe(function() {
    return activeElement2.contentWindow.document;
  }) ? getActiveElement(activeElement2.contentWindow.document) : activeElement2;
};

// node_modules/focus-lock/dist/es2015/focusInside.js
var focusInFrame = function(frame, activeElement2) {
  return frame === activeElement2;
};
var focusInsideIframe = function(topNode, activeElement2) {
  return Boolean(toArray(topNode.querySelectorAll("iframe")).some(function(node3) {
    return focusInFrame(node3, activeElement2);
  }));
};
var focusInside = function(topNode, activeElement2) {
  if (activeElement2 === void 0) {
    activeElement2 = getActiveElement(getFirst(topNode).ownerDocument);
  }
  if (!activeElement2 || activeElement2.dataset && activeElement2.dataset.focusGuard) {
    return false;
  }
  return getAllAffectedNodes(topNode).some(function(node3) {
    return contains2(node3, activeElement2) || focusInsideIframe(node3, activeElement2);
  });
};

// node_modules/focus-lock/dist/es2015/focusIsHidden.js
var focusIsHidden = function(inDocument) {
  if (inDocument === void 0) {
    inDocument = document;
  }
  var activeElement2 = getActiveElement(inDocument);
  if (!activeElement2) {
    return false;
  }
  return toArray(inDocument.querySelectorAll("[".concat(FOCUS_ALLOW, "]"))).some(function(node3) {
    return contains2(node3, activeElement2);
  });
};

// node_modules/focus-lock/dist/es2015/utils/correctFocus.js
var findSelectedRadio = function(node3, nodes) {
  return nodes.filter(isRadioElement).filter(function(el) {
    return el.name === node3.name;
  }).filter(function(el) {
    return el.checked;
  })[0] || node3;
};
var correctNode = function(node3, nodes) {
  if (isRadioElement(node3) && node3.name) {
    return findSelectedRadio(node3, nodes);
  }
  return node3;
};
var correctNodes = function(nodes) {
  var resultSet = /* @__PURE__ */ new Set();
  nodes.forEach(function(node3) {
    return resultSet.add(correctNode(node3, nodes));
  });
  return nodes.filter(function(node3) {
    return resultSet.has(node3);
  });
};

// node_modules/focus-lock/dist/es2015/utils/firstFocus.js
var pickFirstFocus = function(nodes) {
  if (nodes[0] && nodes.length > 1) {
    return correctNode(nodes[0], nodes);
  }
  return nodes[0];
};
var pickFocusable = function(nodes, index4) {
  if (nodes.length > 1) {
    return nodes.indexOf(correctNode(nodes[index4], nodes));
  }
  return index4;
};

// node_modules/focus-lock/dist/es2015/solver.js
var NEW_FOCUS = "NEW_FOCUS";
var newFocus = function(innerNodes, outerNodes, activeElement2, lastNode) {
  var cnt = innerNodes.length;
  var firstFocus = innerNodes[0];
  var lastFocus = innerNodes[cnt - 1];
  var isOnGuard = isGuard(activeElement2);
  if (activeElement2 && innerNodes.indexOf(activeElement2) >= 0) {
    return void 0;
  }
  var activeIndex = activeElement2 !== void 0 ? outerNodes.indexOf(activeElement2) : -1;
  var lastIndex = lastNode ? outerNodes.indexOf(lastNode) : activeIndex;
  var lastNodeInside = lastNode ? innerNodes.indexOf(lastNode) : -1;
  var indexDiff = activeIndex - lastIndex;
  var firstNodeIndex = outerNodes.indexOf(firstFocus);
  var lastNodeIndex = outerNodes.indexOf(lastFocus);
  var correctedNodes = correctNodes(outerNodes);
  var correctedIndex = activeElement2 !== void 0 ? correctedNodes.indexOf(activeElement2) : -1;
  var correctedIndexDiff = correctedIndex - (lastNode ? correctedNodes.indexOf(lastNode) : activeIndex);
  var returnFirstNode = pickFocusable(innerNodes, 0);
  var returnLastNode = pickFocusable(innerNodes, cnt - 1);
  if (activeIndex === -1 || lastNodeInside === -1) {
    return NEW_FOCUS;
  }
  if (!indexDiff && lastNodeInside >= 0) {
    return lastNodeInside;
  }
  if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
    return returnLastNode;
  }
  if (activeIndex >= lastNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
    return returnFirstNode;
  }
  if (indexDiff && Math.abs(correctedIndexDiff) > 1) {
    return lastNodeInside;
  }
  if (activeIndex <= firstNodeIndex) {
    return returnLastNode;
  }
  if (activeIndex > lastNodeIndex) {
    return returnFirstNode;
  }
  if (indexDiff) {
    if (Math.abs(indexDiff) > 1) {
      return lastNodeInside;
    }
    return (cnt + lastNodeInside + indexDiff) % cnt;
  }
  return void 0;
};

// node_modules/focus-lock/dist/es2015/utils/auto-focus.js
var findAutoFocused = function(autoFocusables) {
  return function(node3) {
    var _a2;
    var autofocus = (_a2 = getDataset(node3)) === null || _a2 === void 0 ? void 0 : _a2.autofocus;
    return (
      // @ts-expect-error
      node3.autofocus || //
      autofocus !== void 0 && autofocus !== "false" || //
      autoFocusables.indexOf(node3) >= 0
    );
  };
};
var pickAutofocus = function(nodesIndexes, orderedNodes, groups) {
  var nodes = nodesIndexes.map(function(_a2) {
    var node3 = _a2.node;
    return node3;
  });
  var autoFocusable = filterAutoFocusable(nodes.filter(findAutoFocused(groups)));
  if (autoFocusable && autoFocusable.length) {
    return pickFirstFocus(autoFocusable);
  }
  return pickFirstFocus(filterAutoFocusable(orderedNodes));
};

// node_modules/focus-lock/dist/es2015/utils/parenting.js
var getParents = function(node3, parents) {
  if (parents === void 0) {
    parents = [];
  }
  parents.push(node3);
  if (node3.parentNode) {
    getParents(node3.parentNode.host || node3.parentNode, parents);
  }
  return parents;
};
var getCommonParent = function(nodeA, nodeB) {
  var parentsA = getParents(nodeA);
  var parentsB = getParents(nodeB);
  for (var i2 = 0; i2 < parentsA.length; i2 += 1) {
    var currentParent = parentsA[i2];
    if (parentsB.indexOf(currentParent) >= 0) {
      return currentParent;
    }
  }
  return false;
};
var getTopCommonParent = function(baseActiveElement, leftEntry, rightEntries) {
  var activeElements = asArray(baseActiveElement);
  var leftEntries = asArray(leftEntry);
  var activeElement2 = activeElements[0];
  var topCommon = false;
  leftEntries.filter(Boolean).forEach(function(entry) {
    topCommon = getCommonParent(topCommon || entry, entry) || topCommon;
    rightEntries.filter(Boolean).forEach(function(subEntry) {
      var common = getCommonParent(activeElement2, subEntry);
      if (common) {
        if (!topCommon || contains2(common, topCommon)) {
          topCommon = common;
        } else {
          topCommon = getCommonParent(common, topCommon);
        }
      }
    });
  });
  return topCommon;
};
var allParentAutofocusables = function(entries, visibilityCache) {
  return entries.reduce(function(acc, node3) {
    return acc.concat(parentAutofocusables(node3, visibilityCache));
  }, []);
};

// node_modules/focus-lock/dist/es2015/focusSolver.js
var reorderNodes = function(srcNodes, dstNodes) {
  var remap = /* @__PURE__ */ new Map();
  dstNodes.forEach(function(entity) {
    return remap.set(entity.node, entity);
  });
  return srcNodes.map(function(node3) {
    return remap.get(node3);
  }).filter(isDefined);
};
var focusSolver = function(topNode, lastNode) {
  var activeElement2 = getActiveElement(asArray(topNode).length > 0 ? document : getFirst(topNode).ownerDocument);
  var entries = getAllAffectedNodes(topNode).filter(isNotAGuard);
  var commonParent = getTopCommonParent(activeElement2 || topNode, topNode, entries);
  var visibilityCache = /* @__PURE__ */ new Map();
  var anyFocusable = getFocusableNodes(entries, visibilityCache);
  var innerElements = getTabbableNodes(entries, visibilityCache).filter(function(_a2) {
    var node3 = _a2.node;
    return isNotAGuard(node3);
  });
  if (!innerElements[0]) {
    innerElements = anyFocusable;
    if (!innerElements[0]) {
      return void 0;
    }
  }
  var outerNodes = getFocusableNodes([commonParent], visibilityCache).map(function(_a2) {
    var node3 = _a2.node;
    return node3;
  });
  var orderedInnerElements = reorderNodes(outerNodes, innerElements);
  var innerNodes = orderedInnerElements.map(function(_a2) {
    var node3 = _a2.node;
    return node3;
  });
  var newId = newFocus(innerNodes, outerNodes, activeElement2, lastNode);
  if (newId === NEW_FOCUS) {
    var focusNode = pickAutofocus(anyFocusable, innerNodes, allParentAutofocusables(entries, visibilityCache));
    if (focusNode) {
      return { node: focusNode };
    } else {
      console.warn("focus-lock: cannot find any node to move focus into");
      return void 0;
    }
  }
  if (newId === void 0) {
    return newId;
  }
  return orderedInnerElements[newId];
};

// node_modules/focus-lock/dist/es2015/focusables.js
var expandFocusableNodes = function(topNode) {
  var entries = getAllAffectedNodes(topNode).filter(isNotAGuard);
  var commonParent = getTopCommonParent(topNode, topNode, entries);
  var visibilityCache = /* @__PURE__ */ new Map();
  var outerNodes = getTabbableNodes([commonParent], visibilityCache, true);
  var innerElements = getTabbableNodes(entries, visibilityCache).filter(function(_a2) {
    var node3 = _a2.node;
    return isNotAGuard(node3);
  }).map(function(_a2) {
    var node3 = _a2.node;
    return node3;
  });
  return outerNodes.map(function(_a2) {
    var node3 = _a2.node, index4 = _a2.index;
    return {
      node: node3,
      index: index4,
      lockItem: innerElements.indexOf(node3) >= 0,
      guard: isGuard(node3)
    };
  });
};

// node_modules/focus-lock/dist/es2015/commands.js
var focusOn = function(target, focusOptions) {
  if ("focus" in target) {
    target.focus(focusOptions);
  }
  if ("contentWindow" in target && target.contentWindow) {
    target.contentWindow.focus();
  }
};

// node_modules/focus-lock/dist/es2015/moveFocusInside.js
var guardCount = 0;
var lockDisabled = false;
var moveFocusInside = function(topNode, lastNode, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var focusable = focusSolver(topNode, lastNode);
  if (lockDisabled) {
    return;
  }
  if (focusable) {
    if (guardCount > 2) {
      console.error("FocusLock: focus-fighting detected. Only one focus management system could be active. See https://github.com/theKashey/focus-lock/#focus-fighting");
      lockDisabled = true;
      setTimeout(function() {
        lockDisabled = false;
      }, 1);
      return;
    }
    guardCount++;
    focusOn(focusable.node, options2.focusOptions);
    guardCount--;
  }
};

// node_modules/react-focus-lock/dist/es2015/util.js
function deferAction(action) {
  setTimeout(action, 1);
}
var inlineProp = function inlineProp2(name2, value) {
  var obj = {};
  obj[name2] = value;
  return obj;
};

// node_modules/react-focus-lock/dist/es2015/Trap.js
var focusOnBody = function focusOnBody2() {
  return document && document.activeElement === document.body;
};
var isFreeFocus = function isFreeFocus2() {
  return focusOnBody() || focusIsHidden();
};
var lastActiveTrap = null;
var lastActiveFocus = null;
var lastPortaledElement = null;
var focusWasOutsideWindow = false;
var defaultWhitelist = function defaultWhitelist2() {
  return true;
};
var focusWhitelisted = function focusWhitelisted2(activeElement2) {
  return (lastActiveTrap.whiteList || defaultWhitelist)(activeElement2);
};
var recordPortal = function recordPortal2(observerNode, portaledElement) {
  lastPortaledElement = {
    observerNode,
    portaledElement
  };
};
var focusIsPortaledPair = function focusIsPortaledPair2(element) {
  return lastPortaledElement && lastPortaledElement.portaledElement === element;
};
function autoGuard(startIndex, end2, step, allNodes) {
  var lastGuard = null;
  var i2 = startIndex;
  do {
    var item = allNodes[i2];
    if (item.guard) {
      if (item.node.dataset.focusAutoGuard) {
        lastGuard = item;
      }
    } else if (item.lockItem) {
      if (i2 !== startIndex) {
        return;
      }
      lastGuard = null;
    } else {
      break;
    }
  } while ((i2 += step) !== end2);
  if (lastGuard) {
    lastGuard.node.tabIndex = 0;
  }
}
var extractRef = function extractRef2(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var focusWasOutside = function focusWasOutside2(crossFrameOption) {
  if (crossFrameOption) {
    return Boolean(focusWasOutsideWindow);
  }
  return focusWasOutsideWindow === "meanwhile";
};
var checkInHost = function checkInHost2(check, el, boundary) {
  return el && // find host equal to active element and check nested active element
  (el.host === check && (!el.activeElement || boundary.contains(el.activeElement)) || el.parentNode && checkInHost2(check, el.parentNode, boundary));
};
var withinHost = function withinHost2(activeElement2, workingArea) {
  return workingArea.some(function(area) {
    return checkInHost(activeElement2, area, area);
  });
};
var activateTrap = function activateTrap2() {
  var result = false;
  if (lastActiveTrap) {
    var _lastActiveTrap = lastActiveTrap, observed = _lastActiveTrap.observed, persistentFocus = _lastActiveTrap.persistentFocus, autoFocus = _lastActiveTrap.autoFocus, shards = _lastActiveTrap.shards, crossFrame = _lastActiveTrap.crossFrame, focusOptions = _lastActiveTrap.focusOptions;
    var workingNode = observed || lastPortaledElement && lastPortaledElement.portaledElement;
    var activeElement2 = document && document.activeElement;
    if (workingNode) {
      var workingArea = [workingNode].concat(shards.map(extractRef).filter(Boolean));
      if (!activeElement2 || focusWhitelisted(activeElement2)) {
        if (persistentFocus || focusWasOutside(crossFrame) || !isFreeFocus() || !lastActiveFocus && autoFocus) {
          if (workingNode && !// active element is "inside" working area
          (focusInside(workingArea) || // check for shadow-dom contained elements
          activeElement2 && withinHost(activeElement2, workingArea) || focusIsPortaledPair(activeElement2, workingNode))) {
            if (document && !lastActiveFocus && activeElement2 && !autoFocus) {
              if (activeElement2.blur) {
                activeElement2.blur();
              }
              document.body.focus();
            } else {
              result = moveFocusInside(workingArea, lastActiveFocus, {
                focusOptions
              });
              lastPortaledElement = {};
            }
          }
          focusWasOutsideWindow = false;
          lastActiveFocus = document && document.activeElement;
        }
      }
      if (document) {
        var newActiveElement = document && document.activeElement;
        var allNodes = expandFocusableNodes(workingArea);
        var focusedIndex = allNodes.map(function(_ref4) {
          var node3 = _ref4.node;
          return node3;
        }).indexOf(newActiveElement);
        if (focusedIndex > -1) {
          allNodes.filter(function(_ref23) {
            var guard = _ref23.guard, node3 = _ref23.node;
            return guard && node3.dataset.focusAutoGuard;
          }).forEach(function(_ref32) {
            var node3 = _ref32.node;
            return node3.removeAttribute("tabIndex");
          });
          autoGuard(focusedIndex, allNodes.length, 1, allNodes);
          autoGuard(focusedIndex, -1, -1, allNodes);
        }
      }
    }
  }
  return result;
};
var onTrap = function onTrap2(event) {
  if (activateTrap() && event) {
    event.stopPropagation();
    event.preventDefault();
  }
};
var onBlur = function onBlur2() {
  return deferAction(activateTrap);
};
var onFocus = function onFocus2(event) {
  var source = event.target;
  var currentNode = event.currentTarget;
  if (!currentNode.contains(source)) {
    recordPortal(currentNode, source);
  }
};
var FocusWatcher = function FocusWatcher2() {
  return null;
};
var FocusTrap = function FocusTrap2(_ref4) {
  var children = _ref4.children;
  return React22.createElement("div", {
    onBlur,
    onFocus
  }, children);
};
FocusTrap.propTypes = true ? {
  children: import_prop_types3.default.node.isRequired
} : {};
var onWindowBlur = function onWindowBlur2() {
  focusWasOutsideWindow = "just";
  deferAction(function() {
    focusWasOutsideWindow = "meanwhile";
  });
};
var attachHandler = function attachHandler2() {
  document.addEventListener("focusin", onTrap);
  document.addEventListener("focusout", onBlur);
  window.addEventListener("blur", onWindowBlur);
};
var detachHandler = function detachHandler2() {
  document.removeEventListener("focusin", onTrap);
  document.removeEventListener("focusout", onBlur);
  window.removeEventListener("blur", onWindowBlur);
};
function reducePropsToState(propsList) {
  return propsList.filter(function(_ref5) {
    var disabled = _ref5.disabled;
    return !disabled;
  });
}
function handleStateChangeOnClient(traps) {
  var trap = traps.slice(-1)[0];
  if (trap && !lastActiveTrap) {
    attachHandler();
  }
  var lastTrap = lastActiveTrap;
  var sameTrap = lastTrap && trap && trap.id === lastTrap.id;
  lastActiveTrap = trap;
  if (lastTrap && !sameTrap) {
    lastTrap.onDeactivation();
    if (!traps.filter(function(_ref6) {
      var id = _ref6.id;
      return id === lastTrap.id;
    }).length) {
      lastTrap.returnFocus(!trap);
    }
  }
  if (trap) {
    lastActiveFocus = null;
    if (!sameTrap || lastTrap.observed !== trap.observed) {
      trap.onActivation();
    }
    activateTrap(true);
    deferAction(activateTrap);
  } else {
    detachHandler();
    lastActiveFocus = null;
  }
}
mediumFocus.assignSyncMedium(onFocus);
mediumBlur.assignMedium(onBlur);
mediumEffect.assignMedium(function(cb) {
  return cb({
    moveFocusInside,
    focusInside
  });
});
var Trap_default = index_es_default(reducePropsToState, handleStateChangeOnClient)(FocusWatcher);

// node_modules/react-focus-lock/dist/es2015/Combination.js
var FocusLockCombination = React23.forwardRef(function FocusLockUICombination(props, ref) {
  return React23.createElement(Lock_default, _extends2({
    sideCar: Trap_default,
    ref
  }, props));
});
var _ref = Lock_default.propTypes || {};
var sideCar = _ref.sideCar;
var propTypes = _objectWithoutPropertiesLoose(_ref, ["sideCar"]);
FocusLockCombination.propTypes = true ? propTypes : {};
var Combination_default = FocusLockCombination;

// node_modules/react-focus-lock/dist/es2015/AutoFocusInside.js
var React24 = __toESM(require_react());
var import_prop_types4 = __toESM(require_prop_types());
var AutoFocusInside = function AutoFocusInside2(_ref4) {
  var _ref$disabled = _ref4.disabled, disabled = _ref$disabled === void 0 ? false : _ref$disabled, children = _ref4.children, _ref$className = _ref4.className, className = _ref$className === void 0 ? void 0 : _ref$className;
  return React24.createElement("div", _extends2({}, inlineProp(FOCUS_AUTO, !disabled), {
    className
  }), children);
};
AutoFocusInside.propTypes = true ? {
  children: import_prop_types4.default.node.isRequired,
  disabled: import_prop_types4.default.bool,
  className: import_prop_types4.default.string
} : {};

// node_modules/react-focus-lock/dist/es2015/MoveFocusInside.js
var React25 = __toESM(require_react());
var import_prop_types5 = __toESM(require_prop_types());
var useFocusInside = function useFocusInside2(observedRef) {
  React25.useEffect(function() {
    var enabled = true;
    mediumEffect.useMedium(function(car) {
      var observed = observedRef && observedRef.current;
      if (enabled && observed) {
        if (!car.focusInside(observed)) {
          car.moveFocusInside(observed, null);
        }
      }
    });
    return function() {
      enabled = false;
    };
  }, [observedRef]);
};
function MoveFocusInside(_ref4) {
  var isDisabled = _ref4.disabled, className = _ref4.className, children = _ref4.children;
  var ref = React25.useRef(null);
  useFocusInside(isDisabled ? void 0 : ref);
  return React25.createElement("div", _extends2({}, inlineProp(FOCUS_AUTO, !isDisabled), {
    ref,
    className
  }), children);
}
MoveFocusInside.propTypes = true ? {
  children: import_prop_types5.default.node.isRequired,
  disabled: import_prop_types5.default.bool,
  className: import_prop_types5.default.string
} : {};
MoveFocusInside.defaultProps = {
  disabled: false,
  className: void 0
};

// node_modules/react-focus-lock/dist/es2015/FreeFocusInside.js
var React26 = __toESM(require_react());
var import_prop_types6 = __toESM(require_prop_types());
var FreeFocusInside = function FreeFocusInside2(_ref4) {
  var children = _ref4.children, className = _ref4.className;
  return React26.createElement("div", _extends2({}, inlineProp(FOCUS_ALLOW, true), {
    className
  }), children);
};
FreeFocusInside.propTypes = true ? {
  children: import_prop_types6.default.node.isRequired,
  className: import_prop_types6.default.string
} : {};
FreeFocusInside.defaultProps = {
  className: void 0
};

// node_modules/react-focus-lock/dist/es2015/index.js
var es2015_default = Combination_default;

// node_modules/@neo4j-ndl/react/lib/esm/popover/Popover.js
var __rest15 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var getOffsetTop = (rect, vertical) => {
  let offset3 = 0;
  if (vertical === "bottom") {
    offset3 = rect.height;
  }
  return offset3;
};
var getOffsetLeft = (rect, horizontal) => {
  switch (horizontal) {
    case "right":
      return rect.width;
    case "center":
      return rect.width / 2;
    case "left":
      return 0;
  }
};
var Popover = (0, import_react26.forwardRef)(function Popover2(_a2, ref) {
  var { as = "div", children, open, anchorEl, onClose, anchorOrigin = { vertical: "bottom", horizontal: "left" }, transformOrigin = { vertical: "top", horizontal: "left" }, transformOriginOffsetFromAnchorOrigin = { vertical: 0, horizontal: 0 }, className, anchorPortal, disableBackdrop = false, nested = false, captureFocus = true, focusLockProps = {} } = _a2, restProps = __rest15(_a2, ["as", "children", "open", "anchorEl", "onClose", "anchorOrigin", "transformOrigin", "transformOriginOffsetFromAnchorOrigin", "className", "anchorPortal", "disableBackdrop", "nested", "captureFocus", "focusLockProps"]);
  const Component4 = as;
  const popoverRef = (0, import_react26.useRef)(null);
  const backdropRef = (0, import_react26.useRef)(null);
  const toggleScrollbar = useDocumentScrollToggle();
  const { themeClassName } = useNeedleTheme();
  useOnClickOutside(popoverRef, (event) => {
    disableBackdrop ? onClose && onClose(event) : null;
  });
  (0, import_react26.useImperativeHandle)(ref, () => {
    const popover = popoverRef.current;
    if (!popover) {
      return null;
    }
    return popover;
  });
  const [enter, setEnter] = (0, import_react26.useState)(false);
  const baseClasses = classNames({
    "ndl-open": open,
    "ndl-enter": enter
  });
  const getPositioningStyles = (0, import_react26.useCallback)(
    (element) => {
      const anchor2 = isRefObject(anchorEl) ? anchorEl.current : anchorEl;
      if (!(anchor2 instanceof HTMLElement)) {
        console.warn(anchorElNotSetWarningMessage);
        return;
      }
      const anchorRect = anchor2.getBoundingClientRect();
      const menuRect = {
        width: element.offsetWidth,
        height: element.offsetHeight
      };
      let transformX;
      switch (transformOrigin.horizontal) {
        case "right":
          transformX = -menuRect.width;
          break;
        case "center":
          transformX = -menuRect.width / 2;
          break;
        case "left":
          transformX = 0;
          break;
      }
      transformX += transformOriginOffsetFromAnchorOrigin.horizontal;
      const transformY = (transformOrigin.vertical == "bottom" ? -menuRect.height : 0) + transformOriginOffsetFromAnchorOrigin.vertical;
      const marginThreshold = 16;
      const heightThreshold = window.innerHeight - marginThreshold;
      const widthThreshold = window.innerWidth - marginThreshold;
      let top3 = anchorRect.top + getOffsetTop(anchorRect, anchorOrigin.vertical) + transformY;
      let left2 = anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal) + transformX;
      const right2 = left2 + menuRect.width;
      const bottom2 = top3 + menuRect.height;
      if (top3 < marginThreshold) {
        const diff = top3 - marginThreshold;
        top3 -= diff;
      } else if (bottom2 > heightThreshold) {
        const diff = bottom2 - heightThreshold;
        top3 -= diff;
      }
      if (left2 < marginThreshold) {
        const diff = left2 - marginThreshold;
        left2 -= diff;
      } else if (right2 > widthThreshold) {
        left2 = anchorRect.left - element.getBoundingClientRect().width;
      }
      return {
        top: top3,
        left: left2
      };
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [anchorOrigin, transformOrigin, anchorEl]
  );
  const setPositioningStyles = (0, import_react26.useCallback)(() => {
    const element = popoverRef.current;
    if (!element) {
      return;
    }
    const positioning = getPositioningStyles(element);
    if (!positioning)
      return;
    if (positioning.top !== null) {
      element.style.top = `${positioning.top}px`;
    }
    if (positioning.left !== null) {
      element.style.left = `${positioning.left}px`;
    }
  }, [getPositioningStyles]);
  (0, import_react26.useLayoutEffect)(() => {
    if (!popoverRef.current || !backdropRef.current)
      return;
    const targetNode = document.body;
    const popovers = [...targetNode.childNodes].filter((node3) => node3 instanceof HTMLElement && node3.classList.contains("ndl-popover") && node3 !== popoverRef.current);
    if (popovers.length > 0) {
      const max4 = Math.max(...popovers.map((node3) => parseInt(window.getComputedStyle(node3).zIndex)));
      const [backdrop, content2] = [max4 + 2, max4 + 3];
      popoverRef.current.style.zIndex = `${content2}`;
      backdropRef.current.style.zIndex = `${backdrop}`;
    }
  }, [popoverRef.current, backdropRef.current]);
  (0, import_react26.useEffect)(() => {
    if (nested) {
      return;
    }
    toggleScrollbar(open);
    return () => {
      if (nested)
        return;
      toggleScrollbar(false);
    };
  }, [open, nested, toggleScrollbar]);
  (0, import_react26.useEffect)(() => {
    if (open) {
      setPositioningStyles();
    }
  }, [open, setPositioningStyles]);
  (0, import_react26.useEffect)(() => setEnter(open), [open]);
  (0, import_react26.useEffect)(() => {
    if (!open) {
      return void 0;
    }
    const handleResize = debounce(() => {
      setPositioningStyles();
    });
    window.addEventListener("resize", handleResize);
    return () => {
      handleResize.clear();
      window.removeEventListener("resize", handleResize);
    };
  }, [anchorEl, open, setPositioningStyles]);
  const handleBackdropClick = (event) => {
    event.stopPropagation();
    event.preventDefault();
    onClose && onClose(event);
  };
  if (!open) {
    return null;
  }
  const classes = classNames("ndl-popover", themeClassName, baseClasses, className);
  const handleKeyDown = (event) => {
    if (event.key === "Escape") {
      onClose && onClose(event);
    }
  };
  const anchor = anchorEl.current ? anchorEl.current : anchorEl;
  return (0, import_jsx_runtime17.jsxs)(Portal, { container: anchorPortal ? anchor || void 0 : void 0, children: [(0, import_jsx_runtime17.jsx)("div", { className: classNames("ndl-popover-backdrop", {
    "ndl-allow-click-event-captured": disableBackdrop
  }), ref: backdropRef, role: "button", tabIndex: 0, onClick: handleBackdropClick, onKeyDown: handleBackdropClick, "data-testid": "ndl-popover-backdrop", "aria-label": "Close popover" }), (0, import_jsx_runtime17.jsx)(ConditionalWrap2, { condition: captureFocus, wrapper: (children2) => (0, import_jsx_runtime17.jsx)(es2015_default, Object.assign({ onDeactivation: () => {
    const anchor2 = isRefObject(anchorEl) ? anchorEl.current : anchorEl;
    if (!(anchor2 instanceof HTMLElement)) {
      console.warn(anchorElNotSetWarningMessage);
      return;
    }
    setTimeout(() => anchor2 === null || anchor2 === void 0 ? void 0 : anchor2.focus(), 0);
  } }, focusLockProps, { children: children2 })), children: (0, import_jsx_runtime17.jsx)(Component4, Object.assign({ "data-testid": "ndl-popover-content" }, restProps, { className: classes, onKeyDown: handleKeyDown, ref: popoverRef, children })) })] });
});

// node_modules/@neo4j-ndl/react/lib/esm/context-menu/SafeArea.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var import_react27 = __toESM(require_react());
var DEBUG = false;
var ARBITRARY_OFFSET = 2;
var SafeArea = (0, import_react27.forwardRef)((props, ref) => {
  const { mouse, nestedRect, anchorRect } = props.area;
  const svgHeight = nestedRect.height;
  const position2 = mouse.x < nestedRect.x ? "right" : "left";
  const svgWidth = position2 === "right" ? nestedRect.x - mouse.x + 4 : mouse.x - nestedRect.x - nestedRect.width;
  const belowStartingY = anchorRect.y + anchorRect.height - nestedRect.y;
  const aboveHeight = anchorRect.y - nestedRect.y;
  const distance = position2 === "right" ? mouse.x - anchorRect.x : anchorRect.x + anchorRect.width - mouse.x;
  const factor = (anchorRect.width - distance) / anchorRect.width;
  const svgBox = {
    width: svgWidth,
    height: svgHeight,
    top: nestedRect.y,
    left: position2 === "right" ? mouse.x - ARBITRARY_OFFSET : nestedRect.x + nestedRect.width + ARBITRARY_OFFSET,
    position: "fixed",
    zIndex: 1e9,
    pointerEvents: "none",
    transform: position2 === "right" ? "none" : "scaleX(-1)",
    border: DEBUG ? "1px #212121 solid" : "none"
  };
  return (0, import_jsx_runtime18.jsxs)("svg", { ref, className: "svg-triangle", style: svgBox, id: "svg-hit-area", children: [(0, import_jsx_runtime18.jsxs)("defs", { children: [(0, import_jsx_runtime18.jsxs)("linearGradient", { id: "safe", x1: "0%", y1: "0%", x2: "100%", y2: "0%", children: [(0, import_jsx_runtime18.jsx)("stop", { offset: "0%", style: { stopColor: tokens.colors.baltic["60"], stopOpacity: 1 } }), (0, import_jsx_runtime18.jsx)("stop", { offset: "100%", style: {
    stopColor: tokens.colors.baltic["50"],
    stopOpacity: 0
  } })] }), (0, import_jsx_runtime18.jsxs)("linearGradient", { id: "unsafe", x1: "0%", y1: "0%", x2: "100%", y2: "0%", children: [(0, import_jsx_runtime18.jsx)("stop", { offset: "0%", style: { stopColor: tokens.colors.hibiscus["50"], stopOpacity: 1 } }), (0, import_jsx_runtime18.jsx)("stop", { offset: "100%", style: {
    stopColor: tokens.colors.hibiscus["50"],
    stopOpacity: 0
  } })] })] }), (0, import_jsx_runtime18.jsx)("path", { pointerEvents: "none", width: "100%", height: "100%", fill: DEBUG ? "url(#unsafe)" : "transparent", d: `M 0,0 L ${svgWidth},0 L ${svgWidth},${svgHeight} L 0,${svgHeight} z` }), (0, import_jsx_runtime18.jsx)("path", {
    onMouseMove: props.onMouseMove,
    pointerEvents: "auto",
    stroke: DEBUG ? "black" : "none",
    strokeWidth: "0.4",
    fill: DEBUG ? "url(#safe)" : "transparent",
    // prettier-ignore
    d: `M 0, ${aboveHeight + 10}
        Q ${svgWidth * 0.7},${(anchorRect.y - nestedRect.y) * (1 - 0.4 * factor)} ${svgWidth},0
        L ${svgWidth},${aboveHeight}
        L 0, ${aboveHeight + 10} z
        `
  }), (0, import_jsx_runtime18.jsx)("path", {
    onMouseMove: props.onMouseMove,
    pointerEvents: "auto",
    stroke: DEBUG ? "black" : "none",
    strokeWidth: "0.4",
    fill: DEBUG ? "url(#safe)" : "transparent",
    // prettier-ignore
    d: `M 0, ${belowStartingY - 10} 
            Q ${svgWidth * 0.7},${belowStartingY + (svgHeight - belowStartingY) * (0.4 * factor)} ${svgWidth},${svgHeight}
            L ${svgWidth},${belowStartingY}
            L 0, ${belowStartingY - 10} z
           `
  })] });
});
SafeArea.displayName = "SafeArea";

// node_modules/@neo4j-ndl/react/lib/esm/context-menu/ContextMenu.js
var __rest16 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var MenuContext = import_react28.default.createContext(null);
var useMenuContext = () => {
  const context = (0, import_react28.useContext)(MenuContext);
  if (context === null) {
    throw new Error("Menu used without context. Did you render this component inside a <Menu />?");
  }
  return context;
};
var MenuComponent = import_react28.default.forwardRef(function MenuComponent2(_a2, ref) {
  var { size: size3 = "small", className, minWidth = 250, open, onClose, children, level = 0, nested } = _a2, rest = __rest16(_a2, ["size", "className", "minWidth", "open", "onClose", "children", "level", "nested"]);
  const menuRef = (0, import_react28.useRef)();
  const focus = (0, import_react28.useCallback)(() => {
    const menu = menuRef.current;
    if (!menu)
      return;
    const menuItems = menu.querySelectorAll(":scope > .ndl-menu-items");
    const menuItemsItems = menu.querySelectorAll(":scope > .ndl-menu-items > .ndl-menu-item");
    if (menuItemsItems.length > 0 && menu.className.includes("nested-menu")) {
      menuItemsItems[0].focus();
      return;
    }
    if (menuItems.length > 0) {
      menuItems[0].focus();
      return;
    }
    menu.focus();
  }, []);
  (0, import_react28.useImperativeHandle)(ref, () => {
    const menu = menuRef.current;
    if (!menu) {
      return null;
    }
    return Object.assign(Object.assign({}, menu), { getElem: () => menu, focus });
  });
  (0, import_react28.useEffect)(() => {
    if (open && !nested) {
      focus();
    }
  }, [open, nested, focus]);
  const { themeClassName } = useNeedleTheme();
  const classes = classNames("ndl-menu", themeClassName, {
    "ndl-small": size3 === "small",
    "ndl-large": size3 === "large"
  }, className);
  return (0, import_jsx_runtime19.jsx)(MenuContext.Provider, { value: { onClose, level, size: size3 }, children: (0, import_jsx_runtime19.jsx)(Popover, Object.assign({ tabIndex: -1, captureFocus: false }, rest, { open, style: Object.assign({ minWidth }, rest.style || {}), className: classes, ref: menuRef, onClose, children })) });
});
MenuComponent.displayName = "Menu";
var getMenuItem = (menuItems, iterator) => {
  const activeElement2 = document.activeElement;
  let newEl = iterator(menuItems, activeElement2);
  let menuItem = null;
  for (let i2 = 0; i2 < 10; i2++) {
    if (!newEl) {
      return null;
    }
    const role = newEl.getAttribute("role");
    if (role === "menuitem") {
      menuItem = newEl;
      break;
    }
    newEl = iterator(menuItems, newEl);
  }
  return menuItem;
};
var nextElement2 = (menuItems, currentEl) => {
  if (currentEl === menuItems || !(currentEl === null || currentEl === void 0 ? void 0 : currentEl.nextElementSibling)) {
    return menuItems.firstChild ? menuItems.firstChild : null;
  } else if (currentEl === null || currentEl === void 0 ? void 0 : currentEl.nextElementSibling) {
    const nextItem = currentEl.nextElementSibling;
    return currentEl.nextElementSibling.className.includes("ndl-disabled") ? nextElement2(menuItems, nextItem) : nextItem;
  }
  return null;
};
var prevElement = (menuItems, currentEl) => {
  if (currentEl === menuItems || !(currentEl === null || currentEl === void 0 ? void 0 : currentEl.previousElementSibling)) {
    return menuItems.lastChild ? menuItems.lastChild : null;
  } else if (currentEl === null || currentEl === void 0 ? void 0 : currentEl.previousElementSibling) {
    const prevItem = currentEl.previousElementSibling;
    return currentEl.previousElementSibling.className.includes("ndl-disabled") ? prevElement(menuItems, prevItem) : prevItem;
  }
  return null;
};
function getAllSiblings(element) {
  var _a2;
  const children = [...((_a2 = element.parentNode) === null || _a2 === void 0 ? void 0 : _a2.children) || []];
  return children.filter((child) => child !== element && child.tagName !== "svg");
}
var MenuItems = import_react28.default.forwardRef(function MenuItems2(_a2, ref) {
  var { as = "ul", children, className } = _a2, rest = __rest16(_a2, ["as", "children", "className"]);
  const menuItemsRef = (0, import_react28.useRef)();
  const { onClose } = useMenuContext();
  const handleKeyDown = (event) => {
    const menuItems = menuItemsRef.current;
    if (!menuItems) {
      return;
    }
    if (event.key == "ArrowDown") {
      event.preventDefault();
      event.stopPropagation();
      const newFocusedElement = getMenuItem(menuItems, nextElement2);
      newFocusedElement === null || newFocusedElement === void 0 ? void 0 : newFocusedElement.focus();
    } else if (event.key == "ArrowUp") {
      event.preventDefault();
      event.stopPropagation();
      const newFocusedElement = getMenuItem(menuItems, prevElement);
      newFocusedElement === null || newFocusedElement === void 0 ? void 0 : newFocusedElement.focus();
    } else if (event.key == "Escape") {
      event.preventDefault();
      event.stopPropagation();
      onClose && onClose(event);
    }
  };
  (0, import_react28.useImperativeHandle)(ref, () => menuItemsRef.current);
  const Component4 = as;
  const classes = classNames("ndl-menu-items", className);
  return (0, import_jsx_runtime19.jsx)(Component4, Object.assign({ tabIndex: -1, onKeyDown: handleKeyDown, role: "menu" }, rest, { className: classes, ref: menuItemsRef, children }));
});
MenuItems.displayName = "Menu.Items";
var isNested = (props) => {
  return !!props.children;
};
var MenuItem = import_react28.default.forwardRef(function MenuItem2(props, ref) {
  if (isNested(props)) {
    return (0, import_jsx_runtime19.jsx)(NestedMenuItem, Object.assign({}, props, { ref }));
  }
  return (0, import_jsx_runtime19.jsx)(StandardMenuItem, Object.assign({}, props, { ref }));
});
MenuItem.displayName = "Menu.Item";
var StandardMenuItem = import_react28.default.forwardRef(function MenuItem3(_a2, ref) {
  var { as = "li", icon, title, description, className, disabled = false, nested = false, onClick, onKeyDown } = _a2, rest = __rest16(_a2, ["as", "icon", "title", "description", "className", "disabled", "nested", "onClick", "onKeyDown"]);
  const Component4 = as;
  const classes = classNames(`ndl-menu-item n-flex n-flex-col`, className, {
    "ndl-disabled": disabled,
    nested
  });
  const handleClick = (e4) => {
    if (disabled) {
      e4.preventDefault();
      return;
    }
    if (onClick)
      onClick(e4);
  };
  const handleKeyDown = (e4) => {
    if (onKeyDown)
      onKeyDown(e4);
    if (e4.key === "Enter") {
      if (disabled) {
        e4.preventDefault();
        return;
      }
      if (onClick)
        onClick(e4);
    }
  };
  return (0, import_jsx_runtime19.jsx)(Component4, Object.assign({ tabIndex: -1, role: "menuitem" }, rest, { className: classes, onClick: handleClick, onKeyDown: handleKeyDown, ref, children: (0, import_jsx_runtime19.jsxs)("div", { className: "n-flex n-flex-row n-gap-token-4", children: [icon && (0, import_jsx_runtime19.jsx)("div", { className: "ndl-menu-item-icon", children: icon }), (0, import_jsx_runtime19.jsxs)("div", { className: "n-flex n-flex-col n-gap-token-2 n-w-full", children: [(0, import_jsx_runtime19.jsx)("div", { className: "ndl-menu-item-title", children: title }), description && (0, import_jsx_runtime19.jsx)("div", { className: "ndl-menu-item-description", children: description })] })] }) }));
});
var MenuHeader = import_react28.default.forwardRef(function MenuHeader2(_a2, ref) {
  var { as = "div", title, description, className } = _a2, rest = __rest16(_a2, ["as", "title", "description", "className"]);
  const Component4 = as;
  const { onClose, size: size3 } = useMenuContext();
  const handleClose2 = (e4) => onClose && onClose(e4);
  const classes = classNames("ndl-menu-header n-flex n-flex-col", className);
  return (0, import_jsx_runtime19.jsxs)(Component4, Object.assign({}, rest, { className: classes, ref, children: [(0, import_jsx_runtime19.jsxs)("div", { className: "n-flex n-justify-between n-items-center", children: [(0, import_jsx_runtime19.jsx)("div", { className: "ndl-menu-header-title", children: title }), (0, import_jsx_runtime19.jsx)(IconButton, { clean: true, tabIndex: 0, onKeyDown: handleClose2, onClick: handleClose2, size: size3, children: (0, import_jsx_runtime19.jsx)(import_XMarkIcon.default, {}) })] }), description && (0, import_jsx_runtime19.jsx)("div", { className: "ndl-menu-header-description", children: description })] }));
});
MenuHeader.displayName = "Menu.Header";
var MenuDivider = () => (0, import_jsx_runtime19.jsx)("div", { className: "ndl-menu-divider" });
MenuDivider.displayName = "Menu.Divider";
var MenuSubheader = (props) => (0, import_jsx_runtime19.jsx)("div", { className: "ndl-menu-subheader", children: (0, import_jsx_runtime19.jsx)("div", { className: "ndl-menu-subheader-title", children: props.title }) });
MenuSubheader.displayName = "Menu.Subheader";
var NestedMenuItem = import_react28.default.forwardRef(function NestedMenuItem2(_a2, ref) {
  var { title, className, children, disabled, safeArea = true } = _a2, props = __rest16(_a2, ["title", "className", "children", "disabled", "safeArea"]);
  const [nestedAnchorEl, setNestedAnchorEl] = (0, import_react28.useState)(null);
  const nestedMenuRef = (0, import_react28.useRef)(null);
  const menuItemRef = (0, import_react28.useRef)(null);
  const [safe, setSafe] = (0, import_react28.useState)(void 0);
  const svgRef = (0, import_react28.useRef)(null);
  const { level } = useMenuContext();
  const levelClass = `nested-level-${level}`;
  (0, import_react28.useImperativeHandle)(ref, () => menuItemRef.current);
  const handleNestedOpen = (event) => {
    if (disabled)
      return;
    setNestedAnchorEl(event.currentTarget);
    if (!menuItemRef.current)
      return;
    const siblings = getAllSiblings(menuItemRef.current);
    siblings.forEach((sibling) => {
      if (sibling instanceof HTMLElement)
        sibling.focus();
      if (sibling instanceof HTMLElement)
        sibling.blur();
    });
  };
  const handleNestedClose = (0, import_react28.useCallback)(() => {
    var _a3;
    if (safe)
      return;
    (_a3 = menuItemRef.current) === null || _a3 === void 0 ? void 0 : _a3.focus();
  }, [safe]);
  const handleNestedFocus = (event) => {
    if (disabled)
      return;
    const el = event.currentTarget;
    setNestedAnchorEl(el);
    el.focus();
  };
  const handleNestedMouseLeave = (0, import_react28.useCallback)((event) => {
    var _a3;
    if (event.relatedTarget instanceof SVGPathElement && ((_a3 = event.relatedTarget.parentElement) === null || _a3 === void 0 ? void 0 : _a3.previousElementSibling) === menuItemRef.current) {
      return;
    }
    const el = event.relatedTarget;
    if (el instanceof Element && el.closest(`.${levelClass}`)) {
      setSafe(void 0);
      return;
    }
    setSafe(void 0);
    setNestedAnchorEl(null);
  }, [levelClass]);
  const handleNestedBlur = (event) => {
    const el = event.relatedTarget;
    if (el === null || el === void 0 ? void 0 : el.closest(`.${levelClass}`)) {
      return;
    }
    setNestedAnchorEl(null);
  };
  const handleMenuItemKeyDown = (event) => {
    var _a3, _b;
    if (event.key === "ArrowRight") {
      event.preventDefault();
      event.stopPropagation();
      (_a3 = nestedMenuRef.current) === null || _a3 === void 0 ? void 0 : _a3.focus();
    }
    if (event.key === "Tab") {
      event.preventDefault();
      event.stopPropagation();
      (_b = nestedMenuRef.current) === null || _b === void 0 ? void 0 : _b.focus();
    }
  };
  const handleNestedMenuKeyDown = (event) => {
    if (event.key === "ArrowLeft" || event.key === "Escape") {
      event.preventDefault();
      event.stopPropagation();
      nestedAnchorEl === null || nestedAnchorEl === void 0 ? void 0 : nestedAnchorEl.focus();
    }
  };
  const nestedMenuProps = {
    className: `nested-menu ${levelClass}`,
    open: Boolean(nestedAnchorEl),
    anchorEl: nestedAnchorEl,
    onClose: handleNestedClose,
    onMouseLeave: handleNestedClose,
    onKeyDown: handleNestedMenuKeyDown,
    disableBackdrop: true,
    ref: nestedMenuRef,
    nested: true,
    level: level + 1
  };
  const handleMouseMove = (event) => {
    var _a3;
    if (!nestedMenuRef.current)
      return;
    const nested = nestedMenuRef.current.getElem();
    if (event.nativeEvent instanceof MouseEvent && nestedMenuRef.current && menuItemRef.current) {
      setSafe({
        mouse: {
          x: event.nativeEvent.clientX,
          y: event.nativeEvent.clientY
        },
        nestedRect: nested.getBoundingClientRect(),
        anchorRect: menuItemRef.current.getBoundingClientRect()
      });
    }
    (_a3 = nestedMenuRef.current) === null || _a3 === void 0 ? void 0 : _a3.focus();
  };
  const deleteSafeArea = (0, import_react28.useCallback)(debounce(() => {
    setSafe(void 0);
  }, 200), [setSafe]);
  return (0, import_jsx_runtime19.jsxs)(import_jsx_runtime19.Fragment, { children: [(0, import_jsx_runtime19.jsx)(StandardMenuItem, Object.assign({}, props, { title: (0, import_jsx_runtime19.jsxs)("span", { className: "n-flex n-justify-between n-items-center", children: [(0, import_jsx_runtime19.jsx)("span", { children: title }), (0, import_jsx_runtime19.jsx)("span", { className: "n-text-palette-neutral-text-weak", children: (0, import_jsx_runtime19.jsx)(import_ChevronRightIcon.default, { className: "n-h-4 n-w-4" }) })] }), onMouseOver: handleNestedOpen, onMouseMove: handleMouseMove, onMouseLeave: handleNestedMouseLeave, onFocus: handleNestedFocus, onBlur: handleNestedBlur, onKeyDown: handleMenuItemKeyDown, className: classNames(className, {
    "ndl-nested-open": !!nestedAnchorEl
  }), ref: menuItemRef, disabled })), safeArea && safe && safe.mouse && (0, import_jsx_runtime19.jsx)(SafeArea, { onMouseMove: () => {
    var _a3;
    (_a3 = nestedMenuRef.current) === null || _a3 === void 0 ? void 0 : _a3.focus();
    deleteSafeArea();
  }, area: safe, ref: svgRef }), children({ nestedMenuProps })] });
});
var Menu = Object.assign(MenuComponent, {
  Divider: MenuDivider,
  Subheader: MenuSubheader,
  Header: MenuHeader,
  Item: MenuItem,
  Items: MenuItems
});

// node_modules/@neo4j-ndl/react/lib/esm/date-picker/DatePicker.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime());
var import_react32 = __toESM(require_react());

// node_modules/react-datepicker/dist/es/index.js
var import_react30 = __toESM(require_react());
var import_prop_types7 = __toESM(require_prop_types());
var import_classnames2 = __toESM(require_classnames());

// node_modules/date-fns/esm/_lib/requiredArgs/index.js
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}

// node_modules/date-fns/esm/isDate/index.js
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || _typeof(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
}

// node_modules/date-fns/esm/toDate/index.js
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || _typeof(argument) === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
      console.warn(new Error().stack);
    }
    return /* @__PURE__ */ new Date(NaN);
  }
}

// node_modules/date-fns/esm/isValid/index.js
function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}

// node_modules/date-fns/esm/_lib/toInteger/index.js
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number2 = Number(dirtyNumber);
  if (isNaN(number2)) {
    return number2;
  }
  return number2 < 0 ? Math.ceil(number2) : Math.floor(number2);
}

// node_modules/date-fns/esm/addMilliseconds/index.js
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}

// node_modules/date-fns/esm/subMilliseconds/index.js
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}

// node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js
var MILLISECONDS_IN_DAY = 864e5;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}

// node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = /* @__PURE__ */ new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js
var MILLISECONDS_IN_WEEK = 6048e5;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

// node_modules/date-fns/esm/_lib/defaultOptions/index.js
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}

// node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js
function startOfUTCWeek(dirtyDate, options2) {
  var _ref4, _ref23, _ref32, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions3 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref4 = (_ref23 = (_ref32 = (_options$weekStartsOn = options2 === null || options2 === void 0 ? void 0 : options2.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options2 === null || options2 === void 0 ? void 0 : (_options$locale = options2.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref32 !== void 0 ? _ref32 : defaultOptions3.weekStartsOn) !== null && _ref23 !== void 0 ? _ref23 : (_defaultOptions$local = defaultOptions3.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref4 !== void 0 ? _ref4 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js
function getUTCWeekYear(dirtyDate, options2) {
  var _ref4, _ref23, _ref32, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions3 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref4 = (_ref23 = (_ref32 = (_options$firstWeekCon = options2 === null || options2 === void 0 ? void 0 : options2.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options2 === null || options2 === void 0 ? void 0 : (_options$locale = options2.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref32 !== void 0 ? _ref32 : defaultOptions3.firstWeekContainsDate) !== null && _ref23 !== void 0 ? _ref23 : (_defaultOptions$local = defaultOptions3.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = /* @__PURE__ */ new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options2);
  var firstWeekOfThisYear = /* @__PURE__ */ new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options2);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js
function startOfUTCWeekYear(dirtyDate, options2) {
  var _ref4, _ref23, _ref32, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions3 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref4 = (_ref23 = (_ref32 = (_options$firstWeekCon = options2 === null || options2 === void 0 ? void 0 : options2.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options2 === null || options2 === void 0 ? void 0 : (_options$locale = options2.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref32 !== void 0 ? _ref32 : defaultOptions3.firstWeekContainsDate) !== null && _ref23 !== void 0 ? _ref23 : (_defaultOptions$local = defaultOptions3.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : 1);
  var year = getUTCWeekYear(dirtyDate, options2);
  var firstWeek = /* @__PURE__ */ new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, options2);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCWeek/index.js
var MILLISECONDS_IN_WEEK2 = 6048e5;
function getUTCWeek(dirtyDate, options2) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options2).getTime() - startOfUTCWeekYear(date, options2).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK2) + 1;
}

// node_modules/date-fns/esm/_lib/addLeadingZeros/index.js
function addLeadingZeros(number2, targetLength) {
  var sign = number2 < 0 ? "-" : "";
  var output = Math.abs(number2).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign + output;
}

// node_modules/date-fns/esm/_lib/format/lightFormatters/index.js
var formatters = {
  // Year
  y: function y(date, token2) {
    var signedYear = date.getUTCFullYear();
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token2 === "yy" ? year % 100 : year, token2.length);
  },
  // Month
  M: function M(date, token2) {
    var month = date.getUTCMonth();
    return token2 === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d: function d(date, token2) {
    return addLeadingZeros(date.getUTCDate(), token2.length);
  },
  // AM or PM
  a: function a(date, token2) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (token2) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h: function h(date, token2) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token2.length);
  },
  // Hour [0-23]
  H: function H(date, token2) {
    return addLeadingZeros(date.getUTCHours(), token2.length);
  },
  // Minute
  m: function m(date, token2) {
    return addLeadingZeros(date.getUTCMinutes(), token2.length);
  },
  // Second
  s: function s(date, token2) {
    return addLeadingZeros(date.getUTCSeconds(), token2.length);
  },
  // Fraction of second
  S: function S(date, token2) {
    var numberOfDigits = token2.length;
    var milliseconds2 = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds2 * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token2.length);
  }
};
var lightFormatters_default = formatters;

// node_modules/date-fns/esm/_lib/format/formatters/index.js
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters2 = {
  // Era
  G: function G(date, token2, localize2) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token2) {
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, {
          width: "abbreviated"
        });
      case "GGGGG":
        return localize2.era(era, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return localize2.era(era, {
          width: "wide"
        });
    }
  },
  // Year
  y: function y2(date, token2, localize2) {
    if (token2 === "yo") {
      var signedYear = date.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, {
        unit: "year"
      });
    }
    return lightFormatters_default.y(date, token2);
  },
  // Local week-numbering year
  Y: function Y(date, token2, localize2, options2) {
    var signedWeekYear = getUTCWeekYear(date, options2);
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token2 === "YY") {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token2 === "Yo") {
      return localize2.ordinalNumber(weekYear, {
        unit: "year"
      });
    }
    return addLeadingZeros(weekYear, token2.length);
  },
  // ISO week-numbering year
  R: function R(date, token2) {
    var isoWeekYear = getUTCISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token2.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function u(date, token2) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token2.length);
  },
  // Quarter
  Q: function Q(date, token2, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token2) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function q(date, token2, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token2) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function M2(date, token2, localize2) {
    var month = date.getUTCMonth();
    switch (token2) {
      case "M":
      case "MM":
        return lightFormatters_default.M(date, token2);
      case "Mo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone month
  L: function L(date, token2, localize2) {
    var month = date.getUTCMonth();
    switch (token2) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Local week of year
  w: function w(date, token2, localize2, options2) {
    var week = getUTCWeek(date, options2);
    if (token2 === "wo") {
      return localize2.ordinalNumber(week, {
        unit: "week"
      });
    }
    return addLeadingZeros(week, token2.length);
  },
  // ISO week of year
  I: function I(date, token2, localize2) {
    var isoWeek = getUTCISOWeek(date);
    if (token2 === "Io") {
      return localize2.ordinalNumber(isoWeek, {
        unit: "week"
      });
    }
    return addLeadingZeros(isoWeek, token2.length);
  },
  // Day of the month
  d: function d2(date, token2, localize2) {
    if (token2 === "do") {
      return localize2.ordinalNumber(date.getUTCDate(), {
        unit: "date"
      });
    }
    return lightFormatters_default.d(date, token2);
  },
  // Day of year
  D: function D(date, token2, localize2) {
    var dayOfYear = getUTCDayOfYear(date);
    if (token2 === "Do") {
      return localize2.ordinalNumber(dayOfYear, {
        unit: "dayOfYear"
      });
    }
    return addLeadingZeros(dayOfYear, token2.length);
  },
  // Day of week
  E: function E(date, token2, localize2) {
    var dayOfWeek = date.getUTCDay();
    switch (token2) {
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function e(date, token2, localize2, options2) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options2.weekStartsOn + 8) % 7 || 7;
    switch (token2) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function c(date, token2, localize2, options2) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options2.weekStartsOn + 8) % 7 || 7;
    switch (token2) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token2.length);
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function i(date, token2, localize2) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token2) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token2.length);
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, {
          unit: "day"
        });
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function a2(date, token2, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token2) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function b(date, token2, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token2) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function B(date, token2, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token2) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function h2(date, token2, localize2) {
    if (token2 === "ho") {
      var hours = date.getUTCHours() % 12;
      if (hours === 0)
        hours = 12;
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return lightFormatters_default.h(date, token2);
  },
  // Hour [0-23]
  H: function H2(date, token2, localize2) {
    if (token2 === "Ho") {
      return localize2.ordinalNumber(date.getUTCHours(), {
        unit: "hour"
      });
    }
    return lightFormatters_default.H(date, token2);
  },
  // Hour [0-11]
  K: function K(date, token2, localize2) {
    var hours = date.getUTCHours() % 12;
    if (token2 === "Ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token2.length);
  },
  // Hour [1-24]
  k: function k(date, token2, localize2) {
    var hours = date.getUTCHours();
    if (hours === 0)
      hours = 24;
    if (token2 === "ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token2.length);
  },
  // Minute
  m: function m2(date, token2, localize2) {
    if (token2 === "mo") {
      return localize2.ordinalNumber(date.getUTCMinutes(), {
        unit: "minute"
      });
    }
    return lightFormatters_default.m(date, token2);
  },
  // Second
  s: function s2(date, token2, localize2) {
    if (token2 === "so") {
      return localize2.ordinalNumber(date.getUTCSeconds(), {
        unit: "second"
      });
    }
    return lightFormatters_default.s(date, token2);
  },
  // Fraction of second
  S: function S2(date, token2) {
    return lightFormatters_default.S(date, token2);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function X(date, token2, _localize, options2) {
    var originalDate = options2._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token2) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function x(date, token2, _localize, options2) {
    var originalDate = options2._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token2) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function O(date, token2, _localize, options2) {
    var originalDate = options2._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token2) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function z(date, token2, _localize, options2) {
    var originalDate = options2._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token2) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function t(date, token2, _localize, options2) {
    var originalDate = options2._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1e3);
    return addLeadingZeros(timestamp, token2.length);
  },
  // Milliseconds timestamp
  T: function T(date, token2, _localize, options2) {
    var originalDate = options2._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token2.length);
  }
};
function formatTimezoneShort(offset3, dirtyDelimiter) {
  var sign = offset3 > 0 ? "-" : "+";
  var absOffset = Math.abs(offset3);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  var delimiter2 = dirtyDelimiter || "";
  return sign + String(hours) + delimiter2 + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset3, dirtyDelimiter) {
  if (offset3 % 60 === 0) {
    var sign = offset3 > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset3) / 60, 2);
  }
  return formatTimezone(offset3, dirtyDelimiter);
}
function formatTimezone(offset3, dirtyDelimiter) {
  var delimiter2 = dirtyDelimiter || "";
  var sign = offset3 > 0 ? "-" : "+";
  var absOffset = Math.abs(offset3);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter2 + minutes;
}
var formatters_default = formatters2;

// node_modules/date-fns/esm/_lib/format/longFormatters/index.js
var dateLongFormatter = function dateLongFormatter2(pattern, formatLong2) {
  switch (pattern) {
    case "P":
      return formatLong2.date({
        width: "short"
      });
    case "PP":
      return formatLong2.date({
        width: "medium"
      });
    case "PPP":
      return formatLong2.date({
        width: "long"
      });
    case "PPPP":
    default:
      return formatLong2.date({
        width: "full"
      });
  }
};
var timeLongFormatter = function timeLongFormatter2(pattern, formatLong2) {
  switch (pattern) {
    case "p":
      return formatLong2.time({
        width: "short"
      });
    case "pp":
      return formatLong2.time({
        width: "medium"
      });
    case "ppp":
      return formatLong2.time({
        width: "long"
      });
    case "pppp":
    default:
      return formatLong2.time({
        width: "full"
      });
  }
};
var dateTimeLongFormatter = function dateTimeLongFormatter2(pattern, formatLong2) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({
        width: "short"
      });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({
        width: "full"
      });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var longFormatters_default = longFormatters;

// node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}

// node_modules/date-fns/esm/_lib/protectedTokens/index.js
var protectedDayOfYearTokens = ["D", "DD"];
var protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(token2) {
  return protectedDayOfYearTokens.indexOf(token2) !== -1;
}
function isProtectedWeekYearToken(token2) {
  return protectedWeekYearTokens.indexOf(token2) !== -1;
}
function throwProtectedError(token2, format3, input) {
  if (token2 === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format3, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token2 === "YY") {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format3, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token2 === "D") {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format3, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token2 === "DD") {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format3, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}

// node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = function formatDistance2(token2, count2, options2) {
  var result;
  var tokenValue = formatDistanceLocale[token2];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count2 === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count2.toString());
  }
  if (options2 !== null && options2 !== void 0 && options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
var formatDistance_default = formatDistance;

// node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js
function buildFormatLongFn(args) {
  return function() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options2.width ? String(options2.width) : args.defaultWidth;
    var format3 = args.formats[width] || args.formats[args.defaultWidth];
    return format3;
  };
}

// node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
var formatLong_default = formatLong;

// node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = function formatRelative2(token2, _date, _baseDate, _options) {
  return formatRelativeLocale[token2];
};
var formatRelative_default = formatRelative;

// node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js
function buildLocalizeFn(args) {
  return function(dirtyIndex, options2) {
    var context = options2 !== null && options2 !== void 0 && options2.context ? String(options2.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options2 !== null && options2 !== void 0 && options2.width ? String(options2.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options2 !== null && options2 !== void 0 && options2.width ? String(options2.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index4 = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index4];
  };
}

// node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = function ordinalNumber2(dirtyNumber, _options) {
  var number2 = Number(dirtyNumber);
  var rem100 = number2 % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number2 + "st";
      case 2:
        return number2 + "nd";
      case 3:
        return number2 + "rd";
    }
  }
  return number2 + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
var localize_default = localize;

// node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js
function buildMatchFn(args) {
  return function(string3) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options2.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string3.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options2.valueCallback ? options2.valueCallback(value) : value;
    var rest = string3.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function findKey(object2, predicate) {
  for (var key in object2) {
    if (object2.hasOwnProperty(key) && predicate(object2[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}

// node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js
function buildMatchPatternFn(args) {
  return function(string3) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string3.match(args.matchPattern);
    if (!matchResult)
      return null;
    var matchedString = matchResult[0];
    var parseResult = string3.match(args.parsePattern);
    if (!parseResult)
      return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options2.valueCallback ? options2.valueCallback(value) : value;
    var rest = string3.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}

// node_modules/date-fns/esm/locale/en-US/_lib/match/index.js
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function valueCallback2(index4) {
      return index4 + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
var match_default = match;

// node_modules/date-fns/esm/locale/en-US/index.js
var locale = {
  code: "en-US",
  formatDistance: formatDistance_default,
  formatLong: formatLong_default,
  formatRelative: formatRelative_default,
  localize: localize_default,
  match: match_default,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var en_US_default = locale;

// node_modules/date-fns/esm/_lib/defaultLocale/index.js
var defaultLocale_default = en_US_default;

// node_modules/date-fns/esm/format/index.js
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(dirtyDate, dirtyFormatStr, options2) {
  var _ref4, _options$locale, _ref23, _ref32, _ref42, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var defaultOptions3 = getDefaultOptions();
  var locale2 = (_ref4 = (_options$locale = options2 === null || options2 === void 0 ? void 0 : options2.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions3.locale) !== null && _ref4 !== void 0 ? _ref4 : defaultLocale_default;
  var firstWeekContainsDate = toInteger((_ref23 = (_ref32 = (_ref42 = (_options$firstWeekCon = options2 === null || options2 === void 0 ? void 0 : options2.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options2 === null || options2 === void 0 ? void 0 : (_options$locale2 = options2.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref42 !== void 0 ? _ref42 : defaultOptions3.firstWeekContainsDate) !== null && _ref32 !== void 0 ? _ref32 : (_defaultOptions$local = defaultOptions3.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref23 !== void 0 ? _ref23 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options2 === null || options2 === void 0 ? void 0 : options2.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options2 === null || options2 === void 0 ? void 0 : (_options$locale3 = options2.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions3.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions3.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale2.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale2.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters_default[firstCharacter];
      return longFormatter(substring, locale2.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }
    var formatter = formatters_default[firstCharacter];
    if (formatter) {
      if (!(options2 !== null && options2 !== void 0 && options2.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      if (!(options2 !== null && options2 !== void 0 && options2.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      return formatter(utcDate, substring, locale2.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString(input) {
  var matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}

// node_modules/date-fns/esm/addMinutes/index.js
var MILLISECONDS_IN_MINUTE = 6e4;
function addMinutes(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE);
}

// node_modules/date-fns/esm/addHours/index.js
var MILLISECONDS_IN_HOUR = 36e5;
function addHours(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_HOUR);
}

// node_modules/date-fns/esm/addDays/index.js
function addDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return /* @__PURE__ */ new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  date.setDate(date.getDate() + amount);
  return date;
}

// node_modules/date-fns/esm/addWeeks/index.js
function addWeeks(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  var days = amount * 7;
  return addDays(dirtyDate, days);
}

// node_modules/date-fns/esm/addMonths/index.js
function addMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return /* @__PURE__ */ new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  var dayOfMonth = date.getDate();
  var endOfDesiredMonth = new Date(date.getTime());
  endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
  var daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    return date;
  }
}

// node_modules/date-fns/esm/addQuarters/index.js
function addQuarters(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  var months = amount * 3;
  return addMonths(dirtyDate, months);
}

// node_modules/date-fns/esm/addYears/index.js
function addYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, amount * 12);
}

// node_modules/date-fns/esm/subDays/index.js
function subDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addDays(dirtyDate, -amount);
}

// node_modules/date-fns/esm/subWeeks/index.js
function subWeeks(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addWeeks(dirtyDate, -amount);
}

// node_modules/date-fns/esm/subMonths/index.js
function subMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, -amount);
}

// node_modules/date-fns/esm/subQuarters/index.js
function subQuarters(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addQuarters(dirtyDate, -amount);
}

// node_modules/date-fns/esm/subYears/index.js
function subYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addYears(dirtyDate, -amount);
}

// node_modules/date-fns/esm/getSeconds/index.js
function getSeconds(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var seconds = date.getSeconds();
  return seconds;
}

// node_modules/date-fns/esm/getMinutes/index.js
function getMinutes(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var minutes = date.getMinutes();
  return minutes;
}

// node_modules/date-fns/esm/getHours/index.js
function getHours(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var hours = date.getHours();
  return hours;
}

// node_modules/date-fns/esm/getDay/index.js
function getDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var day = date.getDay();
  return day;
}

// node_modules/date-fns/esm/getDate/index.js
function getDate(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var dayOfMonth = date.getDate();
  return dayOfMonth;
}

// node_modules/date-fns/esm/startOfWeek/index.js
function startOfWeek(dirtyDate, options2) {
  var _ref4, _ref23, _ref32, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions3 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref4 = (_ref23 = (_ref32 = (_options$weekStartsOn = options2 === null || options2 === void 0 ? void 0 : options2.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options2 === null || options2 === void 0 ? void 0 : (_options$locale = options2.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref32 !== void 0 ? _ref32 : defaultOptions3.weekStartsOn) !== null && _ref23 !== void 0 ? _ref23 : (_defaultOptions$local = defaultOptions3.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref4 !== void 0 ? _ref4 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setDate(date.getDate() - diff);
  date.setHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/startOfISOWeek/index.js
function startOfISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  return startOfWeek(dirtyDate, {
    weekStartsOn: 1
  });
}

// node_modules/date-fns/esm/getISOWeekYear/index.js
function getISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var fourthOfJanuaryOfNextYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  var startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  var startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/esm/startOfISOWeekYear/index.js
function startOfISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getISOWeekYear(dirtyDate);
  var fourthOfJanuary = /* @__PURE__ */ new Date(0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  var date = startOfISOWeek(fourthOfJanuary);
  return date;
}

// node_modules/date-fns/esm/getISOWeek/index.js
var MILLISECONDS_IN_WEEK3 = 6048e5;
function getISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfISOWeek(date).getTime() - startOfISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK3) + 1;
}

// node_modules/date-fns/esm/getMonth/index.js
function getMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  return month;
}

// node_modules/date-fns/esm/getQuarter/index.js
function getQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var quarter = Math.floor(date.getMonth() / 3) + 1;
  return quarter;
}

// node_modules/date-fns/esm/getYear/index.js
function getYear(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getFullYear();
}

// node_modules/date-fns/esm/getTime/index.js
function getTime(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  return timestamp;
}

// node_modules/date-fns/esm/setSeconds/index.js
function setSeconds(dirtyDate, dirtySeconds) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var seconds = toInteger(dirtySeconds);
  date.setSeconds(seconds);
  return date;
}

// node_modules/date-fns/esm/setMinutes/index.js
function setMinutes(dirtyDate, dirtyMinutes) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var minutes = toInteger(dirtyMinutes);
  date.setMinutes(minutes);
  return date;
}

// node_modules/date-fns/esm/setHours/index.js
function setHours(dirtyDate, dirtyHours) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var hours = toInteger(dirtyHours);
  date.setHours(hours);
  return date;
}

// node_modules/date-fns/esm/getDaysInMonth/index.js
function getDaysInMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var monthIndex = date.getMonth();
  var lastDayOfMonth2 = /* @__PURE__ */ new Date(0);
  lastDayOfMonth2.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth2.setHours(0, 0, 0, 0);
  return lastDayOfMonth2.getDate();
}

// node_modules/date-fns/esm/setMonth/index.js
function setMonth(dirtyDate, dirtyMonth) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var month = toInteger(dirtyMonth);
  var year = date.getFullYear();
  var day = date.getDate();
  var dateWithDesiredMonth = /* @__PURE__ */ new Date(0);
  dateWithDesiredMonth.setFullYear(year, month, 15);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  var daysInMonth = getDaysInMonth(dateWithDesiredMonth);
  date.setMonth(month, Math.min(day, daysInMonth));
  return date;
}

// node_modules/date-fns/esm/setQuarter/index.js
function setQuarter(dirtyDate, dirtyQuarter) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var quarter = toInteger(dirtyQuarter);
  var oldQuarter = Math.floor(date.getMonth() / 3) + 1;
  var diff = quarter - oldQuarter;
  return setMonth(date, date.getMonth() + diff * 3);
}

// node_modules/date-fns/esm/setYear/index.js
function setYear(dirtyDate, dirtyYear) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var year = toInteger(dirtyYear);
  if (isNaN(date.getTime())) {
    return /* @__PURE__ */ new Date(NaN);
  }
  date.setFullYear(year);
  return date;
}

// node_modules/date-fns/esm/min/index.js
function min2(dirtyDatesArray) {
  requiredArgs(1, arguments);
  var datesArray;
  if (dirtyDatesArray && typeof dirtyDatesArray.forEach === "function") {
    datesArray = dirtyDatesArray;
  } else if (_typeof(dirtyDatesArray) === "object" && dirtyDatesArray !== null) {
    datesArray = Array.prototype.slice.call(dirtyDatesArray);
  } else {
    return /* @__PURE__ */ new Date(NaN);
  }
  var result;
  datesArray.forEach(function(dirtyDate) {
    var currentDate = toDate(dirtyDate);
    if (result === void 0 || result > currentDate || isNaN(currentDate.getDate())) {
      result = currentDate;
    }
  });
  return result || /* @__PURE__ */ new Date(NaN);
}

// node_modules/date-fns/esm/max/index.js
function max2(dirtyDatesArray) {
  requiredArgs(1, arguments);
  var datesArray;
  if (dirtyDatesArray && typeof dirtyDatesArray.forEach === "function") {
    datesArray = dirtyDatesArray;
  } else if (_typeof(dirtyDatesArray) === "object" && dirtyDatesArray !== null) {
    datesArray = Array.prototype.slice.call(dirtyDatesArray);
  } else {
    return /* @__PURE__ */ new Date(NaN);
  }
  var result;
  datesArray.forEach(function(dirtyDate) {
    var currentDate = toDate(dirtyDate);
    if (result === void 0 || result < currentDate || isNaN(Number(currentDate))) {
      result = currentDate;
    }
  });
  return result || /* @__PURE__ */ new Date(NaN);
}

// node_modules/date-fns/esm/startOfDay/index.js
function startOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/differenceInCalendarDays/index.js
var MILLISECONDS_IN_DAY2 = 864e5;
function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var startOfDayLeft = startOfDay(dirtyDateLeft);
  var startOfDayRight = startOfDay(dirtyDateRight);
  var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight);
  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY2);
}

// node_modules/date-fns/esm/differenceInCalendarMonths/index.js
function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
  var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
  return yearDiff * 12 + monthDiff;
}

// node_modules/date-fns/esm/differenceInCalendarYears/index.js
function differenceInCalendarYears(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() - dateRight.getFullYear();
}

// node_modules/date-fns/esm/startOfMonth/index.js
function startOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/startOfQuarter/index.js
function startOfQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var currentMonth = date.getMonth();
  var month = currentMonth - currentMonth % 3;
  date.setMonth(month, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/startOfYear/index.js
function startOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var cleanDate = toDate(dirtyDate);
  var date = /* @__PURE__ */ new Date(0);
  date.setFullYear(cleanDate.getFullYear(), 0, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/endOfDay/index.js
function endOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(23, 59, 59, 999);
  return date;
}

// node_modules/date-fns/esm/endOfMonth/index.js
function endOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  date.setFullYear(date.getFullYear(), month + 1, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}

// node_modules/date-fns/esm/endOfYear/index.js
function endOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  date.setFullYear(year + 1, 0, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}

// node_modules/date-fns/esm/isEqual/index.js
function isEqual(dirtyLeftDate, dirtyRightDate) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyLeftDate);
  var dateRight = toDate(dirtyRightDate);
  return dateLeft.getTime() === dateRight.getTime();
}

// node_modules/date-fns/esm/isSameDay/index.js
function isSameDay(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
  var dateRightStartOfDay = startOfDay(dirtyDateRight);
  return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
}

// node_modules/date-fns/esm/isSameMonth/index.js
function isSameMonth(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();
}

// node_modules/date-fns/esm/isSameYear/index.js
function isSameYear(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear();
}

// node_modules/date-fns/esm/isSameQuarter/index.js
function isSameQuarter(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfQuarter = startOfQuarter(dirtyDateLeft);
  var dateRightStartOfQuarter = startOfQuarter(dirtyDateRight);
  return dateLeftStartOfQuarter.getTime() === dateRightStartOfQuarter.getTime();
}

// node_modules/date-fns/esm/isAfter/index.js
function isAfter(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() > dateToCompare.getTime();
}

// node_modules/date-fns/esm/isBefore/index.js
function isBefore(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() < dateToCompare.getTime();
}

// node_modules/date-fns/esm/isWithinInterval/index.js
function isWithinInterval(dirtyDate, interval) {
  requiredArgs(2, arguments);
  var time = toDate(dirtyDate).getTime();
  var startTime = toDate(interval.start).getTime();
  var endTime = toDate(interval.end).getTime();
  if (!(startTime <= endTime)) {
    throw new RangeError("Invalid interval");
  }
  return time >= startTime && time <= endTime;
}

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}

// node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it2) {
    if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it2)
        o = it2;
      var i2 = 0;
      var F = function F2() {
      };
      return {
        s: F,
        n: function n() {
          if (i2 >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i2++]
          };
        },
        e: function e4(_e2) {
          throw _e2;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function s3() {
      it2 = it2.call(o);
    },
    n: function n() {
      var step = it2.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e4(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it2["return"] != null)
          it2["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}

// node_modules/date-fns/esm/_lib/assign/index.js
function assign(target, object2) {
  if (target == null) {
    throw new TypeError("assign requires that input parameter not be null or undefined");
  }
  for (var property in object2) {
    if (Object.prototype.hasOwnProperty.call(object2, property)) {
      ;
      target[property] = object2[property];
    }
  }
  return target;
}

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}

// node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  try {
    var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t5) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct3() {
    return !!t4;
  })();
}

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}

// node_modules/@babel/runtime/helpers/esm/createSuper.js
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

// node_modules/date-fns/esm/parse/_lib/Setter.js
var TIMEZONE_UNIT_PRIORITY = 10;
var Setter = function() {
  function Setter2() {
    _classCallCheck(this, Setter2);
    _defineProperty(this, "priority", void 0);
    _defineProperty(this, "subPriority", 0);
  }
  _createClass(Setter2, [{
    key: "validate",
    value: function validate(_utcDate, _options) {
      return true;
    }
  }]);
  return Setter2;
}();
var ValueSetter = function(_Setter) {
  _inherits(ValueSetter2, _Setter);
  var _super = _createSuper(ValueSetter2);
  function ValueSetter2(value, validateValue, setValue, priority, subPriority) {
    var _this;
    _classCallCheck(this, ValueSetter2);
    _this = _super.call(this);
    _this.value = value;
    _this.validateValue = validateValue;
    _this.setValue = setValue;
    _this.priority = priority;
    if (subPriority) {
      _this.subPriority = subPriority;
    }
    return _this;
  }
  _createClass(ValueSetter2, [{
    key: "validate",
    value: function validate(utcDate, options2) {
      return this.validateValue(utcDate, this.value, options2);
    }
  }, {
    key: "set",
    value: function set2(utcDate, flags, options2) {
      return this.setValue(utcDate, flags, this.value, options2);
    }
  }]);
  return ValueSetter2;
}(Setter);
var DateToSystemTimezoneSetter = function(_Setter2) {
  _inherits(DateToSystemTimezoneSetter2, _Setter2);
  var _super2 = _createSuper(DateToSystemTimezoneSetter2);
  function DateToSystemTimezoneSetter2() {
    var _this2;
    _classCallCheck(this, DateToSystemTimezoneSetter2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super2.call.apply(_super2, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
    _defineProperty(_assertThisInitialized(_this2), "subPriority", -1);
    return _this2;
  }
  _createClass(DateToSystemTimezoneSetter2, [{
    key: "set",
    value: function set2(date, flags) {
      if (flags.timestampIsSet) {
        return date;
      }
      var convertedDate = /* @__PURE__ */ new Date(0);
      convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
      convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
      return convertedDate;
    }
  }]);
  return DateToSystemTimezoneSetter2;
}(Setter);

// node_modules/date-fns/esm/parse/_lib/Parser.js
var Parser = function() {
  function Parser4() {
    _classCallCheck(this, Parser4);
    _defineProperty(this, "incompatibleTokens", void 0);
    _defineProperty(this, "priority", void 0);
    _defineProperty(this, "subPriority", void 0);
  }
  _createClass(Parser4, [{
    key: "run",
    value: function run(dateString, token2, match3, options2) {
      var result = this.parse(dateString, token2, match3, options2);
      if (!result) {
        return null;
      }
      return {
        setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
        rest: result.rest
      };
    }
  }, {
    key: "validate",
    value: function validate(_utcDate, _value, _options) {
      return true;
    }
  }]);
  return Parser4;
}();

// node_modules/date-fns/esm/parse/_lib/parsers/EraParser.js
var EraParser = function(_Parser) {
  _inherits(EraParser2, _Parser);
  var _super = _createSuper(EraParser2);
  function EraParser2() {
    var _this;
    _classCallCheck(this, EraParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 140);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["R", "u", "t", "T"]);
    return _this;
  }
  _createClass(EraParser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3) {
      switch (token2) {
        case "G":
        case "GG":
        case "GGG":
          return match3.era(dateString, {
            width: "abbreviated"
          }) || match3.era(dateString, {
            width: "narrow"
          });
        case "GGGGG":
          return match3.era(dateString, {
            width: "narrow"
          });
        case "GGGG":
        default:
          return match3.era(dateString, {
            width: "wide"
          }) || match3.era(dateString, {
            width: "abbreviated"
          }) || match3.era(dateString, {
            width: "narrow"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return EraParser2;
}(Parser);

// node_modules/date-fns/esm/constants/index.js
var daysInYear = 365.2425;
var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
var millisecondsInMinute = 6e4;
var millisecondsInHour = 36e5;
var millisecondsInSecond = 1e3;
var minTime = -maxTime;
var secondsInHour = 3600;
var secondsInDay = secondsInHour * 24;
var secondsInWeek = secondsInDay * 7;
var secondsInYear = secondsInDay * daysInYear;
var secondsInMonth = secondsInYear / 12;
var secondsInQuarter = secondsInMonth * 3;

// node_modules/date-fns/esm/parse/_lib/constants.js
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};

// node_modules/date-fns/esm/parse/_lib/utils.js
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  var sign = matchResult[1] === "+" ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
  }
}
function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0;
  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd2 = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd2 / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd2 % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

// node_modules/date-fns/esm/parse/_lib/parsers/YearParser.js
var YearParser = function(_Parser) {
  _inherits(YearParser2, _Parser);
  var _super = _createSuper(YearParser2);
  function YearParser2() {
    var _this;
    _classCallCheck(this, YearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(YearParser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3) {
      var valueCallback3 = function valueCallback4(year) {
        return {
          year,
          isTwoDigitYear: token2 === "yy"
        };
      };
      switch (token2) {
        case "y":
          return mapValue(parseNDigits(4, dateString), valueCallback3);
        case "yo":
          return mapValue(match3.ordinalNumber(dateString, {
            unit: "year"
          }), valueCallback3);
        default:
          return mapValue(parseNDigits(token2.length, dateString), valueCallback3);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      var currentYear = date.getUTCFullYear();
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return YearParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/LocalWeekYearParser.js
var LocalWeekYearParser = function(_Parser) {
  _inherits(LocalWeekYearParser2, _Parser);
  var _super = _createSuper(LocalWeekYearParser2);
  function LocalWeekYearParser2() {
    var _this;
    _classCallCheck(this, LocalWeekYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]);
    return _this;
  }
  _createClass(LocalWeekYearParser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3) {
      var valueCallback3 = function valueCallback4(year) {
        return {
          year,
          isTwoDigitYear: token2 === "YY"
        };
      };
      switch (token2) {
        case "Y":
          return mapValue(parseNDigits(4, dateString), valueCallback3);
        case "Yo":
          return mapValue(match3.ordinalNumber(dateString, {
            unit: "year"
          }), valueCallback3);
        default:
          return mapValue(parseNDigits(token2.length, dateString), valueCallback3);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set2(date, flags, value, options2) {
      var currentYear = getUTCWeekYear(date, options2);
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options2.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options2);
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options2.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options2);
    }
  }]);
  return LocalWeekYearParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/ISOWeekYearParser.js
var ISOWeekYearParser = function(_Parser) {
  _inherits(ISOWeekYearParser2, _Parser);
  var _super = _createSuper(ISOWeekYearParser2);
  function ISOWeekYearParser2() {
    var _this;
    _classCallCheck(this, ISOWeekYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(ISOWeekYearParser2, [{
    key: "parse",
    value: function parse5(dateString, token2) {
      if (token2 === "R") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token2.length, dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      var firstWeekOfYear = /* @__PURE__ */ new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    }
  }]);
  return ISOWeekYearParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/ExtendedYearParser.js
var ExtendedYearParser = function(_Parser) {
  _inherits(ExtendedYearParser2, _Parser);
  var _super = _createSuper(ExtendedYearParser2);
  function ExtendedYearParser2() {
    var _this;
    _classCallCheck(this, ExtendedYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(ExtendedYearParser2, [{
    key: "parse",
    value: function parse5(dateString, token2) {
      if (token2 === "u") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token2.length, dateString);
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ExtendedYearParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/QuarterParser.js
var QuarterParser = function(_Parser) {
  _inherits(QuarterParser2, _Parser);
  var _super = _createSuper(QuarterParser2);
  function QuarterParser2() {
    var _this;
    _classCallCheck(this, QuarterParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 120);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(QuarterParser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3) {
      switch (token2) {
        case "Q":
        case "QQ":
          return parseNDigits(token2.length, dateString);
        case "Qo":
          return match3.ordinalNumber(dateString, {
            unit: "quarter"
          });
        case "QQQ":
          return match3.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match3.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQQ":
          return match3.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return match3.quarter(dateString, {
            width: "wide",
            context: "formatting"
          }) || match3.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match3.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return QuarterParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/StandAloneQuarterParser.js
var StandAloneQuarterParser = function(_Parser) {
  _inherits(StandAloneQuarterParser2, _Parser);
  var _super = _createSuper(StandAloneQuarterParser2);
  function StandAloneQuarterParser2() {
    var _this;
    _classCallCheck(this, StandAloneQuarterParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 120);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(StandAloneQuarterParser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3) {
      switch (token2) {
        case "q":
        case "qq":
          return parseNDigits(token2.length, dateString);
        case "qo":
          return match3.ordinalNumber(dateString, {
            unit: "quarter"
          });
        case "qqq":
          return match3.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match3.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqqq":
          return match3.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return match3.quarter(dateString, {
            width: "wide",
            context: "standalone"
          }) || match3.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match3.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneQuarterParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/MonthParser.js
var MonthParser = function(_Parser) {
  _inherits(MonthParser2, _Parser);
  var _super = _createSuper(MonthParser2);
  function MonthParser2() {
    var _this;
    _classCallCheck(this, MonthParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]);
    _defineProperty(_assertThisInitialized(_this), "priority", 110);
    return _this;
  }
  _createClass(MonthParser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3) {
      var valueCallback3 = function valueCallback4(value) {
        return value - 1;
      };
      switch (token2) {
        case "M":
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback3);
        case "MM":
          return mapValue(parseNDigits(2, dateString), valueCallback3);
        case "Mo":
          return mapValue(match3.ordinalNumber(dateString, {
            unit: "month"
          }), valueCallback3);
        case "MMM":
          return match3.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match3.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMMM":
          return match3.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return match3.month(dateString, {
            width: "wide",
            context: "formatting"
          }) || match3.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match3.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return MonthParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/StandAloneMonthParser.js
var StandAloneMonthParser = function(_Parser) {
  _inherits(StandAloneMonthParser2, _Parser);
  var _super = _createSuper(StandAloneMonthParser2);
  function StandAloneMonthParser2() {
    var _this;
    _classCallCheck(this, StandAloneMonthParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 110);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(StandAloneMonthParser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3) {
      var valueCallback3 = function valueCallback4(value) {
        return value - 1;
      };
      switch (token2) {
        case "L":
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback3);
        case "LL":
          return mapValue(parseNDigits(2, dateString), valueCallback3);
        case "Lo":
          return mapValue(match3.ordinalNumber(dateString, {
            unit: "month"
          }), valueCallback3);
        case "LLL":
          return match3.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match3.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLLL":
          return match3.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return match3.month(dateString, {
            width: "wide",
            context: "standalone"
          }) || match3.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match3.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneMonthParser2;
}(Parser);

// node_modules/date-fns/esm/_lib/setUTCWeek/index.js
function setUTCWeek(dirtyDate, dirtyWeek, options2) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getUTCWeek(date, options2) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

// node_modules/date-fns/esm/parse/_lib/parsers/LocalWeekParser.js
var LocalWeekParser = function(_Parser) {
  _inherits(LocalWeekParser2, _Parser);
  var _super = _createSuper(LocalWeekParser2);
  function LocalWeekParser2() {
    var _this;
    _classCallCheck(this, LocalWeekParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 100);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]);
    return _this;
  }
  _createClass(LocalWeekParser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3) {
      switch (token2) {
        case "w":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "wo":
          return match3.ordinalNumber(dateString, {
            unit: "week"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options2) {
      return startOfUTCWeek(setUTCWeek(date, value, options2), options2);
    }
  }]);
  return LocalWeekParser2;
}(Parser);

// node_modules/date-fns/esm/_lib/setUTCISOWeek/index.js
function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

// node_modules/date-fns/esm/parse/_lib/parsers/ISOWeekParser.js
var ISOWeekParser = function(_Parser) {
  _inherits(ISOWeekParser2, _Parser);
  var _super = _createSuper(ISOWeekParser2);
  function ISOWeekParser2() {
    var _this;
    _classCallCheck(this, ISOWeekParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 100);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(ISOWeekParser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3) {
      switch (token2) {
        case "I":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "Io":
          return match3.ordinalNumber(dateString, {
            unit: "week"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      return startOfUTCISOWeek(setUTCISOWeek(date, value));
    }
  }]);
  return ISOWeekParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/DateParser.js
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DateParser = function(_Parser) {
  _inherits(DateParser2, _Parser);
  var _super = _createSuper(DateParser2);
  function DateParser2() {
    var _this;
    _classCallCheck(this, DateParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "subPriority", 1);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(DateParser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3) {
      switch (token2) {
        case "d":
          return parseNumericPattern(numericPatterns.date, dateString);
        case "do":
          return match3.ordinalNumber(dateString, {
            unit: "date"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear2 = isLeapYearIndex(year);
      var month = date.getUTCMonth();
      if (isLeapYear2) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DateParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/DayOfYearParser.js
var DayOfYearParser = function(_Parser) {
  _inherits(DayOfYearParser2, _Parser);
  var _super = _createSuper(DayOfYearParser2);
  function DayOfYearParser2() {
    var _this;
    _classCallCheck(this, DayOfYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "subpriority", 1);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(DayOfYearParser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3) {
      switch (token2) {
        case "D":
        case "DD":
          return parseNumericPattern(numericPatterns.dayOfYear, dateString);
        case "Do":
          return match3.ordinalNumber(dateString, {
            unit: "date"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear2 = isLeapYearIndex(year);
      if (isLeapYear2) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayOfYearParser2;
}(Parser);

// node_modules/date-fns/esm/_lib/setUTCDay/index.js
function setUTCDay(dirtyDate, dirtyDay, options2) {
  var _ref4, _ref23, _ref32, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(2, arguments);
  var defaultOptions3 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref4 = (_ref23 = (_ref32 = (_options$weekStartsOn = options2 === null || options2 === void 0 ? void 0 : options2.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options2 === null || options2 === void 0 ? void 0 : (_options$locale = options2.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref32 !== void 0 ? _ref32 : defaultOptions3.weekStartsOn) !== null && _ref23 !== void 0 ? _ref23 : (_defaultOptions$local = defaultOptions3.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref4 !== void 0 ? _ref4 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

// node_modules/date-fns/esm/parse/_lib/parsers/DayParser.js
var DayParser = function(_Parser) {
  _inherits(DayParser2, _Parser);
  var _super = _createSuper(DayParser2);
  function DayParser2() {
    var _this;
    _classCallCheck(this, DayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(DayParser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3) {
      switch (token2) {
        case "E":
        case "EE":
        case "EEE":
          return match3.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match3.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match3.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEE":
          return match3.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return match3.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match3.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEE":
        default:
          return match3.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match3.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match3.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match3.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options2) {
      date = setUTCDay(date, value, options2);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/LocalDayParser.js
var LocalDayParser = function(_Parser) {
  _inherits(LocalDayParser2, _Parser);
  var _super = _createSuper(LocalDayParser2);
  function LocalDayParser2() {
    var _this;
    _classCallCheck(this, LocalDayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]);
    return _this;
  }
  _createClass(LocalDayParser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3, options2) {
      var valueCallback3 = function valueCallback4(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options2.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token2) {
        case "e":
        case "ee":
          return mapValue(parseNDigits(token2.length, dateString), valueCallback3);
        case "eo":
          return mapValue(match3.ordinalNumber(dateString, {
            unit: "day"
          }), valueCallback3);
        case "eee":
          return match3.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match3.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match3.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeee":
          return match3.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return match3.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match3.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeee":
        default:
          return match3.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match3.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match3.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match3.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options2) {
      date = setUTCDay(date, value, options2);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return LocalDayParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/StandAloneLocalDayParser.js
var StandAloneLocalDayParser = function(_Parser) {
  _inherits(StandAloneLocalDayParser2, _Parser);
  var _super = _createSuper(StandAloneLocalDayParser2);
  function StandAloneLocalDayParser2() {
    var _this;
    _classCallCheck(this, StandAloneLocalDayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]);
    return _this;
  }
  _createClass(StandAloneLocalDayParser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3, options2) {
      var valueCallback3 = function valueCallback4(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options2.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token2) {
        case "c":
        case "cc":
          return mapValue(parseNDigits(token2.length, dateString), valueCallback3);
        case "co":
          return mapValue(match3.ordinalNumber(dateString, {
            unit: "day"
          }), valueCallback3);
        case "ccc":
          return match3.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match3.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match3.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "ccccc":
          return match3.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return match3.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match3.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "cccc":
        default:
          return match3.day(dateString, {
            width: "wide",
            context: "standalone"
          }) || match3.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match3.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match3.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options2) {
      date = setUTCDay(date, value, options2);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneLocalDayParser2;
}(Parser);

// node_modules/date-fns/esm/_lib/setUTCISODay/index.js
function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);
  if (day % 7 === 0) {
    day = day - 7;
  }
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

// node_modules/date-fns/esm/parse/_lib/parsers/ISODayParser.js
var ISODayParser = function(_Parser) {
  _inherits(ISODayParser2, _Parser);
  var _super = _createSuper(ISODayParser2);
  function ISODayParser2() {
    var _this;
    _classCallCheck(this, ISODayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(ISODayParser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3) {
      var valueCallback3 = function valueCallback4(value) {
        if (value === 0) {
          return 7;
        }
        return value;
      };
      switch (token2) {
        case "i":
        case "ii":
          return parseNDigits(token2.length, dateString);
        case "io":
          return match3.ordinalNumber(dateString, {
            unit: "day"
          });
        case "iii":
          return mapValue(match3.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match3.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match3.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
        case "iiiii":
          return mapValue(match3.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
        case "iiiiii":
          return mapValue(match3.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match3.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
        case "iiii":
        default:
          return mapValue(match3.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match3.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match3.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match3.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 7;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date = setUTCISODay(date, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ISODayParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/AMPMParser.js
var AMPMParser = function(_Parser) {
  _inherits(AMPMParser2, _Parser);
  var _super = _createSuper(AMPMParser2);
  function AMPMParser2() {
    var _this;
    _classCallCheck(this, AMPMParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 80);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass(AMPMParser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3) {
      switch (token2) {
        case "a":
        case "aa":
        case "aaa":
          return match3.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match3.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaaa":
          return match3.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return match3.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match3.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match3.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/AMPMMidnightParser.js
var AMPMMidnightParser = function(_Parser) {
  _inherits(AMPMMidnightParser2, _Parser);
  var _super = _createSuper(AMPMMidnightParser2);
  function AMPMMidnightParser2() {
    var _this;
    _classCallCheck(this, AMPMMidnightParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 80);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass(AMPMMidnightParser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3) {
      switch (token2) {
        case "b":
        case "bb":
        case "bbb":
          return match3.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match3.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbbb":
          return match3.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return match3.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match3.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match3.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMMidnightParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/DayPeriodParser.js
var DayPeriodParser = function(_Parser) {
  _inherits(DayPeriodParser2, _Parser);
  var _super = _createSuper(DayPeriodParser2);
  function DayPeriodParser2() {
    var _this;
    _classCallCheck(this, DayPeriodParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 80);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "t", "T"]);
    return _this;
  }
  _createClass(DayPeriodParser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3) {
      switch (token2) {
        case "B":
        case "BB":
        case "BBB":
          return match3.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match3.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBBB":
          return match3.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return match3.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match3.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match3.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return DayPeriodParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/Hour1to12Parser.js
var Hour1to12Parser = function(_Parser) {
  _inherits(Hour1to12Parser2, _Parser);
  var _super = _createSuper(Hour1to12Parser2);
  function Hour1to12Parser2() {
    var _this;
    _classCallCheck(this, Hour1to12Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["H", "K", "k", "t", "T"]);
    return _this;
  }
  _createClass(Hour1to12Parser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3) {
      switch (token2) {
        case "h":
          return parseNumericPattern(numericPatterns.hour12h, dateString);
        case "ho":
          return match3.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 12;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour1to12Parser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/Hour0to23Parser.js
var Hour0to23Parser = function(_Parser) {
  _inherits(Hour0to23Parser2, _Parser);
  var _super = _createSuper(Hour0to23Parser2);
  function Hour0to23Parser2() {
    var _this;
    _classCallCheck(this, Hour0to23Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
    return _this;
  }
  _createClass(Hour0to23Parser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3) {
      switch (token2) {
        case "H":
          return parseNumericPattern(numericPatterns.hour23h, dateString);
        case "Ho":
          return match3.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 23;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    }
  }]);
  return Hour0to23Parser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/Hour0To11Parser.js
var Hour0To11Parser = function(_Parser) {
  _inherits(Hour0To11Parser2, _Parser);
  var _super = _createSuper(Hour0To11Parser2);
  function Hour0To11Parser2() {
    var _this;
    _classCallCheck(this, Hour0To11Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["h", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass(Hour0To11Parser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3) {
      switch (token2) {
        case "K":
          return parseNumericPattern(numericPatterns.hour11h, dateString);
        case "Ko":
          return match3.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour0To11Parser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/Hour1To24Parser.js
var Hour1To24Parser = function(_Parser) {
  _inherits(Hour1To24Parser2, _Parser);
  var _super = _createSuper(Hour1To24Parser2);
  function Hour1To24Parser2() {
    var _this;
    _classCallCheck(this, Hour1To24Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
    return _this;
  }
  _createClass(Hour1To24Parser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3) {
      switch (token2) {
        case "k":
          return parseNumericPattern(numericPatterns.hour24h, dateString);
        case "ko":
          return match3.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 24;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    }
  }]);
  return Hour1To24Parser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/MinuteParser.js
var MinuteParser = function(_Parser) {
  _inherits(MinuteParser2, _Parser);
  var _super = _createSuper(MinuteParser2);
  function MinuteParser2() {
    var _this;
    _classCallCheck(this, MinuteParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 60);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass(MinuteParser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3) {
      switch (token2) {
        case "m":
          return parseNumericPattern(numericPatterns.minute, dateString);
        case "mo":
          return match3.ordinalNumber(dateString, {
            unit: "minute"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    }
  }]);
  return MinuteParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/SecondParser.js
var SecondParser = function(_Parser) {
  _inherits(SecondParser2, _Parser);
  var _super = _createSuper(SecondParser2);
  function SecondParser2() {
    var _this;
    _classCallCheck(this, SecondParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 50);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass(SecondParser2, [{
    key: "parse",
    value: function parse5(dateString, token2, match3) {
      switch (token2) {
        case "s":
          return parseNumericPattern(numericPatterns.second, dateString);
        case "so":
          return match3.ordinalNumber(dateString, {
            unit: "second"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCSeconds(value, 0);
      return date;
    }
  }]);
  return SecondParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/FractionOfSecondParser.js
var FractionOfSecondParser = function(_Parser) {
  _inherits(FractionOfSecondParser2, _Parser);
  var _super = _createSuper(FractionOfSecondParser2);
  function FractionOfSecondParser2() {
    var _this;
    _classCallCheck(this, FractionOfSecondParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 30);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass(FractionOfSecondParser2, [{
    key: "parse",
    value: function parse5(dateString, token2) {
      var valueCallback3 = function valueCallback4(value) {
        return Math.floor(value * Math.pow(10, -token2.length + 3));
      };
      return mapValue(parseNDigits(token2.length, dateString), valueCallback3);
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMilliseconds(value);
      return date;
    }
  }]);
  return FractionOfSecondParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/ISOTimezoneWithZParser.js
var ISOTimezoneWithZParser = function(_Parser) {
  _inherits(ISOTimezoneWithZParser2, _Parser);
  var _super = _createSuper(ISOTimezoneWithZParser2);
  function ISOTimezoneWithZParser2() {
    var _this;
    _classCallCheck(this, ISOTimezoneWithZParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 10);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T", "x"]);
    return _this;
  }
  _createClass(ISOTimezoneWithZParser2, [{
    key: "parse",
    value: function parse5(dateString, token2) {
      switch (token2) {
        case "X":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case "XX":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "XXXX":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case "XXXXX":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case "XXX":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneWithZParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/ISOTimezoneParser.js
var ISOTimezoneParser = function(_Parser) {
  _inherits(ISOTimezoneParser2, _Parser);
  var _super = _createSuper(ISOTimezoneParser2);
  function ISOTimezoneParser2() {
    var _this;
    _classCallCheck(this, ISOTimezoneParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 10);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T", "X"]);
    return _this;
  }
  _createClass(ISOTimezoneParser2, [{
    key: "parse",
    value: function parse5(dateString, token2) {
      switch (token2) {
        case "x":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case "xx":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "xxxx":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case "xxxxx":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case "xxx":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/TimestampSecondsParser.js
var TimestampSecondsParser = function(_Parser) {
  _inherits(TimestampSecondsParser2, _Parser);
  var _super = _createSuper(TimestampSecondsParser2);
  function TimestampSecondsParser2() {
    var _this;
    _classCallCheck(this, TimestampSecondsParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 40);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", "*");
    return _this;
  }
  _createClass(TimestampSecondsParser2, [{
    key: "parse",
    value: function parse5(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      return [new Date(value * 1e3), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampSecondsParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/TimestampMillisecondsParser.js
var TimestampMillisecondsParser = function(_Parser) {
  _inherits(TimestampMillisecondsParser2, _Parser);
  var _super = _createSuper(TimestampMillisecondsParser2);
  function TimestampMillisecondsParser2() {
    var _this;
    _classCallCheck(this, TimestampMillisecondsParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 20);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", "*");
    return _this;
  }
  _createClass(TimestampMillisecondsParser2, [{
    key: "parse",
    value: function parse5(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampMillisecondsParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/index.js
var parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};

// node_modules/date-fns/esm/parse/index.js
var formattingTokensRegExp2 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp2 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp2 = /^'([^]*?)'?$/;
var doubleQuoteRegExp2 = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp2 = /[a-zA-Z]/;
function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options2) {
  var _ref4, _options$locale, _ref23, _ref32, _ref42, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var defaultOptions3 = getDefaultOptions();
  var locale2 = (_ref4 = (_options$locale = options2 === null || options2 === void 0 ? void 0 : options2.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions3.locale) !== null && _ref4 !== void 0 ? _ref4 : defaultLocale_default;
  if (!locale2.match) {
    throw new RangeError("locale must contain match property");
  }
  var firstWeekContainsDate = toInteger((_ref23 = (_ref32 = (_ref42 = (_options$firstWeekCon = options2 === null || options2 === void 0 ? void 0 : options2.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options2 === null || options2 === void 0 ? void 0 : (_options$locale2 = options2.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref42 !== void 0 ? _ref42 : defaultOptions3.firstWeekContainsDate) !== null && _ref32 !== void 0 ? _ref32 : (_defaultOptions$local = defaultOptions3.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref23 !== void 0 ? _ref23 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options2 === null || options2 === void 0 ? void 0 : options2.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options2 === null || options2 === void 0 ? void 0 : (_options$locale3 = options2.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions3.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions3.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (formatString === "") {
    if (dateString === "") {
      return toDate(dirtyReferenceDate);
    } else {
      return /* @__PURE__ */ new Date(NaN);
    }
  }
  var subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2
  };
  var setters = [new DateToSystemTimezoneSetter()];
  var tokens2 = formatString.match(longFormattingTokensRegExp2).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter in longFormatters_default) {
      var longFormatter = longFormatters_default[firstCharacter];
      return longFormatter(substring, locale2.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp2);
  var usedTokens = [];
  var _iterator = _createForOfIteratorHelper(tokens2), _step;
  try {
    var _loop = function _loop2() {
      var token2 = _step.value;
      if (!(options2 !== null && options2 !== void 0 && options2.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token2)) {
        throwProtectedError(token2, formatString, dirtyDateString);
      }
      if (!(options2 !== null && options2 !== void 0 && options2.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token2)) {
        throwProtectedError(token2, formatString, dirtyDateString);
      }
      var firstCharacter = token2[0];
      var parser = parsers[firstCharacter];
      if (parser) {
        var incompatibleTokens = parser.incompatibleTokens;
        if (Array.isArray(incompatibleTokens)) {
          var incompatibleToken = usedTokens.find(function(usedToken) {
            return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
          });
          if (incompatibleToken) {
            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token2, "` at the same time"));
          }
        } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
          throw new RangeError("The format string mustn't contain `".concat(token2, "` and any other token at the same time"));
        }
        usedTokens.push({
          token: firstCharacter,
          fullToken: token2
        });
        var parseResult = parser.run(dateString, token2, locale2.match, subFnOptions);
        if (!parseResult) {
          return {
            v: /* @__PURE__ */ new Date(NaN)
          };
        }
        setters.push(parseResult.setter);
        dateString = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp2)) {
          throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
        }
        if (token2 === "''") {
          token2 = "'";
        } else if (firstCharacter === "'") {
          token2 = cleanEscapedString2(token2);
        }
        if (dateString.indexOf(token2) === 0) {
          dateString = dateString.slice(token2.length);
        } else {
          return {
            v: /* @__PURE__ */ new Date(NaN)
          };
        }
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _ret = _loop();
      if (_typeof(_ret) === "object")
        return _ret.v;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var uniquePrioritySetters = setters.map(function(setter2) {
    return setter2.priority;
  }).sort(function(a3, b2) {
    return b2 - a3;
  }).filter(function(priority, index4, array) {
    return array.indexOf(priority) === index4;
  }).map(function(priority) {
    return setters.filter(function(setter2) {
      return setter2.priority === priority;
    }).sort(function(a3, b2) {
      return b2.subPriority - a3.subPriority;
    });
  }).map(function(setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyReferenceDate);
  if (isNaN(date.getTime())) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var flags = {};
  var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var setter = _step2.value;
      if (!setter.validate(utcDate, subFnOptions)) {
        return /* @__PURE__ */ new Date(NaN);
      }
      var result = setter.set(utcDate, flags, subFnOptions);
      if (Array.isArray(result)) {
        utcDate = result[0];
        assign(flags, result[1]);
      } else {
        utcDate = result;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return utcDate;
}
function cleanEscapedString2(input) {
  return input.match(escapedStringRegExp2)[1].replace(doubleQuoteRegExp2, "'");
}

// node_modules/date-fns/esm/parseISO/index.js
function parseISO(argument, options2) {
  var _options$additionalDi;
  requiredArgs(1, arguments);
  var additionalDigits = toInteger((_options$additionalDi = options2 === null || options2 === void 0 ? void 0 : options2.additionalDigits) !== null && _options$additionalDi !== void 0 ? _options$additionalDi : 2);
  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  }
  if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var dateStrings = splitDateString(argument);
  var date;
  if (dateStrings.date) {
    var parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }
  if (!date || isNaN(date.getTime())) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var timestamp = date.getTime();
  var time = 0;
  var offset3;
  if (dateStrings.time) {
    time = parseTime(dateStrings.time);
    if (isNaN(time)) {
      return /* @__PURE__ */ new Date(NaN);
    }
  }
  if (dateStrings.timezone) {
    offset3 = parseTimezone(dateStrings.timezone);
    if (isNaN(offset3)) {
      return /* @__PURE__ */ new Date(NaN);
    }
  } else {
    var dirtyDate = new Date(timestamp + time);
    var result = /* @__PURE__ */ new Date(0);
    result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
    result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
    return result;
  }
  return new Date(timestamp + time + offset3);
}
var patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
};
var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function splitDateString(dateString) {
  var dateStrings = {};
  var array = dateString.split(patterns.dateTimeDelimiter);
  var timeString;
  if (array.length > 2) {
    return dateStrings;
  }
  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(dateStrings.date.length, dateString.length);
    }
  }
  if (timeString) {
    var token2 = patterns.timezone.exec(timeString);
    if (token2) {
      dateStrings.time = timeString.replace(token2[1], "");
      dateStrings.timezone = token2[1];
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  var regex = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)");
  var captures = dateString.match(regex);
  if (!captures)
    return {
      year: NaN,
      restDateString: ""
    };
  var year = captures[1] ? parseInt(captures[1]) : null;
  var century = captures[2] ? parseInt(captures[2]) : null;
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}
function parseDate(dateString, year) {
  if (year === null)
    return /* @__PURE__ */ new Date(NaN);
  var captures = dateString.match(dateRegex);
  if (!captures)
    return /* @__PURE__ */ new Date(NaN);
  var isWeekDate = !!captures[4];
  var dayOfYear = parseDateUnit(captures[1]);
  var month = parseDateUnit(captures[2]) - 1;
  var day = parseDateUnit(captures[3]);
  var week = parseDateUnit(captures[4]);
  var dayOfWeek = parseDateUnit(captures[5]) - 1;
  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    var date = /* @__PURE__ */ new Date(0);
    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}
function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}
function parseTime(timeString) {
  var captures = timeString.match(timeRegex);
  if (!captures)
    return NaN;
  var hours = parseTimeUnit(captures[1]);
  var minutes = parseTimeUnit(captures[2]);
  var seconds = parseTimeUnit(captures[3]);
  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }
  return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1e3;
}
function parseTimeUnit(value) {
  return value && parseFloat(value.replace(",", ".")) || 0;
}
function parseTimezone(timezoneString) {
  if (timezoneString === "Z")
    return 0;
  var captures = timezoneString.match(timezoneRegex);
  if (!captures)
    return 0;
  var sign = captures[1] === "+" ? -1 : 1;
  var hours = parseInt(captures[2]);
  var minutes = captures[3] && parseInt(captures[3]) || 0;
  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }
  return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  var date = /* @__PURE__ */ new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7;
  var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex2(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date) {
  return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex2(year) ? 29 : 28));
}
function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex2(year) ? 366 : 365);
}
function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}
function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }
  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}
function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}

// node_modules/react-onclickoutside/dist/react-onclickoutside.es.js
var import_react29 = __toESM(require_react());
var import_react_dom5 = __toESM(require_react_dom());
function _inheritsLoose2(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf2(subClass, superClass);
}
function _setPrototypeOf2(o, p) {
  _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf2(o, p);
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _assertThisInitialized2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function isNodeFound(current, componentNode, ignoreClass) {
  if (current === componentNode) {
    return true;
  }
  if (current.correspondingElement) {
    return current.correspondingElement.classList.contains(ignoreClass);
  }
  return current.classList.contains(ignoreClass);
}
function findHighest(current, componentNode, ignoreClass) {
  if (current === componentNode) {
    return true;
  }
  while (current.parentNode || current.host) {
    if (current.parentNode && isNodeFound(current, componentNode, ignoreClass)) {
      return true;
    }
    current = current.parentNode || current.host;
  }
  return current;
}
function clickedScrollbar(evt) {
  return document.documentElement.clientWidth <= evt.clientX || document.documentElement.clientHeight <= evt.clientY;
}
var testPassiveEventSupport = function testPassiveEventSupport2() {
  if (typeof window === "undefined" || typeof window.addEventListener !== "function") {
    return;
  }
  var passive2 = false;
  var options2 = Object.defineProperty({}, "passive", {
    get: function get2() {
      passive2 = true;
    }
  });
  var noop5 = function noop6() {
  };
  window.addEventListener("testPassiveEventSupport", noop5, options2);
  window.removeEventListener("testPassiveEventSupport", noop5, options2);
  return passive2;
};
function autoInc(seed) {
  if (seed === void 0) {
    seed = 0;
  }
  return function() {
    return ++seed;
  };
}
var uid = autoInc();
var passiveEventSupport;
var handlersMap = {};
var enabledInstances = {};
var touchEvents = ["touchstart", "touchmove"];
var IGNORE_CLASS_NAME = "ignore-react-onclickoutside";
function getEventHandlerOptions(instance, eventName) {
  var handlerOptions = {};
  var isTouchEvent2 = touchEvents.indexOf(eventName) !== -1;
  if (isTouchEvent2 && passiveEventSupport) {
    handlerOptions.passive = !instance.props.preventDefault;
  }
  return handlerOptions;
}
function onClickOutsideHOC(WrappedComponent, config2) {
  var _class, _temp;
  var componentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
  return _temp = _class = function(_Component) {
    _inheritsLoose2(onClickOutside, _Component);
    function onClickOutside(props) {
      var _this;
      _this = _Component.call(this, props) || this;
      _this.__outsideClickHandler = function(event) {
        if (typeof _this.__clickOutsideHandlerProp === "function") {
          _this.__clickOutsideHandlerProp(event);
          return;
        }
        var instance = _this.getInstance();
        if (typeof instance.props.handleClickOutside === "function") {
          instance.props.handleClickOutside(event);
          return;
        }
        if (typeof instance.handleClickOutside === "function") {
          instance.handleClickOutside(event);
          return;
        }
        throw new Error("WrappedComponent: " + componentName + " lacks a handleClickOutside(event) function for processing outside click events.");
      };
      _this.__getComponentNode = function() {
        var instance = _this.getInstance();
        if (config2 && typeof config2.setClickOutsideRef === "function") {
          return config2.setClickOutsideRef()(instance);
        }
        if (typeof instance.setClickOutsideRef === "function") {
          return instance.setClickOutsideRef();
        }
        return (0, import_react_dom5.findDOMNode)(instance);
      };
      _this.enableOnClickOutside = function() {
        if (typeof document === "undefined" || enabledInstances[_this._uid]) {
          return;
        }
        if (typeof passiveEventSupport === "undefined") {
          passiveEventSupport = testPassiveEventSupport();
        }
        enabledInstances[_this._uid] = true;
        var events = _this.props.eventTypes;
        if (!events.forEach) {
          events = [events];
        }
        handlersMap[_this._uid] = function(event) {
          if (_this.componentNode === null)
            return;
          if (_this.props.preventDefault) {
            event.preventDefault();
          }
          if (_this.props.stopPropagation) {
            event.stopPropagation();
          }
          if (_this.props.excludeScrollbar && clickedScrollbar(event))
            return;
          var current = event.composed && event.composedPath && event.composedPath().shift() || event.target;
          if (findHighest(current, _this.componentNode, _this.props.outsideClickIgnoreClass) !== document) {
            return;
          }
          _this.__outsideClickHandler(event);
        };
        events.forEach(function(eventName) {
          document.addEventListener(eventName, handlersMap[_this._uid], getEventHandlerOptions(_assertThisInitialized2(_this), eventName));
        });
      };
      _this.disableOnClickOutside = function() {
        delete enabledInstances[_this._uid];
        var fn2 = handlersMap[_this._uid];
        if (fn2 && typeof document !== "undefined") {
          var events = _this.props.eventTypes;
          if (!events.forEach) {
            events = [events];
          }
          events.forEach(function(eventName) {
            return document.removeEventListener(eventName, fn2, getEventHandlerOptions(_assertThisInitialized2(_this), eventName));
          });
          delete handlersMap[_this._uid];
        }
      };
      _this.getRef = function(ref) {
        return _this.instanceRef = ref;
      };
      _this._uid = uid();
      return _this;
    }
    var _proto = onClickOutside.prototype;
    _proto.getInstance = function getInstance() {
      if (WrappedComponent.prototype && !WrappedComponent.prototype.isReactComponent) {
        return this;
      }
      var ref = this.instanceRef;
      return ref.getInstance ? ref.getInstance() : ref;
    };
    _proto.componentDidMount = function componentDidMount() {
      if (typeof document === "undefined" || !document.createElement) {
        return;
      }
      var instance = this.getInstance();
      if (config2 && typeof config2.handleClickOutside === "function") {
        this.__clickOutsideHandlerProp = config2.handleClickOutside(instance);
        if (typeof this.__clickOutsideHandlerProp !== "function") {
          throw new Error("WrappedComponent: " + componentName + " lacks a function for processing outside click events specified by the handleClickOutside config option.");
        }
      }
      this.componentNode = this.__getComponentNode();
      if (this.props.disableOnClickOutside)
        return;
      this.enableOnClickOutside();
    };
    _proto.componentDidUpdate = function componentDidUpdate() {
      this.componentNode = this.__getComponentNode();
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.disableOnClickOutside();
    };
    _proto.render = function render2() {
      var _this$props = this.props;
      _this$props.excludeScrollbar;
      var props = _objectWithoutPropertiesLoose2(_this$props, ["excludeScrollbar"]);
      if (WrappedComponent.prototype && WrappedComponent.prototype.isReactComponent) {
        props.ref = this.getRef;
      } else {
        props.wrappedRef = this.getRef;
      }
      props.disableOnClickOutside = this.disableOnClickOutside;
      props.enableOnClickOutside = this.enableOnClickOutside;
      return (0, import_react29.createElement)(WrappedComponent, props);
    };
    return onClickOutside;
  }(import_react29.Component), _class.displayName = "OnClickOutside(" + componentName + ")", _class.defaultProps = {
    eventTypes: ["mousedown", "touchstart"],
    excludeScrollbar: config2 && config2.excludeScrollbar || false,
    outsideClickIgnoreClass: IGNORE_CLASS_NAME,
    preventDefault: false,
    stopPropagation: false
  }, _class.getClass = function() {
    return WrappedComponent.getClass ? WrappedComponent.getClass() : WrappedComponent;
  }, _temp;
}
var react_onclickoutside_es_default = onClickOutsideHOC;

// node_modules/react-datepicker/dist/es/index.js
var import_react_dom6 = __toESM(require_react_dom());

// node_modules/react-popper/lib/esm/Popper.js
var React31 = __toESM(require_react());

// node_modules/react-popper/lib/esm/Manager.js
var React28 = __toESM(require_react());
var ManagerReferenceNodeContext = React28.createContext();
var ManagerReferenceNodeSetterContext = React28.createContext();
function Manager(_ref4) {
  var children = _ref4.children;
  var _React$useState = React28.useState(null), referenceNode = _React$useState[0], setReferenceNode = _React$useState[1];
  var hasUnmounted = React28.useRef(false);
  React28.useEffect(function() {
    return function() {
      hasUnmounted.current = true;
    };
  }, []);
  var handleSetReferenceNode = React28.useCallback(function(node3) {
    if (!hasUnmounted.current) {
      setReferenceNode(node3);
    }
  }, []);
  return React28.createElement(ManagerReferenceNodeContext.Provider, {
    value: referenceNode
  }, React28.createElement(ManagerReferenceNodeSetterContext.Provider, {
    value: handleSetReferenceNode
  }, children));
}

// node_modules/react-popper/lib/esm/utils.js
var React29 = __toESM(require_react());
var unwrapArray = function unwrapArray2(arg) {
  return Array.isArray(arg) ? arg[0] : arg;
};
var safeInvoke = function safeInvoke2(fn2) {
  if (typeof fn2 === "function") {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return fn2.apply(void 0, args);
  }
};
var setRef = function setRef2(ref, node3) {
  if (typeof ref === "function") {
    return safeInvoke(ref, node3);
  } else if (ref != null) {
    ref.current = node3;
  }
};
var fromEntries = function fromEntries2(entries) {
  return entries.reduce(function(acc, _ref4) {
    var key = _ref4[0], value = _ref4[1];
    acc[key] = value;
    return acc;
  }, {});
};
var useIsomorphicLayoutEffect = typeof window !== "undefined" && window.document && window.document.createElement ? React29.useLayoutEffect : React29.useEffect;

// node_modules/react-popper/lib/esm/usePopper.js
var React30 = __toESM(require_react());
var ReactDOM2 = __toESM(require_react_dom());

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements2 = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName3(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow3(node3) {
  if (node3 == null) {
    return window;
  }
  if (node3.toString() !== "[object Window]") {
    var ownerDocument = node3.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node3;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement3(node3) {
  var OwnElement = getWindow3(node3).Element;
  return node3 instanceof OwnElement || node3 instanceof Element;
}
function isHTMLElement3(node3) {
  var OwnElement = getWindow3(node3).HTMLElement;
  return node3 instanceof OwnElement || node3 instanceof HTMLElement;
}
function isShadowRoot3(node3) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow3(node3).ShadowRoot;
  return node3 instanceof OwnElement || node3 instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref4) {
  var state = _ref4.state;
  Object.keys(state.elements).forEach(function(name2) {
    var style = state.styles[name2] || {};
    var attributes = state.attributes[name2] || {};
    var element = state.elements[name2];
    if (!isHTMLElement3(element) || !getNodeName3(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name3) {
      var value = attributes[name3];
      if (value === false) {
        element.removeAttribute(name3);
      } else {
        element.setAttribute(name3, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref23) {
  var state = _ref23.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name2) {
      var element = state.elements[name2];
      var attributes = state.attributes[name2] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name2) ? state.styles[name2] : initialStyles[name2]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement3(element) || !getNodeName3(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max3 = Math.max;
var min3 = Math.min;
var round2 = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect2(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement3(element)) {
    scaleX = element.offsetWidth > 0 ? round2(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round2(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref4 = isElement3(element) ? getWindow3(element) : window, visualViewport = _ref4.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y3 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y3,
    right: x2 + width,
    bottom: y3 + height,
    left: x2,
    x: x2,
    y: y3
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect2(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains3(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot3(rootNode)) {
    var next2 = child;
    do {
      if (next2 && parent.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle4(element) {
  return getWindow3(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement2(element) {
  return ["table", "td", "th"].indexOf(getNodeName3(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement3(element) {
  return ((isElement3(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode4(element) {
  if (getNodeName3(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot3(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement3(element)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent2(element) {
  if (!isHTMLElement3(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle4(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock2(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement3(element)) {
    var elementCss = getComputedStyle4(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode4(element);
  if (isShadowRoot3(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement3(currentNode) && ["html", "body"].indexOf(getNodeName3(currentNode)) < 0) {
    var css5 = getComputedStyle4(currentNode);
    if (css5.transform !== "none" || css5.perspective !== "none" || css5.contain === "paint" || ["transform", "perspective"].indexOf(css5.willChange) !== -1 || isFirefox && css5.willChange === "filter" || isFirefox && css5.filter && css5.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent2(element) {
  var window2 = getWindow3(element);
  var offsetParent = getTrueOffsetParent2(element);
  while (offsetParent && isTableElement2(offsetParent) && getComputedStyle4(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent2(offsetParent);
  }
  if (offsetParent && (getNodeName3(offsetParent) === "html" || getNodeName3(offsetParent) === "body" && getComputedStyle4(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock2(element) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min4, value, max4) {
  return max3(min4, min3(value, max4));
}
function withinMaxClamp(min4, value, max4) {
  var v = within(min4, value, max4);
  return v > max4 ? max4 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow4(_ref4) {
  var _state$modifiersData$;
  var state = _ref4.state, name2 = _ref4.name, options2 = _ref4.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options2.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent2(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min4 = paddingObject[minProp];
  var max4 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset3 = within(min4, center, max4);
  var axisProp = axis;
  state.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset3, _state$modifiersData$.centerOffset = offset3 - center, _state$modifiersData$);
}
function effect2(_ref23) {
  var state = _ref23.state, options2 = _ref23.options;
  var _options$element = options2.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains3(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow4,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref4, win) {
  var x2 = _ref4.x, y3 = _ref4.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round2(x2 * dpr) / dpr || 0,
    y: round2(y3 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref23) {
  var _Object$assign2;
  var popper2 = _ref23.popper, popperRect = _ref23.popperRect, placement = _ref23.placement, variation = _ref23.variation, offsets = _ref23.offsets, position2 = _ref23.position, gpuAcceleration = _ref23.gpuAcceleration, adaptive = _ref23.adaptive, roundOffsets = _ref23.roundOffsets, isFixed = _ref23.isFixed;
  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y3 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref32 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y: y3
  }) : {
    x: x2,
    y: y3
  };
  x2 = _ref32.x;
  y3 = _ref32.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent2(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow3(popper2)) {
      offsetParent = getDocumentElement3(popper2);
      if (getComputedStyle4(offsetParent).position !== "static" && position2 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y3 -= offsetY - popperRect.height;
      y3 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position2
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x2,
    y: y3
  }, getWindow3(popper2)) : {
    x: x2,
    y: y3
  };
  x2 = _ref4.x;
  y3 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y3 + "px)" : "translate3d(" + x2 + "px, " + y3 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y3 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options2 = _ref5.options;
  var _options$gpuAccelerat = options2.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options2.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options2.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref4) {
  var state = _ref4.state, instance = _ref4.instance, options2 = _ref4.options;
  var _options$scroll = options2.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options2.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow3(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement2(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node3) {
  var win = getWindow3(node3);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX2(element) {
  return getBoundingClientRect2(getDocumentElement3(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect2(element, strategy) {
  var win = getWindow3(element);
  var html = getDocumentElement3(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x2 = 0;
  var y3 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y3 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2 + getWindowScrollBarX2(element),
    y: y3
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect2(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement3(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max3(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max3(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX2(element);
  var y3 = -winScroll.scrollTop;
  if (getComputedStyle4(body || html).direction === "rtl") {
    x2 += max3(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y3
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle4(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node3) {
  if (["html", "body", "#document"].indexOf(getNodeName3(node3)) >= 0) {
    return node3.ownerDocument.body;
  }
  if (isHTMLElement3(node3) && isScrollParent(node3)) {
    return node3;
  }
  return getScrollParent(getParentNode4(node3));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow3(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode4(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect2(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect2(element, strategy) {
  var rect = getBoundingClientRect2(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect2(getViewportRect2(element, strategy)) : isElement3(clippingParent) ? getInnerBoundingClientRect2(clippingParent, strategy) : rectToClientRect2(getDocumentRect2(getDocumentElement3(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode4(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle4(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement3(element) ? getOffsetParent2(element) : element;
  if (!isElement3(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement3(clippingParent) && contains3(clippingParent, clipperElement) && getNodeName3(clippingParent) !== "body";
  });
}
function getClippingRect2(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max3(rect.top, accRect.top);
    accRect.right = min3(rect.right, accRect.right);
    accRect.bottom = min3(rect.bottom, accRect.bottom);
    accRect.left = max3(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref4) {
  var reference2 = _ref4.reference, element = _ref4.element, placement = _ref4.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow2(state, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect2(isElement3(element) ? element : element.contextElement || getDocumentElement3(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect2(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect2(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset3 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset3[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements2 : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements3 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements3.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements3;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow2(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a3, b2) {
    return overflows[a3] - overflows[b2];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement2(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip3(_ref4) {
  var state = _ref4.state, options2 = _ref4.options, name2 = _ref4.name;
  if (state.modifiersData[name2]._skip) {
    return;
  }
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options2.fallbackPlacements, padding = options2.padding, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, _options$flipVariatio = options2.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options2.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement2(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements3 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements3[0];
  for (var i2 = 0; i2 < placements3.length; i2++) {
    var placement = placements3[i2];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow2(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement2(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement2(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements3.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name2]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip3,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide3(_ref4) {
  var state = _ref4.state, name2 = _ref4.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow2(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow2(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name2] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide3
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset3) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref4 = typeof offset3 === "function" ? offset3(Object.assign({}, rects, {
    placement
  })) : offset3, skidding = _ref4[0], distance = _ref4[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset2(_ref23) {
  var state = _ref23.state, options2 = _ref23.options, name2 = _ref23.name;
  var _options$offset = options2.offset, offset3 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements2.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset3);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y3 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x2;
    state.modifiersData.popperOffsets.y += y3;
  }
  state.modifiersData[name2] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset2
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref4) {
  var state = _ref4.state, name2 = _ref4.name;
  state.modifiersData[name2] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref4) {
  var state = _ref4.state, options2 = _ref4.options, name2 = _ref4.name;
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, padding = options2.padding, _options$tether = options2.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options2.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow2(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset3 = popperOffsets2[mainAxis];
    var min4 = offset3 + overflow[mainSide];
    var max4 = offset3 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset2 = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent2(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset3 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset3 + maxOffset2 - offsetModifierValue;
    var preventedOffset = within(tether ? min3(min4, tetherMin) : min4, offset3, tether ? max3(max4, tetherMax) : max4);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset3;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name2] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll2(node3) {
  if (node3 === getWindow3(node3) || !isHTMLElement3(node3)) {
    return getWindowScroll(node3);
  } else {
    return getHTMLElementScroll(node3);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round2(rect.width) / element.offsetWidth || 1;
  var scaleY = round2(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement3(offsetParent);
  var offsetParentIsScaled = isHTMLElement3(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement3(offsetParent);
  var rect = getBoundingClientRect2(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName3(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll2(offsetParent);
    }
    if (isHTMLElement3(offsetParent)) {
      offsets = getBoundingClientRect2(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX2(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers2) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers2.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers2.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers2) {
  var orderedModifiers = order(modifiers2);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce2(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers2) {
  var merged = modifiers2.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions3 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper4(reference2, popper2, options2) {
    if (options2 === void 0) {
      options2 = defaultOptions3;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions3),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options3 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions3, state.options, options3);
        state.scrollParents = {
          reference: isElement3(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m3) {
          return m3.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent2(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index4 = 0; index4 < state.orderedModifiers.length; index4++) {
          if (state.reset === true) {
            state.reset = false;
            index4 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index4], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name: name2,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce2(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options2).then(function(state2) {
      if (!isDestroyed && options2.onFirstUpdate) {
        options2.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref4) {
        var name2 = _ref4.name, _ref$options = _ref4.options, options3 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref4.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name: name2,
            instance,
            options: options3
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = popperGenerator();

// node_modules/@popperjs/core/lib/popper-lite.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
var createPopper2 = popperGenerator({
  defaultModifiers
});

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper3 = popperGenerator({
  defaultModifiers: defaultModifiers2
});

// node_modules/react-popper/lib/esm/usePopper.js
var import_react_fast_compare = __toESM(require_react_fast_compare());
var EMPTY_MODIFIERS = [];
var usePopper = function usePopper2(referenceElement, popperElement, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var prevOptions = React30.useRef(null);
  var optionsWithDefaults = {
    onFirstUpdate: options2.onFirstUpdate,
    placement: options2.placement || "bottom",
    strategy: options2.strategy || "absolute",
    modifiers: options2.modifiers || EMPTY_MODIFIERS
  };
  var _React$useState = React30.useState({
    styles: {
      popper: {
        position: optionsWithDefaults.strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), state = _React$useState[0], setState = _React$useState[1];
  var updateStateModifier = React30.useMemo(function() {
    return {
      name: "updateState",
      enabled: true,
      phase: "write",
      fn: function fn2(_ref4) {
        var state2 = _ref4.state;
        var elements = Object.keys(state2.elements);
        ReactDOM2.flushSync(function() {
          setState({
            styles: fromEntries(elements.map(function(element) {
              return [element, state2.styles[element] || {}];
            })),
            attributes: fromEntries(elements.map(function(element) {
              return [element, state2.attributes[element]];
            }))
          });
        });
      },
      requires: ["computeStyles"]
    };
  }, []);
  var popperOptions = React30.useMemo(function() {
    var newOptions = {
      onFirstUpdate: optionsWithDefaults.onFirstUpdate,
      placement: optionsWithDefaults.placement,
      strategy: optionsWithDefaults.strategy,
      modifiers: [].concat(optionsWithDefaults.modifiers, [updateStateModifier, {
        name: "applyStyles",
        enabled: false
      }])
    };
    if ((0, import_react_fast_compare.default)(prevOptions.current, newOptions)) {
      return prevOptions.current || newOptions;
    } else {
      prevOptions.current = newOptions;
      return newOptions;
    }
  }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]);
  var popperInstanceRef = React30.useRef();
  useIsomorphicLayoutEffect(function() {
    if (popperInstanceRef.current) {
      popperInstanceRef.current.setOptions(popperOptions);
    }
  }, [popperOptions]);
  useIsomorphicLayoutEffect(function() {
    if (referenceElement == null || popperElement == null) {
      return;
    }
    var createPopper4 = options2.createPopper || createPopper3;
    var popperInstance = createPopper4(referenceElement, popperElement, popperOptions);
    popperInstanceRef.current = popperInstance;
    return function() {
      popperInstance.destroy();
      popperInstanceRef.current = null;
    };
  }, [referenceElement, popperElement, options2.createPopper]);
  return {
    state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
    styles: state.styles,
    attributes: state.attributes,
    update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
    forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
  };
};

// node_modules/react-popper/lib/esm/Popper.js
var NOOP = function NOOP2() {
  return void 0;
};
var NOOP_PROMISE = function NOOP_PROMISE2() {
  return Promise.resolve(null);
};
var EMPTY_MODIFIERS2 = [];
function Popper(_ref4) {
  var _ref$placement = _ref4.placement, placement = _ref$placement === void 0 ? "bottom" : _ref$placement, _ref$strategy = _ref4.strategy, strategy = _ref$strategy === void 0 ? "absolute" : _ref$strategy, _ref$modifiers = _ref4.modifiers, modifiers2 = _ref$modifiers === void 0 ? EMPTY_MODIFIERS2 : _ref$modifiers, referenceElement = _ref4.referenceElement, onFirstUpdate = _ref4.onFirstUpdate, innerRef = _ref4.innerRef, children = _ref4.children;
  var referenceNode = React31.useContext(ManagerReferenceNodeContext);
  var _React$useState = React31.useState(null), popperElement = _React$useState[0], setPopperElement = _React$useState[1];
  var _React$useState2 = React31.useState(null), arrowElement = _React$useState2[0], setArrowElement = _React$useState2[1];
  React31.useEffect(function() {
    setRef(innerRef, popperElement);
  }, [innerRef, popperElement]);
  var options2 = React31.useMemo(function() {
    return {
      placement,
      strategy,
      onFirstUpdate,
      modifiers: [].concat(modifiers2, [{
        name: "arrow",
        enabled: arrowElement != null,
        options: {
          element: arrowElement
        }
      }])
    };
  }, [placement, strategy, onFirstUpdate, modifiers2, arrowElement]);
  var _usePopper = usePopper(referenceElement || referenceNode, popperElement, options2), state = _usePopper.state, styles2 = _usePopper.styles, forceUpdate = _usePopper.forceUpdate, update = _usePopper.update;
  var childrenProps = React31.useMemo(function() {
    return {
      ref: setPopperElement,
      style: styles2.popper,
      placement: state ? state.placement : placement,
      hasPopperEscaped: state && state.modifiersData.hide ? state.modifiersData.hide.hasPopperEscaped : null,
      isReferenceHidden: state && state.modifiersData.hide ? state.modifiersData.hide.isReferenceHidden : null,
      arrowProps: {
        style: styles2.arrow,
        ref: setArrowElement
      },
      forceUpdate: forceUpdate || NOOP,
      update: update || NOOP_PROMISE
    };
  }, [setPopperElement, setArrowElement, placement, state, styles2, update, forceUpdate]);
  return unwrapArray(children)(childrenProps);
}

// node_modules/react-popper/lib/esm/Reference.js
var React32 = __toESM(require_react());
var import_warning = __toESM(require_warning());
function Reference(_ref4) {
  var children = _ref4.children, innerRef = _ref4.innerRef;
  var setReferenceNode = React32.useContext(ManagerReferenceNodeSetterContext);
  var refHandler = React32.useCallback(function(node3) {
    setRef(innerRef, node3);
    safeInvoke(setReferenceNode, node3);
  }, [innerRef, setReferenceNode]);
  React32.useEffect(function() {
    return function() {
      return setRef(innerRef, null);
    };
  }, []);
  React32.useEffect(function() {
    (0, import_warning.default)(Boolean(setReferenceNode), "`Reference` should not be used outside of a `Manager` component.");
  }, [setReferenceNode]);
  return unwrapArray(children)({
    ref: refHandler
  });
}

// node_modules/date-fns/esm/set/index.js
function set(dirtyDate, values) {
  requiredArgs(2, arguments);
  if (_typeof(values) !== "object" || values === null) {
    throw new RangeError("values parameter must be an object");
  }
  var date = toDate(dirtyDate);
  if (isNaN(date.getTime())) {
    return /* @__PURE__ */ new Date(NaN);
  }
  if (values.year != null) {
    date.setFullYear(values.year);
  }
  if (values.month != null) {
    date = setMonth(date, values.month);
  }
  if (values.date != null) {
    date.setDate(toInteger(values.date));
  }
  if (values.hours != null) {
    date.setHours(toInteger(values.hours));
  }
  if (values.minutes != null) {
    date.setMinutes(toInteger(values.minutes));
  }
  if (values.seconds != null) {
    date.setSeconds(toInteger(values.seconds));
  }
  if (values.milliseconds != null) {
    date.setMilliseconds(toInteger(values.milliseconds));
  }
  return date;
}

// node_modules/react-datepicker/dist/es/index.js
function le(e4, t4) {
  var r2 = Object.keys(e4);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e4);
    t4 && (n = n.filter(function(t5) {
      return Object.getOwnPropertyDescriptor(e4, t5).enumerable;
    })), r2.push.apply(r2, n);
  }
  return r2;
}
function de(e4) {
  for (var t4 = 1; t4 < arguments.length; t4++) {
    var r2 = null != arguments[t4] ? arguments[t4] : {};
    t4 % 2 ? le(Object(r2), true).forEach(function(t5) {
      ye(e4, t5, r2[t5]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(r2)) : le(Object(r2)).forEach(function(t5) {
      Object.defineProperty(e4, t5, Object.getOwnPropertyDescriptor(r2, t5));
    });
  }
  return e4;
}
function ue(e4) {
  return ue = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
    return typeof e5;
  } : function(e5) {
    return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
  }, ue(e4);
}
function he(e4, t4) {
  if (!(e4 instanceof t4))
    throw new TypeError("Cannot call a class as a function");
}
function me(e4, t4) {
  for (var r2 = 0; r2 < t4.length; r2++) {
    var n = t4[r2];
    n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(e4, _e(n.key), n);
  }
}
function fe(e4, t4, r2) {
  return t4 && me(e4.prototype, t4), r2 && me(e4, r2), Object.defineProperty(e4, "prototype", { writable: false }), e4;
}
function ye(e4, t4, r2) {
  return (t4 = _e(t4)) in e4 ? Object.defineProperty(e4, t4, { value: r2, enumerable: true, configurable: true, writable: true }) : e4[t4] = r2, e4;
}
function ve() {
  return ve = Object.assign ? Object.assign.bind() : function(e4) {
    for (var t4 = 1; t4 < arguments.length; t4++) {
      var r2 = arguments[t4];
      for (var n in r2)
        Object.prototype.hasOwnProperty.call(r2, n) && (e4[n] = r2[n]);
    }
    return e4;
  }, ve.apply(this, arguments);
}
function De(e4, t4) {
  if ("function" != typeof t4 && null !== t4)
    throw new TypeError("Super expression must either be null or a function");
  e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t4 && ke(e4, t4);
}
function ge(e4) {
  return ge = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e5) {
    return e5.__proto__ || Object.getPrototypeOf(e5);
  }, ge(e4);
}
function ke(e4, t4) {
  return ke = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
    return e5.__proto__ = t5, e5;
  }, ke(e4, t4);
}
function we(e4) {
  if (void 0 === e4)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e4;
}
function be(e4) {
  var t4 = function() {
    if ("undefined" == typeof Reflect || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if ("function" == typeof Proxy)
      return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch (e5) {
      return false;
    }
  }();
  return function() {
    var r2, n = ge(e4);
    if (t4) {
      var o = ge(this).constructor;
      r2 = Reflect.construct(n, arguments, o);
    } else
      r2 = n.apply(this, arguments);
    return function(e5, t5) {
      if (t5 && ("object" == typeof t5 || "function" == typeof t5))
        return t5;
      if (void 0 !== t5)
        throw new TypeError("Derived constructors may only return object or undefined");
      return we(e5);
    }(this, r2);
  };
}
function Se(e4) {
  return function(e5) {
    if (Array.isArray(e5))
      return Ce(e5);
  }(e4) || function(e5) {
    if ("undefined" != typeof Symbol && null != e5[Symbol.iterator] || null != e5["@@iterator"])
      return Array.from(e5);
  }(e4) || function(e5, t4) {
    if (!e5)
      return;
    if ("string" == typeof e5)
      return Ce(e5, t4);
    var r2 = Object.prototype.toString.call(e5).slice(8, -1);
    "Object" === r2 && e5.constructor && (r2 = e5.constructor.name);
    if ("Map" === r2 || "Set" === r2)
      return Array.from(e5);
    if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
      return Ce(e5, t4);
  }(e4) || function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
function Ce(e4, t4) {
  (null == t4 || t4 > e4.length) && (t4 = e4.length);
  for (var r2 = 0, n = new Array(t4); r2 < t4; r2++)
    n[r2] = e4[r2];
  return n;
}
function _e(e4) {
  var t4 = function(e5, t5) {
    if ("object" != typeof e5 || null === e5)
      return e5;
    var r2 = e5[Symbol.toPrimitive];
    if (void 0 !== r2) {
      var n = r2.call(e5, t5 || "default");
      if ("object" != typeof n)
        return n;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === t5 ? String : Number)(e5);
  }(e4, "string");
  return "symbol" == typeof t4 ? t4 : String(t4);
}
var Me = function(e4, t4) {
  switch (e4) {
    case "P":
      return t4.date({ width: "short" });
    case "PP":
      return t4.date({ width: "medium" });
    case "PPP":
      return t4.date({ width: "long" });
    default:
      return t4.date({ width: "full" });
  }
};
var Pe = function(e4, t4) {
  switch (e4) {
    case "p":
      return t4.time({ width: "short" });
    case "pp":
      return t4.time({ width: "medium" });
    case "ppp":
      return t4.time({ width: "long" });
    default:
      return t4.time({ width: "full" });
  }
};
var Ee = { p: Pe, P: function(e4, t4) {
  var r2, n = e4.match(/(P+)(p+)?/) || [], o = n[1], a3 = n[2];
  if (!a3)
    return Me(e4, t4);
  switch (o) {
    case "P":
      r2 = t4.dateTime({ width: "short" });
      break;
    case "PP":
      r2 = t4.dateTime({ width: "medium" });
      break;
    case "PPP":
      r2 = t4.dateTime({ width: "long" });
      break;
    default:
      r2 = t4.dateTime({ width: "full" });
  }
  return r2.replace("{{date}}", Me(o, t4)).replace("{{time}}", Pe(a3, t4));
} };
var Ne = 12;
var xe = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
function Ye(e4) {
  var t4 = e4 ? "string" == typeof e4 || e4 instanceof String ? parseISO(e4) : toDate(e4) : /* @__PURE__ */ new Date();
  return Te(t4) ? t4 : null;
}
function Te(e4, t4) {
  return t4 = t4 || /* @__PURE__ */ new Date("1/1/1000"), isValid(e4) && !isBefore(e4, t4);
}
function Ie(e4, t4, r2) {
  if ("en" === r2)
    return format(e4, t4, { awareOfUnicodeTokens: true });
  var n = Ge(r2);
  return r2 && !n && console.warn('A locale object was not found for the provided string ["'.concat(r2, '"].')), !n && $e() && Ge($e()) && (n = Ge($e())), format(e4, t4, { locale: n || null, awareOfUnicodeTokens: true });
}
function Oe(e4, t4) {
  var r2 = t4.dateFormat, n = t4.locale;
  return e4 && Ie(e4, Array.isArray(r2) ? r2[0] : r2, n) || "";
}
function Re(e4, t4) {
  var r2 = t4.hour, n = void 0 === r2 ? 0 : r2, o = t4.minute, a3 = void 0 === o ? 0 : o, s3 = t4.second;
  return setHours(setMinutes(setSeconds(e4, void 0 === s3 ? 0 : s3), a3), n);
}
function Le(e4, t4, r2) {
  var n = Ge(t4 || $e());
  return startOfWeek(e4, { locale: n, weekStartsOn: r2 });
}
function Fe(e4) {
  return startOfMonth(e4);
}
function Ae(e4) {
  return startOfYear(e4);
}
function We(e4) {
  return startOfQuarter(e4);
}
function Ke() {
  return startOfDay(Ye());
}
function Be(e4, t4) {
  return e4 && t4 ? isSameYear(e4, t4) : !e4 && !t4;
}
function Qe(e4, t4) {
  return e4 && t4 ? isSameMonth(e4, t4) : !e4 && !t4;
}
function He(e4, t4) {
  return e4 && t4 ? isSameQuarter(e4, t4) : !e4 && !t4;
}
function je(e4, t4) {
  return e4 && t4 ? isSameDay(e4, t4) : !e4 && !t4;
}
function Ve(e4, t4) {
  return e4 && t4 ? isEqual(e4, t4) : !e4 && !t4;
}
function qe(e4, t4, r2) {
  var n, o = startOfDay(t4), a3 = endOfDay(r2);
  try {
    n = isWithinInterval(e4, { start: o, end: a3 });
  } catch (e5) {
    n = false;
  }
  return n;
}
function $e() {
  return ("undefined" != typeof window ? window : globalThis).__localeId__;
}
function Ge(e4) {
  if ("string" == typeof e4) {
    var t4 = "undefined" != typeof window ? window : globalThis;
    return t4.__localeData__ ? t4.__localeData__[e4] : null;
  }
  return e4;
}
function Je(e4, t4) {
  return Ie(setMonth(Ye(), e4), "LLLL", t4);
}
function Xe(e4, t4) {
  return Ie(setMonth(Ye(), e4), "LLL", t4);
}
function Ze(e4) {
  var t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t4.minDate, n = t4.maxDate, o = t4.excludeDates, a3 = t4.excludeDateIntervals, s3 = t4.includeDates, i2 = t4.includeDateIntervals, p = t4.filterDate;
  return it(e4, { minDate: r2, maxDate: n }) || o && o.some(function(t5) {
    return je(e4, t5);
  }) || a3 && a3.some(function(t5) {
    var r3 = t5.start, n2 = t5.end;
    return isWithinInterval(e4, { start: r3, end: n2 });
  }) || s3 && !s3.some(function(t5) {
    return je(e4, t5);
  }) || i2 && !i2.some(function(t5) {
    var r3 = t5.start, n2 = t5.end;
    return isWithinInterval(e4, { start: r3, end: n2 });
  }) || p && !p(Ye(e4)) || false;
}
function et(e4) {
  var t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t4.excludeDates, n = t4.excludeDateIntervals;
  return n && n.length > 0 ? n.some(function(t5) {
    var r3 = t5.start, n2 = t5.end;
    return isWithinInterval(e4, { start: r3, end: n2 });
  }) : r2 && r2.some(function(t5) {
    return je(e4, t5);
  }) || false;
}
function tt(e4) {
  var t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t4.minDate, n = t4.maxDate, o = t4.excludeDates, a3 = t4.includeDates, s3 = t4.filterDate;
  return it(e4, { minDate: startOfMonth(r2), maxDate: endOfMonth(n) }) || o && o.some(function(t5) {
    return Qe(e4, t5);
  }) || a3 && !a3.some(function(t5) {
    return Qe(e4, t5);
  }) || s3 && !s3(Ye(e4)) || false;
}
function rt(e4, t4, r2, n) {
  var o = getYear(e4), a3 = getMonth(e4), s3 = getYear(t4), i2 = getMonth(t4), p = getYear(n);
  return o === s3 && o === p ? a3 <= r2 && r2 <= i2 : o < s3 ? p === o && a3 <= r2 || p === s3 && i2 >= r2 || p < s3 && p > o : void 0;
}
function nt(e4) {
  var t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t4.minDate, n = t4.maxDate, o = t4.excludeDates, a3 = t4.includeDates, s3 = t4.filterDate;
  return it(e4, { minDate: r2, maxDate: n }) || o && o.some(function(t5) {
    return He(e4, t5);
  }) || a3 && !a3.some(function(t5) {
    return He(e4, t5);
  }) || s3 && !s3(Ye(e4)) || false;
}
function ot(e4, t4, r2) {
  if (!isValid(t4) || !isValid(r2))
    return false;
  var n = getYear(t4), a3 = getYear(r2);
  return n <= e4 && a3 >= e4;
}
function at(e4) {
  var t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t4.minDate, n = t4.maxDate, o = t4.excludeDates, a3 = t4.includeDates, s3 = t4.filterDate, i2 = new Date(e4, 0, 1);
  return it(i2, { minDate: startOfYear(r2), maxDate: endOfYear(n) }) || o && o.some(function(e5) {
    return Be(i2, e5);
  }) || a3 && !a3.some(function(e5) {
    return Be(i2, e5);
  }) || s3 && !s3(Ye(i2)) || false;
}
function st(e4, t4, r2, n) {
  var o = getYear(e4), a3 = getQuarter(e4), s3 = getYear(t4), i2 = getQuarter(t4), p = getYear(n);
  return o === s3 && o === p ? a3 <= r2 && r2 <= i2 : o < s3 ? p === o && a3 <= r2 || p === s3 && i2 >= r2 || p < s3 && p > o : void 0;
}
function it(e4) {
  var t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t4.minDate, n = t4.maxDate;
  return r2 && differenceInCalendarDays(e4, r2) < 0 || n && differenceInCalendarDays(e4, n) > 0;
}
function pt(e4, t4) {
  return t4.some(function(t5) {
    return getHours(t5) === getHours(e4) && getMinutes(t5) === getMinutes(e4);
  });
}
function ct(e4) {
  var t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t4.excludeTimes, n = t4.includeTimes, o = t4.filterTime;
  return r2 && pt(e4, r2) || n && !pt(e4, n) || o && !o(e4) || false;
}
function lt(e4, t4) {
  var r2 = t4.minTime, n = t4.maxTime;
  if (!r2 || !n)
    throw new Error("Both minTime and maxTime props required");
  var o, a3 = Ye(), s3 = setHours(setMinutes(a3, getMinutes(e4)), getHours(e4)), i2 = setHours(setMinutes(a3, getMinutes(r2)), getHours(r2)), p = setHours(setMinutes(a3, getMinutes(n)), getHours(n));
  try {
    o = !isWithinInterval(s3, { start: i2, end: p });
  } catch (e5) {
    o = false;
  }
  return o;
}
function dt(e4) {
  var t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t4.minDate, n = t4.includeDates, o = subMonths(e4, 1);
  return r2 && differenceInCalendarMonths(r2, o) > 0 || n && n.every(function(e5) {
    return differenceInCalendarMonths(e5, o) > 0;
  }) || false;
}
function ut(e4) {
  var t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t4.maxDate, n = t4.includeDates, o = addMonths(e4, 1);
  return r2 && differenceInCalendarMonths(o, r2) > 0 || n && n.every(function(e5) {
    return differenceInCalendarMonths(o, e5) > 0;
  }) || false;
}
function ht(e4) {
  var t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t4.minDate, n = t4.includeDates, o = subYears(e4, 1);
  return r2 && differenceInCalendarYears(r2, o) > 0 || n && n.every(function(e5) {
    return differenceInCalendarYears(e5, o) > 0;
  }) || false;
}
function mt(e4) {
  var t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t4.maxDate, n = t4.includeDates, o = addYears(e4, 1);
  return r2 && differenceInCalendarYears(o, r2) > 0 || n && n.every(function(e5) {
    return differenceInCalendarYears(o, e5) > 0;
  }) || false;
}
function ft(e4) {
  var t4 = e4.minDate, r2 = e4.includeDates;
  if (r2 && t4) {
    var n = r2.filter(function(e5) {
      return differenceInCalendarDays(e5, t4) >= 0;
    });
    return min2(n);
  }
  return r2 ? min2(r2) : t4;
}
function yt(e4) {
  var t4 = e4.maxDate, r2 = e4.includeDates;
  if (r2 && t4) {
    var n = r2.filter(function(e5) {
      return differenceInCalendarDays(e5, t4) <= 0;
    });
    return max2(n);
  }
  return r2 ? max2(r2) : t4;
}
function vt() {
  for (var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "react-datepicker__day--highlighted", r2 = /* @__PURE__ */ new Map(), o = 0, a3 = e4.length; o < a3; o++) {
    var s3 = e4[o];
    if (isDate(s3)) {
      var i2 = Ie(s3, "MM.dd.yyyy"), p = r2.get(i2) || [];
      p.includes(t4) || (p.push(t4), r2.set(i2, p));
    } else if ("object" === ue(s3)) {
      var c2 = Object.keys(s3), l = c2[0], d3 = s3[c2[0]];
      if ("string" == typeof l && d3.constructor === Array)
        for (var u2 = 0, h3 = d3.length; u2 < h3; u2++) {
          var m3 = Ie(d3[u2], "MM.dd.yyyy"), f = r2.get(m3) || [];
          f.includes(l) || (f.push(l), r2.set(m3, f));
        }
    }
  }
  return r2;
}
function Dt() {
  var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "react-datepicker__day--holidays", r2 = /* @__PURE__ */ new Map();
  return e4.forEach(function(e5) {
    var o = e5.date, a3 = e5.holidayName;
    if (isDate(o)) {
      var s3 = Ie(o, "MM.dd.yyyy"), i2 = r2.get(s3) || {};
      if (!("className" in i2) || i2.className !== t4 || (p = i2.holidayNames, c2 = [a3], p.length !== c2.length || !p.every(function(e6, t5) {
        return e6 === c2[t5];
      }))) {
        var p, c2;
        i2.className = t4;
        var l = i2.holidayNames;
        i2.holidayNames = l ? [].concat(Se(l), [a3]) : [a3], r2.set(s3, i2);
      }
    }
  }), r2;
}
function gt(e4, t4, r2, n, o) {
  for (var a3 = o.length, p = [], c2 = 0; c2 < a3; c2++) {
    var l = addMinutes(addHours(e4, getHours(o[c2])), getMinutes(o[c2])), d3 = addMinutes(e4, (r2 + 1) * n);
    isAfter(l, t4) && isBefore(l, d3) && p.push(o[c2]);
  }
  return p;
}
function kt(e4) {
  return e4 < 10 ? "0".concat(e4) : "".concat(e4);
}
function wt(e4) {
  var t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Ne, r2 = Math.ceil(getYear(e4) / t4) * t4;
  return { startPeriod: r2 - (t4 - 1), endPeriod: r2 };
}
function bt(e4) {
  var t4 = e4.getSeconds(), r2 = e4.getMilliseconds();
  return toDate(e4.getTime() - 1e3 * t4 - r2);
}
function St(e4, t4, r2, n) {
  for (var o = [], a3 = 0; a3 < 2 * t4 + 1; a3++) {
    var s3 = e4 + t4 - a3, i2 = true;
    r2 && (i2 = getYear(r2) <= s3), n && i2 && (i2 = getYear(n) >= s3), i2 && o.push(s3);
  }
  return o;
}
var Ct = react_onclickoutside_es_default(function(n) {
  De(a3, import_react30.default.Component);
  var o = be(a3);
  function a3(r2) {
    var n2;
    he(this, a3), ye(we(n2 = o.call(this, r2)), "renderOptions", function() {
      var t4 = n2.props.year, r3 = n2.state.yearsList.map(function(r4) {
        return import_react30.default.createElement("div", { className: t4 === r4 ? "react-datepicker__year-option react-datepicker__year-option--selected_year" : "react-datepicker__year-option", key: r4, onClick: n2.onChange.bind(we(n2), r4), "aria-selected": t4 === r4 ? "true" : void 0 }, t4 === r4 ? import_react30.default.createElement("span", { className: "react-datepicker__year-option--selected" }, "") : "", r4);
      }), o2 = n2.props.minDate ? getYear(n2.props.minDate) : null, a4 = n2.props.maxDate ? getYear(n2.props.maxDate) : null;
      return a4 && n2.state.yearsList.find(function(e4) {
        return e4 === a4;
      }) || r3.unshift(import_react30.default.createElement("div", { className: "react-datepicker__year-option", key: "upcoming", onClick: n2.incrementYears }, import_react30.default.createElement("a", { className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-upcoming" }))), o2 && n2.state.yearsList.find(function(e4) {
        return e4 === o2;
      }) || r3.push(import_react30.default.createElement("div", { className: "react-datepicker__year-option", key: "previous", onClick: n2.decrementYears }, import_react30.default.createElement("a", { className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-previous" }))), r3;
    }), ye(we(n2), "onChange", function(e4) {
      n2.props.onChange(e4);
    }), ye(we(n2), "handleClickOutside", function() {
      n2.props.onCancel();
    }), ye(we(n2), "shiftYears", function(e4) {
      var t4 = n2.state.yearsList.map(function(t5) {
        return t5 + e4;
      });
      n2.setState({ yearsList: t4 });
    }), ye(we(n2), "incrementYears", function() {
      return n2.shiftYears(1);
    }), ye(we(n2), "decrementYears", function() {
      return n2.shiftYears(-1);
    });
    var s3 = r2.yearDropdownItemNumber, i2 = r2.scrollableYearDropdown, p = s3 || (i2 ? 10 : 5);
    return n2.state = { yearsList: St(n2.props.year, p, n2.props.minDate, n2.props.maxDate) }, n2.dropdownRef = (0, import_react30.createRef)(), n2;
  }
  return fe(a3, [{ key: "componentDidMount", value: function() {
    var e4 = this.dropdownRef.current;
    if (e4) {
      var t4 = e4.children ? Array.from(e4.children) : null, r2 = t4 ? t4.find(function(e5) {
        return e5.ariaSelected;
      }) : null;
      e4.scrollTop = r2 ? r2.offsetTop + (r2.clientHeight - e4.clientHeight) / 2 : (e4.scrollHeight - e4.clientHeight) / 2;
    }
  } }, { key: "render", value: function() {
    var t4 = (0, import_classnames2.default)({ "react-datepicker__year-dropdown": true, "react-datepicker__year-dropdown--scrollable": this.props.scrollableYearDropdown });
    return import_react30.default.createElement("div", { className: t4, ref: this.dropdownRef }, this.renderOptions());
  } }]), a3;
}());
var _t = function(t4) {
  De(n, import_react30.default.Component);
  var r2 = be(n);
  function n() {
    var t5;
    he(this, n);
    for (var o = arguments.length, a3 = new Array(o), s3 = 0; s3 < o; s3++)
      a3[s3] = arguments[s3];
    return ye(we(t5 = r2.call.apply(r2, [this].concat(a3))), "state", { dropdownVisible: false }), ye(we(t5), "renderSelectOptions", function() {
      for (var r3 = t5.props.minDate ? getYear(t5.props.minDate) : 1900, n2 = t5.props.maxDate ? getYear(t5.props.maxDate) : 2100, o2 = [], a4 = r3; a4 <= n2; a4++)
        o2.push(import_react30.default.createElement("option", { key: a4, value: a4 }, a4));
      return o2;
    }), ye(we(t5), "onSelectChange", function(e4) {
      t5.onChange(e4.target.value);
    }), ye(we(t5), "renderSelectMode", function() {
      return import_react30.default.createElement("select", { value: t5.props.year, className: "react-datepicker__year-select", onChange: t5.onSelectChange }, t5.renderSelectOptions());
    }), ye(we(t5), "renderReadView", function(r3) {
      return import_react30.default.createElement("div", { key: "read", style: { visibility: r3 ? "visible" : "hidden" }, className: "react-datepicker__year-read-view", onClick: function(e4) {
        return t5.toggleDropdown(e4);
      } }, import_react30.default.createElement("span", { className: "react-datepicker__year-read-view--down-arrow" }), import_react30.default.createElement("span", { className: "react-datepicker__year-read-view--selected-year" }, t5.props.year));
    }), ye(we(t5), "renderDropdown", function() {
      return import_react30.default.createElement(Ct, { key: "dropdown", year: t5.props.year, onChange: t5.onChange, onCancel: t5.toggleDropdown, minDate: t5.props.minDate, maxDate: t5.props.maxDate, scrollableYearDropdown: t5.props.scrollableYearDropdown, yearDropdownItemNumber: t5.props.yearDropdownItemNumber });
    }), ye(we(t5), "renderScrollMode", function() {
      var e4 = t5.state.dropdownVisible, r3 = [t5.renderReadView(!e4)];
      return e4 && r3.unshift(t5.renderDropdown()), r3;
    }), ye(we(t5), "onChange", function(e4) {
      t5.toggleDropdown(), e4 !== t5.props.year && t5.props.onChange(e4);
    }), ye(we(t5), "toggleDropdown", function(e4) {
      t5.setState({ dropdownVisible: !t5.state.dropdownVisible }, function() {
        t5.props.adjustDateOnChange && t5.handleYearChange(t5.props.date, e4);
      });
    }), ye(we(t5), "handleYearChange", function(e4, r3) {
      t5.onSelect(e4, r3), t5.setOpen();
    }), ye(we(t5), "onSelect", function(e4, r3) {
      t5.props.onSelect && t5.props.onSelect(e4, r3);
    }), ye(we(t5), "setOpen", function() {
      t5.props.setOpen && t5.props.setOpen(true);
    }), t5;
  }
  return fe(n, [{ key: "render", value: function() {
    var t5;
    switch (this.props.dropdownMode) {
      case "scroll":
        t5 = this.renderScrollMode();
        break;
      case "select":
        t5 = this.renderSelectMode();
    }
    return import_react30.default.createElement("div", { className: "react-datepicker__year-dropdown-container react-datepicker__year-dropdown-container--".concat(this.props.dropdownMode) }, t5);
  } }]), n;
}();
var Mt = react_onclickoutside_es_default(function(t4) {
  De(n, import_react30.default.Component);
  var r2 = be(n);
  function n() {
    var t5;
    he(this, n);
    for (var o = arguments.length, a3 = new Array(o), s3 = 0; s3 < o; s3++)
      a3[s3] = arguments[s3];
    return ye(we(t5 = r2.call.apply(r2, [this].concat(a3))), "isSelectedMonth", function(e4) {
      return t5.props.month === e4;
    }), ye(we(t5), "renderOptions", function() {
      return t5.props.monthNames.map(function(r3, n2) {
        return import_react30.default.createElement("div", { className: t5.isSelectedMonth(n2) ? "react-datepicker__month-option react-datepicker__month-option--selected_month" : "react-datepicker__month-option", key: r3, onClick: t5.onChange.bind(we(t5), n2), "aria-selected": t5.isSelectedMonth(n2) ? "true" : void 0 }, t5.isSelectedMonth(n2) ? import_react30.default.createElement("span", { className: "react-datepicker__month-option--selected" }, "") : "", r3);
      });
    }), ye(we(t5), "onChange", function(e4) {
      return t5.props.onChange(e4);
    }), ye(we(t5), "handleClickOutside", function() {
      return t5.props.onCancel();
    }), t5;
  }
  return fe(n, [{ key: "render", value: function() {
    return import_react30.default.createElement("div", { className: "react-datepicker__month-dropdown" }, this.renderOptions());
  } }]), n;
}());
var Pt = function(t4) {
  De(n, import_react30.default.Component);
  var r2 = be(n);
  function n() {
    var t5;
    he(this, n);
    for (var o = arguments.length, a3 = new Array(o), s3 = 0; s3 < o; s3++)
      a3[s3] = arguments[s3];
    return ye(we(t5 = r2.call.apply(r2, [this].concat(a3))), "state", { dropdownVisible: false }), ye(we(t5), "renderSelectOptions", function(t6) {
      return t6.map(function(t7, r3) {
        return import_react30.default.createElement("option", { key: r3, value: r3 }, t7);
      });
    }), ye(we(t5), "renderSelectMode", function(r3) {
      return import_react30.default.createElement("select", { value: t5.props.month, className: "react-datepicker__month-select", onChange: function(e4) {
        return t5.onChange(e4.target.value);
      } }, t5.renderSelectOptions(r3));
    }), ye(we(t5), "renderReadView", function(r3, n2) {
      return import_react30.default.createElement("div", { key: "read", style: { visibility: r3 ? "visible" : "hidden" }, className: "react-datepicker__month-read-view", onClick: t5.toggleDropdown }, import_react30.default.createElement("span", { className: "react-datepicker__month-read-view--down-arrow" }), import_react30.default.createElement("span", { className: "react-datepicker__month-read-view--selected-month" }, n2[t5.props.month]));
    }), ye(we(t5), "renderDropdown", function(r3) {
      return import_react30.default.createElement(Mt, { key: "dropdown", month: t5.props.month, monthNames: r3, onChange: t5.onChange, onCancel: t5.toggleDropdown });
    }), ye(we(t5), "renderScrollMode", function(e4) {
      var r3 = t5.state.dropdownVisible, n2 = [t5.renderReadView(!r3, e4)];
      return r3 && n2.unshift(t5.renderDropdown(e4)), n2;
    }), ye(we(t5), "onChange", function(e4) {
      t5.toggleDropdown(), e4 !== t5.props.month && t5.props.onChange(e4);
    }), ye(we(t5), "toggleDropdown", function() {
      return t5.setState({ dropdownVisible: !t5.state.dropdownVisible });
    }), t5;
  }
  return fe(n, [{ key: "render", value: function() {
    var t5, r3 = this, n2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(this.props.useShortMonthInDropdown ? function(e4) {
      return Xe(e4, r3.props.locale);
    } : function(e4) {
      return Je(e4, r3.props.locale);
    });
    switch (this.props.dropdownMode) {
      case "scroll":
        t5 = this.renderScrollMode(n2);
        break;
      case "select":
        t5 = this.renderSelectMode(n2);
    }
    return import_react30.default.createElement("div", { className: "react-datepicker__month-dropdown-container react-datepicker__month-dropdown-container--".concat(this.props.dropdownMode) }, t5);
  } }]), n;
}();
function Et(e4, t4) {
  for (var r2 = [], n = Fe(e4), o = Fe(t4); !isAfter(n, o); )
    r2.push(Ye(n)), n = addMonths(n, 1);
  return r2;
}
var Nt = react_onclickoutside_es_default(function(t4) {
  De(o, import_react30.default.Component);
  var n = be(o);
  function o(t5) {
    var r2;
    return he(this, o), ye(we(r2 = n.call(this, t5)), "renderOptions", function() {
      return r2.state.monthYearsList.map(function(t6) {
        var n2 = getTime(t6), o2 = Be(r2.props.date, t6) && Qe(r2.props.date, t6);
        return import_react30.default.createElement("div", { className: o2 ? "react-datepicker__month-year-option--selected_month-year" : "react-datepicker__month-year-option", key: n2, onClick: r2.onChange.bind(we(r2), n2), "aria-selected": o2 ? "true" : void 0 }, o2 ? import_react30.default.createElement("span", { className: "react-datepicker__month-year-option--selected" }, "") : "", Ie(t6, r2.props.dateFormat, r2.props.locale));
      });
    }), ye(we(r2), "onChange", function(e4) {
      return r2.props.onChange(e4);
    }), ye(we(r2), "handleClickOutside", function() {
      r2.props.onCancel();
    }), r2.state = { monthYearsList: Et(r2.props.minDate, r2.props.maxDate) }, r2;
  }
  return fe(o, [{ key: "render", value: function() {
    var t5 = (0, import_classnames2.default)({ "react-datepicker__month-year-dropdown": true, "react-datepicker__month-year-dropdown--scrollable": this.props.scrollableMonthYearDropdown });
    return import_react30.default.createElement("div", { className: t5 }, this.renderOptions());
  } }]), o;
}());
var xt = function(t4) {
  De(n, import_react30.default.Component);
  var r2 = be(n);
  function n() {
    var t5;
    he(this, n);
    for (var o = arguments.length, a3 = new Array(o), s3 = 0; s3 < o; s3++)
      a3[s3] = arguments[s3];
    return ye(we(t5 = r2.call.apply(r2, [this].concat(a3))), "state", { dropdownVisible: false }), ye(we(t5), "renderSelectOptions", function() {
      for (var r3 = Fe(t5.props.minDate), n2 = Fe(t5.props.maxDate), o2 = []; !isAfter(r3, n2); ) {
        var a4 = getTime(r3);
        o2.push(import_react30.default.createElement("option", { key: a4, value: a4 }, Ie(r3, t5.props.dateFormat, t5.props.locale))), r3 = addMonths(r3, 1);
      }
      return o2;
    }), ye(we(t5), "onSelectChange", function(e4) {
      t5.onChange(e4.target.value);
    }), ye(we(t5), "renderSelectMode", function() {
      return import_react30.default.createElement("select", { value: getTime(Fe(t5.props.date)), className: "react-datepicker__month-year-select", onChange: t5.onSelectChange }, t5.renderSelectOptions());
    }), ye(we(t5), "renderReadView", function(r3) {
      var n2 = Ie(t5.props.date, t5.props.dateFormat, t5.props.locale);
      return import_react30.default.createElement("div", { key: "read", style: { visibility: r3 ? "visible" : "hidden" }, className: "react-datepicker__month-year-read-view", onClick: function(e4) {
        return t5.toggleDropdown(e4);
      } }, import_react30.default.createElement("span", { className: "react-datepicker__month-year-read-view--down-arrow" }), import_react30.default.createElement("span", { className: "react-datepicker__month-year-read-view--selected-month-year" }, n2));
    }), ye(we(t5), "renderDropdown", function() {
      return import_react30.default.createElement(Nt, { key: "dropdown", date: t5.props.date, dateFormat: t5.props.dateFormat, onChange: t5.onChange, onCancel: t5.toggleDropdown, minDate: t5.props.minDate, maxDate: t5.props.maxDate, scrollableMonthYearDropdown: t5.props.scrollableMonthYearDropdown, locale: t5.props.locale });
    }), ye(we(t5), "renderScrollMode", function() {
      var e4 = t5.state.dropdownVisible, r3 = [t5.renderReadView(!e4)];
      return e4 && r3.unshift(t5.renderDropdown()), r3;
    }), ye(we(t5), "onChange", function(e4) {
      t5.toggleDropdown();
      var r3 = Ye(parseInt(e4));
      Be(t5.props.date, r3) && Qe(t5.props.date, r3) || t5.props.onChange(r3);
    }), ye(we(t5), "toggleDropdown", function() {
      return t5.setState({ dropdownVisible: !t5.state.dropdownVisible });
    }), t5;
  }
  return fe(n, [{ key: "render", value: function() {
    var t5;
    switch (this.props.dropdownMode) {
      case "scroll":
        t5 = this.renderScrollMode();
        break;
      case "select":
        t5 = this.renderSelectMode();
    }
    return import_react30.default.createElement("div", { className: "react-datepicker__month-year-dropdown-container react-datepicker__month-year-dropdown-container--".concat(this.props.dropdownMode) }, t5);
  } }]), n;
}();
var Yt = function(t4) {
  De(o, import_react30.default.Component);
  var n = be(o);
  function o() {
    var t5;
    he(this, o);
    for (var a3 = arguments.length, s3 = new Array(a3), i2 = 0; i2 < a3; i2++)
      s3[i2] = arguments[i2];
    return ye(we(t5 = n.call.apply(n, [this].concat(s3))), "dayEl", import_react30.default.createRef()), ye(we(t5), "handleClick", function(e4) {
      !t5.isDisabled() && t5.props.onClick && t5.props.onClick(e4);
    }), ye(we(t5), "handleMouseEnter", function(e4) {
      !t5.isDisabled() && t5.props.onMouseEnter && t5.props.onMouseEnter(e4);
    }), ye(we(t5), "handleOnKeyDown", function(e4) {
      " " === e4.key && (e4.preventDefault(), e4.key = "Enter"), t5.props.handleOnKeyDown(e4);
    }), ye(we(t5), "isSameDay", function(e4) {
      return je(t5.props.day, e4);
    }), ye(we(t5), "isKeyboardSelected", function() {
      return !t5.props.disabledKeyboardNavigation && !(t5.isSameDay(t5.props.selected) || t5.isSameWeek(t5.props.selected)) && (t5.isSameDay(t5.props.preSelection) || t5.isSameWeek(t5.props.preSelection));
    }), ye(we(t5), "isDisabled", function() {
      return Ze(t5.props.day, t5.props);
    }), ye(we(t5), "isExcluded", function() {
      return et(t5.props.day, t5.props);
    }), ye(we(t5), "isStartOfWeek", function() {
      return je(t5.props.day, Le(t5.props.day, t5.props.locale, t5.props.calendarStartDay));
    }), ye(we(t5), "isSameWeek", function(e4) {
      return t5.props.showWeekPicker && je(e4, Le(t5.props.day, t5.props.locale, t5.props.calendarStartDay));
    }), ye(we(t5), "getHighLightedClass", function() {
      var e4 = t5.props, r2 = e4.day, n2 = e4.highlightDates;
      if (!n2)
        return false;
      var o2 = Ie(r2, "MM.dd.yyyy");
      return n2.get(o2);
    }), ye(we(t5), "getHolidaysClass", function() {
      var e4 = t5.props, r2 = e4.day, n2 = e4.holidays;
      if (!n2)
        return false;
      var o2 = Ie(r2, "MM.dd.yyyy");
      return n2.has(o2) ? [n2.get(o2).className] : void 0;
    }), ye(we(t5), "isInRange", function() {
      var e4 = t5.props, r2 = e4.day, n2 = e4.startDate, o2 = e4.endDate;
      return !(!n2 || !o2) && qe(r2, n2, o2);
    }), ye(we(t5), "isInSelectingRange", function() {
      var e4, r2 = t5.props, n2 = r2.day, o2 = r2.selectsStart, a4 = r2.selectsEnd, s4 = r2.selectsRange, i3 = r2.selectsDisabledDaysInRange, p = r2.startDate, c2 = r2.endDate, l = null !== (e4 = t5.props.selectingDate) && void 0 !== e4 ? e4 : t5.props.preSelection;
      return !(!(o2 || a4 || s4) || !l || !i3 && t5.isDisabled()) && (o2 && c2 && (isBefore(l, c2) || Ve(l, c2)) ? qe(n2, l, c2) : (a4 && p && (isAfter(l, p) || Ve(l, p)) || !(!s4 || !p || c2 || !isAfter(l, p) && !Ve(l, p))) && qe(n2, p, l));
    }), ye(we(t5), "isSelectingRangeStart", function() {
      var e4;
      if (!t5.isInSelectingRange())
        return false;
      var r2 = t5.props, n2 = r2.day, o2 = r2.startDate, a4 = r2.selectsStart, s4 = null !== (e4 = t5.props.selectingDate) && void 0 !== e4 ? e4 : t5.props.preSelection;
      return je(n2, a4 ? s4 : o2);
    }), ye(we(t5), "isSelectingRangeEnd", function() {
      var e4;
      if (!t5.isInSelectingRange())
        return false;
      var r2 = t5.props, n2 = r2.day, o2 = r2.endDate, a4 = r2.selectsEnd, s4 = r2.selectsRange, i3 = null !== (e4 = t5.props.selectingDate) && void 0 !== e4 ? e4 : t5.props.preSelection;
      return je(n2, a4 || s4 ? i3 : o2);
    }), ye(we(t5), "isRangeStart", function() {
      var e4 = t5.props, r2 = e4.day, n2 = e4.startDate, o2 = e4.endDate;
      return !(!n2 || !o2) && je(n2, r2);
    }), ye(we(t5), "isRangeEnd", function() {
      var e4 = t5.props, r2 = e4.day, n2 = e4.startDate, o2 = e4.endDate;
      return !(!n2 || !o2) && je(o2, r2);
    }), ye(we(t5), "isWeekend", function() {
      var e4 = getDay(t5.props.day);
      return 0 === e4 || 6 === e4;
    }), ye(we(t5), "isAfterMonth", function() {
      return void 0 !== t5.props.month && (t5.props.month + 1) % 12 === getMonth(t5.props.day);
    }), ye(we(t5), "isBeforeMonth", function() {
      return void 0 !== t5.props.month && (getMonth(t5.props.day) + 1) % 12 === t5.props.month;
    }), ye(we(t5), "isCurrentDay", function() {
      return t5.isSameDay(Ye());
    }), ye(we(t5), "isSelected", function() {
      return t5.isSameDay(t5.props.selected) || t5.isSameWeek(t5.props.selected);
    }), ye(we(t5), "getClassNames", function(e4) {
      var n2, o2 = t5.props.dayClassName ? t5.props.dayClassName(e4) : void 0;
      return (0, import_classnames2.default)("react-datepicker__day", o2, "react-datepicker__day--" + Ie(t5.props.day, "ddd", n2), { "react-datepicker__day--disabled": t5.isDisabled(), "react-datepicker__day--excluded": t5.isExcluded(), "react-datepicker__day--selected": t5.isSelected(), "react-datepicker__day--keyboard-selected": t5.isKeyboardSelected(), "react-datepicker__day--range-start": t5.isRangeStart(), "react-datepicker__day--range-end": t5.isRangeEnd(), "react-datepicker__day--in-range": t5.isInRange(), "react-datepicker__day--in-selecting-range": t5.isInSelectingRange(), "react-datepicker__day--selecting-range-start": t5.isSelectingRangeStart(), "react-datepicker__day--selecting-range-end": t5.isSelectingRangeEnd(), "react-datepicker__day--today": t5.isCurrentDay(), "react-datepicker__day--weekend": t5.isWeekend(), "react-datepicker__day--outside-month": t5.isAfterMonth() || t5.isBeforeMonth() }, t5.getHighLightedClass("react-datepicker__day--highlighted"), t5.getHolidaysClass());
    }), ye(we(t5), "getAriaLabel", function() {
      var e4 = t5.props, r2 = e4.day, n2 = e4.ariaLabelPrefixWhenEnabled, o2 = void 0 === n2 ? "Choose" : n2, a4 = e4.ariaLabelPrefixWhenDisabled, s4 = void 0 === a4 ? "Not available" : a4, i3 = t5.isDisabled() || t5.isExcluded() ? s4 : o2;
      return "".concat(i3, " ").concat(Ie(r2, "PPPP", t5.props.locale));
    }), ye(we(t5), "getTitle", function() {
      var e4 = t5.props, r2 = e4.day, n2 = e4.holidays, o2 = void 0 === n2 ? /* @__PURE__ */ new Map() : n2, a4 = Ie(r2, "MM.dd.yyyy");
      return o2.has(a4) && o2.get(a4).holidayNames.length > 0 ? o2.get(a4).holidayNames.join(", ") : "";
    }), ye(we(t5), "getTabIndex", function(e4, r2) {
      var n2 = e4 || t5.props.selected, o2 = r2 || t5.props.preSelection;
      return (!t5.props.showWeekPicker || !t5.props.showWeekNumber && t5.isStartOfWeek()) && (t5.isKeyboardSelected() || t5.isSameDay(n2) && je(o2, n2)) ? 0 : -1;
    }), ye(we(t5), "handleFocusDay", function() {
      var e4, r2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n2 = false;
      0 === t5.getTabIndex() && !r2.isInputFocused && t5.isSameDay(t5.props.preSelection) && (document.activeElement && document.activeElement !== document.body || (n2 = true), t5.props.inline && !t5.props.shouldFocusDayInline && (n2 = false), t5.props.containerRef && t5.props.containerRef.current && t5.props.containerRef.current.contains(document.activeElement) && document.activeElement.classList.contains("react-datepicker__day") && (n2 = true), t5.props.monthShowsDuplicateDaysEnd && t5.isAfterMonth() && (n2 = false), t5.props.monthShowsDuplicateDaysStart && t5.isBeforeMonth() && (n2 = false)), n2 && (null === (e4 = t5.dayEl.current) || void 0 === e4 || e4.focus({ preventScroll: true }));
    }), ye(we(t5), "renderDayContents", function() {
      return t5.props.monthShowsDuplicateDaysEnd && t5.isAfterMonth() || t5.props.monthShowsDuplicateDaysStart && t5.isBeforeMonth() ? null : t5.props.renderDayContents ? t5.props.renderDayContents(getDate(t5.props.day), t5.props.day) : getDate(t5.props.day);
    }), ye(we(t5), "render", function() {
      return import_react30.default.createElement("div", { ref: t5.dayEl, className: t5.getClassNames(t5.props.day), onKeyDown: t5.handleOnKeyDown, onClick: t5.handleClick, onMouseEnter: t5.handleMouseEnter, tabIndex: t5.getTabIndex(), "aria-label": t5.getAriaLabel(), role: "option", title: t5.getTitle(), "aria-disabled": t5.isDisabled(), "aria-current": t5.isCurrentDay() ? "date" : void 0, "aria-selected": t5.isSelected() || t5.isInRange() }, t5.renderDayContents(), "" !== t5.getTitle() && import_react30.default.createElement("span", { className: "holiday-overlay" }, t5.getTitle()));
    }), t5;
  }
  return fe(o, [{ key: "componentDidMount", value: function() {
    this.handleFocusDay();
  } }, { key: "componentDidUpdate", value: function(e4) {
    this.handleFocusDay(e4);
  } }]), o;
}();
var Tt = function(t4) {
  De(o, import_react30.default.Component);
  var n = be(o);
  function o() {
    var t5;
    he(this, o);
    for (var r2 = arguments.length, a3 = new Array(r2), s3 = 0; s3 < r2; s3++)
      a3[s3] = arguments[s3];
    return ye(we(t5 = n.call.apply(n, [this].concat(a3))), "weekNumberEl", import_react30.default.createRef()), ye(we(t5), "handleClick", function(e4) {
      t5.props.onClick && t5.props.onClick(e4);
    }), ye(we(t5), "handleOnKeyDown", function(e4) {
      " " === e4.key && (e4.preventDefault(), e4.key = "Enter"), t5.props.handleOnKeyDown(e4);
    }), ye(we(t5), "isKeyboardSelected", function() {
      return !t5.props.disabledKeyboardNavigation && !je(t5.props.date, t5.props.selected) && je(t5.props.date, t5.props.preSelection);
    }), ye(we(t5), "getTabIndex", function() {
      return t5.props.showWeekPicker && t5.props.showWeekNumber && (t5.isKeyboardSelected() || je(t5.props.date, t5.props.selected) && je(t5.props.preSelection, t5.props.selected)) ? 0 : -1;
    }), ye(we(t5), "handleFocusWeekNumber", function() {
      var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r3 = false;
      0 === t5.getTabIndex() && !e4.isInputFocused && je(t5.props.date, t5.props.preSelection) && (document.activeElement && document.activeElement !== document.body || (r3 = true), t5.props.inline && !t5.props.shouldFocusDayInline && (r3 = false), t5.props.containerRef && t5.props.containerRef.current && t5.props.containerRef.current.contains(document.activeElement) && document.activeElement && document.activeElement.classList.contains("react-datepicker__week-number") && (r3 = true)), r3 && t5.weekNumberEl.current && t5.weekNumberEl.current.focus({ preventScroll: true });
    }), t5;
  }
  return fe(o, [{ key: "componentDidMount", value: function() {
    this.handleFocusWeekNumber();
  } }, { key: "componentDidUpdate", value: function(e4) {
    this.handleFocusWeekNumber(e4);
  } }, { key: "render", value: function() {
    var t5 = this.props, n2 = t5.weekNumber, o2 = t5.ariaLabelPrefix, a3 = void 0 === o2 ? "week " : o2, s3 = { "react-datepicker__week-number": true, "react-datepicker__week-number--clickable": !!t5.onClick, "react-datepicker__week-number--selected": je(this.props.date, this.props.selected), "react-datepicker__week-number--keyboard-selected": this.isKeyboardSelected() };
    return import_react30.default.createElement("div", { ref: this.weekNumberEl, className: (0, import_classnames2.default)(s3), "aria-label": "".concat(a3, " ").concat(this.props.weekNumber), onClick: this.handleClick, onKeyDown: this.handleOnKeyDown, tabIndex: this.getTabIndex() }, n2);
  } }], [{ key: "defaultProps", get: function() {
    return { ariaLabelPrefix: "week " };
  } }]), o;
}();
var It = function(t4) {
  De(o, import_react30.default.Component);
  var n = be(o);
  function o() {
    var t5;
    he(this, o);
    for (var r2 = arguments.length, a3 = new Array(r2), s3 = 0; s3 < r2; s3++)
      a3[s3] = arguments[s3];
    return ye(we(t5 = n.call.apply(n, [this].concat(a3))), "handleDayClick", function(e4, r3) {
      t5.props.onDayClick && t5.props.onDayClick(e4, r3);
    }), ye(we(t5), "handleDayMouseEnter", function(e4) {
      t5.props.onDayMouseEnter && t5.props.onDayMouseEnter(e4);
    }), ye(we(t5), "handleWeekClick", function(e4, r3, n2) {
      if ("function" == typeof t5.props.onWeekSelect && t5.props.onWeekSelect(e4, r3, n2), t5.props.showWeekPicker) {
        var o2 = Le(e4, t5.props.locale, t5.props.calendarStartDay);
        t5.handleDayClick(o2, n2);
      }
      t5.props.shouldCloseOnSelect && t5.props.setOpen(false);
    }), ye(we(t5), "formatWeekNumber", function(e4) {
      return t5.props.formatWeekNumber ? t5.props.formatWeekNumber(e4) : function(e5, t6) {
        var r3 = t6 && Ge(t6) || $e() && Ge($e());
        return getISOWeek(e5, r3 ? { locale: r3 } : null);
      }(e4);
    }), ye(we(t5), "renderDays", function() {
      var r3 = Le(t5.props.day, t5.props.locale, t5.props.calendarStartDay), n2 = [], o2 = t5.formatWeekNumber(r3);
      if (t5.props.showWeekNumber) {
        var a4 = t5.props.onWeekSelect || t5.props.showWeekPicker ? t5.handleWeekClick.bind(we(t5), r3, o2) : void 0;
        n2.push(import_react30.default.createElement(Tt, { key: "W", weekNumber: o2, date: r3, onClick: a4, selected: t5.props.selected, preSelection: t5.props.preSelection, ariaLabelPrefix: t5.props.ariaLabelPrefix, showWeekPicker: t5.props.showWeekPicker, showWeekNumber: t5.props.showWeekNumber, disabledKeyboardNavigation: t5.props.disabledKeyboardNavigation, handleOnKeyDown: t5.props.handleOnKeyDown, isInputFocused: t5.props.isInputFocused, containerRef: t5.props.containerRef }));
      }
      return n2.concat([0, 1, 2, 3, 4, 5, 6].map(function(n3) {
        var o3 = addDays(r3, n3);
        return import_react30.default.createElement(Yt, { ariaLabelPrefixWhenEnabled: t5.props.chooseDayAriaLabelPrefix, ariaLabelPrefixWhenDisabled: t5.props.disabledDayAriaLabelPrefix, key: o3.valueOf(), day: o3, month: t5.props.month, onClick: t5.handleDayClick.bind(we(t5), o3), onMouseEnter: t5.handleDayMouseEnter.bind(we(t5), o3), minDate: t5.props.minDate, maxDate: t5.props.maxDate, excludeDates: t5.props.excludeDates, excludeDateIntervals: t5.props.excludeDateIntervals, includeDates: t5.props.includeDates, includeDateIntervals: t5.props.includeDateIntervals, highlightDates: t5.props.highlightDates, holidays: t5.props.holidays, selectingDate: t5.props.selectingDate, filterDate: t5.props.filterDate, preSelection: t5.props.preSelection, selected: t5.props.selected, selectsStart: t5.props.selectsStart, selectsEnd: t5.props.selectsEnd, selectsRange: t5.props.selectsRange, showWeekPicker: t5.props.showWeekPicker, showWeekNumber: t5.props.showWeekNumber, selectsDisabledDaysInRange: t5.props.selectsDisabledDaysInRange, startDate: t5.props.startDate, endDate: t5.props.endDate, dayClassName: t5.props.dayClassName, renderDayContents: t5.props.renderDayContents, disabledKeyboardNavigation: t5.props.disabledKeyboardNavigation, handleOnKeyDown: t5.props.handleOnKeyDown, isInputFocused: t5.props.isInputFocused, containerRef: t5.props.containerRef, inline: t5.props.inline, shouldFocusDayInline: t5.props.shouldFocusDayInline, monthShowsDuplicateDaysEnd: t5.props.monthShowsDuplicateDaysEnd, monthShowsDuplicateDaysStart: t5.props.monthShowsDuplicateDaysStart, locale: t5.props.locale });
      }));
    }), ye(we(t5), "startOfWeek", function() {
      return Le(t5.props.day, t5.props.locale, t5.props.calendarStartDay);
    }), ye(we(t5), "isKeyboardSelected", function() {
      return !t5.props.disabledKeyboardNavigation && !je(t5.startOfWeek(), t5.props.selected) && je(t5.startOfWeek(), t5.props.preSelection);
    }), t5;
  }
  return fe(o, [{ key: "render", value: function() {
    var t5 = { "react-datepicker__week": true, "react-datepicker__week--selected": je(this.startOfWeek(), this.props.selected), "react-datepicker__week--keyboard-selected": this.isKeyboardSelected() };
    return import_react30.default.createElement("div", { className: (0, import_classnames2.default)(t5) }, this.renderDays());
  } }], [{ key: "defaultProps", get: function() {
    return { shouldCloseOnSelect: true };
  } }]), o;
}();
var Ot = "two_columns";
var Rt = "three_columns";
var Lt = "four_columns";
var Ft = ye(ye(ye({}, Ot, { grid: [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9], [10, 11]], verticalNavigationOffset: 2 }), Rt, { grid: [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]], verticalNavigationOffset: 3 }), Lt, { grid: [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]], verticalNavigationOffset: 4 });
function At(e4, t4) {
  return e4 ? Lt : t4 ? Ot : Rt;
}
var Wt = function(t4) {
  De(o, import_react30.default.Component);
  var n = be(o);
  function o() {
    var t5;
    he(this, o);
    for (var a3 = arguments.length, s3 = new Array(a3), i2 = 0; i2 < a3; i2++)
      s3[i2] = arguments[i2];
    return ye(we(t5 = n.call.apply(n, [this].concat(s3))), "MONTH_REFS", Se(Array(12)).map(function() {
      return import_react30.default.createRef();
    })), ye(we(t5), "QUARTER_REFS", Se(Array(4)).map(function() {
      return import_react30.default.createRef();
    })), ye(we(t5), "isDisabled", function(e4) {
      return Ze(e4, t5.props);
    }), ye(we(t5), "isExcluded", function(e4) {
      return et(e4, t5.props);
    }), ye(we(t5), "handleDayClick", function(e4, r2) {
      t5.props.onDayClick && t5.props.onDayClick(e4, r2, t5.props.orderInDisplay);
    }), ye(we(t5), "handleDayMouseEnter", function(e4) {
      t5.props.onDayMouseEnter && t5.props.onDayMouseEnter(e4);
    }), ye(we(t5), "handleMouseLeave", function() {
      t5.props.onMouseLeave && t5.props.onMouseLeave();
    }), ye(we(t5), "isRangeStartMonth", function(e4) {
      var r2 = t5.props, n2 = r2.day, o2 = r2.startDate, a4 = r2.endDate;
      return !(!o2 || !a4) && Qe(setMonth(n2, e4), o2);
    }), ye(we(t5), "isRangeStartQuarter", function(e4) {
      var r2 = t5.props, n2 = r2.day, o2 = r2.startDate, a4 = r2.endDate;
      return !(!o2 || !a4) && He(setQuarter(n2, e4), o2);
    }), ye(we(t5), "isRangeEndMonth", function(e4) {
      var r2 = t5.props, n2 = r2.day, o2 = r2.startDate, a4 = r2.endDate;
      return !(!o2 || !a4) && Qe(setMonth(n2, e4), a4);
    }), ye(we(t5), "isRangeEndQuarter", function(e4) {
      var r2 = t5.props, n2 = r2.day, o2 = r2.startDate, a4 = r2.endDate;
      return !(!o2 || !a4) && He(setQuarter(n2, e4), a4);
    }), ye(we(t5), "isInSelectingRangeMonth", function(e4) {
      var r2, n2 = t5.props, o2 = n2.day, a4 = n2.selectsStart, s4 = n2.selectsEnd, i3 = n2.selectsRange, p = n2.startDate, c2 = n2.endDate, l = null !== (r2 = t5.props.selectingDate) && void 0 !== r2 ? r2 : t5.props.preSelection;
      return !(!(a4 || s4 || i3) || !l) && (a4 && c2 ? rt(l, c2, e4, o2) : (s4 && p || !(!i3 || !p || c2)) && rt(p, l, e4, o2));
    }), ye(we(t5), "isSelectingMonthRangeStart", function(e4) {
      var r2;
      if (!t5.isInSelectingRangeMonth(e4))
        return false;
      var n2 = t5.props, o2 = n2.day, a4 = n2.startDate, s4 = n2.selectsStart, i3 = setMonth(o2, e4), p = null !== (r2 = t5.props.selectingDate) && void 0 !== r2 ? r2 : t5.props.preSelection;
      return Qe(i3, s4 ? p : a4);
    }), ye(we(t5), "isSelectingMonthRangeEnd", function(e4) {
      var r2;
      if (!t5.isInSelectingRangeMonth(e4))
        return false;
      var n2 = t5.props, o2 = n2.day, a4 = n2.endDate, s4 = n2.selectsEnd, i3 = n2.selectsRange, p = setMonth(o2, e4), c2 = null !== (r2 = t5.props.selectingDate) && void 0 !== r2 ? r2 : t5.props.preSelection;
      return Qe(p, s4 || i3 ? c2 : a4);
    }), ye(we(t5), "isInSelectingRangeQuarter", function(e4) {
      var r2, n2 = t5.props, o2 = n2.day, a4 = n2.selectsStart, s4 = n2.selectsEnd, i3 = n2.selectsRange, p = n2.startDate, c2 = n2.endDate, l = null !== (r2 = t5.props.selectingDate) && void 0 !== r2 ? r2 : t5.props.preSelection;
      return !(!(a4 || s4 || i3) || !l) && (a4 && c2 ? st(l, c2, e4, o2) : (s4 && p || !(!i3 || !p || c2)) && st(p, l, e4, o2));
    }), ye(we(t5), "isWeekInMonth", function(e4) {
      var r2 = t5.props.day, n2 = addDays(e4, 6);
      return Qe(e4, r2) || Qe(n2, r2);
    }), ye(we(t5), "isCurrentMonth", function(e4, t6) {
      return getYear(e4) === getYear(Ye()) && t6 === getMonth(Ye());
    }), ye(we(t5), "isCurrentQuarter", function(e4, t6) {
      return getYear(e4) === getYear(Ye()) && t6 === getQuarter(Ye());
    }), ye(we(t5), "isSelectedMonth", function(e4, t6, r2) {
      return getMonth(r2) === t6 && getYear(e4) === getYear(r2);
    }), ye(we(t5), "isSelectedQuarter", function(e4, t6, r2) {
      return getQuarter(e4) === t6 && getYear(e4) === getYear(r2);
    }), ye(we(t5), "renderWeeks", function() {
      for (var r2 = [], n2 = t5.props.fixedHeight, o2 = 0, a4 = false, s4 = Le(Fe(t5.props.day), t5.props.locale, t5.props.calendarStartDay); r2.push(import_react30.default.createElement(It, { ariaLabelPrefix: t5.props.weekAriaLabelPrefix, chooseDayAriaLabelPrefix: t5.props.chooseDayAriaLabelPrefix, disabledDayAriaLabelPrefix: t5.props.disabledDayAriaLabelPrefix, key: o2, day: s4, month: getMonth(t5.props.day), onDayClick: t5.handleDayClick, onDayMouseEnter: t5.handleDayMouseEnter, onWeekSelect: t5.props.onWeekSelect, formatWeekNumber: t5.props.formatWeekNumber, locale: t5.props.locale, minDate: t5.props.minDate, maxDate: t5.props.maxDate, excludeDates: t5.props.excludeDates, excludeDateIntervals: t5.props.excludeDateIntervals, includeDates: t5.props.includeDates, includeDateIntervals: t5.props.includeDateIntervals, inline: t5.props.inline, shouldFocusDayInline: t5.props.shouldFocusDayInline, highlightDates: t5.props.highlightDates, holidays: t5.props.holidays, selectingDate: t5.props.selectingDate, filterDate: t5.props.filterDate, preSelection: t5.props.preSelection, selected: t5.props.selected, selectsStart: t5.props.selectsStart, selectsEnd: t5.props.selectsEnd, selectsRange: t5.props.selectsRange, selectsDisabledDaysInRange: t5.props.selectsDisabledDaysInRange, showWeekNumber: t5.props.showWeekNumbers, showWeekPicker: t5.props.showWeekPicker, startDate: t5.props.startDate, endDate: t5.props.endDate, dayClassName: t5.props.dayClassName, setOpen: t5.props.setOpen, shouldCloseOnSelect: t5.props.shouldCloseOnSelect, disabledKeyboardNavigation: t5.props.disabledKeyboardNavigation, renderDayContents: t5.props.renderDayContents, handleOnKeyDown: t5.props.handleOnKeyDown, isInputFocused: t5.props.isInputFocused, containerRef: t5.props.containerRef, calendarStartDay: t5.props.calendarStartDay, monthShowsDuplicateDaysEnd: t5.props.monthShowsDuplicateDaysEnd, monthShowsDuplicateDaysStart: t5.props.monthShowsDuplicateDaysStart })), !a4; ) {
        o2++, s4 = addWeeks(s4, 1);
        var i3 = n2 && o2 >= 6, p = !n2 && !t5.isWeekInMonth(s4);
        if (i3 || p) {
          if (!t5.props.peekNextMonth)
            break;
          a4 = true;
        }
      }
      return r2;
    }), ye(we(t5), "onMonthClick", function(e4, r2) {
      t5.handleDayClick(Fe(setMonth(t5.props.day, r2)), e4);
    }), ye(we(t5), "onMonthMouseEnter", function(e4) {
      t5.handleDayMouseEnter(Fe(setMonth(t5.props.day, e4)));
    }), ye(we(t5), "handleMonthNavigation", function(e4, r2) {
      t5.isDisabled(r2) || t5.isExcluded(r2) || (t5.props.setPreSelection(r2), t5.MONTH_REFS[e4].current && t5.MONTH_REFS[e4].current.focus());
    }), ye(we(t5), "onMonthKeyDown", function(e4, r2) {
      var n2 = t5.props, o2 = n2.selected, a4 = n2.preSelection, s4 = n2.disabledKeyboardNavigation, i3 = n2.showTwoColumnMonthYearPicker, p = n2.showFourColumnMonthYearPicker, c2 = n2.setPreSelection, d3 = e4.key;
      if ("Tab" !== d3 && e4.preventDefault(), !s4) {
        var u2 = At(p, i3), h3 = Ft[u2].verticalNavigationOffset, m3 = Ft[u2].grid;
        switch (d3) {
          case "Enter":
            t5.onMonthClick(e4, r2), c2(o2);
            break;
          case "ArrowRight":
            t5.handleMonthNavigation(11 === r2 ? 0 : r2 + 1, addMonths(a4, 1));
            break;
          case "ArrowLeft":
            t5.handleMonthNavigation(0 === r2 ? 11 : r2 - 1, subMonths(a4, 1));
            break;
          case "ArrowUp":
            t5.handleMonthNavigation(m3[0].includes(r2) ? r2 + 12 - h3 : r2 - h3, subMonths(a4, h3));
            break;
          case "ArrowDown":
            t5.handleMonthNavigation(m3[m3.length - 1].includes(r2) ? r2 - 12 + h3 : r2 + h3, addMonths(a4, h3));
        }
      }
    }), ye(we(t5), "onQuarterClick", function(e4, r2) {
      t5.handleDayClick(We(setQuarter(t5.props.day, r2)), e4);
    }), ye(we(t5), "onQuarterMouseEnter", function(e4) {
      t5.handleDayMouseEnter(We(setQuarter(t5.props.day, e4)));
    }), ye(we(t5), "handleQuarterNavigation", function(e4, r2) {
      t5.isDisabled(r2) || t5.isExcluded(r2) || (t5.props.setPreSelection(r2), t5.QUARTER_REFS[e4 - 1].current && t5.QUARTER_REFS[e4 - 1].current.focus());
    }), ye(we(t5), "onQuarterKeyDown", function(e4, r2) {
      var n2 = e4.key;
      if (!t5.props.disabledKeyboardNavigation)
        switch (n2) {
          case "Enter":
            t5.onQuarterClick(e4, r2), t5.props.setPreSelection(t5.props.selected);
            break;
          case "ArrowRight":
            t5.handleQuarterNavigation(4 === r2 ? 1 : r2 + 1, addQuarters(t5.props.preSelection, 1));
            break;
          case "ArrowLeft":
            t5.handleQuarterNavigation(1 === r2 ? 4 : r2 - 1, subQuarters(t5.props.preSelection, 1));
        }
    }), ye(we(t5), "getMonthClassNames", function(e4) {
      var n2 = t5.props, o2 = n2.day, a4 = n2.startDate, s4 = n2.endDate, i3 = n2.selected, p = n2.minDate, c2 = n2.maxDate, l = n2.preSelection, d3 = n2.monthClassName, u2 = n2.excludeDates, h3 = n2.includeDates, m3 = d3 ? d3(setMonth(o2, e4)) : void 0, f = setMonth(o2, e4);
      return (0, import_classnames2.default)("react-datepicker__month-text", "react-datepicker__month-".concat(e4), m3, { "react-datepicker__month-text--disabled": (p || c2 || u2 || h3) && tt(f, t5.props), "react-datepicker__month-text--selected": t5.isSelectedMonth(o2, e4, i3), "react-datepicker__month-text--keyboard-selected": !t5.props.disabledKeyboardNavigation && getMonth(l) === e4, "react-datepicker__month-text--in-selecting-range": t5.isInSelectingRangeMonth(e4), "react-datepicker__month-text--in-range": rt(a4, s4, e4, o2), "react-datepicker__month-text--range-start": t5.isRangeStartMonth(e4), "react-datepicker__month-text--range-end": t5.isRangeEndMonth(e4), "react-datepicker__month-text--selecting-range-start": t5.isSelectingMonthRangeStart(e4), "react-datepicker__month-text--selecting-range-end": t5.isSelectingMonthRangeEnd(e4), "react-datepicker__month-text--today": t5.isCurrentMonth(o2, e4) });
    }), ye(we(t5), "getTabIndex", function(e4) {
      var r2 = getMonth(t5.props.preSelection);
      return t5.props.disabledKeyboardNavigation || e4 !== r2 ? "-1" : "0";
    }), ye(we(t5), "getQuarterTabIndex", function(e4) {
      var r2 = getQuarter(t5.props.preSelection);
      return t5.props.disabledKeyboardNavigation || e4 !== r2 ? "-1" : "0";
    }), ye(we(t5), "getAriaLabel", function(e4) {
      var r2 = t5.props, n2 = r2.chooseDayAriaLabelPrefix, o2 = void 0 === n2 ? "Choose" : n2, a4 = r2.disabledDayAriaLabelPrefix, s4 = void 0 === a4 ? "Not available" : a4, i3 = r2.day, p = setMonth(i3, e4), c2 = t5.isDisabled(p) || t5.isExcluded(p) ? s4 : o2;
      return "".concat(c2, " ").concat(Ie(p, "MMMM yyyy"));
    }), ye(we(t5), "getQuarterClassNames", function(e4) {
      var n2 = t5.props, o2 = n2.day, a4 = n2.startDate, s4 = n2.endDate, i3 = n2.selected, p = n2.minDate, c2 = n2.maxDate, l = n2.preSelection, d3 = n2.disabledKeyboardNavigation;
      return (0, import_classnames2.default)("react-datepicker__quarter-text", "react-datepicker__quarter-".concat(e4), { "react-datepicker__quarter-text--disabled": (p || c2) && nt(setQuarter(o2, e4), t5.props), "react-datepicker__quarter-text--selected": t5.isSelectedQuarter(o2, e4, i3), "react-datepicker__quarter-text--keyboard-selected": !d3 && getQuarter(l) === e4, "react-datepicker__quarter-text--in-selecting-range": t5.isInSelectingRangeQuarter(e4), "react-datepicker__quarter-text--in-range": st(a4, s4, e4, o2), "react-datepicker__quarter-text--range-start": t5.isRangeStartQuarter(e4), "react-datepicker__quarter-text--range-end": t5.isRangeEndQuarter(e4) });
    }), ye(we(t5), "getMonthContent", function(e4) {
      var r2 = t5.props, n2 = r2.showFullMonthYearPicker, o2 = r2.renderMonthContent, a4 = r2.locale, s4 = r2.day, i3 = Xe(e4, a4), p = Je(e4, a4);
      return o2 ? o2(e4, i3, p, s4) : n2 ? p : i3;
    }), ye(we(t5), "getQuarterContent", function(e4) {
      var r2 = t5.props, n2 = r2.renderQuarterContent, o2 = function(e5, t6) {
        return Ie(setQuarter(Ye(), e5), "QQQ", t6);
      }(e4, r2.locale);
      return n2 ? n2(e4, o2) : o2;
    }), ye(we(t5), "renderMonths", function() {
      var r2 = t5.props, n2 = r2.showTwoColumnMonthYearPicker, o2 = r2.showFourColumnMonthYearPicker, a4 = r2.day, s4 = r2.selected;
      return Ft[At(o2, n2)].grid.map(function(r3, n3) {
        return import_react30.default.createElement("div", { className: "react-datepicker__month-wrapper", key: n3 }, r3.map(function(r4, n4) {
          return import_react30.default.createElement("div", { ref: t5.MONTH_REFS[r4], key: n4, onClick: function(e4) {
            t5.onMonthClick(e4, r4);
          }, onKeyDown: function(e4) {
            t5.onMonthKeyDown(e4, r4);
          }, onMouseEnter: function() {
            return t5.onMonthMouseEnter(r4);
          }, tabIndex: t5.getTabIndex(r4), className: t5.getMonthClassNames(r4), role: "option", "aria-label": t5.getAriaLabel(r4), "aria-current": t5.isCurrentMonth(a4, r4) ? "date" : void 0, "aria-selected": t5.isSelectedMonth(a4, r4, s4) }, t5.getMonthContent(r4));
        }));
      });
    }), ye(we(t5), "renderQuarters", function() {
      var r2 = t5.props, n2 = r2.day, o2 = r2.selected;
      return import_react30.default.createElement("div", { className: "react-datepicker__quarter-wrapper" }, [1, 2, 3, 4].map(function(r3, a4) {
        return import_react30.default.createElement("div", { key: a4, ref: t5.QUARTER_REFS[a4], role: "option", onClick: function(e4) {
          t5.onQuarterClick(e4, r3);
        }, onKeyDown: function(e4) {
          t5.onQuarterKeyDown(e4, r3);
        }, onMouseEnter: function() {
          return t5.onQuarterMouseEnter(r3);
        }, className: t5.getQuarterClassNames(r3), "aria-selected": t5.isSelectedQuarter(n2, r3, o2), tabIndex: t5.getQuarterTabIndex(r3), "aria-current": t5.isCurrentQuarter(n2, r3) ? "date" : void 0 }, t5.getQuarterContent(r3));
      }));
    }), ye(we(t5), "getClassNames", function() {
      var e4 = t5.props, n2 = e4.selectingDate, o2 = e4.selectsStart, a4 = e4.selectsEnd, s4 = e4.showMonthYearPicker, i3 = e4.showQuarterYearPicker, p = e4.showWeekPicker;
      return (0, import_classnames2.default)("react-datepicker__month", { "react-datepicker__month--selecting-range": n2 && (o2 || a4) }, { "react-datepicker__monthPicker": s4 }, { "react-datepicker__quarterPicker": i3 }, { "react-datepicker__weekPicker": p });
    }), t5;
  }
  return fe(o, [{ key: "render", value: function() {
    var t5 = this.props, r2 = t5.showMonthYearPicker, n2 = t5.showQuarterYearPicker, o2 = t5.day, a3 = t5.ariaLabelPrefix, s3 = void 0 === a3 ? "month " : a3;
    return import_react30.default.createElement("div", { className: this.getClassNames(), onMouseLeave: this.handleMouseLeave, "aria-label": "".concat(s3, " ").concat(Ie(o2, "yyyy-MM")), role: "listbox" }, r2 ? this.renderMonths() : n2 ? this.renderQuarters() : this.renderWeeks());
  } }]), o;
}();
var Kt = function(t4) {
  De(n, import_react30.default.Component);
  var r2 = be(n);
  function n() {
    var t5;
    he(this, n);
    for (var o = arguments.length, a3 = new Array(o), i2 = 0; i2 < o; i2++)
      a3[i2] = arguments[i2];
    return ye(we(t5 = r2.call.apply(r2, [this].concat(a3))), "state", { height: null }), ye(we(t5), "scrollToTheSelectedTime", function() {
      requestAnimationFrame(function() {
        t5.list && (t5.list.scrollTop = t5.centerLi && n.calcCenterPosition(t5.props.monthRef ? t5.props.monthRef.clientHeight - t5.header.clientHeight : t5.list.clientHeight, t5.centerLi));
      });
    }), ye(we(t5), "handleClick", function(e4) {
      (t5.props.minTime || t5.props.maxTime) && lt(e4, t5.props) || (t5.props.excludeTimes || t5.props.includeTimes || t5.props.filterTime) && ct(e4, t5.props) || t5.props.onChange(e4);
    }), ye(we(t5), "isSelectedTime", function(e4) {
      return t5.props.selected && (r3 = t5.props.selected, n2 = e4, bt(r3).getTime() === bt(n2).getTime());
      var r3, n2;
    }), ye(we(t5), "isDisabledTime", function(e4) {
      return (t5.props.minTime || t5.props.maxTime) && lt(e4, t5.props) || (t5.props.excludeTimes || t5.props.includeTimes || t5.props.filterTime) && ct(e4, t5.props);
    }), ye(we(t5), "liClasses", function(e4) {
      var r3 = ["react-datepicker__time-list-item", t5.props.timeClassName ? t5.props.timeClassName(e4) : void 0];
      return t5.isSelectedTime(e4) && r3.push("react-datepicker__time-list-item--selected"), t5.isDisabledTime(e4) && r3.push("react-datepicker__time-list-item--disabled"), t5.props.injectTimes && (60 * getHours(e4) + getMinutes(e4)) % t5.props.intervals != 0 && r3.push("react-datepicker__time-list-item--injected"), r3.join(" ");
    }), ye(we(t5), "handleOnKeyDown", function(e4, r3) {
      " " === e4.key && (e4.preventDefault(), e4.key = "Enter"), "ArrowUp" !== e4.key && "ArrowLeft" !== e4.key || !e4.target.previousSibling || (e4.preventDefault(), e4.target.previousSibling.focus()), "ArrowDown" !== e4.key && "ArrowRight" !== e4.key || !e4.target.nextSibling || (e4.preventDefault(), e4.target.nextSibling.focus()), "Enter" === e4.key && t5.handleClick(r3), t5.props.handleOnKeyDown(e4);
    }), ye(we(t5), "renderTimes", function() {
      for (var r3 = [], n2 = t5.props.format ? t5.props.format : "p", o2 = t5.props.intervals, a4 = t5.props.selected || t5.props.openToDate || Ye(), i3 = startOfDay(a4), p = t5.props.injectTimes && t5.props.injectTimes.sort(function(e4, t6) {
        return e4 - t6;
      }), c2 = 60 * function(e4) {
        var t6 = new Date(e4.getFullYear(), e4.getMonth(), e4.getDate()), r4 = new Date(e4.getFullYear(), e4.getMonth(), e4.getDate(), 24);
        return Math.round((+r4 - +t6) / 36e5);
      }(a4), l = c2 / o2, d3 = 0; d3 < l; d3++) {
        var u2 = addMinutes(i3, d3 * o2);
        if (r3.push(u2), p) {
          var h3 = gt(i3, u2, d3, o2, p);
          r3 = r3.concat(h3);
        }
      }
      var m3 = r3.reduce(function(e4, t6) {
        return t6.getTime() <= a4.getTime() ? t6 : e4;
      }, r3[0]);
      return r3.map(function(r4, o3) {
        return import_react30.default.createElement("li", { key: o3, onClick: t5.handleClick.bind(we(t5), r4), className: t5.liClasses(r4), ref: function(e4) {
          r4 === m3 && (t5.centerLi = e4);
        }, onKeyDown: function(e4) {
          t5.handleOnKeyDown(e4, r4);
        }, tabIndex: r4 === m3 ? 0 : -1, role: "option", "aria-selected": t5.isSelectedTime(r4) ? "true" : void 0, "aria-disabled": t5.isDisabledTime(r4) ? "true" : void 0 }, Ie(r4, n2, t5.props.locale));
      });
    }), t5;
  }
  return fe(n, [{ key: "componentDidMount", value: function() {
    this.scrollToTheSelectedTime(), this.props.monthRef && this.header && this.setState({ height: this.props.monthRef.clientHeight - this.header.clientHeight });
  } }, { key: "render", value: function() {
    var t5 = this, r3 = this.state.height;
    return import_react30.default.createElement("div", { className: "react-datepicker__time-container ".concat(this.props.todayButton ? "react-datepicker__time-container--with-today-button" : "") }, import_react30.default.createElement("div", { className: "react-datepicker__header react-datepicker__header--time ".concat(this.props.showTimeSelectOnly ? "react-datepicker__header--time--only" : ""), ref: function(e4) {
      t5.header = e4;
    } }, import_react30.default.createElement("div", { className: "react-datepicker-time__header" }, this.props.timeCaption)), import_react30.default.createElement("div", { className: "react-datepicker__time" }, import_react30.default.createElement("div", { className: "react-datepicker__time-box" }, import_react30.default.createElement("ul", { className: "react-datepicker__time-list", ref: function(e4) {
      t5.list = e4;
    }, style: r3 ? { height: r3 } : {}, role: "listbox", "aria-label": this.props.timeCaption }, this.renderTimes()))));
  } }], [{ key: "defaultProps", get: function() {
    return { intervals: 30, onTimeChange: function() {
    }, todayButton: null, timeCaption: "Time" };
  } }]), n;
}();
ye(Kt, "calcCenterPosition", function(e4, t4) {
  return t4.offsetTop - (e4 / 2 - t4.clientHeight / 2);
});
var Bt = function(t4) {
  De(o, import_react30.default.Component);
  var n = be(o);
  function o(t5) {
    var a3;
    return he(this, o), ye(we(a3 = n.call(this, t5)), "YEAR_REFS", Se(Array(a3.props.yearItemNumber)).map(function() {
      return import_react30.default.createRef();
    })), ye(we(a3), "isDisabled", function(e4) {
      return Ze(e4, a3.props);
    }), ye(we(a3), "isExcluded", function(e4) {
      return et(e4, a3.props);
    }), ye(we(a3), "selectingDate", function() {
      var e4;
      return null !== (e4 = a3.props.selectingDate) && void 0 !== e4 ? e4 : a3.props.preSelection;
    }), ye(we(a3), "updateFocusOnPaginate", function(e4) {
      var t6 = (function() {
        this.YEAR_REFS[e4].current.focus();
      }).bind(we(a3));
      window.requestAnimationFrame(t6);
    }), ye(we(a3), "handleYearClick", function(e4, t6) {
      a3.props.onDayClick && a3.props.onDayClick(e4, t6);
    }), ye(we(a3), "handleYearNavigation", function(e4, t6) {
      var r2 = a3.props, n2 = r2.date, o2 = r2.yearItemNumber, s3 = wt(n2, o2).startPeriod;
      a3.isDisabled(t6) || a3.isExcluded(t6) || (a3.props.setPreSelection(t6), e4 - s3 == -1 ? a3.updateFocusOnPaginate(o2 - 1) : e4 - s3 === o2 ? a3.updateFocusOnPaginate(0) : a3.YEAR_REFS[e4 - s3].current.focus());
    }), ye(we(a3), "isSameDay", function(e4, t6) {
      return je(e4, t6);
    }), ye(we(a3), "isCurrentYear", function(e4) {
      return e4 === getYear(Ye());
    }), ye(we(a3), "isRangeStart", function(e4) {
      return a3.props.startDate && a3.props.endDate && Be(setYear(Ye(), e4), a3.props.startDate);
    }), ye(we(a3), "isRangeEnd", function(e4) {
      return a3.props.startDate && a3.props.endDate && Be(setYear(Ye(), e4), a3.props.endDate);
    }), ye(we(a3), "isInRange", function(e4) {
      return ot(e4, a3.props.startDate, a3.props.endDate);
    }), ye(we(a3), "isInSelectingRange", function(e4) {
      var t6 = a3.props, r2 = t6.selectsStart, n2 = t6.selectsEnd, o2 = t6.selectsRange, s3 = t6.startDate, i2 = t6.endDate;
      return !(!(r2 || n2 || o2) || !a3.selectingDate()) && (r2 && i2 ? ot(e4, a3.selectingDate(), i2) : (n2 && s3 || !(!o2 || !s3 || i2)) && ot(e4, s3, a3.selectingDate()));
    }), ye(we(a3), "isSelectingRangeStart", function(e4) {
      if (!a3.isInSelectingRange(e4))
        return false;
      var t6 = a3.props, r2 = t6.startDate, n2 = t6.selectsStart, o2 = setYear(Ye(), e4);
      return Be(o2, n2 ? a3.selectingDate() : r2);
    }), ye(we(a3), "isSelectingRangeEnd", function(e4) {
      if (!a3.isInSelectingRange(e4))
        return false;
      var t6 = a3.props, r2 = t6.endDate, n2 = t6.selectsEnd, o2 = t6.selectsRange, s3 = setYear(Ye(), e4);
      return Be(s3, n2 || o2 ? a3.selectingDate() : r2);
    }), ye(we(a3), "isKeyboardSelected", function(e4) {
      var t6 = Ae(setYear(a3.props.date, e4));
      return !a3.props.disabledKeyboardNavigation && !a3.props.inline && !je(t6, Ae(a3.props.selected)) && je(t6, Ae(a3.props.preSelection));
    }), ye(we(a3), "onYearClick", function(e4, t6) {
      var r2 = a3.props.date;
      a3.handleYearClick(Ae(setYear(r2, t6)), e4);
    }), ye(we(a3), "onYearKeyDown", function(e4, t6) {
      var r2 = e4.key;
      if (!a3.props.disabledKeyboardNavigation)
        switch (r2) {
          case "Enter":
            a3.onYearClick(e4, t6), a3.props.setPreSelection(a3.props.selected);
            break;
          case "ArrowRight":
            a3.handleYearNavigation(t6 + 1, addYears(a3.props.preSelection, 1));
            break;
          case "ArrowLeft":
            a3.handleYearNavigation(t6 - 1, subYears(a3.props.preSelection, 1));
        }
    }), ye(we(a3), "getYearClassNames", function(e4) {
      var t6 = a3.props, n2 = t6.minDate, o2 = t6.maxDate, s3 = t6.selected, i2 = t6.excludeDates, p = t6.includeDates, c2 = t6.filterDate;
      return (0, import_classnames2.default)("react-datepicker__year-text", { "react-datepicker__year-text--selected": e4 === getYear(s3), "react-datepicker__year-text--disabled": (n2 || o2 || i2 || p || c2) && at(e4, a3.props), "react-datepicker__year-text--keyboard-selected": a3.isKeyboardSelected(e4), "react-datepicker__year-text--range-start": a3.isRangeStart(e4), "react-datepicker__year-text--range-end": a3.isRangeEnd(e4), "react-datepicker__year-text--in-range": a3.isInRange(e4), "react-datepicker__year-text--in-selecting-range": a3.isInSelectingRange(e4), "react-datepicker__year-text--selecting-range-start": a3.isSelectingRangeStart(e4), "react-datepicker__year-text--selecting-range-end": a3.isSelectingRangeEnd(e4), "react-datepicker__year-text--today": a3.isCurrentYear(e4) });
    }), ye(we(a3), "getYearTabIndex", function(e4) {
      return a3.props.disabledKeyboardNavigation ? "-1" : e4 === getYear(a3.props.preSelection) ? "0" : "-1";
    }), ye(we(a3), "getYearContainerClassNames", function() {
      var e4 = a3.props, t6 = e4.selectingDate, n2 = e4.selectsStart, o2 = e4.selectsEnd, s3 = e4.selectsRange;
      return (0, import_classnames2.default)("react-datepicker__year", { "react-datepicker__year--selecting-range": t6 && (n2 || o2 || s3) });
    }), ye(we(a3), "getYearContent", function(e4) {
      return a3.props.renderYearContent ? a3.props.renderYearContent(e4) : e4;
    }), a3;
  }
  return fe(o, [{ key: "render", value: function() {
    for (var t5 = this, r2 = [], n2 = this.props, o2 = n2.date, a3 = n2.yearItemNumber, s3 = n2.onYearMouseEnter, i2 = n2.onYearMouseLeave, p = wt(o2, a3), c2 = p.startPeriod, l = p.endPeriod, d3 = function(n3) {
      r2.push(import_react30.default.createElement("div", { ref: t5.YEAR_REFS[n3 - c2], onClick: function(e4) {
        t5.onYearClick(e4, n3);
      }, onKeyDown: function(e4) {
        t5.onYearKeyDown(e4, n3);
      }, tabIndex: t5.getYearTabIndex(n3), className: t5.getYearClassNames(n3), onMouseEnter: function(e4) {
        return s3(e4, n3);
      }, onMouseLeave: function(e4) {
        return i2(e4, n3);
      }, key: n3, "aria-current": t5.isCurrentYear(n3) ? "date" : void 0 }, t5.getYearContent(n3)));
    }, u2 = c2; u2 <= l; u2++)
      d3(u2);
    return import_react30.default.createElement("div", { className: this.getYearContainerClassNames() }, import_react30.default.createElement("div", { className: "react-datepicker__year-wrapper", onMouseLeave: this.props.clearSelectingDate }, r2));
  } }]), o;
}();
var Qt = function(t4) {
  De(n, import_react30.default.Component);
  var r2 = be(n);
  function n(t5) {
    var o;
    return he(this, n), ye(we(o = r2.call(this, t5)), "onTimeChange", function(e4) {
      o.setState({ time: e4 });
      var t6 = o.props.date, r3 = t6 instanceof Date && !isNaN(t6) ? t6 : /* @__PURE__ */ new Date();
      r3.setHours(e4.split(":")[0]), r3.setMinutes(e4.split(":")[1]), o.props.onChange(r3);
    }), ye(we(o), "renderTimeInput", function() {
      var t6 = o.state.time, r3 = o.props, n2 = r3.date, a3 = r3.timeString, s3 = r3.customTimeInput;
      return s3 ? import_react30.default.cloneElement(s3, { date: n2, value: t6, onChange: o.onTimeChange }) : import_react30.default.createElement("input", { type: "time", className: "react-datepicker-time__input", placeholder: "Time", name: "time-input", required: true, value: t6, onChange: function(e4) {
        o.onTimeChange(e4.target.value || a3);
      } });
    }), o.state = { time: o.props.timeString }, o;
  }
  return fe(n, [{ key: "render", value: function() {
    return import_react30.default.createElement("div", { className: "react-datepicker__input-time-container" }, import_react30.default.createElement("div", { className: "react-datepicker-time__caption" }, this.props.timeInputLabel), import_react30.default.createElement("div", { className: "react-datepicker-time__input-container" }, import_react30.default.createElement("div", { className: "react-datepicker-time__input" }, this.renderTimeInput())));
  } }], [{ key: "getDerivedStateFromProps", value: function(e4, t5) {
    return e4.timeString !== t5.time ? { time: e4.timeString } : null;
  } }]), n;
}();
function Ht(t4) {
  var r2 = t4.className, n = t4.children, o = t4.showPopperArrow, a3 = t4.arrowProps, s3 = void 0 === a3 ? {} : a3;
  return import_react30.default.createElement("div", { className: r2 }, o && import_react30.default.createElement("div", ve({ className: "react-datepicker__triangle" }, s3)), n);
}
var jt = ["react-datepicker__year-select", "react-datepicker__month-select", "react-datepicker__month-year-select"];
var Vt = function(t4) {
  De(o, import_react30.default.Component);
  var n = be(o);
  function o(t5) {
    var a3;
    return he(this, o), ye(we(a3 = n.call(this, t5)), "handleClickOutside", function(e4) {
      a3.props.onClickOutside(e4);
    }), ye(we(a3), "setClickOutsideRef", function() {
      return a3.containerRef.current;
    }), ye(we(a3), "handleDropdownFocus", function(e4) {
      (function() {
        var e5 = ((arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).className || "").split(/\s+/);
        return jt.some(function(t6) {
          return e5.indexOf(t6) >= 0;
        });
      })(e4.target) && a3.props.onDropdownFocus();
    }), ye(we(a3), "getDateInView", function() {
      var e4 = a3.props, t6 = e4.preSelection, r2 = e4.selected, n2 = e4.openToDate, o2 = ft(a3.props), s3 = yt(a3.props), i2 = Ye(), p = n2 || r2 || t6;
      return p || (o2 && isBefore(i2, o2) ? o2 : s3 && isAfter(i2, s3) ? s3 : i2);
    }), ye(we(a3), "increaseMonth", function() {
      a3.setState(function(e4) {
        var t6 = e4.date;
        return { date: addMonths(t6, 1) };
      }, function() {
        return a3.handleMonthChange(a3.state.date);
      });
    }), ye(we(a3), "decreaseMonth", function() {
      a3.setState(function(e4) {
        var t6 = e4.date;
        return { date: subMonths(t6, 1) };
      }, function() {
        return a3.handleMonthChange(a3.state.date);
      });
    }), ye(we(a3), "handleDayClick", function(e4, t6, r2) {
      a3.props.onSelect(e4, t6, r2), a3.props.setPreSelection && a3.props.setPreSelection(e4);
    }), ye(we(a3), "handleDayMouseEnter", function(e4) {
      a3.setState({ selectingDate: e4 }), a3.props.onDayMouseEnter && a3.props.onDayMouseEnter(e4);
    }), ye(we(a3), "handleMonthMouseLeave", function() {
      a3.setState({ selectingDate: null }), a3.props.onMonthMouseLeave && a3.props.onMonthMouseLeave();
    }), ye(we(a3), "handleYearMouseEnter", function(e4, t6) {
      a3.setState({ selectingDate: setYear(Ye(), t6) }), a3.props.onYearMouseEnter && a3.props.onYearMouseEnter(e4, t6);
    }), ye(we(a3), "handleYearMouseLeave", function(e4, t6) {
      a3.props.onYearMouseLeave && a3.props.onYearMouseLeave(e4, t6);
    }), ye(we(a3), "handleYearChange", function(e4) {
      a3.props.onYearChange && (a3.props.onYearChange(e4), a3.setState({ isRenderAriaLiveMessage: true })), a3.props.adjustDateOnChange && (a3.props.onSelect && a3.props.onSelect(e4), a3.props.setOpen && a3.props.setOpen(true)), a3.props.setPreSelection && a3.props.setPreSelection(e4);
    }), ye(we(a3), "handleMonthChange", function(e4) {
      a3.handleCustomMonthChange(e4), a3.props.adjustDateOnChange && (a3.props.onSelect && a3.props.onSelect(e4), a3.props.setOpen && a3.props.setOpen(true)), a3.props.setPreSelection && a3.props.setPreSelection(e4);
    }), ye(we(a3), "handleCustomMonthChange", function(e4) {
      a3.props.onMonthChange && (a3.props.onMonthChange(e4), a3.setState({ isRenderAriaLiveMessage: true }));
    }), ye(we(a3), "handleMonthYearChange", function(e4) {
      a3.handleYearChange(e4), a3.handleMonthChange(e4);
    }), ye(we(a3), "changeYear", function(e4) {
      a3.setState(function(t6) {
        var r2 = t6.date;
        return { date: setYear(r2, e4) };
      }, function() {
        return a3.handleYearChange(a3.state.date);
      });
    }), ye(we(a3), "changeMonth", function(e4) {
      a3.setState(function(t6) {
        var r2 = t6.date;
        return { date: setMonth(r2, e4) };
      }, function() {
        return a3.handleMonthChange(a3.state.date);
      });
    }), ye(we(a3), "changeMonthYear", function(e4) {
      a3.setState(function(t6) {
        var r2 = t6.date;
        return { date: setYear(setMonth(r2, getMonth(e4)), getYear(e4)) };
      }, function() {
        return a3.handleMonthYearChange(a3.state.date);
      });
    }), ye(we(a3), "header", function() {
      var t6 = Le(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a3.state.date, a3.props.locale, a3.props.calendarStartDay), n2 = [];
      return a3.props.showWeekNumbers && n2.push(import_react30.default.createElement("div", { key: "W", className: "react-datepicker__day-name" }, a3.props.weekLabel || "#")), n2.concat([0, 1, 2, 3, 4, 5, 6].map(function(n3) {
        var o2 = addDays(t6, n3), s3 = a3.formatWeekday(o2, a3.props.locale), i2 = a3.props.weekDayClassName ? a3.props.weekDayClassName(o2) : void 0;
        return import_react30.default.createElement("div", { key: n3, className: (0, import_classnames2.default)("react-datepicker__day-name", i2) }, s3);
      }));
    }), ye(we(a3), "formatWeekday", function(e4, t6) {
      return a3.props.formatWeekDay ? function(e5, t7, r2) {
        return t7(Ie(e5, "EEEE", r2));
      }(e4, a3.props.formatWeekDay, t6) : a3.props.useWeekdaysShort ? function(e5, t7) {
        return Ie(e5, "EEE", t7);
      }(e4, t6) : function(e5, t7) {
        return Ie(e5, "EEEEEE", t7);
      }(e4, t6);
    }), ye(we(a3), "decreaseYear", function() {
      a3.setState(function(e4) {
        var t6 = e4.date;
        return { date: subYears(t6, a3.props.showYearPicker ? a3.props.yearItemNumber : 1) };
      }, function() {
        return a3.handleYearChange(a3.state.date);
      });
    }), ye(we(a3), "clearSelectingDate", function() {
      a3.setState({ selectingDate: null });
    }), ye(we(a3), "renderPreviousButton", function() {
      if (!a3.props.renderCustomHeader) {
        var t6;
        switch (true) {
          case a3.props.showMonthYearPicker:
            t6 = ht(a3.state.date, a3.props);
            break;
          case a3.props.showYearPicker:
            t6 = function(e4) {
              var t7 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = t7.minDate, n3 = t7.yearItemNumber, o3 = void 0 === n3 ? Ne : n3, a4 = wt(Ae(subYears(e4, o3)), o3).endPeriod, s4 = r3 && getYear(r3);
              return s4 && s4 > a4 || false;
            }(a3.state.date, a3.props);
            break;
          default:
            t6 = dt(a3.state.date, a3.props);
        }
        if ((a3.props.forceShowMonthNavigation || a3.props.showDisabledMonthNavigation || !t6) && !a3.props.showTimeSelectOnly) {
          var r2 = ["react-datepicker__navigation", "react-datepicker__navigation--previous"], n2 = a3.decreaseMonth;
          (a3.props.showMonthYearPicker || a3.props.showQuarterYearPicker || a3.props.showYearPicker) && (n2 = a3.decreaseYear), t6 && a3.props.showDisabledMonthNavigation && (r2.push("react-datepicker__navigation--previous--disabled"), n2 = null);
          var o2 = a3.props.showMonthYearPicker || a3.props.showQuarterYearPicker || a3.props.showYearPicker, s3 = a3.props, i2 = s3.previousMonthButtonLabel, p = s3.previousYearButtonLabel, c2 = a3.props, l = c2.previousMonthAriaLabel, d3 = void 0 === l ? "string" == typeof i2 ? i2 : "Previous Month" : l, u2 = c2.previousYearAriaLabel, h3 = void 0 === u2 ? "string" == typeof p ? p : "Previous Year" : u2;
          return import_react30.default.createElement("button", { type: "button", className: r2.join(" "), onClick: n2, onKeyDown: a3.props.handleOnKeyDown, "aria-label": o2 ? h3 : d3 }, import_react30.default.createElement("span", { className: ["react-datepicker__navigation-icon", "react-datepicker__navigation-icon--previous"].join(" ") }, o2 ? a3.props.previousYearButtonLabel : a3.props.previousMonthButtonLabel));
        }
      }
    }), ye(we(a3), "increaseYear", function() {
      a3.setState(function(e4) {
        var t6 = e4.date;
        return { date: addYears(t6, a3.props.showYearPicker ? a3.props.yearItemNumber : 1) };
      }, function() {
        return a3.handleYearChange(a3.state.date);
      });
    }), ye(we(a3), "renderNextButton", function() {
      if (!a3.props.renderCustomHeader) {
        var t6;
        switch (true) {
          case a3.props.showMonthYearPicker:
            t6 = mt(a3.state.date, a3.props);
            break;
          case a3.props.showYearPicker:
            t6 = function(e4) {
              var t7 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = t7.maxDate, n3 = t7.yearItemNumber, o3 = void 0 === n3 ? Ne : n3, a4 = wt(addYears(e4, o3), o3).startPeriod, s4 = r3 && getYear(r3);
              return s4 && s4 < a4 || false;
            }(a3.state.date, a3.props);
            break;
          default:
            t6 = ut(a3.state.date, a3.props);
        }
        if ((a3.props.forceShowMonthNavigation || a3.props.showDisabledMonthNavigation || !t6) && !a3.props.showTimeSelectOnly) {
          var r2 = ["react-datepicker__navigation", "react-datepicker__navigation--next"];
          a3.props.showTimeSelect && r2.push("react-datepicker__navigation--next--with-time"), a3.props.todayButton && r2.push("react-datepicker__navigation--next--with-today-button");
          var n2 = a3.increaseMonth;
          (a3.props.showMonthYearPicker || a3.props.showQuarterYearPicker || a3.props.showYearPicker) && (n2 = a3.increaseYear), t6 && a3.props.showDisabledMonthNavigation && (r2.push("react-datepicker__navigation--next--disabled"), n2 = null);
          var o2 = a3.props.showMonthYearPicker || a3.props.showQuarterYearPicker || a3.props.showYearPicker, s3 = a3.props, i2 = s3.nextMonthButtonLabel, p = s3.nextYearButtonLabel, c2 = a3.props, l = c2.nextMonthAriaLabel, d3 = void 0 === l ? "string" == typeof i2 ? i2 : "Next Month" : l, h3 = c2.nextYearAriaLabel, m3 = void 0 === h3 ? "string" == typeof p ? p : "Next Year" : h3;
          return import_react30.default.createElement("button", { type: "button", className: r2.join(" "), onClick: n2, onKeyDown: a3.props.handleOnKeyDown, "aria-label": o2 ? m3 : d3 }, import_react30.default.createElement("span", { className: ["react-datepicker__navigation-icon", "react-datepicker__navigation-icon--next"].join(" ") }, o2 ? a3.props.nextYearButtonLabel : a3.props.nextMonthButtonLabel));
        }
      }
    }), ye(we(a3), "renderCurrentMonth", function() {
      var t6 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a3.state.date, r2 = ["react-datepicker__current-month"];
      return a3.props.showYearDropdown && r2.push("react-datepicker__current-month--hasYearDropdown"), a3.props.showMonthDropdown && r2.push("react-datepicker__current-month--hasMonthDropdown"), a3.props.showMonthYearDropdown && r2.push("react-datepicker__current-month--hasMonthYearDropdown"), import_react30.default.createElement("div", { className: r2.join(" ") }, Ie(t6, a3.props.dateFormat, a3.props.locale));
    }), ye(we(a3), "renderYearDropdown", function() {
      var t6 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      if (a3.props.showYearDropdown && !t6)
        return import_react30.default.createElement(_t, { adjustDateOnChange: a3.props.adjustDateOnChange, date: a3.state.date, onSelect: a3.props.onSelect, setOpen: a3.props.setOpen, dropdownMode: a3.props.dropdownMode, onChange: a3.changeYear, minDate: a3.props.minDate, maxDate: a3.props.maxDate, year: getYear(a3.state.date), scrollableYearDropdown: a3.props.scrollableYearDropdown, yearDropdownItemNumber: a3.props.yearDropdownItemNumber });
    }), ye(we(a3), "renderMonthDropdown", function() {
      var t6 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      if (a3.props.showMonthDropdown && !t6)
        return import_react30.default.createElement(Pt, { dropdownMode: a3.props.dropdownMode, locale: a3.props.locale, onChange: a3.changeMonth, month: getMonth(a3.state.date), useShortMonthInDropdown: a3.props.useShortMonthInDropdown });
    }), ye(we(a3), "renderMonthYearDropdown", function() {
      var t6 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      if (a3.props.showMonthYearDropdown && !t6)
        return import_react30.default.createElement(xt, { dropdownMode: a3.props.dropdownMode, locale: a3.props.locale, dateFormat: a3.props.dateFormat, onChange: a3.changeMonthYear, minDate: a3.props.minDate, maxDate: a3.props.maxDate, date: a3.state.date, scrollableMonthYearDropdown: a3.props.scrollableMonthYearDropdown });
    }), ye(we(a3), "handleTodayButtonClick", function(e4) {
      a3.props.onSelect(Ke(), e4), a3.props.setPreSelection && a3.props.setPreSelection(Ke());
    }), ye(we(a3), "renderTodayButton", function() {
      if (a3.props.todayButton && !a3.props.showTimeSelectOnly)
        return import_react30.default.createElement("div", { className: "react-datepicker__today-button", onClick: function(e4) {
          return a3.handleTodayButtonClick(e4);
        } }, a3.props.todayButton);
    }), ye(we(a3), "renderDefaultHeader", function(t6) {
      var r2 = t6.monthDate, n2 = t6.i;
      return import_react30.default.createElement("div", { className: "react-datepicker__header ".concat(a3.props.showTimeSelect ? "react-datepicker__header--has-time-select" : "") }, a3.renderCurrentMonth(r2), import_react30.default.createElement("div", { className: "react-datepicker__header__dropdown react-datepicker__header__dropdown--".concat(a3.props.dropdownMode), onFocus: a3.handleDropdownFocus }, a3.renderMonthDropdown(0 !== n2), a3.renderMonthYearDropdown(0 !== n2), a3.renderYearDropdown(0 !== n2)), import_react30.default.createElement("div", { className: "react-datepicker__day-names" }, a3.header(r2)));
    }), ye(we(a3), "renderCustomHeader", function() {
      var t6 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r2 = t6.monthDate, n2 = t6.i;
      if (a3.props.showTimeSelect && !a3.state.monthContainer || a3.props.showTimeSelectOnly)
        return null;
      var o2 = dt(a3.state.date, a3.props), s3 = ut(a3.state.date, a3.props), i2 = ht(a3.state.date, a3.props), p = mt(a3.state.date, a3.props), c2 = !a3.props.showMonthYearPicker && !a3.props.showQuarterYearPicker && !a3.props.showYearPicker;
      return import_react30.default.createElement("div", { className: "react-datepicker__header react-datepicker__header--custom", onFocus: a3.props.onDropdownFocus }, a3.props.renderCustomHeader(de(de({}, a3.state), {}, { customHeaderCount: n2, monthDate: r2, changeMonth: a3.changeMonth, changeYear: a3.changeYear, decreaseMonth: a3.decreaseMonth, increaseMonth: a3.increaseMonth, decreaseYear: a3.decreaseYear, increaseYear: a3.increaseYear, prevMonthButtonDisabled: o2, nextMonthButtonDisabled: s3, prevYearButtonDisabled: i2, nextYearButtonDisabled: p })), c2 && import_react30.default.createElement("div", { className: "react-datepicker__day-names" }, a3.header(r2)));
    }), ye(we(a3), "renderYearHeader", function() {
      var t6 = a3.state.date, r2 = a3.props, n2 = r2.showYearPicker, o2 = wt(t6, r2.yearItemNumber), s3 = o2.startPeriod, i2 = o2.endPeriod;
      return import_react30.default.createElement("div", { className: "react-datepicker__header react-datepicker-year-header" }, n2 ? "".concat(s3, " - ").concat(i2) : getYear(t6));
    }), ye(we(a3), "renderHeader", function(e4) {
      switch (true) {
        case void 0 !== a3.props.renderCustomHeader:
          return a3.renderCustomHeader(e4);
        case (a3.props.showMonthYearPicker || a3.props.showQuarterYearPicker || a3.props.showYearPicker):
          return a3.renderYearHeader(e4);
        default:
          return a3.renderDefaultHeader(e4);
      }
    }), ye(we(a3), "renderMonths", function() {
      var t6;
      if (!a3.props.showTimeSelectOnly && !a3.props.showYearPicker) {
        for (var r2 = [], n2 = a3.props.showPreviousMonths ? a3.props.monthsShown - 1 : 0, o2 = subMonths(a3.state.date, n2), s3 = null !== (t6 = a3.props.monthSelectedIn) && void 0 !== t6 ? t6 : n2, i2 = 0; i2 < a3.props.monthsShown; ++i2) {
          var p = addMonths(o2, i2 - s3 + n2), c2 = "month-".concat(i2), d3 = i2 < a3.props.monthsShown - 1, u2 = i2 > 0;
          r2.push(import_react30.default.createElement("div", { key: c2, ref: function(e4) {
            a3.monthContainer = e4;
          }, className: "react-datepicker__month-container" }, a3.renderHeader({ monthDate: p, i: i2 }), import_react30.default.createElement(Wt, { chooseDayAriaLabelPrefix: a3.props.chooseDayAriaLabelPrefix, disabledDayAriaLabelPrefix: a3.props.disabledDayAriaLabelPrefix, weekAriaLabelPrefix: a3.props.weekAriaLabelPrefix, ariaLabelPrefix: a3.props.monthAriaLabelPrefix, onChange: a3.changeMonthYear, day: p, dayClassName: a3.props.dayClassName, calendarStartDay: a3.props.calendarStartDay, monthClassName: a3.props.monthClassName, onDayClick: a3.handleDayClick, handleOnKeyDown: a3.props.handleOnDayKeyDown, onDayMouseEnter: a3.handleDayMouseEnter, onMouseLeave: a3.handleMonthMouseLeave, onWeekSelect: a3.props.onWeekSelect, orderInDisplay: i2, formatWeekNumber: a3.props.formatWeekNumber, locale: a3.props.locale, minDate: a3.props.minDate, maxDate: a3.props.maxDate, excludeDates: a3.props.excludeDates, excludeDateIntervals: a3.props.excludeDateIntervals, highlightDates: a3.props.highlightDates, holidays: a3.props.holidays, selectingDate: a3.state.selectingDate, includeDates: a3.props.includeDates, includeDateIntervals: a3.props.includeDateIntervals, inline: a3.props.inline, shouldFocusDayInline: a3.props.shouldFocusDayInline, fixedHeight: a3.props.fixedHeight, filterDate: a3.props.filterDate, preSelection: a3.props.preSelection, setPreSelection: a3.props.setPreSelection, selected: a3.props.selected, selectsStart: a3.props.selectsStart, selectsEnd: a3.props.selectsEnd, selectsRange: a3.props.selectsRange, selectsDisabledDaysInRange: a3.props.selectsDisabledDaysInRange, showWeekNumbers: a3.props.showWeekNumbers, startDate: a3.props.startDate, endDate: a3.props.endDate, peekNextMonth: a3.props.peekNextMonth, setOpen: a3.props.setOpen, shouldCloseOnSelect: a3.props.shouldCloseOnSelect, renderDayContents: a3.props.renderDayContents, renderMonthContent: a3.props.renderMonthContent, renderQuarterContent: a3.props.renderQuarterContent, renderYearContent: a3.props.renderYearContent, disabledKeyboardNavigation: a3.props.disabledKeyboardNavigation, showMonthYearPicker: a3.props.showMonthYearPicker, showFullMonthYearPicker: a3.props.showFullMonthYearPicker, showTwoColumnMonthYearPicker: a3.props.showTwoColumnMonthYearPicker, showFourColumnMonthYearPicker: a3.props.showFourColumnMonthYearPicker, showYearPicker: a3.props.showYearPicker, showQuarterYearPicker: a3.props.showQuarterYearPicker, showWeekPicker: a3.props.showWeekPicker, isInputFocused: a3.props.isInputFocused, containerRef: a3.containerRef, monthShowsDuplicateDaysEnd: d3, monthShowsDuplicateDaysStart: u2 })));
        }
        return r2;
      }
    }), ye(we(a3), "renderYears", function() {
      if (!a3.props.showTimeSelectOnly)
        return a3.props.showYearPicker ? import_react30.default.createElement("div", { className: "react-datepicker__year--container" }, a3.renderHeader(), import_react30.default.createElement(Bt, ve({ onDayClick: a3.handleDayClick, selectingDate: a3.state.selectingDate, clearSelectingDate: a3.clearSelectingDate, date: a3.state.date }, a3.props, { onYearMouseEnter: a3.handleYearMouseEnter, onYearMouseLeave: a3.handleYearMouseLeave }))) : void 0;
    }), ye(we(a3), "renderTimeSection", function() {
      if (a3.props.showTimeSelect && (a3.state.monthContainer || a3.props.showTimeSelectOnly))
        return import_react30.default.createElement(Kt, { selected: a3.props.selected, openToDate: a3.props.openToDate, onChange: a3.props.onTimeChange, timeClassName: a3.props.timeClassName, format: a3.props.timeFormat, includeTimes: a3.props.includeTimes, intervals: a3.props.timeIntervals, minTime: a3.props.minTime, maxTime: a3.props.maxTime, excludeTimes: a3.props.excludeTimes, filterTime: a3.props.filterTime, timeCaption: a3.props.timeCaption, todayButton: a3.props.todayButton, showMonthDropdown: a3.props.showMonthDropdown, showMonthYearDropdown: a3.props.showMonthYearDropdown, showYearDropdown: a3.props.showYearDropdown, withPortal: a3.props.withPortal, monthRef: a3.state.monthContainer, injectTimes: a3.props.injectTimes, locale: a3.props.locale, handleOnKeyDown: a3.props.handleOnKeyDown, showTimeSelectOnly: a3.props.showTimeSelectOnly });
    }), ye(we(a3), "renderInputTimeSection", function() {
      var t6 = new Date(a3.props.selected), r2 = Te(t6) && Boolean(a3.props.selected) ? "".concat(kt(t6.getHours()), ":").concat(kt(t6.getMinutes())) : "";
      if (a3.props.showTimeInput)
        return import_react30.default.createElement(Qt, { date: t6, timeString: r2, timeInputLabel: a3.props.timeInputLabel, onChange: a3.props.onTimeChange, customTimeInput: a3.props.customTimeInput });
    }), ye(we(a3), "renderAriaLiveRegion", function() {
      var t6, r2 = wt(a3.state.date, a3.props.yearItemNumber), n2 = r2.startPeriod, o2 = r2.endPeriod;
      return t6 = a3.props.showYearPicker ? "".concat(n2, " - ").concat(o2) : a3.props.showMonthYearPicker || a3.props.showQuarterYearPicker ? getYear(a3.state.date) : "".concat(Je(getMonth(a3.state.date), a3.props.locale), " ").concat(getYear(a3.state.date)), import_react30.default.createElement("span", { role: "alert", "aria-live": "polite", className: "react-datepicker__aria-live" }, a3.state.isRenderAriaLiveMessage && t6);
    }), ye(we(a3), "renderChildren", function() {
      if (a3.props.children)
        return import_react30.default.createElement("div", { className: "react-datepicker__children-container" }, a3.props.children);
    }), a3.containerRef = import_react30.default.createRef(), a3.state = { date: a3.getDateInView(), selectingDate: null, monthContainer: null, isRenderAriaLiveMessage: false }, a3;
  }
  return fe(o, [{ key: "componentDidMount", value: function() {
    var e4 = this;
    this.props.showTimeSelect && (this.assignMonthContainer = void e4.setState({ monthContainer: e4.monthContainer }));
  } }, { key: "componentDidUpdate", value: function(e4) {
    var t5 = this;
    if (!this.props.preSelection || je(this.props.preSelection, e4.preSelection) && this.props.monthSelectedIn === e4.monthSelectedIn)
      this.props.openToDate && !je(this.props.openToDate, e4.openToDate) && this.setState({ date: this.props.openToDate });
    else {
      var r2 = !Qe(this.state.date, this.props.preSelection);
      this.setState({ date: this.props.preSelection }, function() {
        return r2 && t5.handleCustomMonthChange(t5.state.date);
      });
    }
  } }, { key: "render", value: function() {
    var t5 = this.props.container || Ht;
    return import_react30.default.createElement("div", { style: { display: "contents" }, ref: this.containerRef }, import_react30.default.createElement(t5, { className: (0, import_classnames2.default)("react-datepicker", this.props.className, { "react-datepicker--time-only": this.props.showTimeSelectOnly }), showPopperArrow: this.props.showPopperArrow, arrowProps: this.props.arrowProps }, this.renderAriaLiveRegion(), this.renderPreviousButton(), this.renderNextButton(), this.renderMonths(), this.renderYears(), this.renderTodayButton(), this.renderTimeSection(), this.renderInputTimeSection(), this.renderChildren()));
  } }], [{ key: "defaultProps", get: function() {
    return { onDropdownFocus: function() {
    }, monthsShown: 1, forceShowMonthNavigation: false, timeCaption: "Time", previousYearButtonLabel: "Previous Year", nextYearButtonLabel: "Next Year", previousMonthButtonLabel: "Previous Month", nextMonthButtonLabel: "Next Month", customTimeInput: null, yearItemNumber: Ne };
  } }]), o;
}();
var qt = function(t4) {
  var r2 = t4.icon, n = t4.className, o = void 0 === n ? "" : n, a3 = t4.onClick, s3 = "react-datepicker__calendar-icon";
  return import_react30.default.isValidElement(r2) ? import_react30.default.cloneElement(r2, { className: "".concat(r2.props.className || "", " ").concat(s3, " ").concat(o), onClick: function(e4) {
    "function" == typeof r2.props.onClick && r2.props.onClick(e4), "function" == typeof a3 && a3(e4);
  } }) : "string" == typeof r2 ? import_react30.default.createElement("i", { className: "".concat(s3, " ").concat(r2, " ").concat(o), "aria-hidden": "true", onClick: a3 }) : import_react30.default.createElement("svg", { className: "".concat(s3, " ").concat(o), xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 448 512", onClick: a3 }, import_react30.default.createElement("path", { d: "M96 32V64H48C21.5 64 0 85.5 0 112v48H448V112c0-26.5-21.5-48-48-48H352V32c0-17.7-14.3-32-32-32s-32 14.3-32 32V64H160V32c0-17.7-14.3-32-32-32S96 14.3 96 32zM448 192H0V464c0 26.5 21.5 48 48 48H400c26.5 0 48-21.5 48-48V192z" }));
};
var Ut = function(t4) {
  De(n, import_react30.default.Component);
  var r2 = be(n);
  function n(e4) {
    var t5;
    return he(this, n), (t5 = r2.call(this, e4)).el = document.createElement("div"), t5;
  }
  return fe(n, [{ key: "componentDidMount", value: function() {
    this.portalRoot = (this.props.portalHost || document).getElementById(this.props.portalId), this.portalRoot || (this.portalRoot = document.createElement("div"), this.portalRoot.setAttribute("id", this.props.portalId), (this.props.portalHost || document.body).appendChild(this.portalRoot)), this.portalRoot.appendChild(this.el);
  } }, { key: "componentWillUnmount", value: function() {
    this.portalRoot.removeChild(this.el);
  } }, { key: "render", value: function() {
    return import_react_dom6.default.createPortal(this.props.children, this.el);
  } }]), n;
}();
var zt = function(e4) {
  return !e4.disabled && -1 !== e4.tabIndex;
};
var $t = function(t4) {
  De(n, import_react30.default.Component);
  var r2 = be(n);
  function n(t5) {
    var o;
    return he(this, n), ye(we(o = r2.call(this, t5)), "getTabChildren", function() {
      return Array.prototype.slice.call(o.tabLoopRef.current.querySelectorAll("[tabindex], a, button, input, select, textarea"), 1, -1).filter(zt);
    }), ye(we(o), "handleFocusStart", function() {
      var e4 = o.getTabChildren();
      e4 && e4.length > 1 && e4[e4.length - 1].focus();
    }), ye(we(o), "handleFocusEnd", function() {
      var e4 = o.getTabChildren();
      e4 && e4.length > 1 && e4[0].focus();
    }), o.tabLoopRef = import_react30.default.createRef(), o;
  }
  return fe(n, [{ key: "render", value: function() {
    return this.props.enableTabLoop ? import_react30.default.createElement("div", { className: "react-datepicker__tab-loop", ref: this.tabLoopRef }, import_react30.default.createElement("div", { className: "react-datepicker__tab-loop__start", tabIndex: "0", onFocus: this.handleFocusStart }), this.props.children, import_react30.default.createElement("div", { className: "react-datepicker__tab-loop__end", tabIndex: "0", onFocus: this.handleFocusEnd })) : this.props.children;
  } }], [{ key: "defaultProps", get: function() {
    return { enableTabLoop: true };
  } }]), n;
}();
var Gt = function(t4) {
  De(o, import_react30.default.Component);
  var n = be(o);
  function o() {
    return he(this, o), n.apply(this, arguments);
  }
  return fe(o, [{ key: "render", value: function() {
    var t5, n2 = this.props, o2 = n2.className, a3 = n2.wrapperClassName, s3 = n2.hidePopper, i2 = n2.popperComponent, p = n2.popperModifiers, c2 = n2.popperPlacement, l = n2.popperProps, d3 = n2.targetComponent, u2 = n2.enableTabLoop, h3 = n2.popperOnKeyDown, m3 = n2.portalId, f = n2.portalHost;
    if (!s3) {
      var y3 = (0, import_classnames2.default)("react-datepicker-popper", o2);
      t5 = import_react30.default.createElement(Popper, ve({ modifiers: p, placement: c2 }, l), function(t6) {
        var r2 = t6.ref, n3 = t6.style, o3 = t6.placement, a4 = t6.arrowProps;
        return import_react30.default.createElement($t, { enableTabLoop: u2 }, import_react30.default.createElement("div", { ref: r2, style: n3, className: y3, "data-placement": o3, onKeyDown: h3 }, import_react30.default.cloneElement(i2, { arrowProps: a4 })));
      });
    }
    this.props.popperContainer && (t5 = import_react30.default.createElement(this.props.popperContainer, {}, t5)), m3 && !s3 && (t5 = import_react30.default.createElement(Ut, { portalId: m3, portalHost: f }, t5));
    var v = (0, import_classnames2.default)("react-datepicker-wrapper", a3);
    return import_react30.default.createElement(Manager, { className: "react-datepicker-manager" }, import_react30.default.createElement(Reference, null, function(t6) {
      var r2 = t6.ref;
      return import_react30.default.createElement("div", { ref: r2, className: v }, d3);
    }), t5);
  } }], [{ key: "defaultProps", get: function() {
    return { hidePopper: true, popperModifiers: [], popperProps: {}, popperPlacement: "bottom-start" };
  } }]), o;
}();
var Jt = "react-datepicker-ignore-onclickoutside";
var Xt = react_onclickoutside_es_default(Vt);
var Zt = "Date input not valid.";
var er = function(t4) {
  De(s3, import_react30.default.Component);
  var a3 = be(s3);
  function s3(t5) {
    var i2;
    return he(this, s3), ye(we(i2 = a3.call(this, t5)), "getPreSelection", function() {
      return i2.props.openToDate ? i2.props.openToDate : i2.props.selectsEnd && i2.props.startDate ? i2.props.startDate : i2.props.selectsStart && i2.props.endDate ? i2.props.endDate : Ye();
    }), ye(we(i2), "modifyHolidays", function() {
      var e4;
      return null === (e4 = i2.props.holidays) || void 0 === e4 ? void 0 : e4.reduce(function(e5, t6) {
        var r2 = new Date(t6.date);
        return isValid(r2) ? [].concat(Se(e5), [de(de({}, t6), {}, { date: r2 })]) : e5;
      }, []);
    }), ye(we(i2), "calcInitialState", function() {
      var e4, t6 = i2.getPreSelection(), r2 = ft(i2.props), n = yt(i2.props), o = r2 && isBefore(t6, startOfDay(r2)) ? r2 : n && isAfter(t6, endOfDay(n)) ? n : t6;
      return { open: i2.props.startOpen || false, preventFocus: false, preSelection: null !== (e4 = i2.props.selectsRange ? i2.props.startDate : i2.props.selected) && void 0 !== e4 ? e4 : o, highlightDates: vt(i2.props.highlightDates), focused: false, shouldFocusDayInline: false, isRenderAriaLiveMessage: false };
    }), ye(we(i2), "clearPreventFocusTimeout", function() {
      i2.preventFocusTimeout && clearTimeout(i2.preventFocusTimeout);
    }), ye(we(i2), "setFocus", function() {
      i2.input && i2.input.focus && i2.input.focus({ preventScroll: true });
    }), ye(we(i2), "setBlur", function() {
      i2.input && i2.input.blur && i2.input.blur(), i2.cancelFocusInput();
    }), ye(we(i2), "setOpen", function(e4) {
      var t6 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      i2.setState({ open: e4, preSelection: e4 && i2.state.open ? i2.state.preSelection : i2.calcInitialState().preSelection, lastPreSelectChange: rr }, function() {
        e4 || i2.setState(function(e5) {
          return { focused: !!t6 && e5.focused };
        }, function() {
          !t6 && i2.setBlur(), i2.setState({ inputValue: null });
        });
      });
    }), ye(we(i2), "inputOk", function() {
      return isDate(i2.state.preSelection);
    }), ye(we(i2), "isCalendarOpen", function() {
      return void 0 === i2.props.open ? i2.state.open && !i2.props.disabled && !i2.props.readOnly : i2.props.open;
    }), ye(we(i2), "handleFocus", function(e4) {
      i2.state.preventFocus || (i2.props.onFocus(e4), i2.props.preventOpenOnFocus || i2.props.readOnly || i2.setOpen(true)), i2.setState({ focused: true });
    }), ye(we(i2), "sendFocusBackToInput", function() {
      i2.preventFocusTimeout && i2.clearPreventFocusTimeout(), i2.setState({ preventFocus: true }, function() {
        i2.preventFocusTimeout = setTimeout(function() {
          i2.setFocus(), i2.setState({ preventFocus: false });
        });
      });
    }), ye(we(i2), "cancelFocusInput", function() {
      clearTimeout(i2.inputFocusTimeout), i2.inputFocusTimeout = null;
    }), ye(we(i2), "deferFocusInput", function() {
      i2.cancelFocusInput(), i2.inputFocusTimeout = setTimeout(function() {
        return i2.setFocus();
      }, 1);
    }), ye(we(i2), "handleDropdownFocus", function() {
      i2.cancelFocusInput();
    }), ye(we(i2), "handleBlur", function(e4) {
      (!i2.state.open || i2.props.withPortal || i2.props.showTimeInput) && i2.props.onBlur(e4), i2.setState({ focused: false });
    }), ye(we(i2), "handleCalendarClickOutside", function(e4) {
      i2.props.inline || i2.setOpen(false), i2.props.onClickOutside(e4), i2.props.withPortal && e4.preventDefault();
    }), ye(we(i2), "handleChange", function() {
      for (var e4 = arguments.length, t6 = new Array(e4), r2 = 0; r2 < e4; r2++)
        t6[r2] = arguments[r2];
      var n = t6[0];
      if (!i2.props.onChangeRaw || (i2.props.onChangeRaw.apply(we(i2), t6), "function" == typeof n.isDefaultPrevented && !n.isDefaultPrevented())) {
        i2.setState({ inputValue: n.target.value, lastPreSelectChange: tr });
        var o, a4, s4, p, c2, l, d3, u2, h3 = (o = n.target.value, a4 = i2.props.dateFormat, s4 = i2.props.locale, p = i2.props.strictParsing, c2 = i2.props.minDate, l = null, d3 = Ge(s4) || Ge($e()), u2 = true, Array.isArray(a4) ? (a4.forEach(function(e5) {
          var t7 = parse(o, e5, /* @__PURE__ */ new Date(), { locale: d3 });
          p && (u2 = Te(t7, c2) && o === Ie(t7, e5, s4)), Te(t7, c2) && u2 && (l = t7);
        }), l) : (l = parse(o, a4, /* @__PURE__ */ new Date(), { locale: d3 }), p ? u2 = Te(l) && o === Ie(l, a4, s4) : Te(l) || (a4 = a4.match(xe).map(function(e5) {
          var t7 = e5[0];
          return "p" === t7 || "P" === t7 ? d3 ? (0, Ee[t7])(e5, d3.formatLong) : t7 : e5;
        }).join(""), o.length > 0 && (l = parse(o, a4.slice(0, o.length), /* @__PURE__ */ new Date())), Te(l) || (l = new Date(o))), Te(l) && u2 ? l : null));
        i2.props.showTimeSelectOnly && i2.props.selected && h3 && !je(h3, i2.props.selected) && (h3 = set(i2.props.selected, { hours: getHours(h3), minutes: getMinutes(h3), seconds: getSeconds(h3) })), !h3 && n.target.value || (i2.props.showWeekPicker && (h3 = Le(h3, i2.props.locale, i2.props.calendarStartDay)), i2.setSelected(h3, n, true));
      }
    }), ye(we(i2), "handleSelect", function(e4, t6, r2) {
      if (i2.props.shouldCloseOnSelect && !i2.props.showTimeSelect && i2.sendFocusBackToInput(), i2.props.onChangeRaw && i2.props.onChangeRaw(t6), i2.props.showWeekPicker && (e4 = Le(e4, i2.props.locale, i2.props.calendarStartDay)), i2.setSelected(e4, t6, false, r2), i2.props.showDateSelect && i2.setState({ isRenderAriaLiveMessage: true }), !i2.props.shouldCloseOnSelect || i2.props.showTimeSelect)
        i2.setPreSelection(e4);
      else if (!i2.props.inline) {
        i2.props.selectsRange || i2.setOpen(false);
        var n = i2.props, o = n.startDate, a4 = n.endDate;
        !o || a4 || isBefore(e4, o) || i2.setOpen(false);
      }
    }), ye(we(i2), "setSelected", function(e4, t6, r2, n) {
      var o = e4;
      if (i2.props.showYearPicker) {
        if (null !== o && at(getYear(o), i2.props))
          return;
      } else if (i2.props.showMonthYearPicker) {
        if (null !== o && tt(o, i2.props))
          return;
      } else if (null !== o && Ze(o, i2.props))
        return;
      var a4 = i2.props, s4 = a4.onChange, p = a4.selectsRange, c2 = a4.startDate, l = a4.endDate;
      if (!Ve(i2.props.selected, o) || i2.props.allowSameDay || p)
        if (null !== o && (!i2.props.selected || r2 && (i2.props.showTimeSelect || i2.props.showTimeSelectOnly || i2.props.showTimeInput) || (o = Re(o, { hour: getHours(i2.props.selected), minute: getMinutes(i2.props.selected), second: getSeconds(i2.props.selected) })), i2.props.inline || i2.setState({ preSelection: o }), i2.props.focusSelectedMonth || i2.setState({ monthSelectedIn: n })), p) {
          var d3 = c2 && !l, u2 = c2 && l;
          !c2 && !l ? s4([o, null], t6) : d3 && (isBefore(o, c2) ? s4([o, null], t6) : s4([c2, o], t6)), u2 && s4([o, null], t6);
        } else
          s4(o, t6);
      r2 || (i2.props.onSelect(o, t6), i2.setState({ inputValue: null }));
    }), ye(we(i2), "setPreSelection", function(e4) {
      var t6 = void 0 !== i2.props.minDate, r2 = void 0 !== i2.props.maxDate, n = true;
      if (e4) {
        i2.props.showWeekPicker && (e4 = Le(e4, i2.props.locale, i2.props.calendarStartDay));
        var o = startOfDay(e4);
        if (t6 && r2)
          n = qe(e4, i2.props.minDate, i2.props.maxDate);
        else if (t6) {
          var a4 = startOfDay(i2.props.minDate);
          n = isAfter(e4, a4) || Ve(o, a4);
        } else if (r2) {
          var s4 = endOfDay(i2.props.maxDate);
          n = isBefore(e4, s4) || Ve(o, s4);
        }
      }
      n && i2.setState({ preSelection: e4 });
    }), ye(we(i2), "toggleCalendar", function() {
      i2.setOpen(!i2.state.open);
    }), ye(we(i2), "handleTimeChange", function(e4) {
      var t6 = i2.props.selected ? i2.props.selected : i2.getPreSelection(), r2 = i2.props.selected ? e4 : Re(t6, { hour: getHours(e4), minute: getMinutes(e4) });
      i2.setState({ preSelection: r2 }), i2.props.onChange(r2), i2.props.shouldCloseOnSelect && (i2.sendFocusBackToInput(), i2.setOpen(false)), i2.props.showTimeInput && i2.setOpen(true), (i2.props.showTimeSelectOnly || i2.props.showTimeSelect) && i2.setState({ isRenderAriaLiveMessage: true }), i2.setState({ inputValue: null });
    }), ye(we(i2), "onInputClick", function() {
      i2.props.disabled || i2.props.readOnly || i2.setOpen(true), i2.props.onInputClick();
    }), ye(we(i2), "onInputKeyDown", function(e4) {
      i2.props.onKeyDown(e4);
      var t6 = e4.key;
      if (i2.state.open || i2.props.inline || i2.props.preventOpenOnFocus) {
        if (i2.state.open) {
          if ("ArrowDown" === t6 || "ArrowUp" === t6) {
            e4.preventDefault();
            var r2 = i2.props.showWeekPicker && i2.props.showWeekNumbers ? '.react-datepicker__week-number[tabindex="0"]' : '.react-datepicker__day[tabindex="0"]', n = i2.calendar.componentNode && i2.calendar.componentNode.querySelector(r2);
            return void (n && n.focus({ preventScroll: true }));
          }
          var o = Ye(i2.state.preSelection);
          "Enter" === t6 ? (e4.preventDefault(), i2.inputOk() && i2.state.lastPreSelectChange === rr ? (i2.handleSelect(o, e4), !i2.props.shouldCloseOnSelect && i2.setPreSelection(o)) : i2.setOpen(false)) : "Escape" === t6 ? (e4.preventDefault(), i2.sendFocusBackToInput(), i2.setOpen(false)) : "Tab" === t6 && i2.setOpen(false), i2.inputOk() || i2.props.onInputError({ code: 1, msg: Zt });
        }
      } else
        "ArrowDown" !== t6 && "ArrowUp" !== t6 && "Enter" !== t6 || i2.onInputClick();
    }), ye(we(i2), "onPortalKeyDown", function(e4) {
      "Escape" === e4.key && (e4.preventDefault(), i2.setState({ preventFocus: true }, function() {
        i2.setOpen(false), setTimeout(function() {
          i2.setFocus(), i2.setState({ preventFocus: false });
        });
      }));
    }), ye(we(i2), "onDayKeyDown", function(e4) {
      i2.props.onKeyDown(e4);
      var t6 = e4.key, r2 = Ye(i2.state.preSelection);
      if ("Enter" === t6)
        e4.preventDefault(), i2.handleSelect(r2, e4), !i2.props.shouldCloseOnSelect && i2.setPreSelection(r2);
      else if ("Escape" === t6)
        e4.preventDefault(), i2.setOpen(false), i2.inputOk() || i2.props.onInputError({ code: 1, msg: Zt });
      else if (!i2.props.disabledKeyboardNavigation) {
        var n;
        switch (t6) {
          case "ArrowLeft":
            n = i2.props.showWeekPicker ? subWeeks(r2, 1) : subDays(r2, 1);
            break;
          case "ArrowRight":
            n = i2.props.showWeekPicker ? addWeeks(r2, 1) : addDays(r2, 1);
            break;
          case "ArrowUp":
            n = subWeeks(r2, 1);
            break;
          case "ArrowDown":
            n = addWeeks(r2, 1);
            break;
          case "PageUp":
            n = subMonths(r2, 1);
            break;
          case "PageDown":
            n = addMonths(r2, 1);
            break;
          case "Home":
            n = subYears(r2, 1);
            break;
          case "End":
            n = addYears(r2, 1);
            break;
          default:
            n = null;
        }
        if (!n)
          return void (i2.props.onInputError && i2.props.onInputError({ code: 1, msg: Zt }));
        if (e4.preventDefault(), i2.setState({ lastPreSelectChange: rr }), i2.props.adjustDateOnChange && i2.setSelected(n), i2.setPreSelection(n), i2.props.inline) {
          var o = getMonth(r2), a4 = getMonth(n), s4 = getYear(r2), d3 = getYear(n);
          o !== a4 || s4 !== d3 ? i2.setState({ shouldFocusDayInline: true }) : i2.setState({ shouldFocusDayInline: false });
        }
      }
    }), ye(we(i2), "onPopperKeyDown", function(e4) {
      "Escape" === e4.key && (e4.preventDefault(), i2.sendFocusBackToInput());
    }), ye(we(i2), "onClearClick", function(e4) {
      e4 && e4.preventDefault && e4.preventDefault(), i2.sendFocusBackToInput(), i2.props.selectsRange ? i2.props.onChange([null, null], e4) : i2.props.onChange(null, e4), i2.setState({ inputValue: null });
    }), ye(we(i2), "clear", function() {
      i2.onClearClick();
    }), ye(we(i2), "onScroll", function(e4) {
      "boolean" == typeof i2.props.closeOnScroll && i2.props.closeOnScroll ? e4.target !== document && e4.target !== document.documentElement && e4.target !== document.body || i2.setOpen(false) : "function" == typeof i2.props.closeOnScroll && i2.props.closeOnScroll(e4) && i2.setOpen(false);
    }), ye(we(i2), "renderCalendar", function() {
      return i2.props.inline || i2.isCalendarOpen() ? import_react30.default.createElement(Xt, { ref: function(e4) {
        i2.calendar = e4;
      }, locale: i2.props.locale, calendarStartDay: i2.props.calendarStartDay, chooseDayAriaLabelPrefix: i2.props.chooseDayAriaLabelPrefix, disabledDayAriaLabelPrefix: i2.props.disabledDayAriaLabelPrefix, weekAriaLabelPrefix: i2.props.weekAriaLabelPrefix, monthAriaLabelPrefix: i2.props.monthAriaLabelPrefix, adjustDateOnChange: i2.props.adjustDateOnChange, setOpen: i2.setOpen, shouldCloseOnSelect: i2.props.shouldCloseOnSelect, dateFormat: i2.props.dateFormatCalendar, useWeekdaysShort: i2.props.useWeekdaysShort, formatWeekDay: i2.props.formatWeekDay, dropdownMode: i2.props.dropdownMode, selected: i2.props.selected, preSelection: i2.state.preSelection, onSelect: i2.handleSelect, onWeekSelect: i2.props.onWeekSelect, openToDate: i2.props.openToDate, minDate: i2.props.minDate, maxDate: i2.props.maxDate, selectsStart: i2.props.selectsStart, selectsEnd: i2.props.selectsEnd, selectsRange: i2.props.selectsRange, startDate: i2.props.startDate, endDate: i2.props.endDate, excludeDates: i2.props.excludeDates, excludeDateIntervals: i2.props.excludeDateIntervals, filterDate: i2.props.filterDate, onClickOutside: i2.handleCalendarClickOutside, formatWeekNumber: i2.props.formatWeekNumber, highlightDates: i2.state.highlightDates, holidays: Dt(i2.modifyHolidays()), includeDates: i2.props.includeDates, includeDateIntervals: i2.props.includeDateIntervals, includeTimes: i2.props.includeTimes, injectTimes: i2.props.injectTimes, inline: i2.props.inline, shouldFocusDayInline: i2.state.shouldFocusDayInline, peekNextMonth: i2.props.peekNextMonth, showMonthDropdown: i2.props.showMonthDropdown, showPreviousMonths: i2.props.showPreviousMonths, useShortMonthInDropdown: i2.props.useShortMonthInDropdown, showMonthYearDropdown: i2.props.showMonthYearDropdown, showWeekNumbers: i2.props.showWeekNumbers, showYearDropdown: i2.props.showYearDropdown, withPortal: i2.props.withPortal, forceShowMonthNavigation: i2.props.forceShowMonthNavigation, showDisabledMonthNavigation: i2.props.showDisabledMonthNavigation, scrollableYearDropdown: i2.props.scrollableYearDropdown, scrollableMonthYearDropdown: i2.props.scrollableMonthYearDropdown, todayButton: i2.props.todayButton, weekLabel: i2.props.weekLabel, outsideClickIgnoreClass: Jt, fixedHeight: i2.props.fixedHeight, monthsShown: i2.props.monthsShown, monthSelectedIn: i2.state.monthSelectedIn, onDropdownFocus: i2.handleDropdownFocus, onMonthChange: i2.props.onMonthChange, onYearChange: i2.props.onYearChange, dayClassName: i2.props.dayClassName, weekDayClassName: i2.props.weekDayClassName, monthClassName: i2.props.monthClassName, timeClassName: i2.props.timeClassName, showDateSelect: i2.props.showDateSelect, showTimeSelect: i2.props.showTimeSelect, showTimeSelectOnly: i2.props.showTimeSelectOnly, onTimeChange: i2.handleTimeChange, timeFormat: i2.props.timeFormat, timeIntervals: i2.props.timeIntervals, minTime: i2.props.minTime, maxTime: i2.props.maxTime, excludeTimes: i2.props.excludeTimes, filterTime: i2.props.filterTime, timeCaption: i2.props.timeCaption, className: i2.props.calendarClassName, container: i2.props.calendarContainer, yearItemNumber: i2.props.yearItemNumber, yearDropdownItemNumber: i2.props.yearDropdownItemNumber, previousMonthAriaLabel: i2.props.previousMonthAriaLabel, previousMonthButtonLabel: i2.props.previousMonthButtonLabel, nextMonthAriaLabel: i2.props.nextMonthAriaLabel, nextMonthButtonLabel: i2.props.nextMonthButtonLabel, previousYearAriaLabel: i2.props.previousYearAriaLabel, previousYearButtonLabel: i2.props.previousYearButtonLabel, nextYearAriaLabel: i2.props.nextYearAriaLabel, nextYearButtonLabel: i2.props.nextYearButtonLabel, timeInputLabel: i2.props.timeInputLabel, disabledKeyboardNavigation: i2.props.disabledKeyboardNavigation, renderCustomHeader: i2.props.renderCustomHeader, popperProps: i2.props.popperProps, renderDayContents: i2.props.renderDayContents, renderMonthContent: i2.props.renderMonthContent, renderQuarterContent: i2.props.renderQuarterContent, renderYearContent: i2.props.renderYearContent, onDayMouseEnter: i2.props.onDayMouseEnter, onMonthMouseLeave: i2.props.onMonthMouseLeave, onYearMouseEnter: i2.props.onYearMouseEnter, onYearMouseLeave: i2.props.onYearMouseLeave, selectsDisabledDaysInRange: i2.props.selectsDisabledDaysInRange, showTimeInput: i2.props.showTimeInput, showMonthYearPicker: i2.props.showMonthYearPicker, showFullMonthYearPicker: i2.props.showFullMonthYearPicker, showTwoColumnMonthYearPicker: i2.props.showTwoColumnMonthYearPicker, showFourColumnMonthYearPicker: i2.props.showFourColumnMonthYearPicker, showYearPicker: i2.props.showYearPicker, showQuarterYearPicker: i2.props.showQuarterYearPicker, showWeekPicker: i2.props.showWeekPicker, showPopperArrow: i2.props.showPopperArrow, excludeScrollbar: i2.props.excludeScrollbar, handleOnKeyDown: i2.props.onKeyDown, handleOnDayKeyDown: i2.onDayKeyDown, isInputFocused: i2.state.focused, customTimeInput: i2.props.customTimeInput, setPreSelection: i2.setPreSelection }, i2.props.children) : null;
    }), ye(we(i2), "renderAriaLiveRegion", function() {
      var t6, r2 = i2.props, n = r2.dateFormat, o = r2.locale, a4 = i2.props.showTimeInput || i2.props.showTimeSelect ? "PPPPp" : "PPPP";
      return t6 = i2.props.selectsRange ? "Selected start date: ".concat(Oe(i2.props.startDate, { dateFormat: a4, locale: o }), ". ").concat(i2.props.endDate ? "End date: " + Oe(i2.props.endDate, { dateFormat: a4, locale: o }) : "") : i2.props.showTimeSelectOnly ? "Selected time: ".concat(Oe(i2.props.selected, { dateFormat: n, locale: o })) : i2.props.showYearPicker ? "Selected year: ".concat(Oe(i2.props.selected, { dateFormat: "yyyy", locale: o })) : i2.props.showMonthYearPicker ? "Selected month: ".concat(Oe(i2.props.selected, { dateFormat: "MMMM yyyy", locale: o })) : i2.props.showQuarterYearPicker ? "Selected quarter: ".concat(Oe(i2.props.selected, { dateFormat: "yyyy, QQQ", locale: o })) : "Selected date: ".concat(Oe(i2.props.selected, { dateFormat: a4, locale: o })), import_react30.default.createElement("span", { role: "alert", "aria-live": "polite", className: "react-datepicker__aria-live" }, t6);
    }), ye(we(i2), "renderDateInput", function() {
      var t6, n = (0, import_classnames2.default)(i2.props.className, ye({}, Jt, i2.state.open)), o = i2.props.customInput || import_react30.default.createElement("input", { type: "text" }), a4 = i2.props.customInputRef || "ref", s4 = "string" == typeof i2.props.value ? i2.props.value : "string" == typeof i2.state.inputValue ? i2.state.inputValue : i2.props.selectsRange ? function(e4, t7, r2) {
        if (!e4)
          return "";
        var n2 = Oe(e4, r2), o2 = t7 ? Oe(t7, r2) : "";
        return "".concat(n2, " - ").concat(o2);
      }(i2.props.startDate, i2.props.endDate, i2.props) : Oe(i2.props.selected, i2.props);
      return import_react30.default.cloneElement(o, (ye(ye(ye(ye(ye(ye(ye(ye(ye(ye(t6 = {}, a4, function(e4) {
        i2.input = e4;
      }), "value", s4), "onBlur", i2.handleBlur), "onChange", i2.handleChange), "onClick", i2.onInputClick), "onFocus", i2.handleFocus), "onKeyDown", i2.onInputKeyDown), "id", i2.props.id), "name", i2.props.name), "form", i2.props.form), ye(ye(ye(ye(ye(ye(ye(ye(ye(ye(t6, "autoFocus", i2.props.autoFocus), "placeholder", i2.props.placeholderText), "disabled", i2.props.disabled), "autoComplete", i2.props.autoComplete), "className", (0, import_classnames2.default)(o.props.className, n)), "title", i2.props.title), "readOnly", i2.props.readOnly), "required", i2.props.required), "tabIndex", i2.props.tabIndex), "aria-describedby", i2.props.ariaDescribedBy), ye(ye(ye(t6, "aria-invalid", i2.props.ariaInvalid), "aria-labelledby", i2.props.ariaLabelledBy), "aria-required", i2.props.ariaRequired)));
    }), ye(we(i2), "renderClearButton", function() {
      var t6 = i2.props, n = t6.isClearable, o = t6.disabled, a4 = t6.selected, s4 = t6.startDate, p = t6.endDate, c2 = t6.clearButtonTitle, l = t6.clearButtonClassName, d3 = void 0 === l ? "" : l, u2 = t6.ariaLabelClose, h3 = void 0 === u2 ? "Close" : u2;
      return !n || null == a4 && null == s4 && null == p ? null : import_react30.default.createElement("button", { type: "button", className: (0, import_classnames2.default)("react-datepicker__close-icon", d3, { "react-datepicker__close-icon--disabled": o }), disabled: o, "aria-label": h3, onClick: i2.onClearClick, title: c2, tabIndex: -1 });
    }), i2.state = i2.calcInitialState(), i2.preventFocusTimeout = null, i2;
  }
  return fe(s3, [{ key: "componentDidMount", value: function() {
    window.addEventListener("scroll", this.onScroll, true);
  } }, { key: "componentDidUpdate", value: function(e4, t5) {
    var r2, n;
    e4.inline && (r2 = e4.selected, n = this.props.selected, r2 && n ? getMonth(r2) !== getMonth(n) || getYear(r2) !== getYear(n) : r2 !== n) && this.setPreSelection(this.props.selected), void 0 !== this.state.monthSelectedIn && e4.monthsShown !== this.props.monthsShown && this.setState({ monthSelectedIn: 0 }), e4.highlightDates !== this.props.highlightDates && this.setState({ highlightDates: vt(this.props.highlightDates) }), t5.focused || Ve(e4.selected, this.props.selected) || this.setState({ inputValue: null }), t5.open !== this.state.open && (false === t5.open && true === this.state.open && this.props.onCalendarOpen(), true === t5.open && false === this.state.open && this.props.onCalendarClose());
  } }, { key: "componentWillUnmount", value: function() {
    this.clearPreventFocusTimeout(), window.removeEventListener("scroll", this.onScroll, true);
  } }, { key: "renderInputContainer", value: function() {
    var t5 = this.props, r2 = t5.showIcon, n = t5.icon, o = t5.calendarIconClassname, a4 = t5.toggleCalendarOnIconClick, s4 = this.state.open;
    return import_react30.default.createElement("div", { className: "react-datepicker__input-container".concat(r2 ? " react-datepicker__view-calendar-icon" : "") }, r2 && import_react30.default.createElement(qt, ve({ icon: n, className: "".concat(o, " ").concat(s4 && "react-datepicker-ignore-onclickoutside") }, a4 ? { onClick: this.toggleCalendar } : null)), this.state.isRenderAriaLiveMessage && this.renderAriaLiveRegion(), this.renderDateInput(), this.renderClearButton());
  } }, { key: "render", value: function() {
    var t5 = this.renderCalendar();
    if (this.props.inline)
      return t5;
    if (this.props.withPortal) {
      var r2 = this.state.open ? import_react30.default.createElement($t, { enableTabLoop: this.props.enableTabLoop }, import_react30.default.createElement("div", { className: "react-datepicker__portal", tabIndex: -1, onKeyDown: this.onPortalKeyDown }, t5)) : null;
      return this.state.open && this.props.portalId && (r2 = import_react30.default.createElement(Ut, { portalId: this.props.portalId, portalHost: this.props.portalHost }, r2)), import_react30.default.createElement("div", null, this.renderInputContainer(), r2);
    }
    return import_react30.default.createElement(Gt, { className: this.props.popperClassName, wrapperClassName: this.props.wrapperClassName, hidePopper: !this.isCalendarOpen(), portalId: this.props.portalId, portalHost: this.props.portalHost, popperModifiers: this.props.popperModifiers, targetComponent: this.renderInputContainer(), popperContainer: this.props.popperContainer, popperComponent: t5, popperPlacement: this.props.popperPlacement, popperProps: this.props.popperProps, popperOnKeyDown: this.onPopperKeyDown, enableTabLoop: this.props.enableTabLoop });
  } }], [{ key: "defaultProps", get: function() {
    return { allowSameDay: false, dateFormat: "MM/dd/yyyy", dateFormatCalendar: "LLLL yyyy", onChange: function() {
    }, disabled: false, disabledKeyboardNavigation: false, dropdownMode: "scroll", onFocus: function() {
    }, onBlur: function() {
    }, onKeyDown: function() {
    }, onInputClick: function() {
    }, onSelect: function() {
    }, onClickOutside: function() {
    }, onMonthChange: function() {
    }, onCalendarOpen: function() {
    }, onCalendarClose: function() {
    }, preventOpenOnFocus: false, onYearChange: function() {
    }, onInputError: function() {
    }, monthsShown: 1, readOnly: false, withPortal: false, selectsDisabledDaysInRange: false, shouldCloseOnSelect: true, showTimeSelect: false, showTimeInput: false, showPreviousMonths: false, showMonthYearPicker: false, showFullMonthYearPicker: false, showTwoColumnMonthYearPicker: false, showFourColumnMonthYearPicker: false, showYearPicker: false, showQuarterYearPicker: false, showWeekPicker: false, strictParsing: false, timeIntervals: 30, timeCaption: "Time", previousMonthAriaLabel: "Previous Month", previousMonthButtonLabel: "Previous Month", nextMonthAriaLabel: "Next Month", nextMonthButtonLabel: "Next Month", previousYearAriaLabel: "Previous Year", previousYearButtonLabel: "Previous Year", nextYearAriaLabel: "Next Year", nextYearButtonLabel: "Next Year", timeInputLabel: "Time", enableTabLoop: true, yearItemNumber: Ne, focusSelectedMonth: false, showPopperArrow: true, excludeScrollbar: true, customTimeInput: null, calendarStartDay: void 0, toggleCalendarOnIconClick: false };
  } }]), s3;
}();
var tr = "input";
var rr = "navigate";

// node_modules/@neo4j-ndl/react/lib/esm/text-input/TextInput.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
var import_react31 = __toESM(require_react());
var __rest17 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var TextInput = (0, import_react31.forwardRef)(function TextInput2(props, ref) {
  const { label, fluid, errorText, helpText, leftIcon, rightIcon, isOptional = false, informationIconText, type = "text", size: size3 = "medium", "aria-label": ariaLabel, tooltipProps } = props, customProps = __rest17(props, ["label", "fluid", "errorText", "helpText", "leftIcon", "rightIcon", "isOptional", "informationIconText", "type", "size", "aria-label", "tooltipProps"]);
  const containerWrappingClasses = classNames(`ndl-form-item ndl-type-text`, customProps.className, {
    "ndl-disabled": customProps.disabled,
    "ndl-small": size3 === "small",
    "ndl-medium": size3 === "medium",
    "ndl-large": size3 === "large",
    "ndl-has-error": errorText,
    "ndl-has-left-icon": leftIcon,
    "ndl-has-right-icon": rightIcon || errorText,
    "ndl-has-icon": leftIcon || rightIcon || errorText
  });
  const hasEmptyLabelValue = !label || label === "";
  const labelWrappingClasses = classNames("ndl-form-item-label", {
    "ndl-fluid": fluid,
    "ndl-form-item-no-label": hasEmptyLabelValue
  });
  const isCustomLabel = label && typeof label !== "string";
  const hasCustomLabelAndNoAriaLabel = isCustomLabel && !ariaLabel;
  (0, import_react31.useMemo)(() => {
    if (!label && !ariaLabel) {
      needleWarningMessage("A TextInput without a label does not have an aria label, be sure to include an aria label for screen readers link: https://dequeuniversity.com/rules/axe/4.2/label?application=axeAPI");
    }
    if (hasCustomLabelAndNoAriaLabel) {
      needleWarningMessage(customLabelAndNoAriaLabelWarningMessage2);
    }
  }, [label, ariaLabel, hasCustomLabelAndNoAriaLabel]);
  const customPropsClassNameStripped = Object.assign(Object.assign({}, customProps), { className: void 0 });
  const informationIconClasses = classNames({
    "ndl-information-icon-small": size3 === "small" || size3 === "medium",
    "ndl-information-icon-large": size3 === "large"
  });
  return (0, import_jsx_runtime20.jsxs)("div", { className: containerWrappingClasses, children: [(0, import_jsx_runtime20.jsxs)("label", { className: labelWrappingClasses, children: [(0, import_jsx_runtime20.jsxs)("div", { className: "ndl-input-wrapper", children: [leftIcon && (0, import_jsx_runtime20.jsx)("div", { className: "ndl-icon ndl-left-icon", children: leftIcon }), (0, import_jsx_runtime20.jsx)("input", Object.assign({}, customPropsClassNameStripped, { type, ref, "aria-label": ariaLabel })), rightIcon && (0, import_jsx_runtime20.jsx)("div", { className: "ndl-icon ndl-right-icon", children: rightIcon })] }), !hasEmptyLabelValue && (0, import_jsx_runtime20.jsxs)("div", { className: "ndl-form-item-wrapper", children: [(0, import_jsx_runtime20.jsx)("span", { className: "ndl-form-label-text", children: label }), informationIconText && (0, import_jsx_runtime20.jsxs)(Tip, Object.assign({}, tooltipProps === null || tooltipProps === void 0 ? void 0 : tooltipProps.tooltipRoot, { children: [(0, import_jsx_runtime20.jsx)(Tip.Trigger, Object.assign({}, tooltipProps === null || tooltipProps === void 0 ? void 0 : tooltipProps.tooltipTrigger, { children: (0, import_jsx_runtime20.jsx)("div", { className: informationIconClasses, "data-testid": "ndl-information-icon", children: (0, import_jsx_runtime20.jsx)(import_InformationCircleIcon.default, {}) }) })), (0, import_jsx_runtime20.jsx)(Tip.Content, Object.assign({}, tooltipProps === null || tooltipProps === void 0 ? void 0 : tooltipProps.tooltipContent, { children: informationIconText }))] })), isOptional && (0, import_jsx_runtime20.jsx)("span", { className: "ndl-form-item-optional", children: "Optional" })] })] }), helpText && !errorText && (0, import_jsx_runtime20.jsx)("div", { className: "ndl-form-msg", children: helpText }), errorText && (0, import_jsx_runtime20.jsxs)("div", { className: "ndl-form-msg", children: [(0, import_jsx_runtime20.jsx)("div", { className: "ndl-error-icon", children: (0, import_jsx_runtime20.jsx)(import_ExclamationCircleIcon2.default, {}) }), (0, import_jsx_runtime20.jsx)("div", { className: "ndl-error-text", children: errorText })] })] });
});
var TextInput_default = TextInput;

// node_modules/date-fns/esm/formatDistanceStrict/index.js
var MILLISECONDS_IN_MINUTE2 = 1e3 * 60;
var MINUTES_IN_DAY = 60 * 24;
var MINUTES_IN_MONTH = MINUTES_IN_DAY * 30;
var MINUTES_IN_YEAR = MINUTES_IN_DAY * 365;

// node_modules/date-fns/esm/getOverlappingDaysInIntervals/index.js
var MILLISECONDS_IN_DAY3 = 24 * 60 * 60 * 1e3;

// node_modules/@neo4j-ndl/react/lib/esm/date-picker/DatePicker.js
var DatePicker = forwardRef(function DatePicker2(props, ref) {
  const { reactDatePickerProps, textInputProps, disabled, className } = props;
  const classes = classNames(`ndl-datepicker`, className, {});
  const datetimeRef = (0, import_react32.useRef)(null);
  const [picker, setPicker] = (0, import_react32.useState)("day");
  const headerAction = (0, import_react32.useCallback)((action) => {
    picker === action ? setPicker("day") : setPicker(action);
  }, [picker]);
  const CustomHeader = (0, import_react32.useCallback)((props2) => {
    const { decreaseMonth, increaseMonth, increaseYear, decreaseYear, nextMonthButtonDisabled, nextYearButtonDisabled, prevMonthButtonDisabled, prevYearButtonDisabled } = props2;
    const prevCallback = picker === "year" ? decreaseYear : decreaseMonth;
    const nextCallback = picker === "year" ? increaseYear : increaseMonth;
    const prevDisabled = picker === "year" ? prevYearButtonDisabled : prevMonthButtonDisabled;
    const nextDisabled = picker === "year" ? nextYearButtonDisabled : nextMonthButtonDisabled;
    return (0, import_jsx_runtime21.jsxs)("div", { className: "ndl-datepicker-header", children: [(0, import_jsx_runtime21.jsxs)("div", { className: "ndl-datepicker-selects", children: [(0, import_jsx_runtime21.jsx)("button", { className: "ndl-datepicker-header", onClick: () => headerAction("month"), children: (0, import_jsx_runtime21.jsxs)("div", { className: "n-flex n-items-center", children: [(0, import_jsx_runtime21.jsx)(Typography, { variant: "label", className: "n-p-2", children: format(props2.date, "MMMM") }), (0, import_jsx_runtime21.jsx)(import_ChevronDownIcon.default, { className: classNames("ndl-datepicker-chevron", {
      "n-rotate-180": picker === "month"
    }), "aria-label": "Chevron icon" })] }) }), (0, import_jsx_runtime21.jsx)("button", { className: "ndl-datepicker-header", onClick: () => headerAction("year"), children: (0, import_jsx_runtime21.jsxs)("div", { className: "n-flex n-items-center", children: [(0, import_jsx_runtime21.jsx)(Typography, { variant: "label", className: "n-p-2", children: format(props2.date, "yyyy") }), (0, import_jsx_runtime21.jsx)(import_ChevronDownIcon.default, { className: classNames("ndl-datepicker-chevron", {
      "n-rotate-180": picker === "year"
    }), "aria-label": "Chevron icon" })] }) })] }), picker !== "month" && (0, import_jsx_runtime21.jsxs)("div", { children: [(0, import_jsx_runtime21.jsx)(IconButton, { "aria-label": "Previous period", clean: true, onClick: prevCallback, disabled: prevDisabled, children: (0, import_jsx_runtime21.jsx)(import_ArrowLeftIcon.default, {}) }), (0, import_jsx_runtime21.jsx)(IconButton, { "aria-label": "Next period", clean: true, onClick: nextCallback, disabled: nextDisabled, children: (0, import_jsx_runtime21.jsx)(import_ArrowRightIcon.default, {}) })] })] });
  }, [picker, headerAction]);
  const interceptedChange = (0, import_react32.useCallback)((...args) => {
    if (picker !== "day") {
      reactDatePickerProps === null || reactDatePickerProps === void 0 ? void 0 : reactDatePickerProps.onChange(...args);
      setPicker("day");
    } else {
      reactDatePickerProps === null || reactDatePickerProps === void 0 ? void 0 : reactDatePickerProps.onChange(...args);
    }
  }, [picker, reactDatePickerProps]);
  const interceptedOnCalendarClose = (0, import_react32.useCallback)(() => {
    var _a2;
    if (picker !== "day") {
      setPicker("day");
    }
    (_a2 = reactDatePickerProps === null || reactDatePickerProps === void 0 ? void 0 : reactDatePickerProps.onCalendarClose) === null || _a2 === void 0 ? void 0 : _a2.call(reactDatePickerProps);
  }, [picker, reactDatePickerProps]);
  return (0, import_jsx_runtime21.jsx)("div", { className: classes, children: (0, import_jsx_runtime21.jsx)(er, Object.assign({ ref: datetimeRef, customInput: (0, import_jsx_runtime21.jsx)(TextInput_default, Object.assign({ ref, "aria-label": "Date picker input", rightIcon: (0, import_jsx_runtime21.jsx)(import_CalendarIcon.default, { onClick: (e4) => {
    var _a2;
    if ((_a2 = datetimeRef.current) === null || _a2 === void 0 ? void 0 : _a2.isCalendarOpen()) {
      datetimeRef.current.setOpen(false);
      e4.preventDefault();
      e4.stopPropagation();
    }
  }, "aria-label": "Calender Icon" }) }, textInputProps, { disabled })), disabled, showMonthYearPicker: picker === "month", showYearPicker: picker === "year", shouldCloseOnSelect: picker === "day", dayClassName: () => "ndl-datepicker-day", renderCustomHeader: CustomHeader }, reactDatePickerProps, { onChange: interceptedChange, onCalendarClose: interceptedOnCalendarClose })) });
});

// node_modules/@neo4j-ndl/react/lib/esm/dialog/Dialog.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
var import_react34 = __toESM(require_react());

// node_modules/@neo4j-ndl/react/lib/esm/modal/Modal.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
var import_react33 = __toESM(require_react());
var ModalCloseReason;
(function(ModalCloseReason2) {
  ModalCloseReason2["BACKDROP_CLICK"] = "backdropClick";
  ModalCloseReason2["ESCAPE_KEY_DOWN"] = "escapeKeyDown";
})(ModalCloseReason || (ModalCloseReason = {}));
var Modal = (0, import_react33.forwardRef)(function Modal2({ open, size: size3 = "medium", onClose, children, container, rootProps, modalProps }, ref) {
  const toggleScrollbar = useDocumentScrollToggle();
  const backdropClick = import_react33.default.useRef(null);
  const handleMouseDown = (event) => {
    backdropClick.current = event.target === event.currentTarget;
  };
  const handleKeyDown = (e4) => {
    if (e4.key === "Escape") {
      e4.preventDefault();
      onClose && onClose(e4, ModalCloseReason.ESCAPE_KEY_DOWN);
    }
  };
  const handleBackdropClick = (e4) => {
    if (!backdropClick.current) {
      return;
    }
    backdropClick.current = null;
    onClose && onClose(e4, ModalCloseReason.BACKDROP_CLICK);
  };
  (0, import_react33.useEffect)(() => {
    toggleScrollbar(open);
    return () => toggleScrollbar(false);
  }, [open, toggleScrollbar]);
  if (!open) {
    return null;
  }
  const classes = classNames("ndl-modal", modalProps === null || modalProps === void 0 ? void 0 : modalProps.className, {
    "ndl-small": size3 === "small",
    "ndl-medium": size3 === "medium",
    "ndl-large": size3 === "large"
  });
  const rootClasses = classNames("ndl-modal-root", rootProps === null || rootProps === void 0 ? void 0 : rootProps.className, {
    "ndl-modal-container": container
  });
  return (0, import_jsx_runtime22.jsx)(Portal, { container, children: (0, import_jsx_runtime22.jsx)(es2015_default, { hasPositiveIndices: true, returnFocus: true, children: (0, import_jsx_runtime22.jsx)("div", { className: rootClasses, onKeyDown: handleKeyDown, onClick: handleBackdropClick, "data-testid": "ndl-modal-backdrop", role: "presentation", children: (0, import_jsx_runtime22.jsx)("div", Object.assign({ className: "ndl-modal-wrapper", "data-testid": "ndl-modal-wrapper" }, rootProps, { onMouseDown: handleMouseDown, role: "presentation", children: (0, import_jsx_runtime22.jsx)("div", Object.assign({}, modalProps, { role: "dialog", "aria-modal": "true", className: classes, ref, children })) })) }) }) });
});

// node_modules/@neo4j-ndl/react/lib/esm/dialog/Dialog.js
var __rest18 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var DialogCloseReason;
(function(DialogCloseReason2) {
  DialogCloseReason2["BACKDROP_CLICK"] = "backdropClick";
  DialogCloseReason2["ESCAPE_KEY_DOWN"] = "escapeKeyDown";
  DialogCloseReason2["CLOSE_BUTTON_CLICK"] = "closeButtonClick";
})(DialogCloseReason || (DialogCloseReason = {}));
var DialogContext = import_react34.default.createContext(null);
var useDialogContext = () => {
  const value = (0, import_react34.useContext)(DialogContext);
  if (!value) {
    throw new Error("Accessing `useDialogContext` outside of the context provider");
  }
  return value;
};
var convertCloseReason = (reason) => {
  const dialogReason = reason;
  if (Object.values(DialogCloseReason).includes(dialogReason)) {
    return dialogReason;
  }
  throw new Error(`Unknown reason '${reason}' received from popup`);
};
var typeIcons = {
  warning: (0, import_jsx_runtime23.jsx)(import_ExclamationTriangleIcon.default, { strokeWidth: "0.8" }),
  danger: (0, import_jsx_runtime23.jsx)(import_ExclamationCircleIcon.default, { strokeWidth: "0.8" }),
  info: (0, import_jsx_runtime23.jsx)(import_InformationCircleIcon.default, { strokeWidth: "0.8" }),
  success: (0, import_jsx_runtime23.jsx)(import_CheckCircleIcon.default, { strokeWidth: "0.8" })
};
var Dialog = (_a2) => {
  var _b;
  var { open, onClose, children, type, size: size3, disableCloseButton = false } = _a2, restProps = __rest18(_a2, ["open", "onClose", "children", "type", "size", "disableCloseButton"]);
  const handleCloseClick = (e4) => {
    e4.preventDefault();
    onClose && onClose(e4, DialogCloseReason.CLOSE_BUTTON_CLICK);
  };
  const handleClose2 = (e4, reason) => {
    onClose && onClose(e4, reason ? convertCloseReason(reason) : void 0);
  };
  if (!open) {
    return null;
  }
  const classes = classNames("ndl-dialog", (_b = restProps.modalProps) === null || _b === void 0 ? void 0 : _b.className, {
    "ndl-with-icon": !!type,
    "ndl-with-close-button": !disableCloseButton
  });
  const contentWrapperClasses = classNames("n-flex n-flex-nowrap", {
    "n-mt-10": !!type
  });
  return (0, import_jsx_runtime23.jsx)(Modal, Object.assign({}, restProps, { open, onClose: handleClose2, modalProps: Object.assign(Object.assign({}, (restProps === null || restProps === void 0 ? void 0 : restProps.modalProps) || {}), { className: classes, role: "dialog" }), size: size3, children: (0, import_jsx_runtime23.jsxs)(DialogContext.Provider, { value: { type }, children: [!disableCloseButton && (0, import_jsx_runtime23.jsx)(IconButton, { clean: true, size: "large", className: "ndl-dialog-close", onClick: handleCloseClick, role: "button", "data-testid": "ndl-dialog-close", "aria-label": "close", children: (0, import_jsx_runtime23.jsx)(import_XMarkIcon.default, {}) }), (0, import_jsx_runtime23.jsxs)("div", { className: contentWrapperClasses, children: [type && (0, import_jsx_runtime23.jsx)("div", { className: `ndl-dialog-type-icon ndl-${type}`, "data-testid": "ndl-dialog-type-icon", children: typeIcons[type] }), (0, import_jsx_runtime23.jsx)("div", { className: "n-flex n-flex-col n-flex-1 n-w-full", children })] })] }) }));
};
var Actions3 = (_a2) => {
  var { children, className = "" } = _a2, rest = __rest18(_a2, ["children", "className"]);
  const { type } = useDialogContext();
  const classes = classNames("ndl-dialog-actions", className);
  let childrenToRender = children;
  if (type === "danger") {
    childrenToRender = import_react34.default.Children.map(children, (element) => {
      if (!import_react34.default.isValidElement(element))
        return;
      const { color } = element.props;
      if (!color || color === "primary") {
        return import_react34.default.cloneElement(element, Object.assign(Object.assign({}, element.props), { color: "danger" }));
      }
      return element;
    });
  }
  return (0, import_jsx_runtime23.jsx)("div", Object.assign({}, rest, { className: classes, children: childrenToRender }));
};
Dialog.Actions = Actions3;
var Header2 = (_a2) => {
  var { children, className = "" } = _a2, rest = __rest18(_a2, ["children", "className"]);
  const classes = classNames("ndl-dialog-header", className);
  return (0, import_jsx_runtime23.jsx)("h4", Object.assign({}, rest, { className: classes, children }));
};
Dialog.Header = Header2;
var Subtitle = (_a2) => {
  var { children, className } = _a2, rest = __rest18(_a2, ["children", "className"]);
  const classes = classNames("ndl-dialog-subtitle n-body-large", className);
  return (0, import_jsx_runtime23.jsx)("div", Object.assign({}, rest, { className: classes, children }));
};
Dialog.Subtitle = Subtitle;
var Description = (_a2) => {
  var { children, className = "" } = _a2, rest = __rest18(_a2, ["children", "className"]);
  const classes = classNames("ndl-dialog-description n-body-medium", className);
  return (0, import_jsx_runtime23.jsx)("div", Object.assign({}, rest, { className: classes, children }));
};
Dialog.Description = Description;
var Content4 = (_a2) => {
  var { children, className = "" } = _a2, rest = __rest18(_a2, ["children", "className"]);
  const classes = classNames("ndl-dialog-content", className);
  return (0, import_jsx_runtime23.jsx)("div", Object.assign({}, rest, { className: classes, children }));
};
Dialog.Content = Content4;

// node_modules/@neo4j-ndl/react/lib/esm/tabs/Tabs.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime());
var import_react35 = __toESM(require_react());
var __rest19 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var TabsContext = import_react35.default.createContext(null);
var useTabsContext = () => {
  const context = (0, import_react35.useContext)(TabsContext);
  if (context === null) {
    throw new Error("Tab used without context");
  }
  return context;
};
var getTabPanelId = (tabId) => `tabpanel-${tabId}`;
var getGeneralTabClasses = (size3, fill) => {
  return {
    "ndl-large": size3 === "large",
    "ndl-small": size3 === "small",
    "ndl-filled-tab": fill === "filled",
    "ndl-underline-tab": fill === "underline"
  };
};
var TabsComponent = forwardRef(function TabsComponent2(_a2, ref) {
  var { children, size: size3 = "large", fill = "underline", onChange: onChange2, value, className, as = "div" } = _a2, restProps = __rest19(_a2, ["children", "size", "fill", "onChange", "value", "className", "as"]);
  const classes = classNames("ndl-tabs", getGeneralTabClasses(size3, fill), className);
  const Component4 = as;
  return (0, import_jsx_runtime24.jsx)(Component4, Object.assign({ className: classes, role: "tablist" }, restProps, { ref, children: (0, import_jsx_runtime24.jsx)(TabsContext.Provider, { value: { value, size: size3, fill, onChange: onChange2 }, children }) }));
});
TabsComponent.displayName = "Tabs";
var TabsTab = forwardRef(function TabsTab2(_a2, ref) {
  var { children, tabId, disabled = false, className, as = "button" } = _a2, restProps = __rest19(_a2, ["children", "tabId", "disabled", "className", "as"]);
  const { size: size3, fill, value, onChange: onChange2 } = useTabsContext();
  const baseClasses = classNames(Object.assign(Object.assign({}, getGeneralTabClasses(size3, fill)), { "ndl-selected": value === tabId, "ndl-disabled": disabled }));
  const Component4 = as;
  const castOnChange = onChange2;
  const handleChange = () => !disabled && castOnChange(tabId);
  const classes = classNames("ndl-tab", baseClasses, className);
  return (0, import_jsx_runtime24.jsxs)(Component4, Object.assign({ className: classes, onClick: handleChange, role: "tab", "aria-controls": value === tabId ? getTabPanelId(tabId) : void 0 }, restProps, { ref, children: [children, fill === "underline" && (0, import_jsx_runtime24.jsx)("span", { className: "ndl-tab-underline" })] }));
});
TabsTab.displayName = "Tabs.Tab";
var TabsTabPanel = import_react35.default.forwardRef(function TabsTabPanel2(_a2, ref) {
  var { as = "div", children, value, tabId } = _a2, restProps = __rest19(_a2, ["as", "children", "value", "tabId"]);
  const Component4 = as;
  return (0, import_jsx_runtime24.jsx)(import_jsx_runtime24.Fragment, { children: value === tabId && (0, import_jsx_runtime24.jsx)(Component4, Object.assign({ role: "tabpanel", id: getTabPanelId(tabId) }, restProps, { ref, children })) });
});
TabsTabPanel.displayName = "Tabs.TabPanel";
var Tabs = Object.assign(TabsComponent, {
  Tab: TabsTab,
  TabPanel: TabsTabPanel
});

// node_modules/@neo4j-ndl/react/lib/esm/segmented-control/SegmentedControl.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime());
var import_react36 = __toESM(require_react());
var __rest20 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var SegmentedControlContext = import_react36.default.createContext(null);
var useSelectorContext = () => {
  const context = (0, import_react36.useContext)(SegmentedControlContext);
  if (context === null) {
    throw new Error("SegmentedControl used without context");
  }
  return context;
};
var SegmentedControlComponent = forwardRef(function SegmentedControlComponent2(_a2, ref) {
  var { size: size3 = "large", hasOnlyIcons = false, children, selected, onChange: onChange2, as = "div", className } = _a2, restProps = __rest20(_a2, ["size", "hasOnlyIcons", "children", "selected", "onChange", "as", "className"]);
  const classes = classNames("ndl-segmented-control", className, {
    "ndl-small": size3 === "small",
    "ndl-large": size3 === "large"
  });
  const Component4 = as;
  return (0, import_jsx_runtime25.jsx)(Component4, Object.assign({}, restProps, { className: classes, role: "group", ref, children: (0, import_jsx_runtime25.jsx)(SegmentedControlContext.Provider, { value: { onChange: onChange2, selected, hasOnlyIcons }, children }) }));
});
SegmentedControlComponent.displayName = "SegmentedControl";
var SegmentedControlItem = import_react36.default.forwardRef(function SegmentedControlItem2(_a2, ref) {
  var { children, value, as = "button", className } = _a2, restProps = __rest20(_a2, ["children", "value", "as", "className"]);
  const { onChange: onChange2, selected, hasOnlyIcons } = useSelectorContext();
  const isSelected = value && value === selected;
  const baseClasses = classNames(className, {
    "ndl-segment-item": !hasOnlyIcons,
    "ndl-segment-icon": hasOnlyIcons,
    "ndl-current": value && value === selected
  });
  const Component4 = as;
  return (0, import_jsx_runtime25.jsx)(Component4, Object.assign({}, restProps, { onClick: () => !isSelected && onChange2(value), className: baseClasses, ref, children }));
});
SegmentedControlItem.displayName = "SegmentedControl.Item";
var SegmentedControl = Object.assign(SegmentedControlComponent, {
  Item: SegmentedControlItem
});

// node_modules/@neo4j-ndl/react/lib/esm/progress-bar/ProgressBar.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime());
var import_react37 = __toESM(require_react());
var __rest21 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var ProgressBar = import_react37.default.forwardRef(function ProgressBar2(_a2, ref) {
  var { heading: heading2, value, size: size3 = "small", className } = _a2, restProps = __rest21(_a2, ["heading", "value", "size", "className"]);
  const classes = classNames("ndl-progress-bar-wrapper", className, {
    "ndl-small": size3 === "small",
    "ndl-large": size3 === "large"
  });
  return (0, import_jsx_runtime26.jsxs)("div", Object.assign({}, restProps, { className: classes, ref, children: [heading2 && (0, import_jsx_runtime26.jsxs)("div", { className: "ndl-header", children: [(0, import_jsx_runtime26.jsx)("span", { className: "ndl-heading", children: heading2 }), (0, import_jsx_runtime26.jsx)("span", { className: "ndl-progress-number", children: value + "%" })] }), (0, import_jsx_runtime26.jsx)("div", { className: "ndl-progress-bar-container", role: "progressbar", title: "progress bar", "aria-valuemin": 0, "aria-valuemax": 100, "aria-valuenow": value, children: (0, import_jsx_runtime26.jsx)("div", { className: "ndl-progress-bar", style: { width: value + "%" } }) })] }));
});
var ProgressBar_default = ProgressBar;

// node_modules/@neo4j-ndl/react/lib/esm/table/Table.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime());
var import_react41 = __toESM(require_react());

// node_modules/@neo4j-ndl/react/lib/esm/table/TableContext.js
var import_react38 = __toESM(require_react());
var TableContext = (0, import_react38.createContext)(null);
function useTableContext() {
  const context = (0, import_react38.useContext)(TableContext);
  if (!context) {
    throw new Error("useTableContext be used under Table component provider");
  }
  return context;
}

// node_modules/@neo4j-ndl/react/lib/esm/table/Components.js
var import_react39 = __toESM(require_react());
var import_jsx_runtime27 = __toESM(require_jsx_runtime());
var import_react40 = __toESM(require_react());

// node_modules/@tanstack/react-table/build/lib/index.mjs
var React38 = __toESM(require_react(), 1);

// node_modules/@tanstack/table-core/build/lib/index.mjs
var defaultColumnSizing = {
  size: 150,
  minSize: 20,
  maxSize: Number.MAX_SAFE_INTEGER
};
var includesString = (row, columnId, filterValue) => {
  var _row$getValue;
  const search3 = filterValue.toLowerCase();
  return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search3));
};
includesString.autoRemove = (val) => testFalsey(val);
var includesStringSensitive = (row, columnId, filterValue) => {
  var _row$getValue2;
  return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));
};
includesStringSensitive.autoRemove = (val) => testFalsey(val);
var equalsString = (row, columnId, filterValue) => {
  var _row$getValue3;
  return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());
};
equalsString.autoRemove = (val) => testFalsey(val);
var arrIncludes = (row, columnId, filterValue) => {
  var _row$getValue4;
  return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);
};
arrIncludes.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
var arrIncludesAll = (row, columnId, filterValue) => {
  return !filterValue.some((val) => {
    var _row$getValue5;
    return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));
  });
};
arrIncludesAll.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
var arrIncludesSome = (row, columnId, filterValue) => {
  return filterValue.some((val) => {
    var _row$getValue6;
    return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);
  });
};
arrIncludesSome.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
var equals = (row, columnId, filterValue) => {
  return row.getValue(columnId) === filterValue;
};
equals.autoRemove = (val) => testFalsey(val);
var weakEquals = (row, columnId, filterValue) => {
  return row.getValue(columnId) == filterValue;
};
weakEquals.autoRemove = (val) => testFalsey(val);
var inNumberRange = (row, columnId, filterValue) => {
  let [min4, max4] = filterValue;
  const rowValue = row.getValue(columnId);
  return rowValue >= min4 && rowValue <= max4;
};
inNumberRange.resolveFilterValue = (val) => {
  let [unsafeMin, unsafeMax] = val;
  let parsedMin = typeof unsafeMin !== "number" ? parseFloat(unsafeMin) : unsafeMin;
  let parsedMax = typeof unsafeMax !== "number" ? parseFloat(unsafeMax) : unsafeMax;
  let min4 = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;
  let max4 = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;
  if (min4 > max4) {
    const temp = min4;
    min4 = max4;
    max4 = temp;
  }
  return [min4, max4];
};
inNumberRange.autoRemove = (val) => testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);
function testFalsey(val) {
  return val === void 0 || val === null || val === "";
}

// node_modules/@tanstack/react-table/build/lib/index.mjs
function flexRender(Comp, props) {
  return !Comp ? null : isReactComponent(Comp) ? React38.createElement(Comp, props) : Comp;
}
function isReactComponent(component) {
  return isClassComponent(component) || typeof component === "function" || isExoticComponent(component);
}
function isClassComponent(component) {
  return typeof component === "function" && (() => {
    const proto = Object.getPrototypeOf(component);
    return proto.prototype && proto.prototype.isReactComponent;
  })();
}
function isExoticComponent(component) {
  return typeof component === "object" && typeof component.$$typeof === "symbol" && ["react.memo", "react.forward_ref"].includes(component.$$typeof.description);
}

// node_modules/@neo4j-ndl/react/lib/esm/table/helpers.js
var helpers_exports = {};
__export(helpers_exports, {
  gridGenerator: () => gridGenerator,
  userFriendlyPagination: () => userFriendlyPagination
});
var userFriendlyPagination = (current, max4) => {
  const last = max4;
  const delta = 1;
  const left2 = current - delta;
  const right2 = current + delta + 1;
  const range = [];
  const rangeWithDots = [];
  let length2;
  for (let i2 = 1; i2 <= last; i2 += 1) {
    if (i2 === 1 || i2 === last || i2 >= left2 && i2 < right2) {
      range.push(i2);
    }
  }
  for (let i2 = 0; i2 < range.length; i2 += 1) {
    if (length2) {
      if (range[i2] - length2 === 2) {
        rangeWithDots.push(length2 + 1);
      } else if (range[i2] - length2 !== 1) {
        rangeWithDots.push("...");
      }
    }
    rangeWithDots.push(range[i2]);
    length2 = range[i2];
  }
  return rangeWithDots;
};
var gridGenerator = (table) => {
  const visibleColumns = table.getVisibleFlatColumns();
  const tableDefaultMin = table._getDefaultColumnDef().minSize;
  const defaultMin = tableDefaultMin !== 20 ? tableDefaultMin : 100;
  return visibleColumns.map((i2, idx) => {
    var _a2;
    return visibleColumns.length === idx + 1 ? `minmax(${i2.getSize()}px ,auto)` : `minmax(${((_a2 = table.getColumn(i2.id)) === null || _a2 === void 0 ? void 0 : _a2.columnDef.minSize) || defaultMin}px,${i2.getSize()}px)`;
  }).join(" ");
};

// node_modules/@neo4j-ndl/react/lib/esm/table/Components.js
var TABLE_RESULTS = {
  DEFAULT: 10,
  values: [10, 25, 50, 100]
};
var ResizingBar = ({ header, children, innerProps }) => {
  const { className = void 0 } = innerProps || {};
  return (0, import_jsx_runtime27.jsx)(import_jsx_runtime27.Fragment, { children: children || (0, import_jsx_runtime27.jsx)("button", Object.assign({}, innerProps, { type: "button", className: "ndl-table-resizer-wrapper", onMouseDown: header.getResizeHandler(), onTouchStart: header.getResizeHandler(), "aria-label": "resizing bar", children: (0, import_jsx_runtime27.jsx)("div", { className: classNames("ndl-table-resizer", className, {
    "ndl-table-is-resizing": header.column.getIsResizing()
  }) }) })) });
};
var Scrollable = ({ children, innerProps }) => {
  const { className } = innerProps || {};
  return (0, import_jsx_runtime27.jsx)("div", Object.assign({}, innerProps, { className: classNames("ndl-table-scrollable", className), children }));
};
var Header3 = ({ children, innerProps }) => {
  const { tableProps, components: components2 } = useTableContext();
  const { getHeaderGroups, getState } = tableProps;
  const { className = void 0 } = innerProps || {};
  const commonStyle = {
    display: "grid",
    gridTemplateColumns: gridGenerator(tableProps)
  };
  return (0, import_jsx_runtime27.jsx)("div", Object.assign({}, innerProps, { role: "rowgroup", className: classNames("ndl-table-thead", className, {
    "ndl-table-is-resizing": getState().columnSizingInfo.isResizingColumn
  }), children: children || (0, import_jsx_runtime27.jsx)(import_jsx_runtime27.Fragment, { children: getHeaderGroups().map((headerGroup) => (0, import_jsx_runtime27.jsx)("div", { className: "ndl-table-tr", style: commonStyle, role: "row", children: headerGroup.headers.map((header) => components2.HeaderCell && (0, import_jsx_runtime27.jsx)(components2.HeaderCell, { cell: header }, header.id)) }, headerGroup.id)) }) }));
};
var SortingButton = ({ sortDirection, children, innerProps }) => {
  let icon;
  const { className, style, onClick } = innerProps || {};
  const commonProps = Object.assign(Object.assign({}, innerProps), { className: classNames("ndl-header-icon", className), style: Object.assign(Object.assign({}, style), sortDirection && { display: "inline-block" }), onClick: (e4) => onClick && onClick(e4), onKeyDown: (e4) => {
    if (e4.key === " " && typeof onClick === "function")
      onClick(e4);
  }, tabIndex: 0 });
  switch (sortDirection) {
    case "desc":
      icon = (0, import_jsx_runtime27.jsx)(import_BarsArrowDownIcon.default, Object.assign({}, commonProps));
      break;
    case "asc":
      icon = (0, import_jsx_runtime27.jsx)(import_BarsArrowUpIcon.default, Object.assign({}, commonProps));
      break;
    default:
      icon = (0, import_jsx_runtime27.jsx)(import_Bars3CenterLeftIcon.default, Object.assign({}, commonProps));
  }
  return (0, import_jsx_runtime27.jsx)(import_jsx_runtime27.Fragment, { children: children || icon });
};
var ColumnControls = ({ cell, controls, children, innerProps }) => {
  const { className } = innerProps || {};
  return (0, import_jsx_runtime27.jsx)("div", Object.assign({}, innerProps, { className: classNames("ndl-header-action-group", className), children: children || (0, import_jsx_runtime27.jsx)(import_jsx_runtime27.Fragment, { children: controls === null || controls === void 0 ? void 0 : controls.map((control) => control) }) }));
};
var HeaderCell = ({ cell, children, innerProps }) => {
  const { components: components2, resizable } = useTableContext();
  const { className } = innerProps || {};
  const sort = cell.column.getIsSorted();
  const canSort = cell.column.getCanSort();
  const ariaSortRole = (0, import_react40.useMemo)(() => {
    switch (sort) {
      case "asc":
        return "ascending";
      case "desc":
        return "descending";
      default:
        return "none";
    }
  }, [sort]);
  const sortingControl = (0, import_react40.useMemo)(() => {
    if (canSort) {
      return (0, import_jsx_runtime27.jsx)(SortingButton, { sortDirection: sort, innerProps: {
        onClick: () => cell.column.toggleSorting()
      } }, cell.id);
    } else if (!canSort && sort !== false) {
      return (0, import_jsx_runtime27.jsx)(SortingButton, { sortDirection: sort, innerProps: {
        tabIndex: -1,
        style: {
          cursor: "not-allowed"
        }
      } }, cell.id);
    }
  }, [sort, cell, canSort]);
  return (0, import_jsx_runtime27.jsx)("div", Object.assign({ tabIndex: -1, role: "columnheader" }, innerProps, { className: classNames("ndl-table-th ndl-focusable-cell", className), "aria-sort": ariaSortRole, children: children || (0, import_jsx_runtime27.jsxs)(import_jsx_runtime27.Fragment, { children: [(0, import_jsx_runtime27.jsxs)("div", { className: "ndl-header-group", children: [(0, import_jsx_runtime27.jsx)("div", { className: "ndl-header-cell", children: cell.isPlaceholder ? null : flexRender(cell.column.columnDef.header, cell.getContext()) }), components2.ColumnControls && (0, import_jsx_runtime27.jsx)(components2.ColumnControls, { cell, controls: sortingControl ? [sortingControl] : [], innerProps: {
    tabIndex: canSort ? 0 : -1
  } })] }), resizable && cell.headerGroup.headers.length - 1 !== cell.index && cell.column.getCanResize() && components2.ResizingBar && (0, import_jsx_runtime27.jsx)(components2.ResizingBar, { header: cell })] }) }), cell.id);
};
var Body3 = ({ children, innerProps }) => {
  const { tableProps, components: components2, loading } = useTableContext();
  const { getRowModel } = tableProps;
  const { className } = innerProps || {};
  return (0, import_jsx_runtime27.jsx)("div", Object.assign({}, innerProps, { className: classNames("ndl-table-tbody", className), role: "rowgroup", "aria-busy": loading ? "true" : "false", children: children || (0, import_jsx_runtime27.jsxs)(import_jsx_runtime27.Fragment, { children: [loading && components2.LoadingPlaceholder && (0, import_jsx_runtime27.jsx)(components2.LoadingPlaceholder, {}), !loading && getRowModel().rows.length === 0 && components2.NoDataPlaceholder && (0, import_jsx_runtime27.jsx)(components2.NoDataPlaceholder, {}), !loading && getRowModel().rows.map((row, idx) => components2.BodyRow && (0, import_jsx_runtime27.jsx)(components2.BodyRow, { row }, `table-row-${idx}`))] }) }));
};
var BodyCell = ({ cell, children, innerProps }) => {
  const isResizing = cell.column.getIsResizing();
  const { className } = innerProps || {};
  return (0, import_jsx_runtime27.jsx)("div", Object.assign({}, innerProps, { className: classNames("ndl-table-td ndl-focusable-cell", className, {
    "ndl-table-is-resizing": isResizing
  }), role: "cell", tabIndex: 0, children: children || flexRender(cell.column.columnDef.cell, cell.getContext()) }), cell.id);
};
var BodyRow = ({ row, children, innerProps }) => {
  const { components: components2, tableProps } = useTableContext();
  const { className } = innerProps || {};
  const commonStyle = {
    display: "grid",
    gridTemplateColumns: gridGenerator(tableProps)
  };
  return (0, import_react39.createElement)("div", Object.assign({}, innerProps, { key: row.id, className: classNames("ndl-table-tr", className), style: commonStyle, role: "row" }), children || (0, import_jsx_runtime27.jsx)(import_jsx_runtime27.Fragment, { children: row.getVisibleCells().map((cell) => components2.BodyCell && (0, import_jsx_runtime27.jsx)(components2.BodyCell, { cell }, cell.id)) }));
};
var TableResults = ({ children, innerProps, manualPagination }) => {
  const { tableProps } = useTableContext();
  const { getState, getRowModel, getCoreRowModel } = tableProps;
  const { pagination: { pageSize, pageIndex } } = getState();
  const { rows } = getRowModel();
  const { from: from2, to, totalRows } = (0, import_react40.useMemo)(() => manualPagination || {
    from: 1 + pageIndex * pageSize,
    to: rows.length + pageIndex * pageSize,
    totalRows: getCoreRowModel().rows.length
  }, [pageIndex, pageSize, manualPagination, rows, getCoreRowModel]);
  const { className } = innerProps || {};
  return (0, import_jsx_runtime27.jsx)("span", Object.assign({}, innerProps, { className: classNames("ndl-table-results", className), children: children || (0, import_jsx_runtime27.jsxs)("span", { children: ["Showing", " ", (0, import_jsx_runtime27.jsx)("b", { children: totalRows ? `${from2}${to !== from2 ? `-${to}` : ""}` : 0 }), " of", " ", (0, import_jsx_runtime27.jsx)("b", { children: totalRows }), " results"] }) }));
};
var RowsPerPage = ({ children, innerProps }) => {
  const { tableProps } = useTableContext();
  const { setPageSize, getState } = tableProps;
  const { className } = innerProps || {};
  const { pagination: { pageSize } } = getState();
  return (0, import_jsx_runtime27.jsx)("div", Object.assign({}, innerProps, { className: classNames("ndl-table-rows-per-page", className), children: children || (0, import_jsx_runtime27.jsxs)(import_jsx_runtime27.Fragment, { children: ["Show", (0, import_jsx_runtime27.jsx)("select", { onChange: (e4) => setPageSize(parseInt(e4.target.value, 10)), className: "ndl-table-select", value: pageSize, "aria-label": "Select page size", children: [.../* @__PURE__ */ new Set([...TABLE_RESULTS.values, pageSize])].sort((a3, b2) => a3 - b2).map((option) => (0, import_jsx_runtime27.jsx)("option", { value: `${option}`, children: option }, `${option}`)) })] }) }));
};
var PaginationArrowButton = ({ action, children, innerProps }) => {
  const { className } = innerProps || {};
  return (0, import_jsx_runtime27.jsx)("button", Object.assign({}, innerProps, { type: "button", className: classNames("ndl-table-pagination-icon-button", className), children: children || (0, import_jsx_runtime27.jsxs)(import_jsx_runtime27.Fragment, { children: [action === "previous" && (0, import_jsx_runtime27.jsxs)(import_jsx_runtime27.Fragment, { children: [(0, import_jsx_runtime27.jsx)("span", { className: "n-sr-only", children: "Previous table page" }), (0, import_jsx_runtime27.jsx)(import_ChevronLeftIcon.default, { className: "ndl-table-pagination-icon" })] }), action === "next" && (0, import_jsx_runtime27.jsxs)(import_jsx_runtime27.Fragment, { children: [(0, import_jsx_runtime27.jsx)("span", { className: "n-sr-only", children: "Next table page" }), (0, import_jsx_runtime27.jsx)(import_ChevronRightIcon.default, { className: "ndl-table-pagination-icon" })] })] }) }));
};
var PaginationNumericButton = ({ currentIndex, isSelected, children, innerProps }) => {
  const { className, onClick } = innerProps || {};
  return (0, import_jsx_runtime27.jsx)("button", Object.assign({}, innerProps, { type: "button", "data-testid": `ndl-table-${currentIndex}`, className: classNames("ndl-table-pagination-numeric-button", className, {
    "ndl-not-selected-numeric": typeof currentIndex === "number" && !isSelected,
    "ndl-is-selected": isSelected,
    "ndl-not-selected": !isSelected
  }), onClick: (e4) => typeof currentIndex === "number" && onClick && onClick(e4), tabIndex: typeof currentIndex === "number" ? 0 : -1, children: children || currentIndex }));
};
var PaginationNumericButtons = () => {
  const { tableProps, components: components2 } = useTableContext();
  const { getState, setPageIndex, getPageCount } = tableProps;
  const { pagination: { pageIndex } } = getState();
  return (0, import_jsx_runtime27.jsx)(import_jsx_runtime27.Fragment, { children: userFriendlyPagination(pageIndex + 1, getPageCount()).map((option, idx) => components2.PaginationNumericButton && (0, import_jsx_runtime27.jsx)(
    components2.PaginationNumericButton,
    { innerProps: {
      onClick: () => typeof option === "number" && setPageIndex(option - 1)
    }, currentIndex: option, isSelected: option === pageIndex + 1 },
    `${option}-${idx}`
  )) });
};
var Pagination = ({ children, innerProps }) => {
  const { tableProps, components: components2 } = useTableContext();
  const { getCanPreviousPage, getCanNextPage, previousPage, nextPage } = tableProps;
  const { className } = innerProps || {};
  return (0, import_jsx_runtime27.jsx)("nav", Object.assign({}, innerProps, { className: classNames("ndl-table-nav", className), "aria-label": "Pagination", children: children || (0, import_jsx_runtime27.jsxs)(import_jsx_runtime27.Fragment, { children: [getCanPreviousPage() ? components2.PaginationArrowButton && (0, import_jsx_runtime27.jsx)(components2.PaginationArrowButton, { action: "previous", innerProps: {
    onClick: previousPage
  } }) : null, components2.PaginationNumericButtons && (0, import_jsx_runtime27.jsx)(components2.PaginationNumericButtons, {}), getCanNextPage() ? components2.PaginationArrowButton && (0, import_jsx_runtime27.jsx)(components2.PaginationArrowButton, { action: "next", innerProps: {
    onClick: nextPage
  } }) : null] }) }));
};
var Navigation = ({ children, innerProps }) => {
  const { tableProps, components: components2 } = useTableContext();
  const { getPageCount } = tableProps;
  const { className } = innerProps || {};
  return (0, import_jsx_runtime27.jsx)("div", Object.assign({}, innerProps, { className: classNames("ndl-table-navigation", className), children: (0, import_jsx_runtime27.jsx)(import_jsx_runtime27.Fragment, { children: children || (0, import_jsx_runtime27.jsxs)(import_jsx_runtime27.Fragment, { children: [components2.TableResults && (0, import_jsx_runtime27.jsx)(components2.TableResults, {}), (0, import_jsx_runtime27.jsxs)("div", { className: "ndl-table-navigation-right-items", children: [getPageCount() > 1 && components2.Pagination && (0, import_jsx_runtime27.jsx)(components2.Pagination, {}), components2.RowsPerPage && (0, import_jsx_runtime27.jsx)(components2.RowsPerPage, {})] })] }) }) }));
};
var LoadingPlaceholder = ({ children, innerProps }) => {
  const { className } = innerProps || {};
  return (0, import_jsx_runtime27.jsx)("div", Object.assign({}, innerProps, { className: classNames("nld-table-placeholder-wrapper", className), role: "row", children: children || (0, import_jsx_runtime27.jsx)("div", { role: "cell", className: "ndl-table-placeholder", children: (0, import_jsx_runtime27.jsxs)("div", { className: "ndl-table-loading-placeholder", children: [(0, import_jsx_runtime27.jsx)(LoadingSpinner_default, {}), (0, import_jsx_runtime27.jsx)("h6", { children: "Loading data" })] }) }) }));
};
var NoDataPlaceholder = ({ children, innerProps }) => {
  const { className } = innerProps || {};
  return (0, import_jsx_runtime27.jsx)("div", Object.assign({}, innerProps, { className: classNames("nld-table-placeholder-wrapper", className), role: "row", children: children || (0, import_jsx_runtime27.jsx)("div", { role: "cell", className: "ndl-table-placeholder", children: (0, import_jsx_runtime27.jsx)("h6", { children: "No data present" }) }) }));
};

// node_modules/@neo4j-ndl/react/lib/esm/table/Table.js
var __rest22 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var TableComponents = {
  ResizingBar,
  Header: Header3,
  Body: Body3,
  BodyCell,
  BodyRow,
  HeaderCell,
  ColumnControls,
  Navigation,
  TableResults,
  RowsPerPage,
  Pagination,
  PaginationNumericButtons,
  PaginationNumericButton,
  PaginationArrowButton,
  LoadingPlaceholder,
  NoDataPlaceholder,
  SortingButton,
  Scrollable
};
var Table = forwardRef(function Table2(_a2, ref) {
  var { className = "", style = {}, resizable = true, loading = false, focusableCells = false, tableProps, components: components2 } = _a2, restProps = __rest22(_a2, ["className", "style", "resizable", "loading", "focusableCells", "tableProps", "components"]);
  const Components = (0, import_react41.useMemo)(() => Object.assign(Object.assign({}, TableComponents), components2), [components2]);
  const ScrollableContainer = (Components === null || Components === void 0 ? void 0 : Components.Scrollable) ? Components.Scrollable : Scrollable;
  return (0, import_jsx_runtime28.jsx)(TableContext.Provider, { value: {
    resizable,
    tableProps,
    loading,
    components: Components
  }, children: (0, import_jsx_runtime28.jsxs)("div", Object.assign({}, restProps, { className: classNames("ndl-table-root", className, {
    "ndl-table-focusable-cells": focusableCells
  }), style, ref, children: [(0, import_jsx_runtime28.jsx)(ScrollableContainer, { children: (0, import_jsx_runtime28.jsxs)("div", { className: "ndl-div-table", role: "table", "aria-busy": loading ? "true" : "false", children: [(Components === null || Components === void 0 ? void 0 : Components.Header) && (0, import_jsx_runtime28.jsx)(Components.Header, {}), (Components === null || Components === void 0 ? void 0 : Components.Body) && (0, import_jsx_runtime28.jsx)(Components.Body, {})] }) }), (Components === null || Components === void 0 ? void 0 : Components.Navigation) && (0, import_jsx_runtime28.jsx)(Components.Navigation, {})] })) });
});
var RowActions = (_a2) => {
  var { className } = _a2, restProps = __rest22(_a2, ["className"]);
  return (0, import_jsx_runtime28.jsx)("div", Object.assign({}, restProps, { className: classNames("ndl-table-row-actions", className) }));
};
var TableNameSpace = Object.assign(Table, { RowActions });
var Table_default = TableNameSpace;

// node_modules/@neo4j-ndl/react/lib/esm/dropzone/Dropzone.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime());
var import_react142 = __toESM(require_react());

// node_modules/detect-browser/es/index.js
var __spreadArray2 = function(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from2.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i2);
        ar[i2] = from2[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
};
var BrowserInfo = (
  /** @class */
  function() {
    function BrowserInfo2(name2, version, os) {
      this.name = name2;
      this.version = version;
      this.os = os;
      this.type = "browser";
    }
    return BrowserInfo2;
  }()
);
var NodeInfo = (
  /** @class */
  function() {
    function NodeInfo2(version) {
      this.version = version;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo2;
  }()
);
var SearchBotDeviceInfo = (
  /** @class */
  function() {
    function SearchBotDeviceInfo2(name2, version, os, bot) {
      this.name = name2;
      this.version = version;
      this.os = os;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  }()
);
var BotInfo = (
  /** @class */
  function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  }()
);
var ReactNativeInfo = (
  /** @class */
  function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  }()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a2) {
    var browser3 = _a2[0], regex = _a2[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser3, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name2 = matchedRule[0], match3 = matchedRule[1];
  if (name2 === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match3[1] && match3[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray2(__spreadArray2([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version = versionParts.join(".");
  var os = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name2, version, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name2, version, os);
}
function detectOS(ua) {
  for (var ii = 0, count2 = operatingSystemRules.length; ii < count2; ii++) {
    var _a2 = operatingSystemRules[ii], os = _a2[0], regex = _a2[1];
    var match3 = regex.exec(ua);
    if (match3) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode4 = typeof process !== "undefined" && process.version;
  return isNode4 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count2) {
  var output = [];
  for (var ii = 0; ii < count2; ii++) {
    output.push("0");
  }
  return output;
}

// node_modules/@neo4j-ndl/react/lib/esm/dropzone/icons/Cloud.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime());
var SvgComponent = (props) => (0, import_jsx_runtime29.jsxs)("svg", Object.assign({ width: 112, height: 52, fill: "none", xmlns: "http://www.w3.org/2000/svg" }, props, { children: [(0, import_jsx_runtime29.jsx)("mask", { id: "a", fill: "rgb(var(--theme-palette-neutral-bg-weak))", children: (0, import_jsx_runtime29.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M104.47 18.62c.236-.72.363-1.488.363-2.287a7.333 7.333 0 0 0-9.88-6.879A9.67 9.67 0 0 0 85.833 3c-5.004 0-9.12 3.803-9.616 8.677a7 7 0 0 0-7.362 7.544A9.333 9.333 0 0 0 72.833 37h29.334a9.333 9.333 0 0 0 9.333-9.333c0-4.36-2.989-8.022-7.03-9.047Z" }) }), (0, import_jsx_runtime29.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M104.47 18.62c.236-.72.363-1.488.363-2.287a7.333 7.333 0 0 0-9.88-6.879A9.67 9.67 0 0 0 85.833 3c-5.004 0-9.12 3.803-9.616 8.677a7 7 0 0 0-7.362 7.544A9.333 9.333 0 0 0 72.833 37h29.334a9.333 9.333 0 0 0 9.333-9.333c0-4.36-2.989-8.022-7.03-9.047Z", fill: "rgb(var(--theme-palette-neutral-bg-strong))" }), (0, import_jsx_runtime29.jsx)("path", { d: "m104.47 18.62-.246.969-1.038-.263.334-1.018.95.312Zm-9.517-9.166.348.938-.953.353-.338-.958.943-.333Zm-18.736 2.223.995.101-.097.949-.952-.052.054-.998Zm-7.362 7.544.997-.078.054.688-.624.295-.427-.905Zm34.665-.913c.203-.62.313-1.283.313-1.975h2a8.31 8.31 0 0 1-.413 2.598l-1.9-.623Zm.313-1.975A6.333 6.333 0 0 0 97.5 10V8a8.333 8.333 0 0 1 8.333 8.333h-2ZM97.5 10c-.775 0-1.516.139-2.2.392l-.694-1.875A8.318 8.318 0 0 1 97.5 8v2Zm-3.49-.213A8.67 8.67 0 0 0 85.833 4V2c4.65 0 8.603 2.975 10.064 7.122l-1.887.665ZM85.833 4a8.668 8.668 0 0 0-8.621 7.778l-1.99-.202C75.769 6.196 80.31 2 85.833 2v2Zm-9.67 8.675a6.087 6.087 0 0 0-.33-.008v-2c.147 0 .293.004.438.011l-.108 1.997Zm-.33-.008a6 6 0 0 0-6 6h-2a8 8 0 0 1 8-8v2Zm-6 6c0 .16.007.319.02.476l-1.995.156a8.083 8.083 0 0 1-.025-.632h2Zm-.551 1.459a8.334 8.334 0 0 0-4.782 7.54h-2c0-4.132 2.427-7.697 5.928-9.35l.854 1.81Zm-4.782 7.54A8.333 8.333 0 0 0 72.833 36v2C67.126 38 62.5 33.374 62.5 27.667h2ZM72.833 36h29.334v2H72.833v-2Zm29.334 0a8.333 8.333 0 0 0 8.333-8.333h2c0 5.707-4.626 10.333-10.333 10.333v-2Zm8.333-8.333a8.337 8.337 0 0 0-6.276-8.078l.492-1.938c4.474 1.135 7.784 5.188 7.784 10.016h-2Z", fill: "rgb(var(--theme-palette-neutral-bg-strong))", mask: "url(#a)" }), (0, import_jsx_runtime29.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15.85 18.72a3 3 0 0 0-5.71 1.14 4.866 4.866 0 0 0-5.695 6.442A5.455 5.455 0 0 0 5.954 37h22.727a5.455 5.455 0 0 0 .926-10.83 5.098 5.098 0 0 0-6.596-6.16 4.002 4.002 0 0 0-7.162-1.29Z", fill: "rgb(var(--theme-palette-neutral-bg-strong))" }), (0, import_jsx_runtime29.jsx)("mask", { id: "b", fill: "rgb(var(--theme-palette-neutral-bg-stronger))", children: (0, import_jsx_runtime29.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M26.045 24.43A10.99 10.99 0 0 1 25.5 21c0-6.075 4.925-11 11-11 1.343 0 2.63.24 3.82.681C42.306 5.041 47.68 1 54 1c7.507 0 13.681 5.705 14.425 13.015.19-.01.382-.015.575-.015 5.799 0 10.5 4.701 10.5 10.5 0 .28-.011.557-.032.832C84.215 27.572 87.5 32.402 87.5 38c0 7.732-6.268 14-14 14h-44c-7.732 0-14-6.268-14-14 0-6.54 4.484-12.032 10.545-13.57Z" }) }), (0, import_jsx_runtime29.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M26.045 24.43A10.99 10.99 0 0 1 25.5 21c0-6.075 4.925-11 11-11 1.343 0 2.63.24 3.82.681C42.306 5.041 47.68 1 54 1c7.507 0 13.681 5.705 14.425 13.015.19-.01.382-.015.575-.015 5.799 0 10.5 4.701 10.5 10.5 0 .28-.011.557-.032.832C84.215 27.572 87.5 32.402 87.5 38c0 7.732-6.268 14-14 14h-44c-7.732 0-14-6.268-14-14 0-6.54 4.484-12.032 10.545-13.57Z", fill: "rgb(var(--theme-palette-neutral-bg-strong))" }), (0, import_jsx_runtime29.jsx)("path", { d: "m26.045 24.43.492 1.938 2.076-.527-.667-2.035-1.9.623ZM40.32 10.68l-.695 1.876 1.906.706.675-1.917-1.886-.665Zm28.105 3.335-1.99.202.193 1.897 1.905-.102-.108-1.998Zm11.043 11.316-1.994-.156-.108 1.376 1.248.589.853-1.81Zm-51.522-1.526A8.99 8.99 0 0 1 27.5 21h-4c0 1.412.226 2.775.645 4.053l3.8-1.247ZM27.5 21a9 9 0 0 1 9-9V8c-7.18 0-13 5.82-13 13h4Zm9-9c1.102 0 2.154.197 3.125.557l1.39-3.751A12.978 12.978 0 0 0 36.5 8v4Zm5.706-.654C43.92 6.482 48.556 3 54 3v-4c-7.194 0-13.307 4.602-15.566 11.017l3.772 1.329ZM54 3c6.47 0 11.794 4.918 12.435 11.218l3.98-.405C69.568 5.492 62.544-1 54-1v4Zm14.533 13.013c.154-.009.31-.013.467-.013v-4c-.229 0-.457.006-.683.018l.216 3.995ZM69 16a8.5 8.5 0 0 1 8.5 8.5h4C81.5 17.596 75.904 12 69 12v4Zm8.5 8.5c0 .228-.009.453-.026.676l3.987.312c.026-.326.039-.656.039-.988h-4Zm1.114 2.64A12.002 12.002 0 0 1 85.5 38h4c0-6.4-3.758-11.919-9.179-14.477l-1.707 3.618ZM85.5 38c0 6.627-5.373 12-12 12v4c8.837 0 16-7.163 16-16h-4Zm-12 12h-44v4h44v-4Zm-44 0c-6.627 0-12-5.373-12-12h-4c0 8.837 7.163 16 16 16v-4Zm-12-12c0-5.603 3.841-10.313 9.037-11.632l-.984-3.877C18.626 24.249 13.5 30.523 13.5 38h4Z", fill: "rgb(var(--theme-palette-neutral-bg-weak))", mask: "url(#b)" }), (0, import_jsx_runtime29.jsx)("rect", { x: 70.5, y: 8, width: 3, height: 3, rx: 1.5, fill: "rgb(var(--theme-palette-neutral-bg-strong))" }), (0, import_jsx_runtime29.jsx)("rect", { x: 35.5, width: 6, height: 6, rx: 3, fill: "rgb(var(--theme-palette-neutral-bg-strong))" }), (0, import_jsx_runtime29.jsx)("path", { d: "m58.5 30-6-6m0 0-6 6m6-6v18", stroke: "rgb(var(--theme-palette-neutral-bg-stronger))", strokeWidth: 4, strokeLinecap: "round", strokeLinejoin: "round" })] }));
var Cloud_default = SvgComponent;

// node_modules/@neo4j-ndl/react/lib/esm/dropzone/icons/File.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime());
var SvgComponent2 = (props) => (0, import_jsx_runtime30.jsxs)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: 44, height: 52, fill: "none" }, props, { children: [(0, import_jsx_runtime30.jsx)("path", { fill: "rgb(var(--theme-palette-primary-border-weak))", stroke: "rgb(var(--theme-palette-primary-bg-strong))", d: "M35.402 51.488h-27a7.5 7.5 0 0 1-7.5-7.5v-35a7.5 7.5 0 0 1 7.5-7.5h20.142a7.5 7.5 0 0 1 4.7 1.655l4.24 3.41 3.019 2.8a7.5 7.5 0 0 1 2.399 5.498v29.137a7.5 7.5 0 0 1-7.5 7.5Z" }), (0, import_jsx_runtime30.jsx)("path", { fill: "rgb(var(--theme-palette-primary-bg-strong))", d: "M29.402.988c1.371 0 2.701.474 3.763 1.342l4.721 3.858 3.624 3.416a6.025 6.025 0 0 1 1.892 4.384h-10a4 4 0 0 1-4-4v-9Z" }), (0, import_jsx_runtime30.jsx)("path", { stroke: "rgb(var(--theme-palette-primary-bg-strong))", strokeLinecap: "round", strokeWidth: 3, d: "M12.902 20.488h20M8.902 26.488h20M10.902 32.488h23M9.902 38.488h22" })] }));
var File_default = SvgComponent2;

// node_modules/@neo4j-ndl/react/lib/esm/dropzone/icons/InvalidFile.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime());
var SvgComponent3 = (props) => (0, import_jsx_runtime31.jsxs)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: 44, height: 52, fill: "none" }, props, { children: [(0, import_jsx_runtime31.jsx)("path", { fill: "rgb(var(--theme-palette-danger-border-weak))", stroke: "rgb(var(--theme-palette-danger-border-strong))", d: "M35.402 51.488h-27a7.5 7.5 0 0 1-7.5-7.5v-35a7.5 7.5 0 0 1 7.5-7.5h20.142a7.5 7.5 0 0 1 4.7 1.655l4.24 3.41 3.019 2.8a7.5 7.5 0 0 1 2.399 5.498v29.137a7.5 7.5 0 0 1-7.5 7.5Z" }), (0, import_jsx_runtime31.jsx)("path", { fill: "rgb(var(--theme-palette-danger-border-strong))", d: "M29.402.988c1.371 0 2.701.474 3.763 1.342l4.721 3.858 3.624 3.416a6.025 6.025 0 0 1 1.892 4.384h-10a4 4 0 0 1-4-4v-9Z" }), (0, import_jsx_runtime31.jsx)("path", { stroke: "rgb(var(--theme-palette-danger-border-strong))", strokeLinecap: "round", strokeWidth: 3, d: "M12.902 20.488h20M8.902 26.488h20M10.902 32.488h23M9.902 38.488h22" })] }));
var InvalidFile_default = SvgComponent3;

// node_modules/react-use/esm/factory/createMemo.js
var import_react42 = __toESM(require_react());

// node_modules/react-use/esm/factory/createReducerContext.js
var import_react43 = __toESM(require_react());

// node_modules/react-use/esm/factory/createReducer.js
var import_react46 = __toESM(require_react());

// node_modules/react-use/esm/useUpdateEffect.js
var import_react45 = __toESM(require_react());

// node_modules/react-use/esm/useFirstMountState.js
var import_react44 = __toESM(require_react());

// node_modules/react-use/esm/factory/createStateContext.js
var import_react47 = __toESM(require_react());

// node_modules/react-use/esm/useAsync.js
var import_react50 = __toESM(require_react());

// node_modules/react-use/esm/useAsyncFn.js
init_tslib_es6();
var import_react49 = __toESM(require_react());

// node_modules/react-use/esm/useMountedState.js
var import_react48 = __toESM(require_react());

// node_modules/react-use/esm/useAsyncRetry.js
init_tslib_es6();
var import_react51 = __toESM(require_react());

// node_modules/react-use/esm/factory/createHTMLMediaHook.js
init_tslib_es6();
var React39 = __toESM(require_react());
var import_react53 = __toESM(require_react());

// node_modules/react-use/esm/useSetState.js
var import_react52 = __toESM(require_react());
var useSetState = function(initialState2) {
  if (initialState2 === void 0) {
    initialState2 = {};
  }
  var _a2 = (0, import_react52.useState)(initialState2), state = _a2[0], set2 = _a2[1];
  var setState = (0, import_react52.useCallback)(function(patch) {
    set2(function(prevState) {
      return Object.assign({}, prevState, patch instanceof Function ? patch(prevState) : patch);
    });
  }, []);
  return [state, setState];
};
var useSetState_default = useSetState;

// node_modules/react-use/esm/misc/parseTimeRanges.js
function parseTimeRanges(ranges) {
  var result = [];
  for (var i2 = 0; i2 < ranges.length; i2++) {
    result.push({
      start: ranges.start(i2),
      end: ranges.end(i2)
    });
  }
  return result;
}

// node_modules/react-use/esm/factory/createHTMLMediaHook.js
function createHTMLMediaHook(tag) {
  return function(elOrProps) {
    var element;
    var props;
    if (React39.isValidElement(elOrProps)) {
      element = elOrProps;
      props = element.props;
    } else {
      props = elOrProps;
    }
    var _a2 = useSetState_default({
      buffered: [],
      time: 0,
      duration: 0,
      paused: true,
      muted: false,
      volume: 1,
      playing: false
    }), state = _a2[0], setState = _a2[1];
    var ref = (0, import_react53.useRef)(null);
    var wrapEvent = function(userEvent, proxyEvent) {
      return function(event) {
        try {
          proxyEvent && proxyEvent(event);
        } finally {
          userEvent && userEvent(event);
        }
      };
    };
    var onPlay = function() {
      return setState({ paused: false });
    };
    var onPlaying = function() {
      return setState({ playing: true });
    };
    var onWaiting = function() {
      return setState({ playing: false });
    };
    var onPause = function() {
      return setState({ paused: true, playing: false });
    };
    var onVolumeChange = function() {
      var el = ref.current;
      if (!el) {
        return;
      }
      setState({
        muted: el.muted,
        volume: el.volume
      });
    };
    var onDurationChange = function() {
      var el = ref.current;
      if (!el) {
        return;
      }
      var duration = el.duration, buffered = el.buffered;
      setState({
        duration,
        buffered: parseTimeRanges(buffered)
      });
    };
    var onTimeUpdate = function() {
      var el = ref.current;
      if (!el) {
        return;
      }
      setState({ time: el.currentTime });
    };
    var onProgress = function() {
      var el = ref.current;
      if (!el) {
        return;
      }
      setState({ buffered: parseTimeRanges(el.buffered) });
    };
    if (element) {
      element = React39.cloneElement(element, __assign(__assign({ controls: false }, props), { ref, onPlay: wrapEvent(props.onPlay, onPlay), onPlaying: wrapEvent(props.onPlaying, onPlaying), onWaiting: wrapEvent(props.onWaiting, onWaiting), onPause: wrapEvent(props.onPause, onPause), onVolumeChange: wrapEvent(props.onVolumeChange, onVolumeChange), onDurationChange: wrapEvent(props.onDurationChange, onDurationChange), onTimeUpdate: wrapEvent(props.onTimeUpdate, onTimeUpdate), onProgress: wrapEvent(props.onProgress, onProgress) }));
    } else {
      element = React39.createElement(tag, __assign(__assign({ controls: false }, props), { ref, onPlay: wrapEvent(props.onPlay, onPlay), onPlaying: wrapEvent(props.onPlaying, onPlaying), onWaiting: wrapEvent(props.onWaiting, onWaiting), onPause: wrapEvent(props.onPause, onPause), onVolumeChange: wrapEvent(props.onVolumeChange, onVolumeChange), onDurationChange: wrapEvent(props.onDurationChange, onDurationChange), onTimeUpdate: wrapEvent(props.onTimeUpdate, onTimeUpdate), onProgress: wrapEvent(props.onProgress, onProgress) }));
    }
    var lockPlay = false;
    var controls = {
      play: function() {
        var el = ref.current;
        if (!el) {
          return void 0;
        }
        if (!lockPlay) {
          var promise = el.play();
          var isPromise = typeof promise === "object";
          if (isPromise) {
            lockPlay = true;
            var resetLock = function() {
              lockPlay = false;
            };
            promise.then(resetLock, resetLock);
          }
          return promise;
        }
        return void 0;
      },
      pause: function() {
        var el = ref.current;
        if (el && !lockPlay) {
          return el.pause();
        }
      },
      seek: function(time) {
        var el = ref.current;
        if (!el || state.duration === void 0) {
          return;
        }
        time = Math.min(state.duration, Math.max(0, time));
        el.currentTime = time;
      },
      volume: function(volume) {
        var el = ref.current;
        if (!el) {
          return;
        }
        volume = Math.min(1, Math.max(0, volume));
        el.volume = volume;
        setState({ volume });
      },
      mute: function() {
        var el = ref.current;
        if (!el) {
          return;
        }
        el.muted = true;
      },
      unmute: function() {
        var el = ref.current;
        if (!el) {
          return;
        }
        el.muted = false;
      }
    };
    (0, import_react53.useEffect)(function() {
      var el = ref.current;
      if (!el) {
        if (true) {
          if (tag === "audio") {
            console.error("useAudio() ref to <audio> element is empty at mount. It seem you have not rendered the audio element, which it returns as the first argument const [audio] = useAudio(...).");
          } else if (tag === "video") {
            console.error("useVideo() ref to <video> element is empty at mount. It seem you have not rendered the video element, which it returns as the first argument const [video] = useVideo(...).");
          }
        }
        return;
      }
      setState({
        volume: el.volume,
        muted: el.muted,
        paused: el.paused
      });
      if (props.autoPlay && el.paused) {
        controls.play();
      }
    }, [props.src]);
    return [element, state, controls, ref];
  };
}

// node_modules/react-use/esm/useAudio.js
var useAudio = createHTMLMediaHook("audio");

// node_modules/react-use/esm/useBattery.js
var import_react55 = __toESM(require_react());

// node_modules/react-use/esm/misc/util.js
var noop = function() {
};
function on(obj) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (obj && obj.addEventListener) {
    obj.addEventListener.apply(obj, args);
  }
}
function off(obj) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (obj && obj.removeEventListener) {
    obj.removeEventListener.apply(obj, args);
  }
}
var isBrowser = typeof window !== "undefined";
var isNavigator = typeof navigator !== "undefined";

// node_modules/react-use/esm/misc/isDeepEqual.js
var import_react54 = __toESM(require_react2());

// node_modules/react-use/esm/useBattery.js
var nav = isNavigator ? navigator : void 0;
var isBatteryApiSupported = nav && typeof nav.getBattery === "function";

// node_modules/react-use/esm/useBeforeUnload.js
var import_react56 = __toESM(require_react());

// node_modules/react-use/esm/useToggle.js
var import_react57 = __toESM(require_react());

// node_modules/react-use/esm/useClickAway.js
var import_react58 = __toESM(require_react());

// node_modules/react-use/esm/useCookie.js
var import_react59 = __toESM(require_react());
var import_js_cookie = __toESM(require_js_cookie());

// node_modules/react-use/esm/useCopyToClipboard.js
var import_copy_to_clipboard = __toESM(require_copy_to_clipboard());
var import_react60 = __toESM(require_react());

// node_modules/react-use/esm/useCounter.js
var import_react63 = __toESM(require_react());

// node_modules/react-use/esm/useGetSet.js
var import_react62 = __toESM(require_react());

// node_modules/react-use/esm/useUpdate.js
var import_react61 = __toESM(require_react());

// node_modules/react-use/esm/useCss.js
var import_nano_css = __toESM(require_nano_css());
var import_cssom = __toESM(require_cssom());
var import_vcssom = __toESM(require_vcssom());
var import_cssToTree = __toESM(require_cssToTree());
var import_react65 = __toESM(require_react());

// node_modules/react-use/esm/useIsomorphicLayoutEffect.js
var import_react64 = __toESM(require_react());
var useIsomorphicLayoutEffect2 = isBrowser ? import_react64.useLayoutEffect : import_react64.useEffect;
var useIsomorphicLayoutEffect_default = useIsomorphicLayoutEffect2;

// node_modules/react-use/esm/useCss.js
var nano = (0, import_nano_css.create)();
(0, import_cssom.addon)(nano);
(0, import_vcssom.addon)(nano);

// node_modules/react-use/esm/useCustomCompareEffect.js
var import_react66 = __toESM(require_react());

// node_modules/react-use/esm/useDebounce.js
var import_react68 = __toESM(require_react());

// node_modules/react-use/esm/useTimeoutFn.js
var import_react67 = __toESM(require_react());

// node_modules/react-use/esm/useDefault.js
var import_react69 = __toESM(require_react());

// node_modules/react-use/esm/useDrop.js
init_tslib_es6();
var import_react70 = __toESM(require_react());

// node_modules/react-use/esm/useDropArea.js
var import_react71 = __toESM(require_react());

// node_modules/react-use/esm/useEffectOnce.js
var import_react72 = __toESM(require_react());

// node_modules/react-use/esm/useEnsuredForwardedRef.js
var import_react73 = __toESM(require_react());

// node_modules/react-use/esm/useEvent.js
var import_react74 = __toESM(require_react());

// node_modules/react-use/esm/useError.js
var import_react75 = __toESM(require_react());

// node_modules/react-use/esm/useFavicon.js
var import_react76 = __toESM(require_react());

// node_modules/react-use/esm/useFullscreen.js
var import_react77 = __toESM(require_react());
var import_screenfull = __toESM(require_screenfull());

// node_modules/react-use/esm/useGeolocation.js
init_tslib_es6();
var import_react78 = __toESM(require_react());

// node_modules/react-use/esm/useGetSetState.js
init_tslib_es6();
var import_react79 = __toESM(require_react());

// node_modules/react-use/esm/useHarmonicIntervalFn.js
var import_react80 = __toESM(require_react());

// node_modules/react-use/esm/useHover.js
var React40 = __toESM(require_react());

// node_modules/react-use/esm/useHoverDirty.js
var import_react81 = __toESM(require_react());

// node_modules/react-use/esm/useIdle.js
var import_react82 = __toESM(require_react());

// node_modules/react-use/esm/useIntersection.js
var import_react83 = __toESM(require_react());

// node_modules/react-use/esm/useInterval.js
var import_react84 = __toESM(require_react());

// node_modules/react-use/esm/useKey.js
var import_react85 = __toESM(require_react());

// node_modules/react-use/esm/factory/createBreakpoint.js
var import_react86 = __toESM(require_react());

// node_modules/react-use/esm/useKeyPress.js
var import_react87 = __toESM(require_react());

// node_modules/react-use/esm/useLatest.js
var import_react88 = __toESM(require_react());

// node_modules/react-use/esm/useLifecycles.js
var import_react89 = __toESM(require_react());

// node_modules/react-use/esm/useList.js
var import_react90 = __toESM(require_react());

// node_modules/react-use/esm/useLocalStorage.js
var import_react91 = __toESM(require_react());

// node_modules/react-use/esm/useLocation.js
var import_react92 = __toESM(require_react());
var patchHistoryMethod = function(method) {
  var history2 = window.history;
  var original = history2[method];
  history2[method] = function(state) {
    var result = original.apply(this, arguments);
    var event = new Event(method.toLowerCase());
    event.state = state;
    window.dispatchEvent(event);
    return result;
  };
};
if (isBrowser) {
  patchHistoryMethod("pushState");
  patchHistoryMethod("replaceState");
}

// node_modules/react-use/esm/useLockBodyScroll.js
var import_react93 = __toESM(require_react());
var isIosDevice = isBrowser && window.navigator && window.navigator.platform && /iP(ad|hone|od)/.test(window.navigator.platform);

// node_modules/react-use/esm/useLogger.js
init_tslib_es6();

// node_modules/react-use/esm/useLongPress.js
var import_react94 = __toESM(require_react());

// node_modules/react-use/esm/useMap.js
init_tslib_es6();
var import_react95 = __toESM(require_react());

// node_modules/react-use/esm/useMedia.js
var import_react96 = __toESM(require_react());

// node_modules/react-use/esm/useMediaDevices.js
var import_react97 = __toESM(require_react());
var useMediaDevices = function() {
  var _a2 = (0, import_react97.useState)({}), state = _a2[0], setState = _a2[1];
  (0, import_react97.useEffect)(function() {
    var mounted = true;
    var onChange2 = function() {
      navigator.mediaDevices.enumerateDevices().then(function(devices) {
        if (mounted) {
          setState({
            devices: devices.map(function(_a3) {
              var deviceId = _a3.deviceId, groupId = _a3.groupId, kind = _a3.kind, label = _a3.label;
              return {
                deviceId,
                groupId,
                kind,
                label
              };
            })
          });
        }
      }).catch(noop);
    };
    on(navigator.mediaDevices, "devicechange", onChange2);
    onChange2();
    return function() {
      mounted = false;
      off(navigator.mediaDevices, "devicechange", onChange2);
    };
  }, []);
  return state;
};
var useMediaDevicesMock = function() {
  return {};
};
var useMediaDevices_default = isNavigator && !!navigator.mediaDevices ? useMediaDevices : useMediaDevicesMock;

// node_modules/react-use/esm/useMediatedState.js
var import_react98 = __toESM(require_react());

// node_modules/react-use/esm/useMethods.js
var import_react99 = __toESM(require_react());

// node_modules/react-use/esm/useMotion.js
var import_react100 = __toESM(require_react());

// node_modules/react-use/esm/useMouse.js
var import_react103 = __toESM(require_react());

// node_modules/react-use/esm/useRafState.js
var import_react102 = __toESM(require_react());

// node_modules/react-use/esm/useUnmount.js
var import_react101 = __toESM(require_react());

// node_modules/react-use/esm/useMouseWheel.js
var import_react104 = __toESM(require_react());

// node_modules/react-use/esm/useNetworkState.js
var import_react105 = __toESM(require_react());
var nav2 = isNavigator ? navigator : void 0;
var conn = nav2 && (nav2.connection || nav2.mozConnection || nav2.webkitConnection);

// node_modules/react-use/esm/useObservable.js
var import_react106 = __toESM(require_react());

// node_modules/react-use/esm/useOrientation.js
var import_react107 = __toESM(require_react());

// node_modules/react-use/esm/usePageLeave.js
var import_react108 = __toESM(require_react());

// node_modules/react-use/esm/usePermission.js
var import_react109 = __toESM(require_react());

// node_modules/react-use/esm/usePrevious.js
var import_react110 = __toESM(require_react());

// node_modules/react-use/esm/usePreviousDistinct.js
var import_react111 = __toESM(require_react());

// node_modules/react-use/esm/usePromise.js
var import_react112 = __toESM(require_react());

// node_modules/react-use/esm/useQueue.js
init_tslib_es6();
var import_react113 = __toESM(require_react());

// node_modules/react-use/esm/useRaf.js
var import_react114 = __toESM(require_react());

// node_modules/react-use/esm/useRafLoop.js
var import_react115 = __toESM(require_react());

// node_modules/react-use/esm/useSearchParam.js
var import_react116 = __toESM(require_react());

// node_modules/react-use/esm/useScratch.js
init_tslib_es6();
var import_react117 = __toESM(require_react());
var import_react_universal_interface = __toESM(require_lib());

// node_modules/react-use/esm/useScroll.js
var import_react118 = __toESM(require_react());

// node_modules/react-use/esm/useScrolling.js
var import_react119 = __toESM(require_react());

// node_modules/react-use/esm/useSessionStorage.js
var import_react120 = __toESM(require_react());

// node_modules/react-use/esm/useShallowCompareEffect.js
var import_fast_shallow_equal = __toESM(require_fast_shallow_equal());

// node_modules/react-use/esm/useSize.js
init_tslib_es6();
var React41 = __toESM(require_react());

// node_modules/react-use/esm/useSlider.js
var import_react121 = __toESM(require_react());

// node_modules/react-use/esm/useSpeech.js
init_tslib_es6();
var import_react122 = __toESM(require_react());
var Status;
(function(Status2) {
  Status2[Status2["init"] = 0] = "init";
  Status2[Status2["play"] = 1] = "play";
  Status2[Status2["pause"] = 2] = "pause";
  Status2[Status2["end"] = 3] = "end";
})(Status || (Status = {}));

// node_modules/react-use/esm/useStateWithHistory.js
var import_react123 = __toESM(require_react());

// node_modules/react-use/esm/useStateList.js
init_tslib_es6();
var import_react124 = __toESM(require_react());

// node_modules/react-use/esm/useThrottle.js
var import_react125 = __toESM(require_react());

// node_modules/react-use/esm/useThrottleFn.js
var import_react126 = __toESM(require_react());

// node_modules/react-use/esm/useTitle.js
var import_react127 = __toESM(require_react());

// node_modules/react-use/esm/useTween.js
var import_ts_easing = __toESM(require_lib2());

// node_modules/react-use/esm/useUnmountPromise.js
var import_react128 = __toESM(require_react());

// node_modules/react-use/esm/useUpsert.js
init_tslib_es6();

// node_modules/react-use/esm/useVibrate.js
var import_react129 = __toESM(require_react());
var isVibrationApiSupported = isNavigator && "vibrate" in navigator;

// node_modules/react-use/esm/useVideo.js
var useVideo = createHTMLMediaHook("video");

// node_modules/react-use/esm/useStateValidator.js
var import_react130 = __toESM(require_react());

// node_modules/react-use/esm/useScrollbarWidth.js
var import_react131 = __toESM(require_react());

// node_modules/react-use/esm/useMultiStateValidator.js
var import_react132 = __toESM(require_react());

// node_modules/react-use/esm/useWindowScroll.js
var import_react133 = __toESM(require_react());

// node_modules/react-use/esm/useWindowSize.js
var import_react134 = __toESM(require_react());

// node_modules/react-use/esm/useMeasure.js
var import_react135 = __toESM(require_react());
var defaultState = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  top: 0,
  left: 0,
  bottom: 0,
  right: 0
};
function useMeasure() {
  var _a2 = (0, import_react135.useState)(null), element = _a2[0], ref = _a2[1];
  var _b = (0, import_react135.useState)(defaultState), rect = _b[0], setRect = _b[1];
  var observer = (0, import_react135.useMemo)(function() {
    return new window.ResizeObserver(function(entries) {
      if (entries[0]) {
        var _a3 = entries[0].contentRect, x2 = _a3.x, y3 = _a3.y, width = _a3.width, height = _a3.height, top_1 = _a3.top, left2 = _a3.left, bottom2 = _a3.bottom, right2 = _a3.right;
        setRect({ x: x2, y: y3, width, height, top: top_1, left: left2, bottom: bottom2, right: right2 });
      }
    });
  }, []);
  useIsomorphicLayoutEffect_default(function() {
    if (!element)
      return;
    observer.observe(element);
    return function() {
      observer.disconnect();
    };
  }, [element]);
  return [ref, rect];
}
var useMeasure_default = isBrowser && typeof window.ResizeObserver !== "undefined" ? useMeasure : function() {
  return [noop, defaultState];
};

// node_modules/react-use/esm/usePinchZoom.js
var import_react136 = __toESM(require_react());
var ZoomState;
(function(ZoomState2) {
  ZoomState2["ZOOMING_IN"] = "ZOOMING_IN";
  ZoomState2["ZOOMING_OUT"] = "ZOOMING_OUT";
})(ZoomState || (ZoomState = {}));

// node_modules/react-use/esm/useRendersCount.js
var import_react137 = __toESM(require_react());

// node_modules/react-use/esm/useSet.js
init_tslib_es6();
var import_react138 = __toESM(require_react());

// node_modules/react-use/esm/factory/createGlobalState.js
var import_react139 = __toESM(require_react());

// node_modules/react-use/esm/useHash.js
var import_react140 = __toESM(require_react());

// node_modules/react-dropzone/dist/es/index.js
var import_react141 = __toESM(require_react());
var import_prop_types8 = __toESM(require_prop_types());

// node_modules/file-selector/dist/es5/file-selector.js
init_tslib_es6();

// node_modules/file-selector/dist/es5/file.js
var COMMON_MIME_TYPES = /* @__PURE__ */ new Map([
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
  ["aac", "audio/aac"],
  ["abw", "application/x-abiword"],
  ["arc", "application/x-freearc"],
  ["avif", "image/avif"],
  ["avi", "video/x-msvideo"],
  ["azw", "application/vnd.amazon.ebook"],
  ["bin", "application/octet-stream"],
  ["bmp", "image/bmp"],
  ["bz", "application/x-bzip"],
  ["bz2", "application/x-bzip2"],
  ["cda", "application/x-cdf"],
  ["csh", "application/x-csh"],
  ["css", "text/css"],
  ["csv", "text/csv"],
  ["doc", "application/msword"],
  ["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
  ["eot", "application/vnd.ms-fontobject"],
  ["epub", "application/epub+zip"],
  ["gz", "application/gzip"],
  ["gif", "image/gif"],
  ["heic", "image/heic"],
  ["heif", "image/heif"],
  ["htm", "text/html"],
  ["html", "text/html"],
  ["ico", "image/vnd.microsoft.icon"],
  ["ics", "text/calendar"],
  ["jar", "application/java-archive"],
  ["jpeg", "image/jpeg"],
  ["jpg", "image/jpeg"],
  ["js", "text/javascript"],
  ["json", "application/json"],
  ["jsonld", "application/ld+json"],
  ["mid", "audio/midi"],
  ["midi", "audio/midi"],
  ["mjs", "text/javascript"],
  ["mp3", "audio/mpeg"],
  ["mp4", "video/mp4"],
  ["mpeg", "video/mpeg"],
  ["mpkg", "application/vnd.apple.installer+xml"],
  ["odp", "application/vnd.oasis.opendocument.presentation"],
  ["ods", "application/vnd.oasis.opendocument.spreadsheet"],
  ["odt", "application/vnd.oasis.opendocument.text"],
  ["oga", "audio/ogg"],
  ["ogv", "video/ogg"],
  ["ogx", "application/ogg"],
  ["opus", "audio/opus"],
  ["otf", "font/otf"],
  ["png", "image/png"],
  ["pdf", "application/pdf"],
  ["php", "application/x-httpd-php"],
  ["ppt", "application/vnd.ms-powerpoint"],
  ["pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"],
  ["rar", "application/vnd.rar"],
  ["rtf", "application/rtf"],
  ["sh", "application/x-sh"],
  ["svg", "image/svg+xml"],
  ["swf", "application/x-shockwave-flash"],
  ["tar", "application/x-tar"],
  ["tif", "image/tiff"],
  ["tiff", "image/tiff"],
  ["ts", "video/mp2t"],
  ["ttf", "font/ttf"],
  ["txt", "text/plain"],
  ["vsd", "application/vnd.visio"],
  ["wav", "audio/wav"],
  ["weba", "audio/webm"],
  ["webm", "video/webm"],
  ["webp", "image/webp"],
  ["woff", "font/woff"],
  ["woff2", "font/woff2"],
  ["xhtml", "application/xhtml+xml"],
  ["xls", "application/vnd.ms-excel"],
  ["xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
  ["xml", "application/xml"],
  ["xul", "application/vnd.mozilla.xul+xml"],
  ["zip", "application/zip"],
  ["7z", "application/x-7z-compressed"],
  // Others
  ["mkv", "video/x-matroska"],
  ["mov", "video/quicktime"],
  ["msg", "application/vnd.ms-outlook"]
]);
function toFileWithPath(file, path) {
  var f = withMimeType(file);
  if (typeof f.path !== "string") {
    var webkitRelativePath = file.webkitRelativePath;
    Object.defineProperty(f, "path", {
      value: typeof path === "string" ? path : typeof webkitRelativePath === "string" && webkitRelativePath.length > 0 ? webkitRelativePath : file.name,
      writable: false,
      configurable: false,
      enumerable: true
    });
  }
  return f;
}
function withMimeType(file) {
  var name2 = file.name;
  var hasExtension = name2 && name2.lastIndexOf(".") !== -1;
  if (hasExtension && !file.type) {
    var ext = name2.split(".").pop().toLowerCase();
    var type = COMMON_MIME_TYPES.get(ext);
    if (type) {
      Object.defineProperty(file, "type", {
        value: type,
        writable: false,
        configurable: false,
        enumerable: true
      });
    }
  }
  return file;
}

// node_modules/file-selector/dist/es5/file-selector.js
var FILES_TO_IGNORE = [
  // Thumbnail cache files for macOS and Windows
  ".DS_Store",
  "Thumbs.db"
  // Windows
];
function fromEvent(evt) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      if (isObject(evt) && isDataTransfer(evt.dataTransfer)) {
        return [2, getDataTransferFiles(evt.dataTransfer, evt.type)];
      } else if (isChangeEvt(evt)) {
        return [2, getInputFiles(evt)];
      } else if (Array.isArray(evt) && evt.every(function(item) {
        return "getFile" in item && typeof item.getFile === "function";
      })) {
        return [2, getFsHandleFiles(evt)];
      }
      return [2, []];
    });
  });
}
function isDataTransfer(value) {
  return isObject(value);
}
function isChangeEvt(value) {
  return isObject(value) && isObject(value.target);
}
function isObject(v) {
  return typeof v === "object" && v !== null;
}
function getInputFiles(evt) {
  return fromList(evt.target.files).map(function(file) {
    return toFileWithPath(file);
  });
}
function getFsHandleFiles(handles) {
  return __awaiter(this, void 0, void 0, function() {
    var files;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          return [4, Promise.all(handles.map(function(h3) {
            return h3.getFile();
          }))];
        case 1:
          files = _a2.sent();
          return [2, files.map(function(file) {
            return toFileWithPath(file);
          })];
      }
    });
  });
}
function getDataTransferFiles(dt2, type) {
  return __awaiter(this, void 0, void 0, function() {
    var items, files;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          if (!dt2.items)
            return [3, 2];
          items = fromList(dt2.items).filter(function(item) {
            return item.kind === "file";
          });
          if (type !== "drop") {
            return [2, items];
          }
          return [4, Promise.all(items.map(toFilePromises))];
        case 1:
          files = _a2.sent();
          return [2, noIgnoredFiles(flatten(files))];
        case 2:
          return [2, noIgnoredFiles(fromList(dt2.files).map(function(file) {
            return toFileWithPath(file);
          }))];
      }
    });
  });
}
function noIgnoredFiles(files) {
  return files.filter(function(file) {
    return FILES_TO_IGNORE.indexOf(file.name) === -1;
  });
}
function fromList(items) {
  if (items === null) {
    return [];
  }
  var files = [];
  for (var i2 = 0; i2 < items.length; i2++) {
    var file = items[i2];
    files.push(file);
  }
  return files;
}
function toFilePromises(item) {
  if (typeof item.webkitGetAsEntry !== "function") {
    return fromDataTransferItem(item);
  }
  var entry = item.webkitGetAsEntry();
  if (entry && entry.isDirectory) {
    return fromDirEntry(entry);
  }
  return fromDataTransferItem(item);
}
function flatten(items) {
  return items.reduce(function(acc, files) {
    return __spreadArray(__spreadArray([], __read(acc), false), __read(Array.isArray(files) ? flatten(files) : [files]), false);
  }, []);
}
function fromDataTransferItem(item) {
  var file = item.getAsFile();
  if (!file) {
    return Promise.reject("".concat(item, " is not a File"));
  }
  var fwp = toFileWithPath(file);
  return Promise.resolve(fwp);
}
function fromEntry(entry) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, entry.isDirectory ? fromDirEntry(entry) : fromFileEntry(entry)];
    });
  });
}
function fromDirEntry(entry) {
  var reader = entry.createReader();
  return new Promise(function(resolve, reject) {
    var entries = [];
    function readEntries() {
      var _this = this;
      reader.readEntries(function(batch) {
        return __awaiter(_this, void 0, void 0, function() {
          var files, err_1, items;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!!batch.length)
                  return [3, 5];
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 4]);
                return [4, Promise.all(entries)];
              case 2:
                files = _a2.sent();
                resolve(files);
                return [3, 4];
              case 3:
                err_1 = _a2.sent();
                reject(err_1);
                return [3, 4];
              case 4:
                return [3, 6];
              case 5:
                items = Promise.all(batch.map(fromEntry));
                entries.push(items);
                readEntries();
                _a2.label = 6;
              case 6:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, function(err) {
        reject(err);
      });
    }
    readEntries();
  });
}
function fromFileEntry(entry) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, new Promise(function(resolve, reject) {
        entry.file(function(file) {
          var fwp = toFileWithPath(file, entry.fullPath);
          resolve(fwp);
        }, function(err) {
          reject(err);
        });
      })];
    });
  });
}

// node_modules/react-dropzone/dist/es/utils/index.js
var import_attr_accept = __toESM(require_es());
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray2(arr);
}
function ownKeys(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray2(arr, i2) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray2(o, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e2;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e2 = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e2;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
var FILE_INVALID_TYPE = "file-invalid-type";
var FILE_TOO_LARGE = "file-too-large";
var FILE_TOO_SMALL = "file-too-small";
var TOO_MANY_FILES = "too-many-files";
var getInvalidTypeRejectionErr = function getInvalidTypeRejectionErr2(accept) {
  accept = Array.isArray(accept) && accept.length === 1 ? accept[0] : accept;
  var messageSuffix = Array.isArray(accept) ? "one of ".concat(accept.join(", ")) : accept;
  return {
    code: FILE_INVALID_TYPE,
    message: "File type must be ".concat(messageSuffix)
  };
};
var getTooLargeRejectionErr = function getTooLargeRejectionErr2(maxSize) {
  return {
    code: FILE_TOO_LARGE,
    message: "File is larger than ".concat(maxSize, " ").concat(maxSize === 1 ? "byte" : "bytes")
  };
};
var getTooSmallRejectionErr = function getTooSmallRejectionErr2(minSize) {
  return {
    code: FILE_TOO_SMALL,
    message: "File is smaller than ".concat(minSize, " ").concat(minSize === 1 ? "byte" : "bytes")
  };
};
var TOO_MANY_FILES_REJECTION = {
  code: TOO_MANY_FILES,
  message: "Too many files"
};
function fileAccepted(file, accept) {
  var isAcceptable = file.type === "application/x-moz-file" || (0, import_attr_accept.default)(file, accept);
  return [isAcceptable, isAcceptable ? null : getInvalidTypeRejectionErr(accept)];
}
function fileMatchSize(file, minSize, maxSize) {
  if (isDefined2(file.size)) {
    if (isDefined2(minSize) && isDefined2(maxSize)) {
      if (file.size > maxSize)
        return [false, getTooLargeRejectionErr(maxSize)];
      if (file.size < minSize)
        return [false, getTooSmallRejectionErr(minSize)];
    } else if (isDefined2(minSize) && file.size < minSize)
      return [false, getTooSmallRejectionErr(minSize)];
    else if (isDefined2(maxSize) && file.size > maxSize)
      return [false, getTooLargeRejectionErr(maxSize)];
  }
  return [true, null];
}
function isDefined2(value) {
  return value !== void 0 && value !== null;
}
function allFilesAccepted(_ref4) {
  var files = _ref4.files, accept = _ref4.accept, minSize = _ref4.minSize, maxSize = _ref4.maxSize, multiple = _ref4.multiple, maxFiles = _ref4.maxFiles, validator = _ref4.validator;
  if (!multiple && files.length > 1 || multiple && maxFiles >= 1 && files.length > maxFiles) {
    return false;
  }
  return files.every(function(file) {
    var _fileAccepted = fileAccepted(file, accept), _fileAccepted2 = _slicedToArray(_fileAccepted, 1), accepted = _fileAccepted2[0];
    var _fileMatchSize = fileMatchSize(file, minSize, maxSize), _fileMatchSize2 = _slicedToArray(_fileMatchSize, 1), sizeMatch = _fileMatchSize2[0];
    var customErrors = validator ? validator(file) : null;
    return accepted && sizeMatch && !customErrors;
  });
}
function isPropagationStopped(event) {
  if (typeof event.isPropagationStopped === "function") {
    return event.isPropagationStopped();
  } else if (typeof event.cancelBubble !== "undefined") {
    return event.cancelBubble;
  }
  return false;
}
function isEvtWithFiles(event) {
  if (!event.dataTransfer) {
    return !!event.target && !!event.target.files;
  }
  return Array.prototype.some.call(event.dataTransfer.types, function(type) {
    return type === "Files" || type === "application/x-moz-file";
  });
}
function onDocumentDragOver(event) {
  event.preventDefault();
}
function isIe(userAgent) {
  return userAgent.indexOf("MSIE") !== -1 || userAgent.indexOf("Trident/") !== -1;
}
function isEdge(userAgent) {
  return userAgent.indexOf("Edge/") !== -1;
}
function isIeOrEdge() {
  var userAgent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.navigator.userAgent;
  return isIe(userAgent) || isEdge(userAgent);
}
function composeEventHandlers() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }
  return function(event) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    return fns.some(function(fn2) {
      if (!isPropagationStopped(event) && fn2) {
        fn2.apply(void 0, [event].concat(args));
      }
      return isPropagationStopped(event);
    });
  };
}
function canUseFileSystemAccessAPI() {
  return "showOpenFilePicker" in window;
}
function pickerOptionsFromAccept(accept) {
  if (isDefined2(accept)) {
    var acceptForPicker = Object.entries(accept).filter(function(_ref23) {
      var _ref32 = _slicedToArray(_ref23, 2), mimeType = _ref32[0], ext = _ref32[1];
      var ok = true;
      if (!isMIMEType(mimeType)) {
        console.warn('Skipped "'.concat(mimeType, '" because it is not a valid MIME type. Check https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types for a list of valid MIME types.'));
        ok = false;
      }
      if (!Array.isArray(ext) || !ext.every(isExt)) {
        console.warn('Skipped "'.concat(mimeType, '" because an invalid file extension was provided.'));
        ok = false;
      }
      return ok;
    }).reduce(function(agg, _ref4) {
      var _ref5 = _slicedToArray(_ref4, 2), mimeType = _ref5[0], ext = _ref5[1];
      return _objectSpread(_objectSpread({}, agg), {}, _defineProperty2({}, mimeType, ext));
    }, {});
    return [{
      // description is required due to https://crbug.com/1264708
      description: "Files",
      accept: acceptForPicker
    }];
  }
  return accept;
}
function acceptPropAsAcceptAttr(accept) {
  if (isDefined2(accept)) {
    return Object.entries(accept).reduce(function(a3, _ref6) {
      var _ref7 = _slicedToArray(_ref6, 2), mimeType = _ref7[0], ext = _ref7[1];
      return [].concat(_toConsumableArray(a3), [mimeType], _toConsumableArray(ext));
    }, []).filter(function(v) {
      return isMIMEType(v) || isExt(v);
    }).join(",");
  }
  return void 0;
}
function isAbort(v) {
  return v instanceof DOMException && (v.name === "AbortError" || v.code === v.ABORT_ERR);
}
function isSecurityError(v) {
  return v instanceof DOMException && (v.name === "SecurityError" || v.code === v.SECURITY_ERR);
}
function isMIMEType(v) {
  return v === "audio/*" || v === "video/*" || v === "image/*" || v === "text/*" || /\w+\/[-+.\w]+/g.test(v);
}
function isExt(v) {
  return /^.*\.[\w]+$/.test(v);
}

// node_modules/react-dropzone/dist/es/index.js
var _excluded = ["children"];
var _excluded2 = ["open"];
var _excluded3 = ["refKey", "role", "onKeyDown", "onFocus", "onBlur", "onClick", "onDragEnter", "onDragOver", "onDragLeave", "onDrop"];
var _excluded4 = ["refKey", "onChange", "onClick"];
function _toConsumableArray2(arr) {
  return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray3(arr) || _nonIterableSpread2();
}
function _nonIterableSpread2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray2(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles2(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray3(arr);
}
function _slicedToArray2(arr, i2) {
  return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i2) || _unsupportedIterableToArray3(arr, i2) || _nonIterableRest2();
}
function _nonIterableRest2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray3(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray3(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray3(o, minLen);
}
function _arrayLikeToArray3(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _iterableToArrayLimit2(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e2;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e2 = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e2;
    }
  }
  return _arr;
}
function _arrayWithHoles2(arr) {
  if (Array.isArray(arr))
    return arr;
}
function ownKeys2(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty3(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose3(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose3(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var Dropzone = (0, import_react141.forwardRef)(function(_ref4, ref) {
  var children = _ref4.children, params = _objectWithoutProperties(_ref4, _excluded);
  var _useDropzone = useDropzone(params), open = _useDropzone.open, props = _objectWithoutProperties(_useDropzone, _excluded2);
  (0, import_react141.useImperativeHandle)(ref, function() {
    return {
      open
    };
  }, [open]);
  return import_react141.default.createElement(import_react141.Fragment, null, children(_objectSpread2(_objectSpread2({}, props), {}, {
    open
  })));
});
Dropzone.displayName = "Dropzone";
var defaultProps = {
  disabled: false,
  getFilesFromEvent: fromEvent,
  maxSize: Infinity,
  minSize: 0,
  multiple: true,
  maxFiles: 0,
  preventDropOnDocument: true,
  noClick: false,
  noKeyboard: false,
  noDrag: false,
  noDragEventsBubbling: false,
  validator: null,
  useFsAccessApi: true,
  autoFocus: false
};
Dropzone.defaultProps = defaultProps;
Dropzone.propTypes = {
  /**
   * Render function that exposes the dropzone state and prop getter fns
   *
   * @param {object} params
   * @param {Function} params.getRootProps Returns the props you should apply to the root drop container you render
   * @param {Function} params.getInputProps Returns the props you should apply to hidden file input you render
   * @param {Function} params.open Open the native file selection dialog
   * @param {boolean} params.isFocused Dropzone area is in focus
   * @param {boolean} params.isFileDialogActive File dialog is opened
   * @param {boolean} params.isDragActive Active drag is in progress
   * @param {boolean} params.isDragAccept Dragged files are accepted
   * @param {boolean} params.isDragReject Some dragged files are rejected
   * @param {File[]} params.acceptedFiles Accepted files
   * @param {FileRejection[]} params.fileRejections Rejected files and why they were rejected
   */
  children: import_prop_types8.default.func,
  /**
   * Set accepted file types.
   * Checkout https://developer.mozilla.org/en-US/docs/Web/API/window/showOpenFilePicker types option for more information.
   * Keep in mind that mime type determination is not reliable across platforms. CSV files,
   * for example, are reported as text/plain under macOS but as application/vnd.ms-excel under
   * Windows. In some cases there might not be a mime type set at all (https://github.com/react-dropzone/react-dropzone/issues/276).
   */
  accept: import_prop_types8.default.objectOf(import_prop_types8.default.arrayOf(import_prop_types8.default.string)),
  /**
   * Allow drag 'n' drop (or selection from the file dialog) of multiple files
   */
  multiple: import_prop_types8.default.bool,
  /**
   * If false, allow dropped items to take over the current browser window
   */
  preventDropOnDocument: import_prop_types8.default.bool,
  /**
   * If true, disables click to open the native file selection dialog
   */
  noClick: import_prop_types8.default.bool,
  /**
   * If true, disables SPACE/ENTER to open the native file selection dialog.
   * Note that it also stops tracking the focus state.
   */
  noKeyboard: import_prop_types8.default.bool,
  /**
   * If true, disables drag 'n' drop
   */
  noDrag: import_prop_types8.default.bool,
  /**
   * If true, stops drag event propagation to parents
   */
  noDragEventsBubbling: import_prop_types8.default.bool,
  /**
   * Minimum file size (in bytes)
   */
  minSize: import_prop_types8.default.number,
  /**
   * Maximum file size (in bytes)
   */
  maxSize: import_prop_types8.default.number,
  /**
   * Maximum accepted number of files
   * The default value is 0 which means there is no limitation to how many files are accepted.
   */
  maxFiles: import_prop_types8.default.number,
  /**
   * Enable/disable the dropzone
   */
  disabled: import_prop_types8.default.bool,
  /**
   * Use this to provide a custom file aggregator
   *
   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
   */
  getFilesFromEvent: import_prop_types8.default.func,
  /**
   * Cb for when closing the file dialog with no selection
   */
  onFileDialogCancel: import_prop_types8.default.func,
  /**
   * Cb for when opening the file dialog
   */
  onFileDialogOpen: import_prop_types8.default.func,
  /**
   * Set to true to use the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API
   * to open the file picker instead of using an `<input type="file">` click event.
   */
  useFsAccessApi: import_prop_types8.default.bool,
  /**
   * Set to true to focus the root element on render
   */
  autoFocus: import_prop_types8.default.bool,
  /**
   * Cb for when the `dragenter` event occurs.
   *
   * @param {DragEvent} event
   */
  onDragEnter: import_prop_types8.default.func,
  /**
   * Cb for when the `dragleave` event occurs
   *
   * @param {DragEvent} event
   */
  onDragLeave: import_prop_types8.default.func,
  /**
   * Cb for when the `dragover` event occurs
   *
   * @param {DragEvent} event
   */
  onDragOver: import_prop_types8.default.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that this callback is invoked after the `getFilesFromEvent` callback is done.
   *
   * Files are accepted or rejected based on the `accept`, `multiple`, `minSize` and `maxSize` props.
   * `accept` must be a valid [MIME type](http://www.iana.org/assignments/media-types/media-types.xhtml) according to [input element specification](https://www.w3.org/wiki/HTML/Elements/input/file) or a valid file extension.
   * If `multiple` is set to false and additional files are dropped,
   * all files besides the first will be rejected.
   * Any file which does not have a size in the [`minSize`, `maxSize`] range, will be rejected as well.
   *
   * Note that the `onDrop` callback will always be invoked regardless if the dropped files were accepted or rejected.
   * If you'd like to react to a specific scenario, use the `onDropAccepted`/`onDropRejected` props.
   *
   * `onDrop` will provide you with an array of [File](https://developer.mozilla.org/en-US/docs/Web/API/File) objects which you can then process and send to a server.
   * For example, with [SuperAgent](https://github.com/visionmedia/superagent) as a http/ajax library:
   *
   * ```js
   * function onDrop(acceptedFiles) {
   *   const req = request.post('/upload')
   *   acceptedFiles.forEach(file => {
   *     req.attach(file.name, file)
   *   })
   *   req.end(callback)
   * }
   * ```
   *
   * @param {File[]} acceptedFiles
   * @param {FileRejection[]} fileRejections
   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
   */
  onDrop: import_prop_types8.default.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that if no files are accepted, this callback is not invoked.
   *
   * @param {File[]} files
   * @param {(DragEvent|Event)} event
   */
  onDropAccepted: import_prop_types8.default.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that if no files are rejected, this callback is not invoked.
   *
   * @param {FileRejection[]} fileRejections
   * @param {(DragEvent|Event)} event
   */
  onDropRejected: import_prop_types8.default.func,
  /**
   * Cb for when there's some error from any of the promises.
   *
   * @param {Error} error
   */
  onError: import_prop_types8.default.func,
  /**
   * Custom validation function. It must return null if there's no errors.
   * @param {File} file
   * @returns {FileError|FileError[]|null}
   */
  validator: import_prop_types8.default.func
};
var initialState = {
  isFocused: false,
  isFileDialogActive: false,
  isDragActive: false,
  isDragAccept: false,
  isDragReject: false,
  acceptedFiles: [],
  fileRejections: []
};
function useDropzone() {
  var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var _defaultProps$props = _objectSpread2(_objectSpread2({}, defaultProps), props), accept = _defaultProps$props.accept, disabled = _defaultProps$props.disabled, getFilesFromEvent = _defaultProps$props.getFilesFromEvent, maxSize = _defaultProps$props.maxSize, minSize = _defaultProps$props.minSize, multiple = _defaultProps$props.multiple, maxFiles = _defaultProps$props.maxFiles, onDragEnter = _defaultProps$props.onDragEnter, onDragLeave = _defaultProps$props.onDragLeave, onDragOver = _defaultProps$props.onDragOver, onDrop = _defaultProps$props.onDrop, onDropAccepted = _defaultProps$props.onDropAccepted, onDropRejected = _defaultProps$props.onDropRejected, onFileDialogCancel = _defaultProps$props.onFileDialogCancel, onFileDialogOpen = _defaultProps$props.onFileDialogOpen, useFsAccessApi = _defaultProps$props.useFsAccessApi, autoFocus = _defaultProps$props.autoFocus, preventDropOnDocument = _defaultProps$props.preventDropOnDocument, noClick = _defaultProps$props.noClick, noKeyboard = _defaultProps$props.noKeyboard, noDrag = _defaultProps$props.noDrag, noDragEventsBubbling = _defaultProps$props.noDragEventsBubbling, onError = _defaultProps$props.onError, validator = _defaultProps$props.validator;
  var acceptAttr = (0, import_react141.useMemo)(function() {
    return acceptPropAsAcceptAttr(accept);
  }, [accept]);
  var pickerTypes = (0, import_react141.useMemo)(function() {
    return pickerOptionsFromAccept(accept);
  }, [accept]);
  var onFileDialogOpenCb = (0, import_react141.useMemo)(function() {
    return typeof onFileDialogOpen === "function" ? onFileDialogOpen : noop2;
  }, [onFileDialogOpen]);
  var onFileDialogCancelCb = (0, import_react141.useMemo)(function() {
    return typeof onFileDialogCancel === "function" ? onFileDialogCancel : noop2;
  }, [onFileDialogCancel]);
  var rootRef = (0, import_react141.useRef)(null);
  var inputRef = (0, import_react141.useRef)(null);
  var _useReducer = (0, import_react141.useReducer)(reducer, initialState), _useReducer2 = _slicedToArray2(_useReducer, 2), state = _useReducer2[0], dispatch = _useReducer2[1];
  var isFocused = state.isFocused, isFileDialogActive = state.isFileDialogActive;
  var fsAccessApiWorksRef = (0, import_react141.useRef)(typeof window !== "undefined" && window.isSecureContext && useFsAccessApi && canUseFileSystemAccessAPI());
  var onWindowFocus = function onWindowFocus2() {
    if (!fsAccessApiWorksRef.current && isFileDialogActive) {
      setTimeout(function() {
        if (inputRef.current) {
          var files = inputRef.current.files;
          if (!files.length) {
            dispatch({
              type: "closeDialog"
            });
            onFileDialogCancelCb();
          }
        }
      }, 300);
    }
  };
  (0, import_react141.useEffect)(function() {
    window.addEventListener("focus", onWindowFocus, false);
    return function() {
      window.removeEventListener("focus", onWindowFocus, false);
    };
  }, [inputRef, isFileDialogActive, onFileDialogCancelCb, fsAccessApiWorksRef]);
  var dragTargetsRef = (0, import_react141.useRef)([]);
  var onDocumentDrop = function onDocumentDrop2(event) {
    if (rootRef.current && rootRef.current.contains(event.target)) {
      return;
    }
    event.preventDefault();
    dragTargetsRef.current = [];
  };
  (0, import_react141.useEffect)(function() {
    if (preventDropOnDocument) {
      document.addEventListener("dragover", onDocumentDragOver, false);
      document.addEventListener("drop", onDocumentDrop, false);
    }
    return function() {
      if (preventDropOnDocument) {
        document.removeEventListener("dragover", onDocumentDragOver);
        document.removeEventListener("drop", onDocumentDrop);
      }
    };
  }, [rootRef, preventDropOnDocument]);
  (0, import_react141.useEffect)(function() {
    if (!disabled && autoFocus && rootRef.current) {
      rootRef.current.focus();
    }
    return function() {
    };
  }, [rootRef, autoFocus, disabled]);
  var onErrCb = (0, import_react141.useCallback)(function(e4) {
    if (onError) {
      onError(e4);
    } else {
      console.error(e4);
    }
  }, [onError]);
  var onDragEnterCb = (0, import_react141.useCallback)(function(event) {
    event.preventDefault();
    event.persist();
    stopPropagation(event);
    dragTargetsRef.current = [].concat(_toConsumableArray2(dragTargetsRef.current), [event.target]);
    if (isEvtWithFiles(event)) {
      Promise.resolve(getFilesFromEvent(event)).then(function(files) {
        if (isPropagationStopped(event) && !noDragEventsBubbling) {
          return;
        }
        var fileCount = files.length;
        var isDragAccept = fileCount > 0 && allFilesAccepted({
          files,
          accept: acceptAttr,
          minSize,
          maxSize,
          multiple,
          maxFiles,
          validator
        });
        var isDragReject = fileCount > 0 && !isDragAccept;
        dispatch({
          isDragAccept,
          isDragReject,
          isDragActive: true,
          type: "setDraggedFiles"
        });
        if (onDragEnter) {
          onDragEnter(event);
        }
      }).catch(function(e4) {
        return onErrCb(e4);
      });
    }
  }, [getFilesFromEvent, onDragEnter, onErrCb, noDragEventsBubbling, acceptAttr, minSize, maxSize, multiple, maxFiles, validator]);
  var onDragOverCb = (0, import_react141.useCallback)(function(event) {
    event.preventDefault();
    event.persist();
    stopPropagation(event);
    var hasFiles = isEvtWithFiles(event);
    if (hasFiles && event.dataTransfer) {
      try {
        event.dataTransfer.dropEffect = "copy";
      } catch (_unused) {
      }
    }
    if (hasFiles && onDragOver) {
      onDragOver(event);
    }
    return false;
  }, [onDragOver, noDragEventsBubbling]);
  var onDragLeaveCb = (0, import_react141.useCallback)(function(event) {
    event.preventDefault();
    event.persist();
    stopPropagation(event);
    var targets = dragTargetsRef.current.filter(function(target) {
      return rootRef.current && rootRef.current.contains(target);
    });
    var targetIdx = targets.indexOf(event.target);
    if (targetIdx !== -1) {
      targets.splice(targetIdx, 1);
    }
    dragTargetsRef.current = targets;
    if (targets.length > 0) {
      return;
    }
    dispatch({
      type: "setDraggedFiles",
      isDragActive: false,
      isDragAccept: false,
      isDragReject: false
    });
    if (isEvtWithFiles(event) && onDragLeave) {
      onDragLeave(event);
    }
  }, [rootRef, onDragLeave, noDragEventsBubbling]);
  var setFiles = (0, import_react141.useCallback)(function(files, event) {
    var acceptedFiles = [];
    var fileRejections = [];
    files.forEach(function(file) {
      var _fileAccepted = fileAccepted(file, acceptAttr), _fileAccepted2 = _slicedToArray2(_fileAccepted, 2), accepted = _fileAccepted2[0], acceptError = _fileAccepted2[1];
      var _fileMatchSize = fileMatchSize(file, minSize, maxSize), _fileMatchSize2 = _slicedToArray2(_fileMatchSize, 2), sizeMatch = _fileMatchSize2[0], sizeError = _fileMatchSize2[1];
      var customErrors = validator ? validator(file) : null;
      if (accepted && sizeMatch && !customErrors) {
        acceptedFiles.push(file);
      } else {
        var errors = [acceptError, sizeError];
        if (customErrors) {
          errors = errors.concat(customErrors);
        }
        fileRejections.push({
          file,
          errors: errors.filter(function(e4) {
            return e4;
          })
        });
      }
    });
    if (!multiple && acceptedFiles.length > 1 || multiple && maxFiles >= 1 && acceptedFiles.length > maxFiles) {
      acceptedFiles.forEach(function(file) {
        fileRejections.push({
          file,
          errors: [TOO_MANY_FILES_REJECTION]
        });
      });
      acceptedFiles.splice(0);
    }
    dispatch({
      acceptedFiles,
      fileRejections,
      type: "setFiles"
    });
    if (onDrop) {
      onDrop(acceptedFiles, fileRejections, event);
    }
    if (fileRejections.length > 0 && onDropRejected) {
      onDropRejected(fileRejections, event);
    }
    if (acceptedFiles.length > 0 && onDropAccepted) {
      onDropAccepted(acceptedFiles, event);
    }
  }, [dispatch, multiple, acceptAttr, minSize, maxSize, maxFiles, onDrop, onDropAccepted, onDropRejected, validator]);
  var onDropCb = (0, import_react141.useCallback)(function(event) {
    event.preventDefault();
    event.persist();
    stopPropagation(event);
    dragTargetsRef.current = [];
    if (isEvtWithFiles(event)) {
      Promise.resolve(getFilesFromEvent(event)).then(function(files) {
        if (isPropagationStopped(event) && !noDragEventsBubbling) {
          return;
        }
        setFiles(files, event);
      }).catch(function(e4) {
        return onErrCb(e4);
      });
    }
    dispatch({
      type: "reset"
    });
  }, [getFilesFromEvent, setFiles, onErrCb, noDragEventsBubbling]);
  var openFileDialog = (0, import_react141.useCallback)(function() {
    if (fsAccessApiWorksRef.current) {
      dispatch({
        type: "openDialog"
      });
      onFileDialogOpenCb();
      var opts = {
        multiple,
        types: pickerTypes
      };
      window.showOpenFilePicker(opts).then(function(handles) {
        return getFilesFromEvent(handles);
      }).then(function(files) {
        setFiles(files, null);
        dispatch({
          type: "closeDialog"
        });
      }).catch(function(e4) {
        if (isAbort(e4)) {
          onFileDialogCancelCb(e4);
          dispatch({
            type: "closeDialog"
          });
        } else if (isSecurityError(e4)) {
          fsAccessApiWorksRef.current = false;
          if (inputRef.current) {
            inputRef.current.value = null;
            inputRef.current.click();
          } else {
            onErrCb(new Error("Cannot open the file picker because the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API is not supported and no <input> was provided."));
          }
        } else {
          onErrCb(e4);
        }
      });
      return;
    }
    if (inputRef.current) {
      dispatch({
        type: "openDialog"
      });
      onFileDialogOpenCb();
      inputRef.current.value = null;
      inputRef.current.click();
    }
  }, [dispatch, onFileDialogOpenCb, onFileDialogCancelCb, useFsAccessApi, setFiles, onErrCb, pickerTypes, multiple]);
  var onKeyDownCb = (0, import_react141.useCallback)(function(event) {
    if (!rootRef.current || !rootRef.current.isEqualNode(event.target)) {
      return;
    }
    if (event.key === " " || event.key === "Enter" || event.keyCode === 32 || event.keyCode === 13) {
      event.preventDefault();
      openFileDialog();
    }
  }, [rootRef, openFileDialog]);
  var onFocusCb = (0, import_react141.useCallback)(function() {
    dispatch({
      type: "focus"
    });
  }, []);
  var onBlurCb = (0, import_react141.useCallback)(function() {
    dispatch({
      type: "blur"
    });
  }, []);
  var onClickCb = (0, import_react141.useCallback)(function() {
    if (noClick) {
      return;
    }
    if (isIeOrEdge()) {
      setTimeout(openFileDialog, 0);
    } else {
      openFileDialog();
    }
  }, [noClick, openFileDialog]);
  var composeHandler = function composeHandler2(fn2) {
    return disabled ? null : fn2;
  };
  var composeKeyboardHandler = function composeKeyboardHandler2(fn2) {
    return noKeyboard ? null : composeHandler(fn2);
  };
  var composeDragHandler = function composeDragHandler2(fn2) {
    return noDrag ? null : composeHandler(fn2);
  };
  var stopPropagation = function stopPropagation2(event) {
    if (noDragEventsBubbling) {
      event.stopPropagation();
    }
  };
  var getRootProps = (0, import_react141.useMemo)(function() {
    return function() {
      var _ref23 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref2$refKey = _ref23.refKey, refKey = _ref2$refKey === void 0 ? "ref" : _ref2$refKey, role = _ref23.role, onKeyDown = _ref23.onKeyDown, onFocus4 = _ref23.onFocus, onBlur3 = _ref23.onBlur, onClick = _ref23.onClick, onDragEnter2 = _ref23.onDragEnter, onDragOver2 = _ref23.onDragOver, onDragLeave2 = _ref23.onDragLeave, onDrop2 = _ref23.onDrop, rest = _objectWithoutProperties(_ref23, _excluded3);
      return _objectSpread2(_objectSpread2(_defineProperty3({
        onKeyDown: composeKeyboardHandler(composeEventHandlers(onKeyDown, onKeyDownCb)),
        onFocus: composeKeyboardHandler(composeEventHandlers(onFocus4, onFocusCb)),
        onBlur: composeKeyboardHandler(composeEventHandlers(onBlur3, onBlurCb)),
        onClick: composeHandler(composeEventHandlers(onClick, onClickCb)),
        onDragEnter: composeDragHandler(composeEventHandlers(onDragEnter2, onDragEnterCb)),
        onDragOver: composeDragHandler(composeEventHandlers(onDragOver2, onDragOverCb)),
        onDragLeave: composeDragHandler(composeEventHandlers(onDragLeave2, onDragLeaveCb)),
        onDrop: composeDragHandler(composeEventHandlers(onDrop2, onDropCb)),
        role: typeof role === "string" && role !== "" ? role : "presentation"
      }, refKey, rootRef), !disabled && !noKeyboard ? {
        tabIndex: 0
      } : {}), rest);
    };
  }, [rootRef, onKeyDownCb, onFocusCb, onBlurCb, onClickCb, onDragEnterCb, onDragOverCb, onDragLeaveCb, onDropCb, noKeyboard, noDrag, disabled]);
  var onInputElementClick = (0, import_react141.useCallback)(function(event) {
    event.stopPropagation();
  }, []);
  var getInputProps = (0, import_react141.useMemo)(function() {
    return function() {
      var _ref32 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref3$refKey = _ref32.refKey, refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey, onChange2 = _ref32.onChange, onClick = _ref32.onClick, rest = _objectWithoutProperties(_ref32, _excluded4);
      var inputProps = _defineProperty3({
        accept: acceptAttr,
        multiple,
        type: "file",
        style: {
          display: "none"
        },
        onChange: composeHandler(composeEventHandlers(onChange2, onDropCb)),
        onClick: composeHandler(composeEventHandlers(onClick, onInputElementClick)),
        tabIndex: -1
      }, refKey, inputRef);
      return _objectSpread2(_objectSpread2({}, inputProps), rest);
    };
  }, [inputRef, accept, multiple, onDropCb, disabled]);
  return _objectSpread2(_objectSpread2({}, state), {}, {
    isFocused: isFocused && !disabled,
    getRootProps,
    getInputProps,
    rootRef,
    inputRef,
    open: composeHandler(openFileDialog)
  });
}
function reducer(state, action) {
  switch (action.type) {
    case "focus":
      return _objectSpread2(_objectSpread2({}, state), {}, {
        isFocused: true
      });
    case "blur":
      return _objectSpread2(_objectSpread2({}, state), {}, {
        isFocused: false
      });
    case "openDialog":
      return _objectSpread2(_objectSpread2({}, initialState), {}, {
        isFileDialogActive: true
      });
    case "closeDialog":
      return _objectSpread2(_objectSpread2({}, state), {}, {
        isFileDialogActive: false
      });
    case "setDraggedFiles":
      return _objectSpread2(_objectSpread2({}, state), {}, {
        isDragActive: action.isDragActive,
        isDragAccept: action.isDragAccept,
        isDragReject: action.isDragReject
      });
    case "setFiles":
      return _objectSpread2(_objectSpread2({}, state), {}, {
        acceptedFiles: action.acceptedFiles,
        fileRejections: action.fileRejections
      });
    case "reset":
      return _objectSpread2({}, initialState);
    default:
      return state;
  }
}
function noop2() {
}

// node_modules/@neo4j-ndl/react/lib/esm/dropzone/Dropzone.js
var __rest23 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var browser = detect();
var isSafari2 = (browser === null || browser === void 0 ? void 0 : browser.name) === "safari";
var Dropzone2 = (props) => {
  const { dropZoneOptions, supportedFilesDescription, loadingComponent, isTesting, customTitle, rejectedMessage, acceptedFileExtensions } = props, otherProps = __rest23(props, ["dropZoneOptions", "supportedFilesDescription", "loadingComponent", "isTesting", "customTitle", "rejectedMessage", "acceptedFileExtensions"]);
  function onDropInterceptor(acceptedFiles, fileRejections, event) {
    var _a2;
    if (acceptedFileExtensions && acceptedFileExtensions.length > 0) {
      for (const file of acceptedFiles) {
        const isAccepted = acceptedFileExtensions.some((extension) => {
          if (file.name.endsWith(extension))
            return true;
        });
        if (!isAccepted) {
          setIsRejected(true);
          return;
        }
      }
    }
    setIsRejected(false);
    (_a2 = dropZoneOptions.onDrop) === null || _a2 === void 0 ? void 0 : _a2.call(dropZoneOptions, acceptedFiles, fileRejections, event);
  }
  const [currentFileExtension, setCurrentFileExtension] = (0, import_react142.useState)(null);
  const [isRejected, setIsRejected] = (0, import_react142.useState)(false);
  const isDisabled = (dropZoneOptions === null || dropZoneOptions === void 0 ? void 0 : dropZoneOptions.disabled) || !!loadingComponent;
  const { getRootProps, getInputProps, isDragActive, isDragAccept, isDragReject, open } = useDropzone(Object.assign(Object.assign({ onDragEnter: (event) => {
    const { items } = event.dataTransfer;
    if (items.length > 0) {
      setCurrentFileExtension(items[0].type);
    }
  }, onDragLeave: () => setCurrentFileExtension(null), noClick: true }, dropZoneOptions), { onDrop: onDropInterceptor, disabled: isDisabled }));
  const [dropZoneRef, { width }] = useMeasure_default();
  const getFileTypeAbbr = (0, import_react142.useCallback)(() => {
    var _a2;
    if (!isDragAccept) {
      return "???";
    } else {
      return (_a2 = currentFileExtension === null || currentFileExtension === void 0 ? void 0 : currentFileExtension.split("/").slice(-1).pop()) === null || _a2 === void 0 ? void 0 : _a2.toUpperCase();
    }
  }, [isDragAccept, currentFileExtension]);
  const isUploading = !!loadingComponent;
  const computedFileImage = isDragActive && isDragAccept || isUploading ? (0, import_jsx_runtime32.jsx)(File_default, {}) : (0, import_jsx_runtime32.jsx)(InvalidFile_default, {});
  const wrapperClasses = classNames("ndl-dropzone", props.className, {
    "ndl-drag-active": isDragActive,
    "ndl-file-invalid": isDragActive && isDragReject,
    "ndl-drag-disabled": dropZoneOptions === null || dropZoneOptions === void 0 ? void 0 : dropZoneOptions.disabled
  });
  (0, import_react142.useMemo)(() => {
    if (isDragActive && isRejected) {
      setIsRejected(false);
    }
  }, [isDragActive, isRejected]);
  return (0, import_jsx_runtime32.jsxs)(import_jsx_runtime32.Fragment, { children: [isRejected && (0, import_jsx_runtime32.jsx)(BannerNamespace, { className: "ndl-dropzone-error-alert", description: rejectedMessage || "Error. File extension not supported.", type: "danger" }), (0, import_jsx_runtime32.jsx)("div", Object.assign({}, otherProps, { ref: dropZoneRef, className: wrapperClasses, children: (0, import_jsx_runtime32.jsxs)("div", Object.assign({ className: "ndl-dropzone-inner-content" }, getRootProps(), { children: [(0, import_jsx_runtime32.jsx)("input", Object.assign({}, getInputProps())), (0, import_jsx_runtime32.jsxs)("div", { className: "ndl-dropzone-inner", children: [(0, import_jsx_runtime32.jsxs)("div", { className: "ndl-dropzone-header", children: [(0, import_jsx_runtime32.jsx)("div", { className: "ndl-upload-img-wrapper", children: width > 230 && (0, import_jsx_runtime32.jsxs)(import_jsx_runtime32.Fragment, { children: [(isDragActive || isUploading) && !isTesting && !isSafari2 && (0, import_jsx_runtime32.jsx)("span", { className: "ndl-upload-img-label", children: getFileTypeAbbr() }), (isUploading || isDragActive) && !isSafari2 ? computedFileImage : (0, import_jsx_runtime32.jsx)(Cloud_default, {})] }) }), !isUploading && (0, import_jsx_runtime32.jsxs)("div", { className: "ndl-dnd-title-container", children: [(0, import_jsx_runtime32.jsx)("h5", { className: "ndl-dnd-title", children: customTitle || (0, import_jsx_runtime32.jsxs)(import_jsx_runtime32.Fragment, { children: ["Drag ", (0, import_jsx_runtime32.jsx)("span", { className: "n-font-light", children: "&" }), " Drop"] }) }), (0, import_jsx_runtime32.jsxs)("div", { className: "ndl-dnd-subtitle", children: [(0, import_jsx_runtime32.jsx)("span", { children: "or" }), " ", (0, import_jsx_runtime32.jsx)("button", { className: "ndl-dnd-browse-link", onClick: () => open(), disabled: isDisabled, children: "browse" })] })] })] }), (0, import_jsx_runtime32.jsxs)("div", { className: "ndl-dropzone-footer", children: [isUploading && (0, import_jsx_runtime32.jsx)(import_jsx_runtime32.Fragment, { children: loadingComponent }), !isUploading && (0, import_jsx_runtime32.jsx)("div", { className: "ndl-file-support-text", children: supportedFilesDescription })] })] })] })) }))] });
};
var Dropzone_default = Dropzone2;

// node_modules/@neo4j-ndl/react/lib/esm/data-grid/DataGrid.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime());
var import_react146 = __toESM(require_react());

// node_modules/@neo4j-ndl/react/lib/esm/data-grid/DataGridContext.js
var import_react143 = __toESM(require_react());
var DataGridContext = (0, import_react143.createContext)(null);
function useDataGridContext() {
  const context = (0, import_react143.useContext)(DataGridContext);
  if (!context) {
    throw new Error("useDataGridContext should be used under Table component provider");
  }
  return context;
}

// node_modules/@neo4j-ndl/react/lib/esm/data-grid/Components.js
var import_react144 = __toESM(require_react());
var import_jsx_runtime33 = __toESM(require_jsx_runtime());
var import_react145 = __toESM(require_react());

// node_modules/@neo4j-ndl/react/lib/esm/data-grid/helpers.js
var helpers_exports2 = {};
__export(helpers_exports2, {
  gridGenerator: () => gridGenerator2,
  isSizeConstrained: () => isSizeConstrained,
  userFriendlyPagination: () => userFriendlyPagination2
});
var userFriendlyPagination2 = (current, max4) => {
  const last = max4;
  const delta = 1;
  const left2 = current - delta;
  const right2 = current + delta + 1;
  const range = [];
  const rangeWithDots = [];
  let length2;
  for (let i2 = 1; i2 <= last; i2 += 1) {
    if (i2 === 1 || i2 === last || i2 >= left2 && i2 < right2) {
      range.push(i2);
    }
  }
  for (let i2 = 0; i2 < range.length; i2 += 1) {
    if (length2) {
      if (range[i2] - length2 === 2) {
        rangeWithDots.push(length2 + 1);
      } else if (range[i2] - length2 !== 1) {
        rangeWithDots.push("...");
      }
    }
    rangeWithDots.push(range[i2]);
    length2 = range[i2];
  }
  return rangeWithDots;
};
var gridGenerator2 = (table) => {
  const visibleColumns = table.getVisibleFlatColumns();
  const tableDefaultMin = table._getDefaultColumnDef().minSize;
  const defaultMin = tableDefaultMin !== 20 ? tableDefaultMin : 100;
  return visibleColumns.map((i2, idx) => {
    var _a2;
    return visibleColumns.length === idx + 1 ? `minmax(${i2.getSize()}px ,auto)` : `minmax(${((_a2 = table.getColumn(i2.id)) === null || _a2 === void 0 ? void 0 : _a2.columnDef.minSize) || defaultMin}px,${i2.getSize()}px)`;
  }).join(" ");
};
var isSizeConstrained = (columnDef) => columnDef.size !== void 0 && columnDef.size !== 150;

// node_modules/@neo4j-ndl/react/lib/esm/data-grid/Components.js
var TABLE_RESULTS2 = {
  DEFAULT: 10,
  values: [10, 25, 50, 100]
};
var DEFAULT_SORT_ACTIONS = (cell) => ({
  asc: {
    title: "Sort ascending",
    icon: (0, import_jsx_runtime33.jsx)(import_BarsArrowUpIcon.default, {}),
    onClick: () => cell.column.toggleSorting(false)
  },
  desc: {
    title: "Sort descending",
    icon: (0, import_jsx_runtime33.jsx)(import_BarsArrowDownIcon.default, {}),
    onClick: () => cell.column.toggleSorting(true)
  },
  default: {
    title: "Default sort",
    icon: (0, import_jsx_runtime33.jsx)(import_Bars3CenterLeftIcon.default, {}),
    onClick: () => cell.column.clearSorting()
  }
});
var ResizingBar2 = ({ header, children, innerProps }) => {
  const { className = void 0 } = innerProps || {};
  return (0, import_jsx_runtime33.jsx)(import_jsx_runtime33.Fragment, { children: children || (0, import_jsx_runtime33.jsx)("button", Object.assign({}, innerProps, { type: "button", className: "ndl-data-grid-resizer-wrapper", onMouseDown: header.getResizeHandler(), onTouchStart: header.getResizeHandler(), "aria-label": "resizing bar", children: (0, import_jsx_runtime33.jsx)("div", { className: classNames("ndl-data-grid-resizer", className, {
    "ndl-data-grid-is-resizing": header.column.getIsResizing()
  }) }) })) });
};
var Scrollable2 = ({ children, innerProps }) => {
  const { className } = innerProps || {};
  return (0, import_jsx_runtime33.jsx)("div", Object.assign({}, innerProps, { className: classNames("ndl-data-grid-scrollable", className), children }));
};
var Header4 = ({ children, innerProps }) => {
  const { tableProps, components: components2 } = useDataGridContext();
  const { getHeaderGroups, getState } = tableProps;
  const { className = void 0 } = innerProps || {};
  return (0, import_jsx_runtime33.jsx)("div", Object.assign({}, innerProps, { role: "rowgroup", className: classNames("ndl-data-grid-thead", className, {
    "ndl-data-grid-is-resizing": getState().columnSizingInfo.isResizingColumn
  }), children: children || (0, import_jsx_runtime33.jsx)(import_jsx_runtime33.Fragment, { children: getHeaderGroups().map((headerGroup) => (0, import_jsx_runtime33.jsx)("div", { className: "ndl-data-grid-tr", role: "row", children: headerGroup.headers.map((header) => components2.HeaderCell && (0, import_jsx_runtime33.jsx)(components2.HeaderCell, { cell: header }, header.id)) }, headerGroup.id)) }) }));
};
var ActionButton = ({ action, children, onClose, innerProps }) => {
  const { className } = innerProps || {};
  const { onClick } = action;
  const interceptedOnClick = (0, import_react145.useCallback)((e4) => {
    const providedOnClick = onClick || (innerProps === null || innerProps === void 0 ? void 0 : innerProps.onClick);
    if (typeof providedOnClick === "function") {
      providedOnClick(e4);
    }
    onClose();
  }, [innerProps === null || innerProps === void 0 ? void 0 : innerProps.onClick, onClick, onClose]);
  const commonProps = Object.assign(Object.assign(Object.assign({}, innerProps), action), { className: classNames("ndl-data-grid-column-action", className), onClick: interceptedOnClick });
  return (0, import_jsx_runtime33.jsx)(import_react145.Fragment, { children: children || (0, import_jsx_runtime33.jsx)(Menu.Item, Object.assign({}, commonProps)) });
};
var ColumnControls2 = ({ cell, children, innerProps }) => {
  var _a2;
  const { className } = innerProps || {};
  const { components: components2 } = useDataGridContext();
  const sort = cell.column.getIsSorted();
  const canSort = cell.column.getCanSort();
  const { defaultSortingActions = true, actions } = ((_a2 = cell.column.columnDef.meta) === null || _a2 === void 0 ? void 0 : _a2.columnActions) || {};
  const sortingActions = (0, import_react145.useMemo)(() => {
    if (canSort) {
      if (sort !== "asc" && sort !== "desc") {
        return [
          DEFAULT_SORT_ACTIONS(cell).asc,
          DEFAULT_SORT_ACTIONS(cell).desc
        ];
      }
      if (sort === "asc") {
        return [
          DEFAULT_SORT_ACTIONS(cell).default,
          DEFAULT_SORT_ACTIONS(cell).desc
        ];
      }
      if (sort === "desc") {
        return [
          DEFAULT_SORT_ACTIONS(cell).default,
          DEFAULT_SORT_ACTIONS(cell).asc
        ];
      }
    }
    return [];
  }, [sort, cell, canSort]);
  const newActions = [
    ...defaultSortingActions ? sortingActions : [],
    ...actions !== null && actions !== void 0 ? actions : []
  ];
  const actionsButtonRef = (0, import_react145.useRef)(null);
  const [actionsOpen, setActionsOpen] = (0, import_react145.useState)(false);
  if (!actions || actions.length === 0)
    return null;
  return newActions.length > 0 ? (0, import_jsx_runtime33.jsx)("div", Object.assign({}, innerProps, { className: classNames("ndl-header-action-group", className), style: {
    zIndex: 1e5,
    position: "relative",
    right: "12px"
  }, children: children || (0, import_jsx_runtime33.jsxs)(import_react145.Fragment, { children: [(0, import_jsx_runtime33.jsx)(IconButton, { clean: true, size: "medium", "arial-label": `Column actions for ${cell.column.id} column`, ref: actionsButtonRef, active: actionsOpen, onClick: () => {
    setActionsOpen(!actionsOpen);
  }, children: (0, import_jsx_runtime33.jsx)(import_ChevronDownIcon2.default, {}) }), (0, import_jsx_runtime33.jsx)(Menu, { open: actionsOpen, anchorEl: actionsButtonRef.current, onClose: () => setActionsOpen(false), anchorOrigin: {
    vertical: "bottom",
    horizontal: "center"
  }, transformOrigin: {
    horizontal: "center",
    vertical: "top"
  }, children: newActions.map((action, i2) => components2.ActionButton && (0, import_jsx_runtime33.jsx)(components2.ActionButton, { action, onClose: () => setActionsOpen(false) }, `${cell.column.id}-action-${i2}`)) })] }) })) : null;
};
var HeaderCell2 = ({ cell, children, innerProps }) => {
  var _a2;
  const { components: components2, resizable, tableProps, resizeColumns } = useDataGridContext();
  const { className } = innerProps || {};
  const sort = cell.column.getIsSorted();
  const canSort = cell.column.getCanSort();
  const ariaSortRole = (0, import_react145.useMemo)(() => {
    switch (sort) {
      case "asc":
        return "ascending";
      case "desc":
        return "descending";
      default:
        return "none";
    }
  }, [sort]);
  const Icon = (0, import_react145.useMemo)(() => {
    switch (sort) {
      case "asc":
        return (0, import_jsx_runtime33.jsx)(import_BarsArrowUpIcon.default, { className: "ndl-header-icon" });
      case "desc":
        return (0, import_jsx_runtime33.jsx)(import_BarsArrowDownIcon.default, { className: "ndl-header-icon" });
      default:
        return (0, import_jsx_runtime33.jsx)(import_Bars3CenterLeftIcon2.default, { className: "ndl-hoverable-indicator ndl-header-icon" });
    }
  }, [sort]);
  const ariaDescription = canSort ? `Press ENTER or SPACE to sort column ${cell.column.id}` : `Column id: ${cell.column.id}`;
  const constrained = isSizeConstrained(cell.column.columnDef);
  const ref = (0, import_react145.useRef)(null);
  const [grow, setGrow] = (0, import_react145.useState)(resizeColumns);
  (0, import_react145.useEffect)(() => {
    var _a3;
    if (resizeColumns) {
      const { width } = ((_a3 = ref.current) === null || _a3 === void 0 ? void 0 : _a3.getBoundingClientRect()) || {};
      if (width) {
        tableProps.setState((prev2) => Object.assign(Object.assign({}, prev2), { columnSizing: Object.assign(Object.assign({}, prev2.columnSizing), { [cell.column.id]: width }) }));
        setGrow(false);
      }
    }
  }, [tableProps, cell.column.id]);
  const isActionColumn = typeof ((_a2 = cell.column.columnDef.meta) === null || _a2 === void 0 ? void 0 : _a2.isActionCell) === "object";
  const Tag4 = canSort ? "button" : "div";
  return (0, import_jsx_runtime33.jsx)("div", Object.assign({ tabIndex: -1, role: "columnheader" }, innerProps, { className: classNames("ndl-data-grid-th ndl-focusable-cell", className, {
    "ndl-data-grid-row-action": isActionColumn
  }), "aria-sort": ariaSortRole, style: {
    width: isActionColumn ? 40 : cell.getSize(),
    maxWidth: cell.column.columnDef.maxSize ? `${cell.column.columnDef.maxSize}px` : "none",
    flexGrow: !isActionColumn && !constrained && grow ? 1 : 0
  }, ref, children: children || (0, import_jsx_runtime33.jsxs)(import_jsx_runtime33.Fragment, { children: [(0, import_jsx_runtime33.jsx)(Tag4, { className: "ndl-header-group", style: {
    cursor: canSort ? "pointer" : "default"
  }, tabIndex: canSort ? -1 : void 0, "aria-describedby": ariaDescription, onClick: () => canSort && cell.column.toggleSorting(), children: (0, import_jsx_runtime33.jsxs)("div", { className: "ndl-header-cell", children: [cell.isPlaceholder ? null : flexRender(cell.column.columnDef.header, cell.getContext()), canSort && Icon] }) }), components2.ColumnControls && (0, import_jsx_runtime33.jsx)(components2.ColumnControls, { cell }), resizable && cell.headerGroup.headers.length - 1 !== cell.index && cell.column.getCanResize() && components2.ResizingBar && (0, import_jsx_runtime33.jsx)(components2.ResizingBar, { header: cell })] }) }), cell.id);
};
var Body4 = ({ children, innerProps }) => {
  const { tableProps, components: components2, loading } = useDataGridContext();
  const { getRowModel } = tableProps;
  const { className } = innerProps || {};
  return (0, import_jsx_runtime33.jsx)("div", Object.assign({}, innerProps, { className: classNames("ndl-data-grid-tbody", className), role: "rowgroup", "aria-busy": loading ? "true" : "false", children: children || (0, import_jsx_runtime33.jsxs)(import_jsx_runtime33.Fragment, { children: [loading && components2.LoadingPlaceholder && (0, import_jsx_runtime33.jsx)(components2.LoadingPlaceholder, {}), !loading && getRowModel().rows.length === 0 && components2.NoDataPlaceholder && (0, import_jsx_runtime33.jsx)(components2.NoDataPlaceholder, {}), !loading && getRowModel().rows.map((row, idx) => components2.BodyRow && (0, import_jsx_runtime33.jsx)(components2.BodyRow, { row }, `table-row-${idx}`))] }) }));
};
var BodyCell2 = ({ cell, children, innerProps }) => {
  var _a2;
  const isResizing = cell.column.getIsResizing();
  const { className } = innerProps || {};
  const isActionColumn = typeof ((_a2 = cell.column.columnDef.meta) === null || _a2 === void 0 ? void 0 : _a2.isActionCell) === "object";
  return (0, import_jsx_runtime33.jsx)("div", Object.assign({}, innerProps, { className: classNames("ndl-data-grid-td ndl-focusable-cell", className, {
    "ndl-data-grid-is-resizing": isResizing,
    "ndl-data-grid-row-action": isActionColumn
  }), role: "cell", tabIndex: 0, style: {
    width: isActionColumn ? 40 : cell.column.getSize()
  }, children: children || flexRender(cell.column.columnDef.cell, cell.getContext()) }), cell.id);
};
var BodyRow2 = ({ row, children, innerProps }) => {
  const { components: components2 } = useDataGridContext();
  const { className, style = {} } = innerProps || {};
  return (0, import_react144.createElement)("div", Object.assign({}, innerProps, { key: row.id, className: classNames("ndl-data-grid-tr", className), role: "row", style: Object.assign({ display: "flex", flexDirection: "row" }, style) }), children || (0, import_jsx_runtime33.jsx)(import_jsx_runtime33.Fragment, { children: row.getVisibleCells().map((cell) => components2.BodyCell && (0, import_jsx_runtime33.jsx)(components2.BodyCell, { cell }, cell.id)) }));
};
var TableResults2 = ({ children, innerProps, manualPagination }) => {
  const { tableProps } = useDataGridContext();
  const { getState, getRowModel, getCoreRowModel } = tableProps;
  const { pagination: { pageSize, pageIndex } } = getState();
  const { rows } = getRowModel();
  const { from: from2, to, totalRows } = (0, import_react145.useMemo)(() => manualPagination || {
    from: 1 + pageIndex * pageSize,
    to: rows.length + pageIndex * pageSize,
    totalRows: getCoreRowModel().rows.length
  }, [pageIndex, pageSize, manualPagination, rows, getCoreRowModel]);
  const { className } = innerProps || {};
  return (0, import_jsx_runtime33.jsx)("span", Object.assign({}, innerProps, { className: classNames("ndl-data-grid-results", className), children: children || (0, import_jsx_runtime33.jsxs)("span", { children: ["Showing", " ", (0, import_jsx_runtime33.jsx)("b", { children: totalRows ? `${from2}${to !== from2 ? `-${to}` : ""}` : 0 }), " of", " ", (0, import_jsx_runtime33.jsx)("b", { children: totalRows }), " results"] }) }));
};
var RowsPerPage2 = ({ children, innerProps }) => {
  const { tableProps } = useDataGridContext();
  const { setPageSize, getState } = tableProps;
  const { className } = innerProps || {};
  const { pagination: { pageSize } } = getState();
  return (0, import_jsx_runtime33.jsx)("div", Object.assign({}, innerProps, { className: classNames("ndl-data-grid-rows-per-page", className), children: children || (0, import_jsx_runtime33.jsxs)(import_jsx_runtime33.Fragment, { children: ["Show", (0, import_jsx_runtime33.jsx)("select", { onChange: (e4) => setPageSize(parseInt(e4.target.value, 10)), className: "ndl-data-grid-select", value: pageSize, "aria-label": "Select page size", children: [.../* @__PURE__ */ new Set([...TABLE_RESULTS2.values, pageSize])].sort((a3, b2) => a3 - b2).map((option) => (0, import_jsx_runtime33.jsx)("option", { value: `${option}`, children: option }, `${option}`)) })] }) }));
};
var PaginationArrowButton2 = ({ action, children, innerProps }) => {
  const { className } = innerProps || {};
  return (0, import_jsx_runtime33.jsx)("button", Object.assign({}, innerProps, { type: "button", className: classNames("ndl-data-grid-pagination-icon-button", className), children: children || (0, import_jsx_runtime33.jsxs)(import_jsx_runtime33.Fragment, { children: [action === "previous" && (0, import_jsx_runtime33.jsxs)(import_jsx_runtime33.Fragment, { children: [(0, import_jsx_runtime33.jsx)("span", { className: "n-sr-only", children: "Previous table page" }), (0, import_jsx_runtime33.jsx)(import_ChevronLeftIcon.default, { className: "ndl-data-grid-pagination-icon" })] }), action === "next" && (0, import_jsx_runtime33.jsxs)(import_jsx_runtime33.Fragment, { children: [(0, import_jsx_runtime33.jsx)("span", { className: "n-sr-only", children: "Next table page" }), (0, import_jsx_runtime33.jsx)(import_ChevronRightIcon.default, { className: "ndl-data-grid-pagination-icon" })] })] }) }));
};
var PaginationNumericButton2 = ({ currentIndex, isSelected, children, innerProps }) => {
  const { className, onClick } = innerProps || {};
  return (0, import_jsx_runtime33.jsx)("button", Object.assign({}, innerProps, { type: "button", "data-testid": `ndl-table-${currentIndex}`, className: classNames("ndl-data-grid-pagination-numeric-button", className, {
    "ndl-not-selected-numeric": typeof currentIndex === "number" && !isSelected,
    "ndl-is-selected": isSelected,
    "ndl-not-selected": !isSelected
  }), onClick: (e4) => typeof currentIndex === "number" && onClick && onClick(e4), tabIndex: typeof currentIndex === "number" ? 0 : -1, children: children || currentIndex }));
};
var PaginationNumericButtons2 = () => {
  const { tableProps, components: components2 } = useDataGridContext();
  const { getState, setPageIndex, getPageCount } = tableProps;
  const { pagination: { pageIndex } } = getState();
  return (0, import_jsx_runtime33.jsx)(import_jsx_runtime33.Fragment, { children: userFriendlyPagination2(pageIndex + 1, getPageCount()).map((option, idx) => components2.PaginationNumericButton && (0, import_jsx_runtime33.jsx)(
    components2.PaginationNumericButton,
    { innerProps: {
      onClick: () => typeof option === "number" && setPageIndex(option - 1)
    }, currentIndex: option, isSelected: option === pageIndex + 1 },
    `${option}-${idx}`
  )) });
};
var Pagination2 = ({ children, innerProps }) => {
  const { tableProps, components: components2 } = useDataGridContext();
  const { getCanPreviousPage, getCanNextPage, previousPage, nextPage } = tableProps;
  const { className } = innerProps || {};
  return (0, import_jsx_runtime33.jsx)("nav", Object.assign({}, innerProps, { className: classNames("ndl-data-grid-nav", className), "aria-label": "Pagination", children: children || (0, import_jsx_runtime33.jsxs)(import_jsx_runtime33.Fragment, { children: [getCanPreviousPage() ? components2.PaginationArrowButton && (0, import_jsx_runtime33.jsx)(components2.PaginationArrowButton, { action: "previous", innerProps: {
    onClick: previousPage
  } }) : null, components2.PaginationNumericButtons && (0, import_jsx_runtime33.jsx)(components2.PaginationNumericButtons, {}), getCanNextPage() ? components2.PaginationArrowButton && (0, import_jsx_runtime33.jsx)(components2.PaginationArrowButton, { action: "next", innerProps: {
    onClick: nextPage
  } }) : null] }) }));
};
var Navigation2 = ({ children, innerProps }) => {
  const { tableProps, components: components2 } = useDataGridContext();
  const { getPageCount } = tableProps;
  const { className } = innerProps || {};
  return (0, import_jsx_runtime33.jsx)("div", Object.assign({}, innerProps, { className: classNames("ndl-data-grid-navigation", className), children: (0, import_jsx_runtime33.jsx)(import_jsx_runtime33.Fragment, { children: children || (0, import_jsx_runtime33.jsxs)(import_jsx_runtime33.Fragment, { children: [components2.TableResults && (0, import_jsx_runtime33.jsx)(components2.TableResults, {}), (0, import_jsx_runtime33.jsxs)("div", { className: "ndl-data-grid-navigation-right-items", children: [getPageCount() > 1 && components2.Pagination && (0, import_jsx_runtime33.jsx)(components2.Pagination, {}), components2.RowsPerPage && (0, import_jsx_runtime33.jsx)(components2.RowsPerPage, {})] })] }) }) }));
};
var LoadingPlaceholder2 = ({ children, innerProps }) => {
  const { className } = innerProps || {};
  return (0, import_jsx_runtime33.jsx)("div", Object.assign({}, innerProps, { className: classNames("nld-table-placeholder-wrapper", className), role: "row", children: children || (0, import_jsx_runtime33.jsx)("div", { role: "cell", className: "ndl-data-grid-placeholder", children: (0, import_jsx_runtime33.jsxs)("div", { className: "ndl-data-grid-loading-placeholder", children: [(0, import_jsx_runtime33.jsx)(LoadingSpinner_default, {}), (0, import_jsx_runtime33.jsx)("h6", { children: "Loading data" })] }) }) }));
};
var NoDataPlaceholder2 = ({ children, innerProps }) => {
  const { className } = innerProps || {};
  return (0, import_jsx_runtime33.jsx)("div", Object.assign({}, innerProps, { className: classNames("nld-table-placeholder-wrapper", className), role: "row", children: children || (0, import_jsx_runtime33.jsx)("div", { role: "cell", className: "ndl-data-grid-placeholder", children: (0, import_jsx_runtime33.jsx)("h6", { children: "No data present" }) }) }));
};

// node_modules/@table-nav/core/lib/index.mjs
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a3, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a3, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a3, prop, b2[prop]);
    }
  return a3;
};
var Selectors = {
  Cell: '[role="cell"],[role="gridcell"],[role="columnheader"],[role="rowheader"],td,th',
  Row: '[role="row"],tr',
  RowGroup: '[role="rowgroup"],thead,tbody,tfoot',
  /** Selector from here: https://github.com/Shopify/polaris/blob/main/polaris-react/src/utilities/focus.ts#L10 */
  Focusable: 'a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not([aria-disabled="true"]):not([tabindex="-1"]):not(:disabled),*[tabindex]'
};
var DataGridNav = class {
  constructor(config2 = {}) {
    this.keys = [];
    this.debugLog = (functionName, message) => {
      if (this.debug)
        console.info(`[${functionName}]: ${message}`);
    };
    const { selectors = {}, pageUpDown, debug = false } = config2;
    this.selectors = __spreadValues(__spreadValues({}, Selectors), selectors);
    this.pageUpDown = pageUpDown;
    this.keys = [];
    this.debug = debug;
    this.disabled = false;
  }
  /**
   * Disables the keyboard listener in cases
   * that elements inside the grid need to use
   * arrows keys etc., like select dropdowns
   */
  disable() {
    this.disabled = true;
  }
  /**
   * Enables the keyboard listeners
   */
  enable() {
    this.disabled = false;
  }
  isFocusable(el) {
    return el instanceof HTMLElement || el instanceof SVGElement;
  }
  /** Used as a keyboard listener for key up */
  tableKeyUp() {
    this.keys = [];
  }
  /** Used as a keyboard listener for key down */
  tableKeyDown(e4) {
    var _a2;
    this.debugLog("tableKeyDown", `Key pressed: ${e4.key}`);
    if (this.disabled) {
      this.debugLog("tableKeyDown", "interaction is disabled");
      return;
    }
    if ("ArrowDown" === e4.key || "ArrowUp" === e4.key || "ArrowLeft" === e4.key || "ArrowRight" === e4.key) {
      e4.preventDefault();
    }
    if (this.keys.length === 0 || this.keys[this.keys.length - 1] !== e4.key) {
      this.keys.push(e4.key);
    }
    if (!(e4.target instanceof Element))
      return;
    const cell = (_a2 = e4.target.parentElement) == null ? void 0 : _a2.closest(
      `${this.selectors.Cell},${this.selectors.Row}`
    );
    if (!cell) {
      this.debugLog("tableKeyDown", "cell not found");
      return;
    }
    if (cell.matches(this.selectors.Cell)) {
      this.debugLog("tableKeyDown", "event captured in cell");
      this.cellNavigation(e4);
    } else {
      this.debugLog("tableKeyDown", "event captured in cell");
      this.gridNavigation(e4);
    }
  }
  /**
   * Handles the navigation inside a cell
   */
  cellNavigation(e4) {
    if (!(e4.target instanceof Element))
      return;
    if (e4.key === "Escape") {
      const cell = e4.target.closest(this.selectors.Cell);
      if (cell && this.isFocusable(cell)) {
        cell.focus();
        return;
      }
    }
    if (e4.key === "ArrowRight" || e4.key === "ArrowDown") {
      const cell = e4.target.closest(this.selectors.Cell);
      if (!cell) {
        this.debugLog("cellNavigation", "cell not found");
        return;
      }
      const focusableWidgets = [
        ...cell.querySelectorAll(this.selectors.Focusable)
      ];
      const widgetIdx = focusableWidgets.findIndex((el) => el === e4.target);
      const nextFocusable = widgetIdx === focusableWidgets.length - 1 ? 0 : widgetIdx + 1;
      const widgetToFocus = focusableWidgets[nextFocusable];
      if (this.isFocusable(widgetToFocus)) {
        widgetToFocus.focus();
      }
      return;
    }
    if (e4.key === "ArrowLeft" || e4.key === "ArrowUp") {
      const cell = e4.target.closest(this.selectors.Cell);
      if (!cell) {
        this.debugLog("cellNavigation", "cell not found");
        return;
      }
      const focusableWidgets = [
        ...cell.querySelectorAll(this.selectors.Focusable)
      ];
      const widgetIdx = focusableWidgets.findIndex((el) => el === e4.target);
      const previousFocusable = widgetIdx === 0 ? focusableWidgets.length - 1 : widgetIdx - 1;
      const widgetToFocus = focusableWidgets[previousFocusable];
      if (this.isFocusable(widgetToFocus)) {
        widgetToFocus.focus();
      }
      return;
    }
  }
  /**
   * Handles the navigation outside a cell
   * on the grid level
   */
  gridNavigation(e4) {
    var _a2;
    const { target } = e4;
    if (!(e4.target instanceof Element))
      return;
    if (!(target instanceof Element))
      return;
    if (this.keys.length === 1) {
      if (e4.key === "Enter") {
        const cell = e4.target.querySelector(this.selectors.Focusable);
        if (cell && this.isFocusable(cell)) {
          cell.focus();
          e4.preventDefault();
        }
      }
      if (e4.key === "ArrowLeft" || e4.key === "ArrowRight") {
        const direction = e4.key === "ArrowLeft" ? "prev" : "next";
        const cell = e4.target.closest(this.selectors.Cell);
        if (cell && cell instanceof Element) {
          const closeFocusable = this.findUntil(
            direction,
            cell,
            this.selectors.Cell
          );
          if (closeFocusable) {
            closeFocusable.focus();
          }
        }
      }
      if (e4.key === "ArrowDown" || e4.key === "ArrowUp") {
        this.verticalCellNavigation(e4);
        return;
      }
      if (e4.key === "PageUp" || e4.key === "PageDown") {
        this.pageCellNavigation(e4);
        return;
      }
      if (e4.key === "Home" || e4.key === "End") {
        const row = e4.target.closest(this.selectors.Row);
        const rowChildren = [...(row == null ? void 0 : row.children) || []];
        if (e4.key === "End")
          rowChildren.reverse();
        this.focusOnFirstCell(rowChildren);
      }
    } else {
      const [firstKey, secondKey] = this.keys;
      if (firstKey === "Control" && (secondKey === "Home" || secondKey === "End")) {
        const row = e4.target.closest(this.selectors.Row);
        const siblings = (_a2 = row.parentElement) == null ? void 0 : _a2.children;
        if (!siblings) {
          this.debugLog("cellNavigation", "siblings not found");
          return;
        }
        const rowToFocus = secondKey === "Home" ? siblings[0] : siblings[siblings.length - 1];
        const rowChildren = [...(rowToFocus == null ? void 0 : rowToFocus.children) || []];
        if (secondKey === "End")
          rowChildren.reverse();
        this.focusOnFirstCell(rowChildren);
      }
    }
  }
  pageCellNavigation(e4) {
    var _a2;
    if (!(e4.target instanceof Element))
      return;
    const row = e4.target.closest(this.selectors.Row);
    const cell = e4.target.closest(this.selectors.Cell);
    if (row && cell) {
      const position2 = this.getColumnIndex(cell);
      if (position2 === void 0) {
        this.debugLog("cellNavigation", "position not found");
        return;
      }
      const direction = e4.key === "PageUp" ? "prev" : "next";
      const siblings = (_a2 = row.parentElement) == null ? void 0 : _a2.children;
      if (!siblings) {
        this.debugLog("cellNavigation", "siblings not found");
        return;
      }
      let destinationRow;
      if (this.pageUpDown) {
        const methodClbk = direction === "prev" ? "previousSibling" : "nextSibling";
        let sibling = row[methodClbk];
        if (sibling === null)
          return;
        let lastVisitedSibling = sibling;
        for (let i2 = 0; i2 < this.pageUpDown - 1 && sibling; i2++) {
          sibling = sibling[methodClbk];
          if (sibling) {
            lastVisitedSibling = sibling;
          }
        }
        destinationRow = sibling ? sibling : lastVisitedSibling;
      } else {
        destinationRow = direction === "prev" ? siblings[0] : siblings[siblings.length - 1];
      }
      if (!destinationRow || !(destinationRow instanceof Element))
        return;
      const child = destinationRow.children[position2];
      if (child && this.isFocusable(child))
        child.focus();
    }
  }
  verticalCellNavigation(e4) {
    var _a2, _b, _c, _d, _e2;
    if (!(e4.target instanceof Element))
      return;
    const row = e4.target.closest(this.selectors.Row);
    const cell = e4.target.closest(this.selectors.Cell);
    if (row && cell) {
      const cellPosition = this.getColumnIndex(cell);
      const rowPosition = this.getRowIndex(row);
      this.debugLog("gridNavigation", `Initial row position: ${rowPosition}`);
      this.debugLog("gridNavigation", `Initial cell position: ${cellPosition}`);
      if (cellPosition === void 0 || rowPosition === void 0) {
        this.debugLog(
          "verticalCellNavigation",
          "row or cell position not found"
        );
        return;
      }
      const direction = e4.key === "ArrowUp" ? "prev" : "next";
      if (rowPosition === 0 && direction === "prev") {
        const currentRowGroup = (_a2 = row.parentElement) == null ? void 0 : _a2.closest(
          this.selectors.RowGroup
        );
        const siblingRowGroups = [
          ...((_b = currentRowGroup == null ? void 0 : currentRowGroup.parentElement) == null ? void 0 : _b.children) || []
        ];
        const currentRowGroupIdx = siblingRowGroups.findIndex(
          (el) => el === currentRowGroup
        );
        if (currentRowGroupIdx !== 0) {
          const previousRowGroup = siblingRowGroups[currentRowGroupIdx - 1];
          const rows = [
            ...previousRowGroup.querySelectorAll(this.selectors.Row)
          ];
          const child2 = rows[rows.length - 1].children[cellPosition];
          if (child2 && this.isFocusable(child2))
            child2.focus();
          return;
        }
      }
      const siblingRows = [
        ...((_c = row.parentElement) == null ? void 0 : _c.querySelectorAll(this.selectors.Row)) || []
      ];
      if (rowPosition === siblingRows.length - 1 && direction === "next") {
        const currentRowGroup = (_d = row.parentElement) == null ? void 0 : _d.closest(
          this.selectors.RowGroup
        );
        const siblingRowGroups = [
          ...((_e2 = currentRowGroup == null ? void 0 : currentRowGroup.parentElement) == null ? void 0 : _e2.children) || []
        ];
        const currentRowGroupIdx = siblingRowGroups.findIndex(
          (el) => el === currentRowGroup
        );
        if (currentRowGroupIdx !== siblingRowGroups.length - 1) {
          const nextRowGroup = siblingRowGroups[currentRowGroupIdx + 1];
          const rows = [...nextRowGroup.querySelectorAll(this.selectors.Row)];
          const child2 = rows[0].children[cellPosition];
          if (child2 && this.isFocusable(child2))
            child2.focus();
          return;
        }
        return;
      }
      const destinationRow = this.findUntil(direction, row, this.selectors.Row);
      if (!destinationRow)
        return;
      const child = destinationRow.children[cellPosition];
      if (child && this.isFocusable(child))
        child.focus();
    }
  }
  /**
   * Sending a row `Element` and then the first cell will be focused.
   *
   * If you want to focus the last cell then the row children can be passed in
   * reversed order
   */
  focusOnFirstCell(el) {
    for (let i2 = 0; i2 < el.length; i2++) {
      const child = el[i2];
      if (this.isFocusable(child)) {
        child.focus();
        return;
      }
    }
  }
  /**
   * Get the column index of a `cell` based on the first `row` parent.
   * `cellIndex` could be used, but it's not supported in HTML tables.
   */
  getColumnIndex(cell) {
    var _a2;
    let position2 = 0;
    const siblings = (_a2 = cell == null ? void 0 : cell.parentNode) == null ? void 0 : _a2.children;
    if (!siblings)
      return void 0;
    while (cell !== siblings[position2] && siblings[position2] !== void 0) {
      position2++;
    }
    if (siblings[position2] === void 0) {
      this.debugLog("getColumnIndex", "position finding was not successful");
      return void 0;
    }
    return position2;
  }
  /**
   * Get the row index of a `row` based
   * on its sibling rows
   */
  getRowIndex(row) {
    var _a2;
    let position2 = 0;
    const siblings = (_a2 = row == null ? void 0 : row.parentNode) == null ? void 0 : _a2.children;
    if (!siblings)
      return void 0;
    while (row !== siblings[position2] && siblings[position2] !== void 0) {
      position2++;
    }
    if (siblings[position2] === void 0) {
      this.debugLog("getRowIndex", "position finding was not successful");
      return void 0;
    }
    return position2;
  }
  /**
   * Equivalent to prevUntil/nextUntil in jQuery
   * https://api.jquery.com/prevUntil/
   */
  findUntil(direction, el, matchSelector, exitSelector) {
    let element = el;
    const method = direction === "next" ? "nextSibling" : "previousSibling";
    while (element[method]) {
      const sibling = element[method];
      if (!sibling)
        return null;
      if (exitSelector && sibling instanceof Element && sibling.matches(exitSelector)) {
        return null;
      }
      if (sibling instanceof Element && sibling.matches(matchSelector)) {
        return sibling;
      }
      element = sibling;
    }
    return null;
  }
};

// node_modules/@table-nav/react/lib/index.mjs
function useTableNav(options2) {
  const nav4 = new DataGridNav(options2);
  return {
    listeners: {
      onKeyDown: (e4) => nav4.tableKeyDown(e4),
      onKeyUp: () => nav4.tableKeyUp()
    },
    tableNav: nav4
  };
}

// node_modules/@neo4j-ndl/react/lib/esm/data-grid/DataGrid.js
var DataGridComponents = {
  ResizingBar: ResizingBar2,
  Header: Header4,
  Body: Body4,
  BodyCell: BodyCell2,
  BodyRow: BodyRow2,
  HeaderCell: HeaderCell2,
  ActionButton,
  ColumnControls: ColumnControls2,
  Navigation: Navigation2,
  TableResults: TableResults2,
  RowsPerPage: RowsPerPage2,
  Pagination: Pagination2,
  PaginationNumericButtons: PaginationNumericButtons2,
  PaginationNumericButton: PaginationNumericButton2,
  PaginationArrowButton: PaginationArrowButton2,
  LoadingPlaceholder: LoadingPlaceholder2,
  NoDataPlaceholder: NoDataPlaceholder2,
  Scrollable: Scrollable2
};
var BorderStyleEnum;
(function(BorderStyleEnum2) {
  BorderStyleEnum2["AllSides"] = "all-sides";
  BorderStyleEnum2["Horizontal"] = "horizontal";
  BorderStyleEnum2["None"] = "none";
})(BorderStyleEnum || (BorderStyleEnum = {}));
var HeaderStyleEnum;
(function(HeaderStyleEnum2) {
  HeaderStyleEnum2["Filled"] = "filled";
  HeaderStyleEnum2["Clean"] = "clean";
})(HeaderStyleEnum || (HeaderStyleEnum = {}));
var DEFAULT_STYLING = {
  zebraStriping: false,
  borderStyle: BorderStyleEnum.Horizontal,
  headerStyle: HeaderStyleEnum.Filled
};
var DataGrid = forwardRef(function DataGrid2({ isResizable = true, isLoading = false, isKeyboardNavigable = false, isAutoResizingColumns = true, tableInstance, components: components2, rootProps, styling = {}, tableNavRef }, ref) {
  const { className = "", style = {} } = rootProps || {};
  const Styling = (0, import_react146.useMemo)(() => Object.assign(Object.assign({}, DEFAULT_STYLING), styling), [styling]);
  const Components = (0, import_react146.useMemo)(() => Object.assign(Object.assign({}, DataGridComponents), components2), [components2]);
  const ScrollableContainer = (Components === null || Components === void 0 ? void 0 : Components.Scrollable) ? Components.Scrollable : Scrollable2;
  const { listeners, tableNav: tableNavigationReference } = useTableNav({
    debug: false
  });
  (0, import_react146.useImperativeHandle)(tableNavRef, () => tableNavigationReference, [
    tableNavigationReference
  ]);
  return (0, import_jsx_runtime34.jsx)(DataGridContext.Provider, { value: {
    resizable: isResizable,
    tableProps: tableInstance,
    loading: isLoading,
    components: Components,
    resizeColumns: isAutoResizingColumns
  }, children: (0, import_jsx_runtime34.jsxs)("div", Object.assign({}, rootProps, isKeyboardNavigable ? listeners : {}, { className: classNames("ndl-data-grid-root", className, {
    "ndl-data-grid-focusable-cells": isKeyboardNavigable,
    "ndl-data-grid-zebra-striping": Styling.zebraStriping,
    "ndl-data-grid-border-all-sides": Styling.borderStyle === BorderStyleEnum.AllSides,
    "ndl-data-grid-border-horizontal": Styling.borderStyle === BorderStyleEnum.Horizontal,
    "ndl-data-grid-header-filled": Styling.headerStyle === HeaderStyleEnum.Filled
  }), style, ref, children: [(0, import_jsx_runtime34.jsx)(ScrollableContainer, { children: (0, import_jsx_runtime34.jsxs)("div", { className: "ndl-div-table", role: "grid", "aria-busy": isLoading ? "true" : "false", children: [(Components === null || Components === void 0 ? void 0 : Components.Header) && (0, import_jsx_runtime34.jsx)(Components.Header, {}), (Components === null || Components === void 0 ? void 0 : Components.Body) && (0, import_jsx_runtime34.jsx)(Components.Body, {})] }) }), (Components === null || Components === void 0 ? void 0 : Components.Navigation) && (0, import_jsx_runtime34.jsx)(Components.Navigation, {})] })) });
});
var DataGrid_default = DataGrid;

// node_modules/@neo4j-ndl/react/lib/esm/textarea/Textarea.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime());
var import_react148 = __toESM(require_react());
var __rest24 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var Textarea = (0, import_react148.forwardRef)(function Textarea2(props, ref) {
  const { label, fluid, errorText, helpText, isOptional = false, informationIconText, size: size3 = "medium", "aria-label": ariaLabel, tooltipProps } = props, customProps = __rest24(props, ["label", "fluid", "errorText", "helpText", "isOptional", "informationIconText", "size", "aria-label", "tooltipProps"]);
  const containerWrappingClasses = classNames(`ndl-textarea ndl-type-text`, customProps.className, {
    "ndl-disabled": customProps.disabled,
    "ndl-small": size3 === "small",
    "ndl-medium": size3 === "medium",
    "ndl-large": size3 === "large",
    "ndl-has-error": errorText,
    "ndl-has-right-icon": errorText,
    "ndl-has-icon": errorText
  });
  const hasEmptyLabelValue = !label || label === "";
  const labelWrappingClasses = classNames("ndl-textarea-label", {
    "ndl-fluid": fluid,
    "ndl-textarea-no-label": hasEmptyLabelValue
  });
  const isCustomLabel = label && typeof label !== "string";
  const hasCustomLabelAndNoAriaLabel = isCustomLabel && !ariaLabel;
  (0, import_react148.useMemo)(() => {
    if (!label && !ariaLabel) {
      needleWarningMessage("A Textarea without a label does not have an aria label, be sure to include an aria label for screen readers link: https://dequeuniversity.com/rules/axe/4.2/label?application=axeAPI");
    }
    if (hasCustomLabelAndNoAriaLabel) {
      needleWarningMessage(customLabelAndNoAriaLabelWarningMessage2);
    }
  }, [label, ariaLabel, hasCustomLabelAndNoAriaLabel]);
  const customPropsClassNameStripped = Object.assign(Object.assign({}, customProps), { className: void 0 });
  const informationIconClasses = classNames({
    "ndl-information-icon-small": size3 === "small" || size3 === "medium",
    "ndl-information-icon-large": size3 === "large"
  });
  return (0, import_jsx_runtime35.jsxs)("div", { className: containerWrappingClasses, children: [(0, import_jsx_runtime35.jsxs)("label", { className: labelWrappingClasses, children: [(0, import_jsx_runtime35.jsx)("div", { className: "ndl-textarea-wrapper", children: (0, import_jsx_runtime35.jsx)("textarea", Object.assign({}, customPropsClassNameStripped, { ref, "aria-label": ariaLabel })) }), !hasEmptyLabelValue && (0, import_jsx_runtime35.jsxs)("div", { className: "ndl-textarea-wrapper", children: [(0, import_jsx_runtime35.jsx)("span", { className: "ndl-textarea-label-text", children: label }), informationIconText && (0, import_jsx_runtime35.jsxs)(Tip, Object.assign({}, tooltipProps === null || tooltipProps === void 0 ? void 0 : tooltipProps.tooltipRoot, { children: [(0, import_jsx_runtime35.jsx)(Tip.Trigger, Object.assign({}, tooltipProps === null || tooltipProps === void 0 ? void 0 : tooltipProps.tooltipTrigger, { children: (0, import_jsx_runtime35.jsx)("div", { className: informationIconClasses, "data-testid": "ndl-information-icon", children: (0, import_jsx_runtime35.jsx)(import_InformationCircleIcon.default, {}) }) })), (0, import_jsx_runtime35.jsx)(Tip.Content, Object.assign({}, tooltipProps === null || tooltipProps === void 0 ? void 0 : tooltipProps.tooltipContent, { children: informationIconText }))] })), isOptional && (0, import_jsx_runtime35.jsx)("span", { className: "ndl-textarea-optional", children: "Optional" })] })] }), helpText && !errorText && (0, import_jsx_runtime35.jsx)("div", { className: "ndl-textarea-msg", children: helpText }), errorText && (0, import_jsx_runtime35.jsxs)("div", { className: "ndl-textarea-msg", children: [(0, import_jsx_runtime35.jsx)("div", { className: "ndl-error-icon", children: (0, import_jsx_runtime35.jsx)(import_ExclamationCircleIcon2.default, {}) }), (0, import_jsx_runtime35.jsx)("div", { className: "ndl-error-text", children: errorText })] })] });
});
var Textarea_default = Textarea;

// node_modules/@neo4j-ndl/react/lib/esm/text-link/TextLink.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime());
var import_react149 = __toESM(require_react());
var __rest25 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var TextLink = import_react149.default.forwardRef(function TextLink2(_a2, ref) {
  var { children, href, externalLink = false, disabled = false, as, className, target } = _a2, restProps = __rest25(_a2, ["children", "href", "externalLink", "disabled", "as", "className", "target"]);
  const propsTarget = target || (externalLink ? "_blank" : "");
  const Component4 = as || "a";
  const classes = classNames("ndl-text-link", className, {
    "ndl-external-link": externalLink,
    "ndl-disabled-text-link": disabled
  });
  return (0, import_jsx_runtime36.jsxs)(Component4, Object.assign({}, restProps, { className: classes, href, ref }, disabled && { tabIndex: -1 }, propsTarget && { target: propsTarget }, { children: [(0, import_jsx_runtime36.jsx)("div", { children }), externalLink && (0, import_jsx_runtime36.jsx)("div", { children: (0, import_jsx_runtime36.jsx)(import_ArrowTopRightOnSquareIcon.default, { className: "ndl-external-link-icon" }) })] }));
});
var TextLink_default = TextLink;

// node_modules/@neo4j-ndl/react/lib/esm/dropdown/Dropdown.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime());
var import_react165 = __toESM(require_react());

// node_modules/react-select/creatable/dist/react-select-creatable.esm.js
var React48 = __toESM(require_react());
var import_react158 = __toESM(require_react());

// node_modules/@babel/runtime/helpers/esm/objectSpread2.js
function ownKeys3(e4, r2) {
  var t4 = Object.keys(e4);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e4);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e4, r3).enumerable;
    })), t4.push.apply(t4, o);
  }
  return t4;
}
function _objectSpread22(e4) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t4 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys3(Object(t4), true).forEach(function(r3) {
      _defineProperty(e4, r3, t4[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(t4)) : ownKeys3(Object(t4)).forEach(function(r3) {
      Object.defineProperty(e4, r3, Object.getOwnPropertyDescriptor(t4, r3));
    });
  }
  return e4;
}

// node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles3(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}

// node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray3(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}

// node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread3() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray3(arr) {
  return _arrayWithoutHoles3(arr) || _iterableToArray3(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread3();
}

// node_modules/react-select/dist/Select-40119e12.esm.js
var React47 = __toESM(require_react());
var import_react154 = __toESM(require_react());

// node_modules/@emotion/react/dist/emotion-element-c39617d8.browser.esm.js
var React45 = __toESM(require_react());
var import_react150 = __toESM(require_react());

// node_modules/@emotion/sheet/dist/emotion-sheet.browser.esm.js
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
    if (document.styleSheets[i2].ownerNode === tag) {
      return document.styleSheets[i2];
    }
  }
}
function createStyleElement(options2) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options2.key);
  if (options2.nonce !== void 0) {
    tag.setAttribute("nonce", options2.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = function() {
  function StyleSheet2(options2) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options2.speedy === void 0 ? false : options2.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options2.nonce;
    this.key = options2.key;
    this.container = options2.container;
    this.prepend = options2.prepend;
    this.insertionPoint = options2.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert2(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (true) {
      var isImportRule3 = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
      if (isImportRule3 && this._alreadyInsertedOrderInsensitiveRule) {
        console.error("You're attempting to insert the following rule:\n" + rule + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.");
      }
      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule3;
    }
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e4) {
        if (!/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {
          console.error('There was a problem inserting the following rule: "' + rule + '"', e4);
        }
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
    if (true) {
      this._alreadyInsertedOrderInsensitiveRule = false;
    }
  };
  return StyleSheet2;
}();

// node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

// node_modules/stylis/src/Utility.js
var abs = Math.abs;
var from = String.fromCharCode;
var assign2 = Object.assign;
function hash3(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match2(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search3) {
  return value.indexOf(search3);
}
function charat(value, index4) {
  return value.charCodeAt(index4) | 0;
}
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}

// node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node2(value, root, parent, type, props, children, length2) {
  return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
}
function copy(root, props) {
  return assign2(node2("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end2) {
  return substr(characters, begin, end2);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index4, count2) {
  while (--count2 && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index4, caret() + (count2 < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index4) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index4, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier2(index4) {
  while (!token(peek()))
    next();
  return slice(index4, position);
}

// node_modules/stylis/src/Parser.js
function compile(value) {
  return dealloc(parse2("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse2(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index4 = 0;
  var offset3 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference2 = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index4++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset3:
            if (ampersand == -1)
              characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference2 = ruleset(characters2, root, parent, index4, offset3, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset3 === 0)
                parse2(characters2, root, reference2, reference2, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse2(value, reference2, reference2, rule && append(ruleset(value, reference2, reference2, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse2(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                }
        }
        index4 = offset3 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset3 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index4++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset3 = length2 = strlen(type = characters2 += identifier2(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index4, offset3, rules, points, type, props, children, length2) {
  var post = offset3 - 1;
  var rule = offset3 === 0 ? rules : [""];
  var size3 = sizeof(rule);
  for (var i2 = 0, j = 0, k2 = 0; i2 < index4; ++i2)
    for (var x2 = 0, y3 = substr(value, post + 1, post = abs(j = points[i2])), z2 = value; x2 < size3; ++x2)
      if (z2 = trim(j > 0 ? rule[x2] + " " + y3 : replace(y3, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node2(value, root, parent, offset3 === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root, parent) {
  return node2(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent, length2) {
  return node2(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}

// node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i2 = 0; i2 < length2; i2++)
    output += callback(children[i2], i2, children, callback) || "";
  return output;
}
function stringify(element, index4, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}

// node_modules/stylis/src/Middleware.js
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index4, children, callback) {
    var output = "";
    for (var i2 = 0; i2 < length2; i2++)
      output += collection[i2](element, index4, children, callback) || "";
    return output;
  };
}

// node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js
var weakMemoize = function weakMemoize2(func2) {
  var cache = /* @__PURE__ */ new WeakMap();
  return function(arg) {
    if (cache.has(arg)) {
      return cache.get(arg);
    }
    var ret = func2(arg);
    cache.set(arg, ret);
    return ret;
  };
};

// node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function memoize(fn2) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0)
      cache[arg] = fn2(arg);
    return cache[arg];
  };
}

// node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index4) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index4] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index4 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index4] = 1;
        }
        parsed[index4] += identifierWithPointTracking(position - 1, points, index4);
        break;
      case 2:
        parsed[index4] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index4] = peek() === 58 ? "&\f" : "";
          points[index4] = parsed[index4].length;
          break;
        }
      default:
        parsed[index4] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i2 = 0, k2 = 0; i2 < rules.length; i2++) {
    for (var j = 0; j < parentRules.length; j++, k2++) {
      element.props[k2] = points[i2] ? rules[i2].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i2];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
var ignoreFlag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason";
var isIgnoringComment = function isIgnoringComment2(element) {
  return element.type === "comm" && element.children.indexOf(ignoreFlag) > -1;
};
var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm2(cache) {
  return function(element, index4, children) {
    if (element.type !== "rule" || cache.compat)
      return;
    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);
    if (unsafePseudoClasses) {
      var isNested2 = !!element.parent;
      var commentContainer = isNested2 ? element.parent.children : (
        // global rule at the root level
        children
      );
      for (var i2 = commentContainer.length - 1; i2 >= 0; i2--) {
        var node3 = commentContainer[i2];
        if (node3.line < element.line) {
          break;
        }
        if (node3.column < element.column) {
          if (isIgnoringComment(node3)) {
            return;
          }
          break;
        }
      }
      unsafePseudoClasses.forEach(function(unsafePseudoClass) {
        console.error('The pseudo class "' + unsafePseudoClass + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + unsafePseudoClass.split("-child")[0] + '-of-type".');
      });
    }
  };
};
var isImportRule = function isImportRule2(element) {
  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};
var isPrependedWithRegularRules = function isPrependedWithRegularRules2(index4, children) {
  for (var i2 = index4 - 1; i2 >= 0; i2--) {
    if (!isImportRule(children[i2])) {
      return true;
    }
  }
  return false;
};
var nullifyElement = function nullifyElement2(element) {
  element.type = "";
  element.value = "";
  element["return"] = "";
  element.children = "";
  element.props = "";
};
var incorrectImportAlarm = function incorrectImportAlarm2(element, index4, children) {
  if (!isImportRule(element)) {
    return;
  }
  if (element.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element);
  } else if (isPrependedWithRegularRules(index4, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element);
  }
};
function prefix2(value, length2) {
  switch (hash3(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix2(replace(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index4, children, callback) {
  if (element.length > -1) {
    if (!element["return"])
      switch (element.type) {
        case DECLARATION:
          element["return"] = prefix2(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize([copy(element, {
            value: replace(element.value, "@", "@" + WEBKIT)
          })], callback);
        case RULESET:
          if (element.length)
            return combine(element.props, function(value) {
              switch (match2(value, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize([copy(element, {
                    props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                  })], callback);
                case "::placeholder":
                  return serialize([copy(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                  }), copy(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                  }), copy(element, {
                    props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                  })], callback);
              }
              return "";
            });
      }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options2) {
  var key = options2.key;
  if (!key) {
    throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
  }
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node3) {
      var dataEmotionAttribute = node3.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node3);
      node3.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options2.stylisPlugins || defaultStylisPlugins;
  if (true) {
    if (/[^a-z-]/.test(key)) {
      throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
    }
  }
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options2.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node3) {
        var attrib = node3.getAttribute("data-emotion").split(" ");
        for (var i2 = 1; i2 < attrib.length; i2++) {
          inserted[attrib[i2]] = true;
        }
        nodesToHydrate.push(node3);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  if (true) {
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
      get compat() {
        return cache.compat;
      }
    }), incorrectImportAlarm);
  }
  {
    var currentSheet;
    var finalizingPlugins = [stringify, true ? function(element) {
      if (!element.root) {
        if (element["return"]) {
          currentSheet.insert(element["return"]);
        } else if (element.value && element.type !== COMMENT) {
          currentSheet.insert(element.value + "{}");
        }
      }
    } : rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize(compile(styles2), serializer);
    };
    _insert = function insert2(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      if (serialized.map !== void 0) {
        currentSheet = {
          insert: function insert3(rule) {
            sheet.insert(rule + serialized.map);
          }
        };
      }
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options2.nonce,
      speedy: options2.speedy,
      prepend: options2.prepend,
      insertionPoint: options2.insertionPoint
    }),
    nonce: options2.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};

// node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());

// node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
var isBrowser2 = true;
function getRegisteredStyles(registered, registeredStyles, classNames3) {
  var rawClassName = "";
  classNames3.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser2 === false) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};

// node_modules/@emotion/hash/dist/emotion-hash.esm.js
function murmur2(str) {
  var h3 = 0;
  var k2, i2 = 0, len = str.length;
  for (; len >= 4; ++i2, len -= 4) {
    k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h3 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h3 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
    case 2:
      h3 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
    case 1:
      h3 ^= str.charCodeAt(i2) & 255;
      h3 = /* Math.imul(h, m): */
      (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
  }
  h3 ^= h3 >>> 13;
  h3 = /* Math.imul(h, m): */
  (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
  return ((h3 ^ h3 >>> 15) >>> 0).toString(36);
}

// node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

// node_modules/@emotion/serialize/dist/emotion-serialize.browser.esm.js
var ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match3, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
if (true) {
  contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
  contentValues = ["normal", "none", "initial", "inherit", "unset"];
  oldProcessStyleValue = processStyleValue;
  msPattern = /^-ms-/;
  hyphenPattern = /-(.)/g;
  hyphenatedCache = {};
  processStyleValue = function processStyleValue3(key, value) {
    if (key === "content") {
      if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
      }
    }
    var processed = oldProcessStyleValue(key, value);
    if (processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === void 0) {
      hyphenatedCache[key] = true;
      console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, "ms-").replace(hyphenPattern, function(str, _char) {
        return _char.toUpperCase();
      }) + "?");
    }
    return processed;
  };
}
var contentValuePattern;
var contentValues;
var oldProcessStyleValue;
var msPattern;
var hyphenPattern;
var hyphenatedCache;
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    if (interpolation.toString() === "NO_COMPONENT_SELECTOR") {
      throw new Error(noComponentSelectorMessage);
    }
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = interpolation.styles + ";";
        if (interpolation.map !== void 0) {
          styles2 += interpolation.map;
        }
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      } else if (true) {
        console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      }
      break;
    }
    case "string":
      if (true) {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function(match3, p1, p2) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, "") + "`");
          return "${" + fakeVarName + "}";
        });
        if (matched.length) {
          console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\n" + ("css`" + replaced + "`"));
        }
      }
      break;
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string3 = "";
  if (Array.isArray(obj)) {
    for (var i2 = 0; i2 < obj.length; i2++) {
      string3 += handleInterpolation(mergedProps, registered, obj[i2]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string3 += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string3 += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && true) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string3 += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string3 += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              if (_key === "undefined") {
                console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
              }
              string3 += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string3;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var sourceMapPattern;
if (true) {
  sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
}
var cursor;
var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    if (strings[0] === void 0) {
      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
    }
    styles2 += strings[0];
  }
  for (var i2 = 1; i2 < args.length; i2++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i2]);
    if (stringMode) {
      if (strings[i2] === void 0) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }
      styles2 += strings[i2];
    }
  }
  var sourceMap;
  if (true) {
    styles2 = styles2.replace(sourceMapPattern, function(match4) {
      sourceMap = match4;
      return "";
    });
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match3;
  while ((match3 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + // $FlowFixMe we know it's not null
    match3[1];
  }
  var name2 = murmur2(styles2) + identifierName;
  if (true) {
    return {
      name: name2,
      styles: styles2,
      map: sourceMap,
      next: cursor,
      toString: function toString3() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    };
  }
  return {
    name: name2,
    styles: styles2,
    next: cursor
  };
};

// node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js
var React44 = __toESM(require_react());
var syncFallback = function syncFallback2(create2) {
  return create2();
};
var useInsertionEffect3 = React44["useInsertionEffect"] ? React44["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect3 || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect3 || React44.useLayoutEffect;

// node_modules/@emotion/react/dist/emotion-element-c39617d8.browser.esm.js
var isBrowser3 = true;
var hasOwnProperty = {}.hasOwnProperty;
var EmotionCacheContext = React45.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? createCache({
    key: "css"
  }) : null
);
if (true) {
  EmotionCacheContext.displayName = "EmotionCacheContext";
}
var CacheProvider = EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func2) {
  return (0, import_react150.forwardRef)(function(props, ref) {
    var cache = (0, import_react150.useContext)(EmotionCacheContext);
    return func2(props, cache, ref);
  });
};
if (!isBrowser3) {
  withEmotionCache = function withEmotionCache3(func2) {
    return function(props) {
      var cache = (0, import_react150.useContext)(EmotionCacheContext);
      if (cache === null) {
        cache = createCache({
          key: "css"
        });
        return React45.createElement(EmotionCacheContext.Provider, {
          value: cache
        }, func2(props, cache));
      } else {
        return func2(props, cache);
      }
    };
  };
}
var ThemeContext2 = React45.createContext({});
if (true) {
  ThemeContext2.displayName = "EmotionThemeContext";
}
var getTheme = function getTheme2(outerTheme, theme2) {
  if (typeof theme2 === "function") {
    var mergedTheme = theme2(outerTheme);
    if (mergedTheme == null || typeof mergedTheme !== "object" || Array.isArray(mergedTheme)) {
      throw new Error("[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!");
    }
    return mergedTheme;
  }
  if (theme2 == null || typeof theme2 !== "object" || Array.isArray(theme2)) {
    throw new Error("[ThemeProvider] Please make your theme prop a plain object");
  }
  return _extends2({}, outerTheme, theme2);
};
var createCacheWithTheme = weakMemoize(function(outerTheme) {
  return weakMemoize(function(theme2) {
    return getTheme(outerTheme, theme2);
  });
});
var getLastPart = function getLastPart2(functionName) {
  var parts = functionName.split(".");
  return parts[parts.length - 1];
};
var getFunctionNameFromStackTraceLine = function getFunctionNameFromStackTraceLine2(line2) {
  var match3 = /^\s+at\s+([A-Za-z0-9$.]+)\s/.exec(line2);
  if (match3)
    return getLastPart(match3[1]);
  match3 = /^([A-Za-z0-9$.]+)@/.exec(line2);
  if (match3)
    return getLastPart(match3[1]);
  return void 0;
};
var internalReactFunctionNames = /* @__PURE__ */ new Set(["renderWithHooks", "processChild", "finishClassComponent", "renderToString"]);
var sanitizeIdentifier = function sanitizeIdentifier2(identifier3) {
  return identifier3.replace(/\$/g, "-");
};
var getLabelFromStackTrace = function getLabelFromStackTrace2(stackTrace) {
  if (!stackTrace)
    return void 0;
  var lines = stackTrace.split("\n");
  for (var i2 = 0; i2 < lines.length; i2++) {
    var functionName = getFunctionNameFromStackTraceLine(lines[i2]);
    if (!functionName)
      continue;
    if (internalReactFunctionNames.has(functionName))
      break;
    if (/^[A-Z]/.test(functionName))
      return sanitizeIdentifier(functionName);
  }
  return void 0;
};
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var labelPropName = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type, props) {
  if (typeof props.css === "string" && // check if there is a css declaration
  props.css.indexOf(":") !== -1) {
    throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/react' like this: css`" + props.css + "`");
  }
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty.call(props, key)) {
      newProps[key] = props[key];
    }
  }
  newProps[typePropName] = type;
  if (!!props.css && (typeof props.css !== "object" || typeof props.css.name !== "string" || props.css.name.indexOf("-") === -1)) {
    var label = getLabelFromStackTrace(new Error().stack);
    if (label)
      newProps[labelPropName] = label;
  }
  return newProps;
};
var Insertion = function Insertion2(_ref4) {
  var cache = _ref4.cache, serialized = _ref4.serialized, isStringTag = _ref4.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag);
  });
  return null;
};
var Emotion = withEmotionCache(function(props, cache, ref) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
    cssProp = cache.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, React45.useContext(ThemeContext2));
  if (serialized.name.indexOf("-") === -1) {
    var labelFromStack = props[labelPropName];
    if (labelFromStack) {
      serialized = serializeStyles([serialized, "label:" + labelFromStack + ";"]);
    }
  }
  className += cache.key + "-" + serialized.name;
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty.call(props, key) && key !== "css" && key !== typePropName && key !== labelPropName) {
      newProps[key] = props[key];
    }
  }
  newProps.ref = ref;
  newProps.className = className;
  return React45.createElement(React45.Fragment, null, React45.createElement(Insertion, {
    cache,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), React45.createElement(WrappedComponent, newProps));
});
if (true) {
  Emotion.displayName = "EmotionCssPropInternal";
}
var Emotion$1 = Emotion;

// node_modules/@emotion/react/dist/emotion-react.browser.esm.js
var React46 = __toESM(require_react());
var import_hoist_non_react_statics2 = __toESM(require_hoist_non_react_statics_cjs());
var pkg = {
  name: "@emotion/react",
  version: "11.11.3",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  browser: {
    "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
  },
  exports: {
    ".": {
      module: {
        worker: "./dist/emotion-react.worker.esm.js",
        browser: "./dist/emotion-react.browser.esm.js",
        "default": "./dist/emotion-react.esm.js"
      },
      "import": "./dist/emotion-react.cjs.mjs",
      "default": "./dist/emotion-react.cjs.js"
    },
    "./jsx-runtime": {
      module: {
        worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
        browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
      },
      "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
      "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
    },
    "./_isolated-hnrs": {
      module: {
        worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
        browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
      },
      "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
      "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
    },
    "./jsx-dev-runtime": {
      module: {
        worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
        browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
      },
      "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
      "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
    },
    "./package.json": "./package.json",
    "./types/css-prop": "./types/css-prop.d.ts",
    "./macro": {
      types: {
        "import": "./macro.d.mts",
        "default": "./macro.d.ts"
      },
      "default": "./macro.js"
    }
  },
  types: "types/index.d.ts",
  files: [
    "src",
    "dist",
    "jsx-runtime",
    "jsx-dev-runtime",
    "_isolated-hnrs",
    "types/*.d.ts",
    "macro.*"
  ],
  sideEffects: false,
  author: "Emotion Contributors",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@emotion/babel-plugin": "^11.11.0",
    "@emotion/cache": "^11.11.0",
    "@emotion/serialize": "^1.1.3",
    "@emotion/use-insertion-effect-with-fallbacks": "^1.0.1",
    "@emotion/utils": "^1.2.1",
    "@emotion/weak-memoize": "^0.3.1",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@types/react": {
      optional: true
    }
  },
  devDependencies: {
    "@definitelytyped/dtslint": "0.0.112",
    "@emotion/css": "11.11.2",
    "@emotion/css-prettifier": "1.1.3",
    "@emotion/server": "11.11.0",
    "@emotion/styled": "11.11.0",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1",
    typescript: "^4.5.5"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: [
      "./index.js",
      "./jsx-runtime.js",
      "./jsx-dev-runtime.js",
      "./_isolated-hnrs.js"
    ],
    umdName: "emotionReact",
    exports: {
      envConditions: [
        "browser",
        "worker"
      ],
      extra: {
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": {
          types: {
            "import": "./macro.d.mts",
            "default": "./macro.d.ts"
          },
          "default": "./macro.js"
        }
      }
    }
  }
};
var jsx = function jsx2(type, props) {
  var args = arguments;
  if (props == null || !hasOwnProperty.call(props, "css")) {
    return React46.createElement.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type, props);
  for (var i2 = 2; i2 < argsLength; i2++) {
    createElementArgArray[i2] = args[i2];
  }
  return React46.createElement.apply(null, createElementArgArray);
};
var warnedAboutCssPropForGlobal = false;
var Global = withEmotionCache(function(props, cache) {
  if (!warnedAboutCssPropForGlobal && // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // $FlowFixMe I don't really want to add it to the type since it shouldn't be used
  (props.className || props.css)) {
    console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?");
    warnedAboutCssPropForGlobal = true;
  }
  var styles2 = props.styles;
  var serialized = serializeStyles([styles2], void 0, React46.useContext(ThemeContext2));
  if (!isBrowser3) {
    var _ref4;
    var serializedNames = serialized.name;
    var serializedStyles = serialized.styles;
    var next2 = serialized.next;
    while (next2 !== void 0) {
      serializedNames += " " + next2.name;
      serializedStyles += next2.styles;
      next2 = next2.next;
    }
    var shouldCache = cache.compat === true;
    var rules = cache.insert("", {
      name: serializedNames,
      styles: serializedStyles
    }, cache.sheet, shouldCache);
    if (shouldCache) {
      return null;
    }
    return React46.createElement("style", (_ref4 = {}, _ref4["data-emotion"] = cache.key + "-global " + serializedNames, _ref4.dangerouslySetInnerHTML = {
      __html: rules
    }, _ref4.nonce = cache.sheet.nonce, _ref4));
  }
  var sheetRef = React46.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache.key + "-global";
    var sheet = new cache.sheet.constructor({
      key,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false;
    var node3 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }
    if (node3 !== null) {
      rehydrating = true;
      node3.setAttribute("data-emotion", key);
      sheet.hydrate([node3]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
});
if (true) {
  Global.displayName = "EmotionGlobal";
}
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
var keyframes = function keyframes2() {
  var insertable = css.apply(void 0, arguments);
  var name2 = "animation-" + insertable.name;
  return {
    name: name2,
    styles: "@keyframes " + name2 + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString3() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
var classnames = function classnames2(args) {
  var len = args.length;
  var i2 = 0;
  var cls = "";
  for (; i2 < len; i2++) {
    var arg = args[i2];
    if (arg == null)
      continue;
    var toAdd = void 0;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames2(arg);
        } else {
          if (arg.styles !== void 0 && arg.name !== void 0) {
            console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.");
          }
          toAdd = "";
          for (var k2 in arg) {
            if (arg[k2] && k2) {
              toAdd && (toAdd += " ");
              toAdd += k2;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};
function merge(registered, css5, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css5(registeredStyles);
}
var Insertion3 = function Insertion4(_ref4) {
  var cache = _ref4.cache, serializedArr = _ref4.serializedArr;
  useInsertionEffectAlwaysWithSyncFallback(function() {
    for (var i2 = 0; i2 < serializedArr.length; i2++) {
      insertStyles(cache, serializedArr[i2], false);
    }
  });
  return null;
};
var ClassNames = withEmotionCache(function(props, cache) {
  var hasRendered = false;
  var serializedArr = [];
  var css5 = function css6() {
    if (hasRendered && true) {
      throw new Error("css can only be used during render");
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var serialized = serializeStyles(args, cache.registered);
    serializedArr.push(serialized);
    registerStyles(cache, serialized, false);
    return cache.key + "-" + serialized.name;
  };
  var cx = function cx2() {
    if (hasRendered && true) {
      throw new Error("cx can only be used during render");
    }
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return merge(cache.registered, css5, classnames(args));
  };
  var content2 = {
    css: css5,
    cx,
    theme: React46.useContext(ThemeContext2)
  };
  var ele = props.children(content2);
  hasRendered = true;
  return React46.createElement(React46.Fragment, null, React46.createElement(Insertion3, {
    cache,
    serializedArr
  }), ele);
});
if (true) {
  ClassNames.displayName = "EmotionClassNames";
}
if (true) {
  isBrowser4 = true;
  isTestEnv = typeof jest !== "undefined" || typeof vi !== "undefined";
  if (isBrowser4 && !isTestEnv) {
    globalContext = // $FlowIgnore
    typeof globalThis !== "undefined" ? globalThis : isBrowser4 ? window : global;
    globalKey = "__EMOTION_REACT_" + pkg.version.split(".")[0] + "__";
    if (globalContext[globalKey]) {
      console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used.");
    }
    globalContext[globalKey] = true;
  }
}
var isBrowser4;
var isTestEnv;
var globalContext;
var globalKey;

// node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles3(arr) {
  if (Array.isArray(arr))
    return arr;
}

// node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit3(r2, l) {
  var t4 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t4) {
    var e4, n, i2, u2, a3 = [], f = true, o = false;
    try {
      if (i2 = (t4 = t4.call(r2)).next, 0 === l) {
        if (Object(t4) !== t4)
          return;
        f = false;
      } else
        for (; !(f = (e4 = i2.call(t4)).done) && (a3.push(e4.value), a3.length !== l); f = true)
          ;
    } catch (r3) {
      o = true, n = r3;
    } finally {
      try {
        if (!f && null != t4["return"] && (u2 = t4["return"](), Object(u2) !== u2))
          return;
      } finally {
        if (o)
          throw n;
      }
    }
    return a3;
  }
}

// node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray3(arr, i2) {
  return _arrayWithHoles3(arr) || _iterableToArrayLimit3(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest3();
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties2(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}

// node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js
function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

// node_modules/react-select/dist/index-a86253bb.esm.js
var import_react153 = __toESM(require_react());
var import_react_dom7 = __toESM(require_react_dom());

// node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js
var import_react151 = __toESM(require_react());
var index3 = import_react151.useLayoutEffect;
var use_isomorphic_layout_effect_browser_esm_default = index3;

// node_modules/react-select/dist/index-a86253bb.esm.js
var _excluded$3 = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"];
var noop3 = function noop4() {
};
function applyPrefixToName(prefix3, name2) {
  if (!name2) {
    return prefix3;
  } else if (name2[0] === "-") {
    return prefix3 + name2;
  } else {
    return prefix3 + "__" + name2;
  }
}
function classNames2(prefix3, state) {
  for (var _len = arguments.length, classNameList = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    classNameList[_key - 2] = arguments[_key];
  }
  var arr = [].concat(classNameList);
  if (state && prefix3) {
    for (var key in state) {
      if (state.hasOwnProperty(key) && state[key]) {
        arr.push("".concat(applyPrefixToName(prefix3, key)));
      }
    }
  }
  return arr.filter(function(i2) {
    return i2;
  }).map(function(i2) {
    return String(i2).trim();
  }).join(" ");
}
var cleanValue = function cleanValue2(value) {
  if (isArray(value))
    return value.filter(Boolean);
  if (_typeof(value) === "object" && value !== null)
    return [value];
  return [];
};
var cleanCommonProps = function cleanCommonProps2(props) {
  props.className;
  props.clearValue;
  props.cx;
  props.getStyles;
  props.getClassNames;
  props.getValue;
  props.hasValue;
  props.isMulti;
  props.isRtl;
  props.options;
  props.selectOption;
  props.selectProps;
  props.setValue;
  props.theme;
  var innerProps = _objectWithoutProperties2(props, _excluded$3);
  return _objectSpread22({}, innerProps);
};
var getStyleProps = function getStyleProps2(props, name2, classNamesState) {
  var cx = props.cx, getStyles = props.getStyles, getClassNames = props.getClassNames, className = props.className;
  return {
    css: getStyles(name2, props),
    className: cx(classNamesState !== null && classNamesState !== void 0 ? classNamesState : {}, getClassNames(name2, props), className)
  };
};
function handleInputChange(inputValue, actionMeta, onInputChange) {
  if (onInputChange) {
    var _newValue = onInputChange(inputValue, actionMeta);
    if (typeof _newValue === "string")
      return _newValue;
  }
  return inputValue;
}
function isDocumentElement(el) {
  return [document.documentElement, document.body, window].indexOf(el) > -1;
}
function normalizedHeight(el) {
  if (isDocumentElement(el)) {
    return window.innerHeight;
  }
  return el.clientHeight;
}
function getScrollTop(el) {
  if (isDocumentElement(el)) {
    return window.pageYOffset;
  }
  return el.scrollTop;
}
function scrollTo(el, top3) {
  if (isDocumentElement(el)) {
    window.scrollTo(0, top3);
    return;
  }
  el.scrollTop = top3;
}
function getScrollParent2(element) {
  var style = getComputedStyle(element);
  var excludeStaticParent = style.position === "absolute";
  var overflowRx = /(auto|scroll)/;
  if (style.position === "fixed")
    return document.documentElement;
  for (var parent = element; parent = parent.parentElement; ) {
    style = getComputedStyle(parent);
    if (excludeStaticParent && style.position === "static") {
      continue;
    }
    if (overflowRx.test(style.overflow + style.overflowY + style.overflowX)) {
      return parent;
    }
  }
  return document.documentElement;
}
function easeOutCubic(t4, b2, c2, d3) {
  return c2 * ((t4 = t4 / d3 - 1) * t4 * t4 + 1) + b2;
}
function animatedScrollTo(element, to) {
  var duration = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200;
  var callback = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : noop3;
  var start2 = getScrollTop(element);
  var change = to - start2;
  var increment = 10;
  var currentTime = 0;
  function animateScroll() {
    currentTime += increment;
    var val = easeOutCubic(currentTime, start2, change, duration);
    scrollTo(element, val);
    if (currentTime < duration) {
      window.requestAnimationFrame(animateScroll);
    } else {
      callback(element);
    }
  }
  animateScroll();
}
function scrollIntoView(menuEl, focusedEl) {
  var menuRect = menuEl.getBoundingClientRect();
  var focusedRect = focusedEl.getBoundingClientRect();
  var overScroll = focusedEl.offsetHeight / 3;
  if (focusedRect.bottom + overScroll > menuRect.bottom) {
    scrollTo(menuEl, Math.min(focusedEl.offsetTop + focusedEl.clientHeight - menuEl.offsetHeight + overScroll, menuEl.scrollHeight));
  } else if (focusedRect.top - overScroll < menuRect.top) {
    scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
  }
}
function getBoundingClientObj(element) {
  var rect = element.getBoundingClientRect();
  return {
    bottom: rect.bottom,
    height: rect.height,
    left: rect.left,
    right: rect.right,
    top: rect.top,
    width: rect.width
  };
}
function isTouchCapable() {
  try {
    document.createEvent("TouchEvent");
    return true;
  } catch (e4) {
    return false;
  }
}
function isMobileDevice() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch (e4) {
    return false;
  }
}
var passiveOptionAccessed = false;
var options = {
  get passive() {
    return passiveOptionAccessed = true;
  }
};
var w2 = typeof window !== "undefined" ? window : {};
if (w2.addEventListener && w2.removeEventListener) {
  w2.addEventListener("p", noop3, options);
  w2.removeEventListener("p", noop3, false);
}
var supportsPassiveEvents = passiveOptionAccessed;
function notNullish(item) {
  return item != null;
}
function isArray(arg) {
  return Array.isArray(arg);
}
function valueTernary(isMulti, multiValue, singleValue) {
  return isMulti ? multiValue : singleValue;
}
function singleValueAsValue(singleValue) {
  return singleValue;
}
function multiValueAsValue(multiValue) {
  return multiValue;
}
var removeProps = function removeProps2(propsObj) {
  for (var _len2 = arguments.length, properties = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    properties[_key2 - 1] = arguments[_key2];
  }
  var propsMap = Object.entries(propsObj).filter(function(_ref4) {
    var _ref23 = _slicedToArray3(_ref4, 1), key = _ref23[0];
    return !properties.includes(key);
  });
  return propsMap.reduce(function(newProps, _ref32) {
    var _ref4 = _slicedToArray3(_ref32, 2), key = _ref4[0], val = _ref4[1];
    newProps[key] = val;
    return newProps;
  }, {});
};
function getMenuPlacement(_ref4) {
  var preferredMaxHeight = _ref4.maxHeight, menuEl = _ref4.menuEl, minHeight = _ref4.minHeight, preferredPlacement = _ref4.placement, shouldScroll = _ref4.shouldScroll, isFixedPosition = _ref4.isFixedPosition, controlHeight2 = _ref4.controlHeight;
  var scrollParent = getScrollParent2(menuEl);
  var defaultState2 = {
    placement: "bottom",
    maxHeight: preferredMaxHeight
  };
  if (!menuEl || !menuEl.offsetParent)
    return defaultState2;
  var _scrollParent$getBoun = scrollParent.getBoundingClientRect(), scrollHeight = _scrollParent$getBoun.height;
  var _menuEl$getBoundingCl = menuEl.getBoundingClientRect(), menuBottom = _menuEl$getBoundingCl.bottom, menuHeight = _menuEl$getBoundingCl.height, menuTop = _menuEl$getBoundingCl.top;
  var _menuEl$offsetParent$ = menuEl.offsetParent.getBoundingClientRect(), containerTop = _menuEl$offsetParent$.top;
  var viewHeight = isFixedPosition ? window.innerHeight : normalizedHeight(scrollParent);
  var scrollTop = getScrollTop(scrollParent);
  var marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10);
  var marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10);
  var viewSpaceAbove = containerTop - marginTop;
  var viewSpaceBelow = viewHeight - menuTop;
  var scrollSpaceAbove = viewSpaceAbove + scrollTop;
  var scrollSpaceBelow = scrollHeight - scrollTop - menuTop;
  var scrollDown = menuBottom - viewHeight + scrollTop + marginBottom;
  var scrollUp = scrollTop + menuTop - marginTop;
  var scrollDuration = 160;
  switch (preferredPlacement) {
    case "auto":
    case "bottom":
      if (viewSpaceBelow >= menuHeight) {
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      if (scrollSpaceBelow >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      if (!isFixedPosition && scrollSpaceBelow >= minHeight || isFixedPosition && viewSpaceBelow >= minHeight) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        var constrainedHeight = isFixedPosition ? viewSpaceBelow - marginBottom : scrollSpaceBelow - marginBottom;
        return {
          placement: "bottom",
          maxHeight: constrainedHeight
        };
      }
      if (preferredPlacement === "auto" || isFixedPosition) {
        var _constrainedHeight = preferredMaxHeight;
        var spaceAbove = isFixedPosition ? viewSpaceAbove : scrollSpaceAbove;
        if (spaceAbove >= minHeight) {
          _constrainedHeight = Math.min(spaceAbove - marginBottom - controlHeight2, preferredMaxHeight);
        }
        return {
          placement: "top",
          maxHeight: _constrainedHeight
        };
      }
      if (preferredPlacement === "bottom") {
        if (shouldScroll) {
          scrollTo(scrollParent, scrollDown);
        }
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      break;
    case "top":
      if (viewSpaceAbove >= menuHeight) {
        return {
          placement: "top",
          maxHeight: preferredMaxHeight
        };
      }
      if (scrollSpaceAbove >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: "top",
          maxHeight: preferredMaxHeight
        };
      }
      if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
        var _constrainedHeight2 = preferredMaxHeight;
        if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
          _constrainedHeight2 = isFixedPosition ? viewSpaceAbove - marginTop : scrollSpaceAbove - marginTop;
        }
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: "top",
          maxHeight: _constrainedHeight2
        };
      }
      return {
        placement: "bottom",
        maxHeight: preferredMaxHeight
      };
    default:
      throw new Error('Invalid placement provided "'.concat(preferredPlacement, '".'));
  }
  return defaultState2;
}
function alignToControl(placement) {
  var placementToCSSProp = {
    bottom: "top",
    top: "bottom"
  };
  return placement ? placementToCSSProp[placement] : "bottom";
}
var coercePlacement = function coercePlacement2(p) {
  return p === "auto" ? "bottom" : p;
};
var menuCSS = function menuCSS2(_ref23, unstyled) {
  var _objectSpread23;
  var placement = _ref23.placement, _ref2$theme = _ref23.theme, borderRadius2 = _ref2$theme.borderRadius, spacing2 = _ref2$theme.spacing, colors2 = _ref2$theme.colors;
  return _objectSpread22((_objectSpread23 = {
    label: "menu"
  }, _defineProperty(_objectSpread23, alignToControl(placement), "100%"), _defineProperty(_objectSpread23, "position", "absolute"), _defineProperty(_objectSpread23, "width", "100%"), _defineProperty(_objectSpread23, "zIndex", 1), _objectSpread23), unstyled ? {} : {
    backgroundColor: colors2.neutral0,
    borderRadius: borderRadius2,
    boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
    marginBottom: spacing2.menuGutter,
    marginTop: spacing2.menuGutter
  });
};
var PortalPlacementContext = (0, import_react153.createContext)(null);
var MenuPlacer = function MenuPlacer2(props) {
  var children = props.children, minMenuHeight = props.minMenuHeight, maxMenuHeight = props.maxMenuHeight, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition, menuShouldScrollIntoView = props.menuShouldScrollIntoView, theme2 = props.theme;
  var _ref32 = (0, import_react153.useContext)(PortalPlacementContext) || {}, setPortalPlacement = _ref32.setPortalPlacement;
  var ref = (0, import_react153.useRef)(null);
  var _useState = (0, import_react153.useState)(maxMenuHeight), _useState2 = _slicedToArray3(_useState, 2), maxHeight = _useState2[0], setMaxHeight = _useState2[1];
  var _useState3 = (0, import_react153.useState)(null), _useState4 = _slicedToArray3(_useState3, 2), placement = _useState4[0], setPlacement = _useState4[1];
  var controlHeight2 = theme2.spacing.controlHeight;
  use_isomorphic_layout_effect_browser_esm_default(function() {
    var menuEl = ref.current;
    if (!menuEl)
      return;
    var isFixedPosition = menuPosition === "fixed";
    var shouldScroll = menuShouldScrollIntoView && !isFixedPosition;
    var state = getMenuPlacement({
      maxHeight: maxMenuHeight,
      menuEl,
      minHeight: minMenuHeight,
      placement: menuPlacement,
      shouldScroll,
      isFixedPosition,
      controlHeight: controlHeight2
    });
    setMaxHeight(state.maxHeight);
    setPlacement(state.placement);
    setPortalPlacement === null || setPortalPlacement === void 0 ? void 0 : setPortalPlacement(state.placement);
  }, [maxMenuHeight, menuPlacement, menuPosition, menuShouldScrollIntoView, minMenuHeight, setPortalPlacement, controlHeight2]);
  return children({
    ref,
    placerProps: _objectSpread22(_objectSpread22({}, props), {}, {
      placement: placement || coercePlacement(menuPlacement),
      maxHeight
    })
  });
};
var Menu2 = function Menu3(props) {
  var children = props.children, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends2({}, getStyleProps(props, "menu", {
    menu: true
  }), {
    ref: innerRef
  }, innerProps), children);
};
var menuListCSS = function menuListCSS2(_ref4, unstyled) {
  var maxHeight = _ref4.maxHeight, baseUnit2 = _ref4.theme.spacing.baseUnit;
  return _objectSpread22({
    maxHeight,
    overflowY: "auto",
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }, unstyled ? {} : {
    paddingBottom: baseUnit2,
    paddingTop: baseUnit2
  });
};
var MenuList = function MenuList2(props) {
  var children = props.children, innerProps = props.innerProps, innerRef = props.innerRef, isMulti = props.isMulti;
  return jsx("div", _extends2({}, getStyleProps(props, "menuList", {
    "menu-list": true,
    "menu-list--is-multi": isMulti
  }), {
    ref: innerRef
  }, innerProps), children);
};
var noticeCSS = function noticeCSS2(_ref5, unstyled) {
  var _ref5$theme = _ref5.theme, baseUnit2 = _ref5$theme.spacing.baseUnit, colors2 = _ref5$theme.colors;
  return _objectSpread22({
    textAlign: "center"
  }, unstyled ? {} : {
    color: colors2.neutral40,
    padding: "".concat(baseUnit2 * 2, "px ").concat(baseUnit2 * 3, "px")
  });
};
var noOptionsMessageCSS = noticeCSS;
var loadingMessageCSS = noticeCSS;
var NoOptionsMessage = function NoOptionsMessage2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends2({}, getStyleProps(props, "noOptionsMessage", {
    "menu-notice": true,
    "menu-notice--no-options": true
  }), innerProps), children);
};
NoOptionsMessage.defaultProps = {
  children: "No options"
};
var LoadingMessage = function LoadingMessage2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends2({}, getStyleProps(props, "loadingMessage", {
    "menu-notice": true,
    "menu-notice--loading": true
  }), innerProps), children);
};
LoadingMessage.defaultProps = {
  children: "Loading..."
};
var menuPortalCSS = function menuPortalCSS2(_ref6) {
  var rect = _ref6.rect, offset3 = _ref6.offset, position2 = _ref6.position;
  return {
    left: rect.left,
    position: position2,
    top: offset3,
    width: rect.width,
    zIndex: 1
  };
};
var MenuPortal = function MenuPortal2(props) {
  var appendTo = props.appendTo, children = props.children, controlElement = props.controlElement, innerProps = props.innerProps, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition;
  var menuPortalRef = (0, import_react153.useRef)(null);
  var cleanupRef = (0, import_react153.useRef)(null);
  var _useState5 = (0, import_react153.useState)(coercePlacement(menuPlacement)), _useState6 = _slicedToArray3(_useState5, 2), placement = _useState6[0], setPortalPlacement = _useState6[1];
  var portalPlacementContext = (0, import_react153.useMemo)(function() {
    return {
      setPortalPlacement
    };
  }, []);
  var _useState7 = (0, import_react153.useState)(null), _useState8 = _slicedToArray3(_useState7, 2), computedPosition = _useState8[0], setComputedPosition = _useState8[1];
  var updateComputedPosition = (0, import_react153.useCallback)(function() {
    if (!controlElement)
      return;
    var rect = getBoundingClientObj(controlElement);
    var scrollDistance = menuPosition === "fixed" ? 0 : window.pageYOffset;
    var offset3 = rect[placement] + scrollDistance;
    if (offset3 !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset) || rect.left !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left) || rect.width !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width)) {
      setComputedPosition({
        offset: offset3,
        rect
      });
    }
  }, [controlElement, menuPosition, placement, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width]);
  use_isomorphic_layout_effect_browser_esm_default(function() {
    updateComputedPosition();
  }, [updateComputedPosition]);
  var runAutoUpdate = (0, import_react153.useCallback)(function() {
    if (typeof cleanupRef.current === "function") {
      cleanupRef.current();
      cleanupRef.current = null;
    }
    if (controlElement && menuPortalRef.current) {
      cleanupRef.current = autoUpdate(controlElement, menuPortalRef.current, updateComputedPosition, {
        elementResize: "ResizeObserver" in window
      });
    }
  }, [controlElement, updateComputedPosition]);
  use_isomorphic_layout_effect_browser_esm_default(function() {
    runAutoUpdate();
  }, [runAutoUpdate]);
  var setMenuPortalElement = (0, import_react153.useCallback)(function(menuPortalElement) {
    menuPortalRef.current = menuPortalElement;
    runAutoUpdate();
  }, [runAutoUpdate]);
  if (!appendTo && menuPosition !== "fixed" || !computedPosition)
    return null;
  var menuWrapper = jsx("div", _extends2({
    ref: setMenuPortalElement
  }, getStyleProps(_objectSpread22(_objectSpread22({}, props), {}, {
    offset: computedPosition.offset,
    position: menuPosition,
    rect: computedPosition.rect
  }), "menuPortal", {
    "menu-portal": true
  }), innerProps), children);
  return jsx(PortalPlacementContext.Provider, {
    value: portalPlacementContext
  }, appendTo ? (0, import_react_dom7.createPortal)(menuWrapper, appendTo) : menuWrapper);
};
var containerCSS = function containerCSS2(_ref4) {
  var isDisabled = _ref4.isDisabled, isRtl = _ref4.isRtl;
  return {
    label: "container",
    direction: isRtl ? "rtl" : void 0,
    pointerEvents: isDisabled ? "none" : void 0,
    // cancel mouse events when disabled
    position: "relative"
  };
};
var SelectContainer = function SelectContainer2(props) {
  var children = props.children, innerProps = props.innerProps, isDisabled = props.isDisabled, isRtl = props.isRtl;
  return jsx("div", _extends2({}, getStyleProps(props, "container", {
    "--is-disabled": isDisabled,
    "--is-rtl": isRtl
  }), innerProps), children);
};
var valueContainerCSS = function valueContainerCSS2(_ref23, unstyled) {
  var spacing2 = _ref23.theme.spacing, isMulti = _ref23.isMulti, hasValue = _ref23.hasValue, controlShouldRenderValue = _ref23.selectProps.controlShouldRenderValue;
  return _objectSpread22({
    alignItems: "center",
    display: isMulti && hasValue && controlShouldRenderValue ? "flex" : "grid",
    flex: 1,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, unstyled ? {} : {
    padding: "".concat(spacing2.baseUnit / 2, "px ").concat(spacing2.baseUnit * 2, "px")
  });
};
var ValueContainer = function ValueContainer2(props) {
  var children = props.children, innerProps = props.innerProps, isMulti = props.isMulti, hasValue = props.hasValue;
  return jsx("div", _extends2({}, getStyleProps(props, "valueContainer", {
    "value-container": true,
    "value-container--is-multi": isMulti,
    "value-container--has-value": hasValue
  }), innerProps), children);
};
var indicatorsContainerCSS = function indicatorsContainerCSS2() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
};
var IndicatorsContainer = function IndicatorsContainer2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends2({}, getStyleProps(props, "indicatorsContainer", {
    indicators: true
  }), innerProps), children);
};
var _templateObject;
var _excluded$2 = ["size"];
function _EMOTION_STRINGIFIED_CSS_ERROR__() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var _ref2 = false ? {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
} : {
  name: "tj5bde-Svg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0;label:Svg;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlCSSIsImZpbGUiOiJpbmRpY2F0b3JzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4LCBrZXlmcmFtZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmltcG9ydCB7XG4gIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lLFxuICBDU1NPYmplY3RXaXRoTGFiZWwsXG4gIEdyb3VwQmFzZSxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0U3R5bGVQcm9wcyB9IGZyb20gJy4uL3V0aWxzJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEljb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgU3ZnID0gKHtcbiAgc2l6ZSxcbiAgLi4ucHJvcHNcbn06IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3ZnJ10gJiB7IHNpemU6IG51bWJlciB9KSA9PiAoXG4gIDxzdmdcbiAgICBoZWlnaHQ9e3NpemV9XG4gICAgd2lkdGg9e3NpemV9XG4gICAgdmlld0JveD1cIjAgMCAyMCAyMFwiXG4gICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgY3NzPXt7XG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGZpbGw6ICdjdXJyZW50Q29sb3InLFxuICAgICAgbGluZUhlaWdodDogMSxcbiAgICAgIHN0cm9rZTogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBzdHJva2VXaWR0aDogMCxcbiAgICB9fVxuICAgIHsuLi5wcm9wc31cbiAgLz5cbik7XG5cbmV4cG9ydCB0eXBlIENyb3NzSWNvblByb3BzID0gSlNYLkludHJpbnNpY0VsZW1lbnRzWydzdmcnXSAmIHsgc2l6ZT86IG51bWJlciB9O1xuZXhwb3J0IGNvbnN0IENyb3NzSWNvbiA9IChwcm9wczogQ3Jvc3NJY29uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTE0LjM0OCAxNC44NDljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDBsLTIuNjUxLTMuMDMwLTIuNjUxIDMuMDI5Yy0wLjQ2OSAwLjQ2OS0xLjIyOSAwLjQ2OS0xLjY5NyAwLTAuNDY5LTAuNDY5LTAuNDY5LTEuMjI5IDAtMS42OTdsMi43NTgtMy4xNS0yLjc1OS0zLjE1MmMtMC40NjktMC40NjktMC40NjktMS4yMjggMC0xLjY5N3MxLjIyOC0wLjQ2OSAxLjY5NyAwbDIuNjUyIDMuMDMxIDIuNjUxLTMuMDMxYzAuNDY5LTAuNDY5IDEuMjI4LTAuNDY5IDEuNjk3IDBzMC40NjkgMS4yMjkgMCAxLjY5N2wtMi43NTggMy4xNTIgMi43NTggMy4xNWMwLjQ2OSAwLjQ2OSAwLjQ2OSAxLjIyOSAwIDEuNjk4elwiIC8+XG4gIDwvU3ZnPlxuKTtcbmV4cG9ydCB0eXBlIERvd25DaGV2cm9uUHJvcHMgPSBKU1guSW50cmluc2ljRWxlbWVudHNbJ3N2ZyddICYgeyBzaXplPzogbnVtYmVyIH07XG5leHBvcnQgY29uc3QgRG93bkNoZXZyb24gPSAocHJvcHM6IERvd25DaGV2cm9uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTQuNTE2IDcuNTQ4YzAuNDM2LTAuNDQ2IDEuMDQzLTAuNDgxIDEuNTc2IDBsMy45MDggMy43NDcgMy45MDgtMy43NDdjMC41MzMtMC40ODEgMS4xNDEtMC40NDYgMS41NzQgMCAwLjQzNiAwLjQ0NSAwLjQwOCAxLjE5NyAwIDEuNjE1LTAuNDA2IDAuNDE4LTQuNjk1IDQuNTAyLTQuNjk1IDQuNTAyLTAuMjE3IDAuMjIzLTAuNTAyIDAuMzM1LTAuNzg3IDAuMzM1cy0wLjU3LTAuMTEyLTAuNzg5LTAuMzM1YzAgMC00LjI4Ny00LjA4NC00LjY5NS00LjUwMnMtMC40MzYtMS4xNyAwLTEuNjE1elwiIC8+XG4gIDwvU3ZnPlxuKTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEJ1dHRvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8XG4gIE9wdGlvbiA9IHVua25vd24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPiA9IEdyb3VwQmFzZTxPcHRpb24+XG4+IGV4dGVuZHMgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWU8T3B0aW9uLCBJc011bHRpLCBHcm91cD4ge1xuICAvKiogVGhlIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgaW5kaWNhdG9yLiAqL1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpc0Rpc2FibGVkOiBib29sZWFuO1xufVxuXG5jb25zdCBiYXNlQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHRoZW1lOiB7XG4gICAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgICBjb2xvcnMsXG4gICAgfSxcbiAgfTpcbiAgICB8IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbiAgICB8IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JDb250YWluZXInLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gICAgICAgICc6aG92ZXInOiB7XG4gICAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsODAgOiBjb2xvcnMubmV1dHJhbDQwLFxuICAgICAgICB9LFxuICAgICAgfSksXG59KTtcblxuZXhwb3J0IGNvbnN0IGRyb3Bkb3duSW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBEcm9wZG93bkluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2Ryb3Bkb3duSW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdkcm9wZG93bi1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPERvd25DaGV2cm9uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBDbGVhckluZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFRoZSBjaGlsZHJlbiB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGluZGljYXRvci4gKi9cbiAgY2hpbGRyZW4/OiBSZWFjdE5vZGU7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IGNsZWFySW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBDbGVhckluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2NsZWFySW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdjbGVhci1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPENyb3NzSWNvbiAvPn1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU2VwYXJhdG9yXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBJbmRpY2F0b3JTZXBhcmF0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaW5uZXJQcm9wcz86IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3BhbiddO1xufVxuXG5leHBvcnQgY29uc3QgaW5kaWNhdG9yU2VwYXJhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNEaXNhYmxlZCxcbiAgICB0aGVtZToge1xuICAgICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgICAgY29sb3JzLFxuICAgIH0sXG4gIH06IEluZGljYXRvclNlcGFyYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+LFxuICB1bnN0eWxlZDogYm9vbGVhblxuKTogQ1NTT2JqZWN0V2l0aExhYmVsID0+ICh7XG4gIGxhYmVsOiAnaW5kaWNhdG9yU2VwYXJhdG9yJyxcbiAgYWxpZ25TZWxmOiAnc3RyZXRjaCcsXG4gIHdpZHRoOiAxLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogaXNEaXNhYmxlZCA/IGNvbG9ycy5uZXV0cmFsMTAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBtYXJnaW5Cb3R0b206IGJhc2VVbml0ICogMixcbiAgICAgICAgbWFyZ2luVG9wOiBiYXNlVW5pdCAqIDIsXG4gICAgICB9KSxcbn0pO1xuXG5leHBvcnQgY29uc3QgSW5kaWNhdG9yU2VwYXJhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogSW5kaWNhdG9yU2VwYXJhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxzcGFuXG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnaW5kaWNhdG9yU2VwYXJhdG9yJywge1xuICAgICAgICAnaW5kaWNhdG9yLXNlcGFyYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAvPlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBMb2FkaW5nXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgbG9hZGluZ0RvdEFuaW1hdGlvbnMgPSBrZXlmcmFtZXNgXG4gIDAlLCA4MCUsIDEwMCUgeyBvcGFjaXR5OiAwOyB9XG4gIDQwJSB7IG9wYWNpdHk6IDE7IH1cbmA7XG5cbmV4cG9ydCBjb25zdCBsb2FkaW5nSW5kaWNhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHNpemUsXG4gICAgdGhlbWU6IHtcbiAgICAgIGNvbG9ycyxcbiAgICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICB9LFxuICB9OiBMb2FkaW5nSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdsb2FkaW5nSW5kaWNhdG9yJyxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICB0cmFuc2l0aW9uOiAnY29sb3IgMTUwbXMnLFxuICBhbGlnblNlbGY6ICdjZW50ZXInLFxuICBmb250U2l6ZTogc2l6ZSxcbiAgbGluZUhlaWdodDogMSxcbiAgbWFyZ2luUmlnaHQ6IHNpemUsXG4gIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGNvbG9yOiBpc0ZvY3VzZWQgPyBjb2xvcnMubmV1dHJhbDYwIDogY29sb3JzLm5ldXRyYWwyMCxcbiAgICAgICAgcGFkZGluZzogYmFzZVVuaXQgKiAyLFxuICAgICAgfSksXG59KTtcblxuaW50ZXJmYWNlIExvYWRpbmdEb3RQcm9wcyB7XG4gIGRlbGF5OiBudW1iZXI7XG4gIG9mZnNldDogYm9vbGVhbjtcbn1cbmNvbnN0IExvYWRpbmdEb3QgPSAoeyBkZWxheSwgb2Zmc2V0IH06IExvYWRpbmdEb3RQcm9wcykgPT4gKFxuICA8c3BhblxuICAgIGNzcz17e1xuICAgICAgYW5pbWF0aW9uOiBgJHtsb2FkaW5nRG90QW5pbWF0aW9uc30gMXMgZWFzZS1pbi1vdXQgJHtkZWxheX1tcyBpbmZpbml0ZTtgLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnY3VycmVudENvbG9yJyxcbiAgICAgIGJvcmRlclJhZGl1czogJzFlbScsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIG1hcmdpbkxlZnQ6IG9mZnNldCA/ICcxZW0nIDogdW5kZWZpbmVkLFxuICAgICAgaGVpZ2h0OiAnMWVtJyxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgICAgd2lkdGg6ICcxZW0nLFxuICAgIH19XG4gIC8+XG4pO1xuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRpbmdJbmRpY2F0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgLyoqIFNldCBzaXplIG9mIHRoZSBjb250YWluZXIuICovXG4gIHNpemU6IG51bWJlcjtcbn1cbmV4cG9ydCBjb25zdCBMb2FkaW5nSW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogTG9hZGluZ0luZGljYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+XG4pID0+IHtcbiAgY29uc3QgeyBpbm5lclByb3BzLCBpc1J0bCB9ID0gcHJvcHM7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2xvYWRpbmdJbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2xvYWRpbmctaW5kaWNhdG9yJzogdHJ1ZSxcbiAgICAgIH0pfVxuICAgICAgey4uLmlubmVyUHJvcHN9XG4gICAgPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezB9IG9mZnNldD17aXNSdGx9IC8+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MTYwfSBvZmZzZXQgLz5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXszMjB9IG9mZnNldD17IWlzUnRsfSAvPlxuICAgIDwvZGl2PlxuICApO1xufTtcbkxvYWRpbmdJbmRpY2F0b3IuZGVmYXVsdFByb3BzID0geyBzaXplOiA0IH07XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__
};
var Svg = function Svg2(_ref4) {
  var size3 = _ref4.size, props = _objectWithoutProperties2(_ref4, _excluded$2);
  return jsx("svg", _extends2({
    height: size3,
    width: size3,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: _ref2
  }, props));
};
var CrossIcon = function CrossIcon2(props) {
  return jsx(Svg, _extends2({
    size: 20
  }, props), jsx("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
};
var DownChevron = function DownChevron2(props) {
  return jsx(Svg, _extends2({
    size: 20
  }, props), jsx("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
};
var baseCSS = function baseCSS2(_ref32, unstyled) {
  var isFocused = _ref32.isFocused, _ref3$theme = _ref32.theme, baseUnit2 = _ref3$theme.spacing.baseUnit, colors2 = _ref3$theme.colors;
  return _objectSpread22({
    label: "indicatorContainer",
    display: "flex",
    transition: "color 150ms"
  }, unstyled ? {} : {
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    padding: baseUnit2 * 2,
    ":hover": {
      color: isFocused ? colors2.neutral80 : colors2.neutral40
    }
  });
};
var dropdownIndicatorCSS = baseCSS;
var DropdownIndicator = function DropdownIndicator2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends2({}, getStyleProps(props, "dropdownIndicator", {
    indicator: true,
    "dropdown-indicator": true
  }), innerProps), children || jsx(DownChevron, null));
};
var clearIndicatorCSS = baseCSS;
var ClearIndicator = function ClearIndicator2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends2({}, getStyleProps(props, "clearIndicator", {
    indicator: true,
    "clear-indicator": true
  }), innerProps), children || jsx(CrossIcon, null));
};
var indicatorSeparatorCSS = function indicatorSeparatorCSS2(_ref4, unstyled) {
  var isDisabled = _ref4.isDisabled, _ref4$theme = _ref4.theme, baseUnit2 = _ref4$theme.spacing.baseUnit, colors2 = _ref4$theme.colors;
  return _objectSpread22({
    label: "indicatorSeparator",
    alignSelf: "stretch",
    width: 1
  }, unstyled ? {} : {
    backgroundColor: isDisabled ? colors2.neutral10 : colors2.neutral20,
    marginBottom: baseUnit2 * 2,
    marginTop: baseUnit2 * 2
  });
};
var IndicatorSeparator = function IndicatorSeparator2(props) {
  var innerProps = props.innerProps;
  return jsx("span", _extends2({}, innerProps, getStyleProps(props, "indicatorSeparator", {
    "indicator-separator": true
  })));
};
var loadingDotAnimations = keyframes(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  0%, 80%, 100% { opacity: 0; }\n  40% { opacity: 1; }\n"])));
var loadingIndicatorCSS = function loadingIndicatorCSS2(_ref5, unstyled) {
  var isFocused = _ref5.isFocused, size3 = _ref5.size, _ref5$theme = _ref5.theme, colors2 = _ref5$theme.colors, baseUnit2 = _ref5$theme.spacing.baseUnit;
  return _objectSpread22({
    label: "loadingIndicator",
    display: "flex",
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: size3,
    lineHeight: 1,
    marginRight: size3,
    textAlign: "center",
    verticalAlign: "middle"
  }, unstyled ? {} : {
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    padding: baseUnit2 * 2
  });
};
var LoadingDot = function LoadingDot2(_ref6) {
  var delay = _ref6.delay, offset3 = _ref6.offset;
  return jsx("span", {
    css: css({
      animation: "".concat(loadingDotAnimations, " 1s ease-in-out ").concat(delay, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: offset3 ? "1em" : void 0,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, false ? "" : ";label:LoadingDot;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1RSSIsImZpbGUiOiJpbmRpY2F0b3JzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4LCBrZXlmcmFtZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmltcG9ydCB7XG4gIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lLFxuICBDU1NPYmplY3RXaXRoTGFiZWwsXG4gIEdyb3VwQmFzZSxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0U3R5bGVQcm9wcyB9IGZyb20gJy4uL3V0aWxzJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEljb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgU3ZnID0gKHtcbiAgc2l6ZSxcbiAgLi4ucHJvcHNcbn06IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3ZnJ10gJiB7IHNpemU6IG51bWJlciB9KSA9PiAoXG4gIDxzdmdcbiAgICBoZWlnaHQ9e3NpemV9XG4gICAgd2lkdGg9e3NpemV9XG4gICAgdmlld0JveD1cIjAgMCAyMCAyMFwiXG4gICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgY3NzPXt7XG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGZpbGw6ICdjdXJyZW50Q29sb3InLFxuICAgICAgbGluZUhlaWdodDogMSxcbiAgICAgIHN0cm9rZTogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBzdHJva2VXaWR0aDogMCxcbiAgICB9fVxuICAgIHsuLi5wcm9wc31cbiAgLz5cbik7XG5cbmV4cG9ydCB0eXBlIENyb3NzSWNvblByb3BzID0gSlNYLkludHJpbnNpY0VsZW1lbnRzWydzdmcnXSAmIHsgc2l6ZT86IG51bWJlciB9O1xuZXhwb3J0IGNvbnN0IENyb3NzSWNvbiA9IChwcm9wczogQ3Jvc3NJY29uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTE0LjM0OCAxNC44NDljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDBsLTIuNjUxLTMuMDMwLTIuNjUxIDMuMDI5Yy0wLjQ2OSAwLjQ2OS0xLjIyOSAwLjQ2OS0xLjY5NyAwLTAuNDY5LTAuNDY5LTAuNDY5LTEuMjI5IDAtMS42OTdsMi43NTgtMy4xNS0yLjc1OS0zLjE1MmMtMC40NjktMC40NjktMC40NjktMS4yMjggMC0xLjY5N3MxLjIyOC0wLjQ2OSAxLjY5NyAwbDIuNjUyIDMuMDMxIDIuNjUxLTMuMDMxYzAuNDY5LTAuNDY5IDEuMjI4LTAuNDY5IDEuNjk3IDBzMC40NjkgMS4yMjkgMCAxLjY5N2wtMi43NTggMy4xNTIgMi43NTggMy4xNWMwLjQ2OSAwLjQ2OSAwLjQ2OSAxLjIyOSAwIDEuNjk4elwiIC8+XG4gIDwvU3ZnPlxuKTtcbmV4cG9ydCB0eXBlIERvd25DaGV2cm9uUHJvcHMgPSBKU1guSW50cmluc2ljRWxlbWVudHNbJ3N2ZyddICYgeyBzaXplPzogbnVtYmVyIH07XG5leHBvcnQgY29uc3QgRG93bkNoZXZyb24gPSAocHJvcHM6IERvd25DaGV2cm9uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTQuNTE2IDcuNTQ4YzAuNDM2LTAuNDQ2IDEuMDQzLTAuNDgxIDEuNTc2IDBsMy45MDggMy43NDcgMy45MDgtMy43NDdjMC41MzMtMC40ODEgMS4xNDEtMC40NDYgMS41NzQgMCAwLjQzNiAwLjQ0NSAwLjQwOCAxLjE5NyAwIDEuNjE1LTAuNDA2IDAuNDE4LTQuNjk1IDQuNTAyLTQuNjk1IDQuNTAyLTAuMjE3IDAuMjIzLTAuNTAyIDAuMzM1LTAuNzg3IDAuMzM1cy0wLjU3LTAuMTEyLTAuNzg5LTAuMzM1YzAgMC00LjI4Ny00LjA4NC00LjY5NS00LjUwMnMtMC40MzYtMS4xNyAwLTEuNjE1elwiIC8+XG4gIDwvU3ZnPlxuKTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEJ1dHRvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8XG4gIE9wdGlvbiA9IHVua25vd24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPiA9IEdyb3VwQmFzZTxPcHRpb24+XG4+IGV4dGVuZHMgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWU8T3B0aW9uLCBJc011bHRpLCBHcm91cD4ge1xuICAvKiogVGhlIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgaW5kaWNhdG9yLiAqL1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpc0Rpc2FibGVkOiBib29sZWFuO1xufVxuXG5jb25zdCBiYXNlQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHRoZW1lOiB7XG4gICAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgICBjb2xvcnMsXG4gICAgfSxcbiAgfTpcbiAgICB8IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbiAgICB8IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JDb250YWluZXInLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gICAgICAgICc6aG92ZXInOiB7XG4gICAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsODAgOiBjb2xvcnMubmV1dHJhbDQwLFxuICAgICAgICB9LFxuICAgICAgfSksXG59KTtcblxuZXhwb3J0IGNvbnN0IGRyb3Bkb3duSW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBEcm9wZG93bkluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2Ryb3Bkb3duSW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdkcm9wZG93bi1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPERvd25DaGV2cm9uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBDbGVhckluZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFRoZSBjaGlsZHJlbiB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGluZGljYXRvci4gKi9cbiAgY2hpbGRyZW4/OiBSZWFjdE5vZGU7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IGNsZWFySW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBDbGVhckluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2NsZWFySW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdjbGVhci1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPENyb3NzSWNvbiAvPn1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU2VwYXJhdG9yXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBJbmRpY2F0b3JTZXBhcmF0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaW5uZXJQcm9wcz86IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3BhbiddO1xufVxuXG5leHBvcnQgY29uc3QgaW5kaWNhdG9yU2VwYXJhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNEaXNhYmxlZCxcbiAgICB0aGVtZToge1xuICAgICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgICAgY29sb3JzLFxuICAgIH0sXG4gIH06IEluZGljYXRvclNlcGFyYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+LFxuICB1bnN0eWxlZDogYm9vbGVhblxuKTogQ1NTT2JqZWN0V2l0aExhYmVsID0+ICh7XG4gIGxhYmVsOiAnaW5kaWNhdG9yU2VwYXJhdG9yJyxcbiAgYWxpZ25TZWxmOiAnc3RyZXRjaCcsXG4gIHdpZHRoOiAxLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogaXNEaXNhYmxlZCA/IGNvbG9ycy5uZXV0cmFsMTAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBtYXJnaW5Cb3R0b206IGJhc2VVbml0ICogMixcbiAgICAgICAgbWFyZ2luVG9wOiBiYXNlVW5pdCAqIDIsXG4gICAgICB9KSxcbn0pO1xuXG5leHBvcnQgY29uc3QgSW5kaWNhdG9yU2VwYXJhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogSW5kaWNhdG9yU2VwYXJhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxzcGFuXG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnaW5kaWNhdG9yU2VwYXJhdG9yJywge1xuICAgICAgICAnaW5kaWNhdG9yLXNlcGFyYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAvPlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBMb2FkaW5nXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgbG9hZGluZ0RvdEFuaW1hdGlvbnMgPSBrZXlmcmFtZXNgXG4gIDAlLCA4MCUsIDEwMCUgeyBvcGFjaXR5OiAwOyB9XG4gIDQwJSB7IG9wYWNpdHk6IDE7IH1cbmA7XG5cbmV4cG9ydCBjb25zdCBsb2FkaW5nSW5kaWNhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHNpemUsXG4gICAgdGhlbWU6IHtcbiAgICAgIGNvbG9ycyxcbiAgICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICB9LFxuICB9OiBMb2FkaW5nSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdsb2FkaW5nSW5kaWNhdG9yJyxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICB0cmFuc2l0aW9uOiAnY29sb3IgMTUwbXMnLFxuICBhbGlnblNlbGY6ICdjZW50ZXInLFxuICBmb250U2l6ZTogc2l6ZSxcbiAgbGluZUhlaWdodDogMSxcbiAgbWFyZ2luUmlnaHQ6IHNpemUsXG4gIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGNvbG9yOiBpc0ZvY3VzZWQgPyBjb2xvcnMubmV1dHJhbDYwIDogY29sb3JzLm5ldXRyYWwyMCxcbiAgICAgICAgcGFkZGluZzogYmFzZVVuaXQgKiAyLFxuICAgICAgfSksXG59KTtcblxuaW50ZXJmYWNlIExvYWRpbmdEb3RQcm9wcyB7XG4gIGRlbGF5OiBudW1iZXI7XG4gIG9mZnNldDogYm9vbGVhbjtcbn1cbmNvbnN0IExvYWRpbmdEb3QgPSAoeyBkZWxheSwgb2Zmc2V0IH06IExvYWRpbmdEb3RQcm9wcykgPT4gKFxuICA8c3BhblxuICAgIGNzcz17e1xuICAgICAgYW5pbWF0aW9uOiBgJHtsb2FkaW5nRG90QW5pbWF0aW9uc30gMXMgZWFzZS1pbi1vdXQgJHtkZWxheX1tcyBpbmZpbml0ZTtgLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnY3VycmVudENvbG9yJyxcbiAgICAgIGJvcmRlclJhZGl1czogJzFlbScsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIG1hcmdpbkxlZnQ6IG9mZnNldCA/ICcxZW0nIDogdW5kZWZpbmVkLFxuICAgICAgaGVpZ2h0OiAnMWVtJyxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgICAgd2lkdGg6ICcxZW0nLFxuICAgIH19XG4gIC8+XG4pO1xuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRpbmdJbmRpY2F0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgLyoqIFNldCBzaXplIG9mIHRoZSBjb250YWluZXIuICovXG4gIHNpemU6IG51bWJlcjtcbn1cbmV4cG9ydCBjb25zdCBMb2FkaW5nSW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogTG9hZGluZ0luZGljYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+XG4pID0+IHtcbiAgY29uc3QgeyBpbm5lclByb3BzLCBpc1J0bCB9ID0gcHJvcHM7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2xvYWRpbmdJbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2xvYWRpbmctaW5kaWNhdG9yJzogdHJ1ZSxcbiAgICAgIH0pfVxuICAgICAgey4uLmlubmVyUHJvcHN9XG4gICAgPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezB9IG9mZnNldD17aXNSdGx9IC8+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MTYwfSBvZmZzZXQgLz5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXszMjB9IG9mZnNldD17IWlzUnRsfSAvPlxuICAgIDwvZGl2PlxuICApO1xufTtcbkxvYWRpbmdJbmRpY2F0b3IuZGVmYXVsdFByb3BzID0geyBzaXplOiA0IH07XG4iXX0= */")
  });
};
var LoadingIndicator = function LoadingIndicator2(props) {
  var innerProps = props.innerProps, isRtl = props.isRtl;
  return jsx("div", _extends2({}, getStyleProps(props, "loadingIndicator", {
    indicator: true,
    "loading-indicator": true
  }), innerProps), jsx(LoadingDot, {
    delay: 0,
    offset: isRtl
  }), jsx(LoadingDot, {
    delay: 160,
    offset: true
  }), jsx(LoadingDot, {
    delay: 320,
    offset: !isRtl
  }));
};
LoadingIndicator.defaultProps = {
  size: 4
};
var css$1 = function css2(_ref4, unstyled) {
  var isDisabled = _ref4.isDisabled, isFocused = _ref4.isFocused, _ref$theme = _ref4.theme, colors2 = _ref$theme.colors, borderRadius2 = _ref$theme.borderRadius, spacing2 = _ref$theme.spacing;
  return _objectSpread22({
    label: "control",
    alignItems: "center",
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: spacing2.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms"
  }, unstyled ? {} : {
    backgroundColor: isDisabled ? colors2.neutral5 : colors2.neutral0,
    borderColor: isDisabled ? colors2.neutral10 : isFocused ? colors2.primary : colors2.neutral20,
    borderRadius: borderRadius2,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: isFocused ? "0 0 0 1px ".concat(colors2.primary) : void 0,
    "&:hover": {
      borderColor: isFocused ? colors2.primary : colors2.neutral30
    }
  });
};
var Control = function Control2(props) {
  var children = props.children, isDisabled = props.isDisabled, isFocused = props.isFocused, innerRef = props.innerRef, innerProps = props.innerProps, menuIsOpen = props.menuIsOpen;
  return jsx("div", _extends2({
    ref: innerRef
  }, getStyleProps(props, "control", {
    control: true,
    "control--is-disabled": isDisabled,
    "control--is-focused": isFocused,
    "control--menu-is-open": menuIsOpen
  }), innerProps), children);
};
var _excluded$1 = ["data"];
var groupCSS = function groupCSS2(_ref4, unstyled) {
  var spacing2 = _ref4.theme.spacing;
  return unstyled ? {} : {
    paddingBottom: spacing2.baseUnit * 2,
    paddingTop: spacing2.baseUnit * 2
  };
};
var Group = function Group2(props) {
  var children = props.children, cx = props.cx, getStyles = props.getStyles, getClassNames = props.getClassNames, Heading = props.Heading, headingProps = props.headingProps, innerProps = props.innerProps, label = props.label, theme2 = props.theme, selectProps = props.selectProps;
  return jsx("div", _extends2({}, getStyleProps(props, "group", {
    group: true
  }), innerProps), jsx(Heading, _extends2({}, headingProps, {
    selectProps,
    theme: theme2,
    getStyles,
    getClassNames,
    cx
  }), label), jsx("div", null, children));
};
var groupHeadingCSS = function groupHeadingCSS2(_ref23, unstyled) {
  var _ref2$theme = _ref23.theme, colors2 = _ref2$theme.colors, spacing2 = _ref2$theme.spacing;
  return _objectSpread22({
    label: "group",
    cursor: "default",
    display: "block"
  }, unstyled ? {} : {
    color: colors2.neutral40,
    fontSize: "75%",
    fontWeight: 500,
    marginBottom: "0.25em",
    paddingLeft: spacing2.baseUnit * 3,
    paddingRight: spacing2.baseUnit * 3,
    textTransform: "uppercase"
  });
};
var GroupHeading = function GroupHeading2(props) {
  var _cleanCommonProps = cleanCommonProps(props);
  _cleanCommonProps.data;
  var innerProps = _objectWithoutProperties2(_cleanCommonProps, _excluded$1);
  return jsx("div", _extends2({}, getStyleProps(props, "groupHeading", {
    "group-heading": true
  }), innerProps));
};
var _excluded5 = ["innerRef", "isDisabled", "isHidden", "inputClassName"];
var inputCSS = function inputCSS2(_ref4, unstyled) {
  var isDisabled = _ref4.isDisabled, value = _ref4.value, _ref$theme = _ref4.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread22(_objectSpread22({
    visibility: isDisabled ? "hidden" : "visible",
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: value ? "translateZ(0)" : ""
  }, containerStyle), unstyled ? {} : {
    margin: spacing2.baseUnit / 2,
    paddingBottom: spacing2.baseUnit / 2,
    paddingTop: spacing2.baseUnit / 2,
    color: colors2.neutral80
  });
};
var spacingStyle = {
  gridArea: "1 / 2",
  font: "inherit",
  minWidth: "2px",
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
};
var containerStyle = {
  flex: "1 1 auto",
  display: "inline-grid",
  gridArea: "1 / 1 / 2 / 3",
  gridTemplateColumns: "0 min-content",
  "&:after": _objectSpread22({
    content: 'attr(data-value) " "',
    visibility: "hidden",
    whiteSpace: "pre"
  }, spacingStyle)
};
var inputStyle = function inputStyle2(isHidden3) {
  return _objectSpread22({
    label: "input",
    color: "inherit",
    background: 0,
    opacity: isHidden3 ? 0 : 1,
    width: "100%"
  }, spacingStyle);
};
var Input = function Input2(props) {
  var cx = props.cx, value = props.value;
  var _cleanCommonProps = cleanCommonProps(props), innerRef = _cleanCommonProps.innerRef, isDisabled = _cleanCommonProps.isDisabled, isHidden3 = _cleanCommonProps.isHidden, inputClassName = _cleanCommonProps.inputClassName, innerProps = _objectWithoutProperties2(_cleanCommonProps, _excluded5);
  return jsx("div", _extends2({}, getStyleProps(props, "input", {
    "input-container": true
  }), {
    "data-value": value || ""
  }), jsx("input", _extends2({
    className: cx({
      input: true
    }, inputClassName),
    ref: innerRef,
    style: inputStyle(isHidden3),
    disabled: isDisabled
  }, innerProps)));
};
var multiValueCSS = function multiValueCSS2(_ref4, unstyled) {
  var _ref$theme = _ref4.theme, spacing2 = _ref$theme.spacing, borderRadius2 = _ref$theme.borderRadius, colors2 = _ref$theme.colors;
  return _objectSpread22({
    label: "multiValue",
    display: "flex",
    minWidth: 0
  }, unstyled ? {} : {
    backgroundColor: colors2.neutral10,
    borderRadius: borderRadius2 / 2,
    margin: spacing2.baseUnit / 2
  });
};
var multiValueLabelCSS = function multiValueLabelCSS2(_ref23, unstyled) {
  var _ref2$theme = _ref23.theme, borderRadius2 = _ref2$theme.borderRadius, colors2 = _ref2$theme.colors, cropWithEllipsis = _ref23.cropWithEllipsis;
  return _objectSpread22({
    overflow: "hidden",
    textOverflow: cropWithEllipsis || cropWithEllipsis === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, unstyled ? {} : {
    borderRadius: borderRadius2 / 2,
    color: colors2.neutral80,
    fontSize: "85%",
    padding: 3,
    paddingLeft: 6
  });
};
var multiValueRemoveCSS = function multiValueRemoveCSS2(_ref32, unstyled) {
  var _ref3$theme = _ref32.theme, spacing2 = _ref3$theme.spacing, borderRadius2 = _ref3$theme.borderRadius, colors2 = _ref3$theme.colors, isFocused = _ref32.isFocused;
  return _objectSpread22({
    alignItems: "center",
    display: "flex"
  }, unstyled ? {} : {
    borderRadius: borderRadius2 / 2,
    backgroundColor: isFocused ? colors2.dangerLight : void 0,
    paddingLeft: spacing2.baseUnit,
    paddingRight: spacing2.baseUnit,
    ":hover": {
      backgroundColor: colors2.dangerLight,
      color: colors2.danger
    }
  });
};
var MultiValueGeneric = function MultiValueGeneric2(_ref4) {
  var children = _ref4.children, innerProps = _ref4.innerProps;
  return jsx("div", innerProps, children);
};
var MultiValueContainer = MultiValueGeneric;
var MultiValueLabel = MultiValueGeneric;
function MultiValueRemove(_ref5) {
  var children = _ref5.children, innerProps = _ref5.innerProps;
  return jsx("div", _extends2({
    role: "button"
  }, innerProps), children || jsx(CrossIcon, {
    size: 14
  }));
}
var MultiValue = function MultiValue2(props) {
  var children = props.children, components2 = props.components, data = props.data, innerProps = props.innerProps, isDisabled = props.isDisabled, removeProps3 = props.removeProps, selectProps = props.selectProps;
  var Container = components2.Container, Label3 = components2.Label, Remove = components2.Remove;
  return jsx(Container, {
    data,
    innerProps: _objectSpread22(_objectSpread22({}, getStyleProps(props, "multiValue", {
      "multi-value": true,
      "multi-value--is-disabled": isDisabled
    })), innerProps),
    selectProps
  }, jsx(Label3, {
    data,
    innerProps: _objectSpread22({}, getStyleProps(props, "multiValueLabel", {
      "multi-value__label": true
    })),
    selectProps
  }, children), jsx(Remove, {
    data,
    innerProps: _objectSpread22(_objectSpread22({}, getStyleProps(props, "multiValueRemove", {
      "multi-value__remove": true
    })), {}, {
      "aria-label": "Remove ".concat(children || "option")
    }, removeProps3),
    selectProps
  }));
};
var optionCSS = function optionCSS2(_ref4, unstyled) {
  var isDisabled = _ref4.isDisabled, isFocused = _ref4.isFocused, isSelected = _ref4.isSelected, _ref$theme = _ref4.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread22({
    label: "option",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
  }, unstyled ? {} : {
    backgroundColor: isSelected ? colors2.primary : isFocused ? colors2.primary25 : "transparent",
    color: isDisabled ? colors2.neutral20 : isSelected ? colors2.neutral0 : "inherit",
    padding: "".concat(spacing2.baseUnit * 2, "px ").concat(spacing2.baseUnit * 3, "px"),
    // provide some affordance on touch devices
    ":active": {
      backgroundColor: !isDisabled ? isSelected ? colors2.primary : colors2.primary50 : void 0
    }
  });
};
var Option = function Option2(props) {
  var children = props.children, isDisabled = props.isDisabled, isFocused = props.isFocused, isSelected = props.isSelected, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends2({}, getStyleProps(props, "option", {
    option: true,
    "option--is-disabled": isDisabled,
    "option--is-focused": isFocused,
    "option--is-selected": isSelected
  }), {
    ref: innerRef,
    "aria-disabled": isDisabled
  }, innerProps), children);
};
var placeholderCSS = function placeholderCSS2(_ref4, unstyled) {
  var _ref$theme = _ref4.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread22({
    label: "placeholder",
    gridArea: "1 / 1 / 2 / 3"
  }, unstyled ? {} : {
    color: colors2.neutral50,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2
  });
};
var Placeholder = function Placeholder2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends2({}, getStyleProps(props, "placeholder", {
    placeholder: true
  }), innerProps), children);
};
var css3 = function css4(_ref4, unstyled) {
  var isDisabled = _ref4.isDisabled, _ref$theme = _ref4.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread22({
    label: "singleValue",
    gridArea: "1 / 1 / 2 / 3",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, unstyled ? {} : {
    color: isDisabled ? colors2.neutral40 : colors2.neutral80,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2
  });
};
var SingleValue = function SingleValue2(props) {
  var children = props.children, isDisabled = props.isDisabled, innerProps = props.innerProps;
  return jsx("div", _extends2({}, getStyleProps(props, "singleValue", {
    "single-value": true,
    "single-value--is-disabled": isDisabled
  }), innerProps), children);
};
var components = {
  ClearIndicator,
  Control,
  DropdownIndicator,
  DownChevron,
  CrossIcon,
  Group,
  GroupHeading,
  IndicatorsContainer,
  IndicatorSeparator,
  Input,
  LoadingIndicator,
  Menu: Menu2,
  MenuList,
  MenuPortal,
  LoadingMessage,
  NoOptionsMessage,
  MultiValue,
  MultiValueContainer,
  MultiValueLabel,
  MultiValueRemove,
  Option,
  Placeholder,
  SelectContainer,
  SingleValue,
  ValueContainer
};
var defaultComponents = function defaultComponents2(props) {
  return _objectSpread22(_objectSpread22({}, components), props.components);
};

// node_modules/memoize-one/dist/memoize-one.esm.js
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual3(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i2 = 0; i2 < newInputs.length; i2++) {
    if (!isEqual3(newInputs[i2], lastInputs[i2])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual4) {
  if (isEqual4 === void 0) {
    isEqual4 = areInputsEqual;
  }
  var cache = null;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (cache && cache.lastThis === this && isEqual4(newArgs, cache.lastArgs)) {
      return cache.lastResult;
    }
    var lastResult = resultFn.apply(this, newArgs);
    cache = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    };
    return lastResult;
  }
  memoized.clear = function clear() {
    cache = null;
  };
  return memoized;
}

// node_modules/react-select/dist/Select-40119e12.esm.js
function _EMOTION_STRINGIFIED_CSS_ERROR__$2() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var _ref3 = false ? {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
} : {
  name: "1f43avz-a11yText-A11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap;label:A11yText;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkExMXlUZXh0LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFNSSIsImZpbGUiOiJBMTF5VGV4dC50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGpzeCBqc3ggKi9cbmltcG9ydCB7IGpzeCB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuLy8gQXNzaXN0aXZlIHRleHQgdG8gZGVzY3JpYmUgdmlzdWFsIGVsZW1lbnRzLiBIaWRkZW4gZm9yIHNpZ2h0ZWQgdXNlcnMuXG5jb25zdCBBMTF5VGV4dCA9IChwcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzcGFuJ10pID0+IChcbiAgPHNwYW5cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAnYTExeVRleHQnLFxuICAgICAgekluZGV4OiA5OTk5LFxuICAgICAgYm9yZGVyOiAwLFxuICAgICAgY2xpcDogJ3JlY3QoMXB4LCAxcHgsIDFweCwgMXB4KScsXG4gICAgICBoZWlnaHQ6IDEsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgQTExeVRleHQ7XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__$2
};
var A11yText = function A11yText2(props) {
  return jsx("span", _extends2({
    css: _ref3
  }, props));
};
var defaultAriaLiveMessages = {
  guidance: function guidance(props) {
    var isSearchable = props.isSearchable, isMulti = props.isMulti, isDisabled = props.isDisabled, tabSelectsValue = props.tabSelectsValue, context = props.context;
    switch (context) {
      case "menu":
        return "Use Up and Down to choose options".concat(isDisabled ? "" : ", press Enter to select the currently focused option", ", press Escape to exit the menu").concat(tabSelectsValue ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return "".concat(props["aria-label"] || "Select", " is focused ").concat(isSearchable ? ",type to refine list" : "", ", press Down to open the menu, ").concat(isMulti ? " press left to focus selected values" : "");
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  },
  onChange: function onChange(props) {
    var action = props.action, _props$label = props.label, label = _props$label === void 0 ? "" : _props$label, labels = props.labels, isDisabled = props.isDisabled;
    switch (action) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(label, ", deselected.");
      case "clear":
        return "All selected options have been cleared.";
      case "initial-input-focus":
        return "option".concat(labels.length > 1 ? "s" : "", " ").concat(labels.join(","), ", selected.");
      case "select-option":
        return isDisabled ? "option ".concat(label, " is disabled. Select another option.") : "option ".concat(label, ", selected.");
      default:
        return "";
    }
  },
  onFocus: function onFocus3(props) {
    var context = props.context, focused = props.focused, options2 = props.options, _props$label2 = props.label, label = _props$label2 === void 0 ? "" : _props$label2, selectValue = props.selectValue, isDisabled = props.isDisabled, isSelected = props.isSelected;
    var getArrayIndex = function getArrayIndex2(arr, item) {
      return arr && arr.length ? "".concat(arr.indexOf(item) + 1, " of ").concat(arr.length) : "";
    };
    if (context === "value" && selectValue) {
      return "value ".concat(label, " focused, ").concat(getArrayIndex(selectValue, focused), ".");
    }
    if (context === "menu") {
      var disabled = isDisabled ? " disabled" : "";
      var status = "".concat(isSelected ? "selected" : "focused").concat(disabled);
      return "option ".concat(label, " ").concat(status, ", ").concat(getArrayIndex(options2, focused), ".");
    }
    return "";
  },
  onFilter: function onFilter(props) {
    var inputValue = props.inputValue, resultsMessage = props.resultsMessage;
    return "".concat(resultsMessage).concat(inputValue ? " for search term " + inputValue : "", ".");
  }
};
var LiveRegion = function LiveRegion2(props) {
  var ariaSelection = props.ariaSelection, focusedOption = props.focusedOption, focusedValue = props.focusedValue, focusableOptions = props.focusableOptions, isFocused = props.isFocused, selectValue = props.selectValue, selectProps = props.selectProps, id = props.id;
  var ariaLiveMessages = selectProps.ariaLiveMessages, getOptionLabel4 = selectProps.getOptionLabel, inputValue = selectProps.inputValue, isMulti = selectProps.isMulti, isOptionDisabled3 = selectProps.isOptionDisabled, isSearchable = selectProps.isSearchable, menuIsOpen = selectProps.menuIsOpen, options2 = selectProps.options, screenReaderStatus2 = selectProps.screenReaderStatus, tabSelectsValue = selectProps.tabSelectsValue;
  var ariaLabel = selectProps["aria-label"];
  var ariaLive = selectProps["aria-live"];
  var messages = (0, import_react154.useMemo)(function() {
    return _objectSpread22(_objectSpread22({}, defaultAriaLiveMessages), ariaLiveMessages || {});
  }, [ariaLiveMessages]);
  var ariaSelected = (0, import_react154.useMemo)(function() {
    var message = "";
    if (ariaSelection && messages.onChange) {
      var option = ariaSelection.option, selectedOptions = ariaSelection.options, removedValue = ariaSelection.removedValue, removedValues = ariaSelection.removedValues, value = ariaSelection.value;
      var asOption = function asOption2(val) {
        return !Array.isArray(val) ? val : null;
      };
      var selected = removedValue || option || asOption(value);
      var label = selected ? getOptionLabel4(selected) : "";
      var multiSelected = selectedOptions || removedValues || void 0;
      var labels = multiSelected ? multiSelected.map(getOptionLabel4) : [];
      var onChangeProps = _objectSpread22({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: selected && isOptionDisabled3(selected, selectValue),
        label,
        labels
      }, ariaSelection);
      message = messages.onChange(onChangeProps);
    }
    return message;
  }, [ariaSelection, messages, isOptionDisabled3, selectValue, getOptionLabel4]);
  var ariaFocused = (0, import_react154.useMemo)(function() {
    var focusMsg = "";
    var focused = focusedOption || focusedValue;
    var isSelected = !!(focusedOption && selectValue && selectValue.includes(focusedOption));
    if (focused && messages.onFocus) {
      var onFocusProps = {
        focused,
        label: getOptionLabel4(focused),
        isDisabled: isOptionDisabled3(focused, selectValue),
        isSelected,
        options: focusableOptions,
        context: focused === focusedOption ? "menu" : "value",
        selectValue
      };
      focusMsg = messages.onFocus(onFocusProps);
    }
    return focusMsg;
  }, [focusedOption, focusedValue, getOptionLabel4, isOptionDisabled3, messages, focusableOptions, selectValue]);
  var ariaResults = (0, import_react154.useMemo)(function() {
    var resultsMsg = "";
    if (menuIsOpen && options2.length && messages.onFilter) {
      var resultsMessage = screenReaderStatus2({
        count: focusableOptions.length
      });
      resultsMsg = messages.onFilter({
        inputValue,
        resultsMessage
      });
    }
    return resultsMsg;
  }, [focusableOptions, inputValue, menuIsOpen, messages, options2, screenReaderStatus2]);
  var ariaGuidance = (0, import_react154.useMemo)(function() {
    var guidanceMsg = "";
    if (messages.guidance) {
      var context = focusedValue ? "value" : menuIsOpen ? "menu" : "input";
      guidanceMsg = messages.guidance({
        "aria-label": ariaLabel,
        context,
        isDisabled: focusedOption && isOptionDisabled3(focusedOption, selectValue),
        isMulti,
        isSearchable,
        tabSelectsValue
      });
    }
    return guidanceMsg;
  }, [ariaLabel, focusedOption, focusedValue, isMulti, isOptionDisabled3, isSearchable, menuIsOpen, messages, selectValue, tabSelectsValue]);
  var ariaContext = "".concat(ariaFocused, " ").concat(ariaResults, " ").concat(ariaGuidance);
  var ScreenReaderText = jsx(import_react154.Fragment, null, jsx("span", {
    id: "aria-selection"
  }, ariaSelected), jsx("span", {
    id: "aria-context"
  }, ariaContext));
  var isInitialFocus = (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus";
  return jsx(import_react154.Fragment, null, jsx(A11yText, {
    id
  }, isInitialFocus && ScreenReaderText), jsx(A11yText, {
    "aria-live": ariaLive,
    "aria-atomic": "false",
    "aria-relevant": "additions text"
  }, isFocused && !isInitialFocus && ScreenReaderText));
};
var diacritics = [{
  base: "A",
  letters: "A"
}, {
  base: "AA",
  letters: ""
}, {
  base: "AE",
  letters: ""
}, {
  base: "AO",
  letters: ""
}, {
  base: "AU",
  letters: ""
}, {
  base: "AV",
  letters: ""
}, {
  base: "AY",
  letters: ""
}, {
  base: "B",
  letters: "B"
}, {
  base: "C",
  letters: "C"
}, {
  base: "D",
  letters: "D"
}, {
  base: "DZ",
  letters: ""
}, {
  base: "Dz",
  letters: ""
}, {
  base: "E",
  letters: "E"
}, {
  base: "F",
  letters: "F"
}, {
  base: "G",
  letters: "G"
}, {
  base: "H",
  letters: "H"
}, {
  base: "I",
  letters: "I"
}, {
  base: "J",
  letters: "J"
}, {
  base: "K",
  letters: "K"
}, {
  base: "L",
  letters: "L"
}, {
  base: "LJ",
  letters: ""
}, {
  base: "Lj",
  letters: ""
}, {
  base: "M",
  letters: "M"
}, {
  base: "N",
  letters: "N"
}, {
  base: "NJ",
  letters: ""
}, {
  base: "Nj",
  letters: ""
}, {
  base: "O",
  letters: "O"
}, {
  base: "OI",
  letters: ""
}, {
  base: "OO",
  letters: ""
}, {
  base: "OU",
  letters: ""
}, {
  base: "P",
  letters: "P"
}, {
  base: "Q",
  letters: "Q"
}, {
  base: "R",
  letters: "R"
}, {
  base: "S",
  letters: "S"
}, {
  base: "T",
  letters: "T"
}, {
  base: "TZ",
  letters: ""
}, {
  base: "U",
  letters: "U"
}, {
  base: "V",
  letters: "V"
}, {
  base: "VY",
  letters: ""
}, {
  base: "W",
  letters: "W"
}, {
  base: "X",
  letters: "X"
}, {
  base: "Y",
  letters: "Y"
}, {
  base: "Z",
  letters: "Z"
}, {
  base: "a",
  letters: "a"
}, {
  base: "aa",
  letters: ""
}, {
  base: "ae",
  letters: ""
}, {
  base: "ao",
  letters: ""
}, {
  base: "au",
  letters: ""
}, {
  base: "av",
  letters: ""
}, {
  base: "ay",
  letters: ""
}, {
  base: "b",
  letters: "b"
}, {
  base: "c",
  letters: "c"
}, {
  base: "d",
  letters: "d"
}, {
  base: "dz",
  letters: ""
}, {
  base: "e",
  letters: "e"
}, {
  base: "f",
  letters: "f"
}, {
  base: "g",
  letters: "g"
}, {
  base: "h",
  letters: "h"
}, {
  base: "hv",
  letters: ""
}, {
  base: "i",
  letters: "i"
}, {
  base: "j",
  letters: "j"
}, {
  base: "k",
  letters: "k"
}, {
  base: "l",
  letters: "l"
}, {
  base: "lj",
  letters: ""
}, {
  base: "m",
  letters: "m"
}, {
  base: "n",
  letters: "n"
}, {
  base: "nj",
  letters: ""
}, {
  base: "o",
  letters: "o"
}, {
  base: "oi",
  letters: ""
}, {
  base: "ou",
  letters: ""
}, {
  base: "oo",
  letters: ""
}, {
  base: "p",
  letters: "p"
}, {
  base: "q",
  letters: "q"
}, {
  base: "r",
  letters: "r"
}, {
  base: "s",
  letters: "s"
}, {
  base: "t",
  letters: "t"
}, {
  base: "tz",
  letters: ""
}, {
  base: "u",
  letters: "u"
}, {
  base: "v",
  letters: "v"
}, {
  base: "vy",
  letters: ""
}, {
  base: "w",
  letters: "w"
}, {
  base: "x",
  letters: "x"
}, {
  base: "y",
  letters: "y"
}, {
  base: "z",
  letters: "z"
}];
var anyDiacritic = new RegExp("[" + diacritics.map(function(d3) {
  return d3.letters;
}).join("") + "]", "g");
var diacriticToBase = {};
for (i2 = 0; i2 < diacritics.length; i2++) {
  diacritic = diacritics[i2];
  for (j = 0; j < diacritic.letters.length; j++) {
    diacriticToBase[diacritic.letters[j]] = diacritic.base;
  }
}
var diacritic;
var j;
var i2;
var stripDiacritics = function stripDiacritics2(str) {
  return str.replace(anyDiacritic, function(match3) {
    return diacriticToBase[match3];
  });
};
var memoizedStripDiacriticsForInput = memoizeOne(stripDiacritics);
var trimString = function trimString2(str) {
  return str.replace(/^\s+|\s+$/g, "");
};
var defaultStringify = function defaultStringify2(option) {
  return "".concat(option.label, " ").concat(option.value);
};
var createFilter = function createFilter2(config2) {
  return function(option, rawInput) {
    if (option.data.__isNew__)
      return true;
    var _ignoreCase$ignoreAcc = _objectSpread22({
      ignoreCase: true,
      ignoreAccents: true,
      stringify: defaultStringify,
      trim: true,
      matchFrom: "any"
    }, config2), ignoreCase = _ignoreCase$ignoreAcc.ignoreCase, ignoreAccents = _ignoreCase$ignoreAcc.ignoreAccents, stringify2 = _ignoreCase$ignoreAcc.stringify, trim2 = _ignoreCase$ignoreAcc.trim, matchFrom = _ignoreCase$ignoreAcc.matchFrom;
    var input = trim2 ? trimString(rawInput) : rawInput;
    var candidate = trim2 ? trimString(stringify2(option)) : stringify2(option);
    if (ignoreCase) {
      input = input.toLowerCase();
      candidate = candidate.toLowerCase();
    }
    if (ignoreAccents) {
      input = memoizedStripDiacriticsForInput(input);
      candidate = stripDiacritics(candidate);
    }
    return matchFrom === "start" ? candidate.substr(0, input.length) === input : candidate.indexOf(input) > -1;
  };
};
var _excluded6 = ["innerRef"];
function DummyInput(_ref4) {
  var innerRef = _ref4.innerRef, props = _objectWithoutProperties2(_ref4, _excluded6);
  var filteredProps = removeProps(props, "onExited", "in", "enter", "exit", "appear");
  return jsx("input", _extends2({
    ref: innerRef
  }, filteredProps, {
    css: css({
      label: "dummyInput",
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: "transparent",
      fontSize: "inherit",
      gridArea: "1 / 1 / 2 / 3",
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: "transparent",
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(.01)"
    }, false ? "" : ";label:DummyInput;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkR1bW15SW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlCTSIsImZpbGUiOiJEdW1teUlucHV0LnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4IH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuaW1wb3J0IHsgcmVtb3ZlUHJvcHMgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIER1bW15SW5wdXQoe1xuICBpbm5lclJlZixcbiAgLi4ucHJvcHNcbn06IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snaW5wdXQnXSAmIHtcbiAgcmVhZG9ubHkgaW5uZXJSZWY6IFJlZjxIVE1MSW5wdXRFbGVtZW50Pjtcbn0pIHtcbiAgLy8gUmVtb3ZlIGFuaW1hdGlvbiBwcm9wcyBub3QgbWVhbnQgZm9yIEhUTUwgZWxlbWVudHNcbiAgY29uc3QgZmlsdGVyZWRQcm9wcyA9IHJlbW92ZVByb3BzKFxuICAgIHByb3BzLFxuICAgICdvbkV4aXRlZCcsXG4gICAgJ2luJyxcbiAgICAnZW50ZXInLFxuICAgICdleGl0JyxcbiAgICAnYXBwZWFyJ1xuICApO1xuXG4gIHJldHVybiAoXG4gICAgPGlucHV0XG4gICAgICByZWY9e2lubmVyUmVmfVxuICAgICAgey4uLmZpbHRlcmVkUHJvcHN9XG4gICAgICBjc3M9e3tcbiAgICAgICAgbGFiZWw6ICdkdW1teUlucHV0JyxcbiAgICAgICAgLy8gZ2V0IHJpZCBvZiBhbnkgZGVmYXVsdCBzdHlsZXNcbiAgICAgICAgYmFja2dyb3VuZDogMCxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICAvLyBpbXBvcnRhbnQhIHRoaXMgaGlkZXMgdGhlIGZsYXNoaW5nIGN1cnNvclxuICAgICAgICBjYXJldENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICBmb250U2l6ZTogJ2luaGVyaXQnLFxuICAgICAgICBncmlkQXJlYTogJzEgLyAxIC8gMiAvIDMnLFxuICAgICAgICBvdXRsaW5lOiAwLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAvLyBpbXBvcnRhbnQhIHdpdGhvdXQgYHdpZHRoYCBicm93c2VycyB3b24ndCBhbGxvdyBmb2N1c1xuICAgICAgICB3aWR0aDogMSxcblxuICAgICAgICAvLyByZW1vdmUgY3Vyc29yIG9uIGRlc2t0b3BcbiAgICAgICAgY29sb3I6ICd0cmFuc3BhcmVudCcsXG5cbiAgICAgICAgLy8gcmVtb3ZlIGN1cnNvciBvbiBtb2JpbGUgd2hpbHN0IG1haW50YWluaW5nIFwic2Nyb2xsIGludG8gdmlld1wiIGJlaGF2aW91clxuICAgICAgICBsZWZ0OiAtMTAwLFxuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoLjAxKScsXG4gICAgICB9fVxuICAgIC8+XG4gICk7XG59XG4iXX0= */")
  }));
}
var cancelScroll = function cancelScroll2(event) {
  event.preventDefault();
  event.stopPropagation();
};
function useScrollCapture(_ref4) {
  var isEnabled = _ref4.isEnabled, onBottomArrive = _ref4.onBottomArrive, onBottomLeave = _ref4.onBottomLeave, onTopArrive = _ref4.onTopArrive, onTopLeave = _ref4.onTopLeave;
  var isBottom = (0, import_react154.useRef)(false);
  var isTop = (0, import_react154.useRef)(false);
  var touchStart = (0, import_react154.useRef)(0);
  var scrollTarget = (0, import_react154.useRef)(null);
  var handleEventDelta = (0, import_react154.useCallback)(function(event, delta) {
    if (scrollTarget.current === null)
      return;
    var _scrollTarget$current = scrollTarget.current, scrollTop = _scrollTarget$current.scrollTop, scrollHeight = _scrollTarget$current.scrollHeight, clientHeight = _scrollTarget$current.clientHeight;
    var target = scrollTarget.current;
    var isDeltaPositive = delta > 0;
    var availableScroll = scrollHeight - clientHeight - scrollTop;
    var shouldCancelScroll = false;
    if (availableScroll > delta && isBottom.current) {
      if (onBottomLeave)
        onBottomLeave(event);
      isBottom.current = false;
    }
    if (isDeltaPositive && isTop.current) {
      if (onTopLeave)
        onTopLeave(event);
      isTop.current = false;
    }
    if (isDeltaPositive && delta > availableScroll) {
      if (onBottomArrive && !isBottom.current) {
        onBottomArrive(event);
      }
      target.scrollTop = scrollHeight;
      shouldCancelScroll = true;
      isBottom.current = true;
    } else if (!isDeltaPositive && -delta > scrollTop) {
      if (onTopArrive && !isTop.current) {
        onTopArrive(event);
      }
      target.scrollTop = 0;
      shouldCancelScroll = true;
      isTop.current = true;
    }
    if (shouldCancelScroll) {
      cancelScroll(event);
    }
  }, [onBottomArrive, onBottomLeave, onTopArrive, onTopLeave]);
  var onWheel = (0, import_react154.useCallback)(function(event) {
    handleEventDelta(event, event.deltaY);
  }, [handleEventDelta]);
  var onTouchStart = (0, import_react154.useCallback)(function(event) {
    touchStart.current = event.changedTouches[0].clientY;
  }, []);
  var onTouchMove = (0, import_react154.useCallback)(function(event) {
    var deltaY = touchStart.current - event.changedTouches[0].clientY;
    handleEventDelta(event, deltaY);
  }, [handleEventDelta]);
  var startListening = (0, import_react154.useCallback)(function(el) {
    if (!el)
      return;
    var notPassive = supportsPassiveEvents ? {
      passive: false
    } : false;
    el.addEventListener("wheel", onWheel, notPassive);
    el.addEventListener("touchstart", onTouchStart, notPassive);
    el.addEventListener("touchmove", onTouchMove, notPassive);
  }, [onTouchMove, onTouchStart, onWheel]);
  var stopListening = (0, import_react154.useCallback)(function(el) {
    if (!el)
      return;
    el.removeEventListener("wheel", onWheel, false);
    el.removeEventListener("touchstart", onTouchStart, false);
    el.removeEventListener("touchmove", onTouchMove, false);
  }, [onTouchMove, onTouchStart, onWheel]);
  (0, import_react154.useEffect)(function() {
    if (!isEnabled)
      return;
    var element = scrollTarget.current;
    startListening(element);
    return function() {
      stopListening(element);
    };
  }, [isEnabled, startListening, stopListening]);
  return function(element) {
    scrollTarget.current = element;
  };
}
var STYLE_KEYS = ["boxSizing", "height", "overflow", "paddingRight", "position"];
var LOCK_STYLES = {
  boxSizing: "border-box",
  // account for possible declaration `width: 100%;` on body
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function preventTouchMove(e4) {
  e4.preventDefault();
}
function allowTouchMove(e4) {
  e4.stopPropagation();
}
function preventInertiaScroll() {
  var top3 = this.scrollTop;
  var totalScroll = this.scrollHeight;
  var currentScroll = top3 + this.offsetHeight;
  if (top3 === 0) {
    this.scrollTop = 1;
  } else if (currentScroll === totalScroll) {
    this.scrollTop = top3 - 1;
  }
}
function isTouchDevice() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var activeScrollLocks = 0;
var listenerOptions = {
  capture: false,
  passive: false
};
function useScrollLock(_ref4) {
  var isEnabled = _ref4.isEnabled, _ref$accountForScroll = _ref4.accountForScrollbars, accountForScrollbars = _ref$accountForScroll === void 0 ? true : _ref$accountForScroll;
  var originalStyles = (0, import_react154.useRef)({});
  var scrollTarget = (0, import_react154.useRef)(null);
  var addScrollLock = (0, import_react154.useCallback)(function(touchScrollTarget) {
    if (!canUseDOM)
      return;
    var target = document.body;
    var targetStyle = target && target.style;
    if (accountForScrollbars) {
      STYLE_KEYS.forEach(function(key) {
        var val = targetStyle && targetStyle[key];
        originalStyles.current[key] = val;
      });
    }
    if (accountForScrollbars && activeScrollLocks < 1) {
      var currentPadding = parseInt(originalStyles.current.paddingRight, 10) || 0;
      var clientWidth = document.body ? document.body.clientWidth : 0;
      var adjustedPadding = window.innerWidth - clientWidth + currentPadding || 0;
      Object.keys(LOCK_STYLES).forEach(function(key) {
        var val = LOCK_STYLES[key];
        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
      if (targetStyle) {
        targetStyle.paddingRight = "".concat(adjustedPadding, "px");
      }
    }
    if (target && isTouchDevice()) {
      target.addEventListener("touchmove", preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.addEventListener("touchstart", preventInertiaScroll, listenerOptions);
        touchScrollTarget.addEventListener("touchmove", allowTouchMove, listenerOptions);
      }
    }
    activeScrollLocks += 1;
  }, [accountForScrollbars]);
  var removeScrollLock = (0, import_react154.useCallback)(function(touchScrollTarget) {
    if (!canUseDOM)
      return;
    var target = document.body;
    var targetStyle = target && target.style;
    activeScrollLocks = Math.max(activeScrollLocks - 1, 0);
    if (accountForScrollbars && activeScrollLocks < 1) {
      STYLE_KEYS.forEach(function(key) {
        var val = originalStyles.current[key];
        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
    }
    if (target && isTouchDevice()) {
      target.removeEventListener("touchmove", preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.removeEventListener("touchstart", preventInertiaScroll, listenerOptions);
        touchScrollTarget.removeEventListener("touchmove", allowTouchMove, listenerOptions);
      }
    }
  }, [accountForScrollbars]);
  (0, import_react154.useEffect)(function() {
    if (!isEnabled)
      return;
    var element = scrollTarget.current;
    addScrollLock(element);
    return function() {
      removeScrollLock(element);
    };
  }, [isEnabled, addScrollLock, removeScrollLock]);
  return function(element) {
    scrollTarget.current = element;
  };
}
function _EMOTION_STRINGIFIED_CSS_ERROR__$1() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var blurSelectInput = function blurSelectInput2() {
  return document.activeElement && document.activeElement.blur();
};
var _ref2$1 = false ? {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
} : {
  name: "bp8cua-ScrollManager",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0;label:ScrollManager;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNjcm9sbE1hbmFnZXIudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQStDVSIsImZpbGUiOiJTY3JvbGxNYW5hZ2VyLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsganN4IH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuaW1wb3J0IHsgRnJhZ21lbnQsIFJlYWN0RWxlbWVudCwgUmVmQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlU2Nyb2xsQ2FwdHVyZSBmcm9tICcuL3VzZVNjcm9sbENhcHR1cmUnO1xuaW1wb3J0IHVzZVNjcm9sbExvY2sgZnJvbSAnLi91c2VTY3JvbGxMb2NrJztcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgcmVhZG9ubHkgY2hpbGRyZW46IChyZWY6IFJlZkNhbGxiYWNrPEhUTUxFbGVtZW50PikgPT4gUmVhY3RFbGVtZW50O1xuICByZWFkb25seSBsb2NrRW5hYmxlZDogYm9vbGVhbjtcbiAgcmVhZG9ubHkgY2FwdHVyZUVuYWJsZWQ6IGJvb2xlYW47XG4gIHJlYWRvbmx5IG9uQm90dG9tQXJyaXZlPzogKGV2ZW50OiBXaGVlbEV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZDtcbiAgcmVhZG9ubHkgb25Cb3R0b21MZWF2ZT86IChldmVudDogV2hlZWxFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWQ7XG4gIHJlYWRvbmx5IG9uVG9wQXJyaXZlPzogKGV2ZW50OiBXaGVlbEV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZDtcbiAgcmVhZG9ubHkgb25Ub3BMZWF2ZT86IChldmVudDogV2hlZWxFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWQ7XG59XG5cbmNvbnN0IGJsdXJTZWxlY3RJbnB1dCA9ICgpID0+XG4gIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpLmJsdXIoKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2Nyb2xsTWFuYWdlcih7XG4gIGNoaWxkcmVuLFxuICBsb2NrRW5hYmxlZCxcbiAgY2FwdHVyZUVuYWJsZWQgPSB0cnVlLFxuICBvbkJvdHRvbUFycml2ZSxcbiAgb25Cb3R0b21MZWF2ZSxcbiAgb25Ub3BBcnJpdmUsXG4gIG9uVG9wTGVhdmUsXG59OiBQcm9wcykge1xuICBjb25zdCBzZXRTY3JvbGxDYXB0dXJlVGFyZ2V0ID0gdXNlU2Nyb2xsQ2FwdHVyZSh7XG4gICAgaXNFbmFibGVkOiBjYXB0dXJlRW5hYmxlZCxcbiAgICBvbkJvdHRvbUFycml2ZSxcbiAgICBvbkJvdHRvbUxlYXZlLFxuICAgIG9uVG9wQXJyaXZlLFxuICAgIG9uVG9wTGVhdmUsXG4gIH0pO1xuICBjb25zdCBzZXRTY3JvbGxMb2NrVGFyZ2V0ID0gdXNlU2Nyb2xsTG9jayh7IGlzRW5hYmxlZDogbG9ja0VuYWJsZWQgfSk7XG5cbiAgY29uc3QgdGFyZ2V0UmVmOiBSZWZDYWxsYmFjazxIVE1MRWxlbWVudD4gPSAoZWxlbWVudCkgPT4ge1xuICAgIHNldFNjcm9sbENhcHR1cmVUYXJnZXQoZWxlbWVudCk7XG4gICAgc2V0U2Nyb2xsTG9ja1RhcmdldChlbGVtZW50KTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxGcmFnbWVudD5cbiAgICAgIHtsb2NrRW5hYmxlZCAmJiAoXG4gICAgICAgIDxkaXZcbiAgICAgICAgICBvbkNsaWNrPXtibHVyU2VsZWN0SW5wdXR9XG4gICAgICAgICAgY3NzPXt7IHBvc2l0aW9uOiAnZml4ZWQnLCBsZWZ0OiAwLCBib3R0b206IDAsIHJpZ2h0OiAwLCB0b3A6IDAgfX1cbiAgICAgICAgLz5cbiAgICAgICl9XG4gICAgICB7Y2hpbGRyZW4odGFyZ2V0UmVmKX1cbiAgICA8L0ZyYWdtZW50PlxuICApO1xufVxuIl19 */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__$1
};
function ScrollManager(_ref4) {
  var children = _ref4.children, lockEnabled = _ref4.lockEnabled, _ref$captureEnabled = _ref4.captureEnabled, captureEnabled = _ref$captureEnabled === void 0 ? true : _ref$captureEnabled, onBottomArrive = _ref4.onBottomArrive, onBottomLeave = _ref4.onBottomLeave, onTopArrive = _ref4.onTopArrive, onTopLeave = _ref4.onTopLeave;
  var setScrollCaptureTarget = useScrollCapture({
    isEnabled: captureEnabled,
    onBottomArrive,
    onBottomLeave,
    onTopArrive,
    onTopLeave
  });
  var setScrollLockTarget = useScrollLock({
    isEnabled: lockEnabled
  });
  var targetRef = function targetRef2(element) {
    setScrollCaptureTarget(element);
    setScrollLockTarget(element);
  };
  return jsx(import_react154.Fragment, null, lockEnabled && jsx("div", {
    onClick: blurSelectInput,
    css: _ref2$1
  }), children(targetRef));
}
function _EMOTION_STRINGIFIED_CSS_ERROR__2() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var _ref22 = false ? {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
} : {
  name: "5kkxb2-requiredInput-RequiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%;label:RequiredInput;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlJlcXVpcmVkSW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWFJIiwiZmlsZSI6IlJlcXVpcmVkSW5wdXQudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBqc3gganN4ICovXG5pbXBvcnQgeyBGb2N1c0V2ZW50SGFuZGxlciwgRnVuY3Rpb25Db21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmNvbnN0IFJlcXVpcmVkSW5wdXQ6IEZ1bmN0aW9uQ29tcG9uZW50PHtcbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuICByZWFkb25seSBvbkZvY3VzOiBGb2N1c0V2ZW50SGFuZGxlcjxIVE1MSW5wdXRFbGVtZW50Pjtcbn0+ID0gKHsgbmFtZSwgb25Gb2N1cyB9KSA9PiAoXG4gIDxpbnB1dFxuICAgIHJlcXVpcmVkXG4gICAgbmFtZT17bmFtZX1cbiAgICB0YWJJbmRleD17LTF9XG4gICAgb25Gb2N1cz17b25Gb2N1c31cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAncmVxdWlyZWRJbnB1dCcsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgIH19XG4gICAgLy8gUHJldmVudCBgU3dpdGNoaW5nIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWRgIGVycm9yXG4gICAgdmFsdWU9XCJcIlxuICAgIG9uQ2hhbmdlPXsoKSA9PiB7fX1cbiAgLz5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFJlcXVpcmVkSW5wdXQ7XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__2
};
var RequiredInput = function RequiredInput2(_ref4) {
  var name2 = _ref4.name, onFocus4 = _ref4.onFocus;
  return jsx("input", {
    required: true,
    name: name2,
    tabIndex: -1,
    onFocus: onFocus4,
    css: _ref22,
    value: "",
    onChange: function onChange2() {
    }
  });
};
var formatGroupLabel = function formatGroupLabel2(group) {
  return group.label;
};
var getOptionLabel$1 = function getOptionLabel(option) {
  return option.label;
};
var getOptionValue$1 = function getOptionValue(option) {
  return option.value;
};
var isOptionDisabled = function isOptionDisabled2(option) {
  return !!option.isDisabled;
};
var defaultStyles = {
  clearIndicator: clearIndicatorCSS,
  container: containerCSS,
  control: css$1,
  dropdownIndicator: dropdownIndicatorCSS,
  group: groupCSS,
  groupHeading: groupHeadingCSS,
  indicatorsContainer: indicatorsContainerCSS,
  indicatorSeparator: indicatorSeparatorCSS,
  input: inputCSS,
  loadingIndicator: loadingIndicatorCSS,
  loadingMessage: loadingMessageCSS,
  menu: menuCSS,
  menuList: menuListCSS,
  menuPortal: menuPortalCSS,
  multiValue: multiValueCSS,
  multiValueLabel: multiValueLabelCSS,
  multiValueRemove: multiValueRemoveCSS,
  noOptionsMessage: noOptionsMessageCSS,
  option: optionCSS,
  placeholder: placeholderCSS,
  singleValue: css3,
  valueContainer: valueContainerCSS
};
var colors = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
};
var borderRadius = 4;
var baseUnit = 4;
var controlHeight = 38;
var menuGutter = baseUnit * 2;
var spacing = {
  baseUnit,
  controlHeight,
  menuGutter
};
var defaultTheme = {
  borderRadius,
  colors,
  spacing
};
var defaultProps2 = {
  "aria-live": "polite",
  backspaceRemovesValue: true,
  blurInputOnSelect: isTouchCapable(),
  captureMenuScroll: !isTouchCapable(),
  classNames: {},
  closeMenuOnSelect: true,
  closeMenuOnScroll: false,
  components: {},
  controlShouldRenderValue: true,
  escapeClearsValue: false,
  filterOption: createFilter(),
  formatGroupLabel,
  getOptionLabel: getOptionLabel$1,
  getOptionValue: getOptionValue$1,
  isDisabled: false,
  isLoading: false,
  isMulti: false,
  isRtl: false,
  isSearchable: true,
  isOptionDisabled,
  loadingMessage: function loadingMessage() {
    return "Loading...";
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: false,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: false,
  menuShouldScrollIntoView: !isMobileDevice(),
  noOptionsMessage: function noOptionsMessage() {
    return "No options";
  },
  openMenuOnFocus: false,
  openMenuOnClick: true,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: function screenReaderStatus(_ref4) {
    var count2 = _ref4.count;
    return "".concat(count2, " result").concat(count2 !== 1 ? "s" : "", " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: true,
  unstyled: false
};
function toCategorizedOption(props, option, selectValue, index4) {
  var isDisabled = _isOptionDisabled(props, option, selectValue);
  var isSelected = _isOptionSelected(props, option, selectValue);
  var label = getOptionLabel2(props, option);
  var value = getOptionValue2(props, option);
  return {
    type: "option",
    data: option,
    isDisabled,
    isSelected,
    label,
    value,
    index: index4
  };
}
function buildCategorizedOptions(props, selectValue) {
  return props.options.map(function(groupOrOption, groupOrOptionIndex) {
    if ("options" in groupOrOption) {
      var categorizedOptions = groupOrOption.options.map(function(option, optionIndex) {
        return toCategorizedOption(props, option, selectValue, optionIndex);
      }).filter(function(categorizedOption2) {
        return isFocusable(props, categorizedOption2);
      });
      return categorizedOptions.length > 0 ? {
        type: "group",
        data: groupOrOption,
        options: categorizedOptions,
        index: groupOrOptionIndex
      } : void 0;
    }
    var categorizedOption = toCategorizedOption(props, groupOrOption, selectValue, groupOrOptionIndex);
    return isFocusable(props, categorizedOption) ? categorizedOption : void 0;
  }).filter(notNullish);
}
function buildFocusableOptionsFromCategorizedOptions(categorizedOptions) {
  return categorizedOptions.reduce(function(optionsAccumulator, categorizedOption) {
    if (categorizedOption.type === "group") {
      optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray3(categorizedOption.options.map(function(option) {
        return option.data;
      })));
    } else {
      optionsAccumulator.push(categorizedOption.data);
    }
    return optionsAccumulator;
  }, []);
}
function buildFocusableOptions(props, selectValue) {
  return buildFocusableOptionsFromCategorizedOptions(buildCategorizedOptions(props, selectValue));
}
function isFocusable(props, categorizedOption) {
  var _props$inputValue = props.inputValue, inputValue = _props$inputValue === void 0 ? "" : _props$inputValue;
  var data = categorizedOption.data, isSelected = categorizedOption.isSelected, label = categorizedOption.label, value = categorizedOption.value;
  return (!shouldHideSelectedOptions(props) || !isSelected) && _filterOption(props, {
    label,
    value,
    data
  }, inputValue);
}
function getNextFocusedValue(state, nextSelectValue) {
  var focusedValue = state.focusedValue, lastSelectValue = state.selectValue;
  var lastFocusedIndex = lastSelectValue.indexOf(focusedValue);
  if (lastFocusedIndex > -1) {
    var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);
    if (nextFocusedIndex > -1) {
      return focusedValue;
    } else if (lastFocusedIndex < nextSelectValue.length) {
      return nextSelectValue[lastFocusedIndex];
    }
  }
  return null;
}
function getNextFocusedOption(state, options2) {
  var lastFocusedOption = state.focusedOption;
  return lastFocusedOption && options2.indexOf(lastFocusedOption) > -1 ? lastFocusedOption : options2[0];
}
var getOptionLabel2 = function getOptionLabel3(props, data) {
  return props.getOptionLabel(data);
};
var getOptionValue2 = function getOptionValue3(props, data) {
  return props.getOptionValue(data);
};
function _isOptionDisabled(props, option, selectValue) {
  return typeof props.isOptionDisabled === "function" ? props.isOptionDisabled(option, selectValue) : false;
}
function _isOptionSelected(props, option, selectValue) {
  if (selectValue.indexOf(option) > -1)
    return true;
  if (typeof props.isOptionSelected === "function") {
    return props.isOptionSelected(option, selectValue);
  }
  var candidate = getOptionValue2(props, option);
  return selectValue.some(function(i2) {
    return getOptionValue2(props, i2) === candidate;
  });
}
function _filterOption(props, option, inputValue) {
  return props.filterOption ? props.filterOption(option, inputValue) : true;
}
var shouldHideSelectedOptions = function shouldHideSelectedOptions2(props) {
  var hideSelectedOptions = props.hideSelectedOptions, isMulti = props.isMulti;
  if (hideSelectedOptions === void 0)
    return isMulti;
  return hideSelectedOptions;
};
var instanceId = 1;
var Select = function(_Component) {
  _inherits(Select2, _Component);
  var _super = _createSuper(Select2);
  function Select2(_props) {
    var _this;
    _classCallCheck(this, Select2);
    _this = _super.call(this, _props);
    _this.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedValue: null,
      inputIsHidden: false,
      isFocused: false,
      selectValue: [],
      clearFocusValueOnUpdate: false,
      prevWasFocused: false,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0
    };
    _this.blockOptionHover = false;
    _this.isComposing = false;
    _this.commonProps = void 0;
    _this.initialTouchX = 0;
    _this.initialTouchY = 0;
    _this.instancePrefix = "";
    _this.openAfterFocus = false;
    _this.scrollToFocusedOptionOnUpdate = false;
    _this.userIsDragging = void 0;
    _this.controlRef = null;
    _this.getControlRef = function(ref) {
      _this.controlRef = ref;
    };
    _this.focusedOptionRef = null;
    _this.getFocusedOptionRef = function(ref) {
      _this.focusedOptionRef = ref;
    };
    _this.menuListRef = null;
    _this.getMenuListRef = function(ref) {
      _this.menuListRef = ref;
    };
    _this.inputRef = null;
    _this.getInputRef = function(ref) {
      _this.inputRef = ref;
    };
    _this.focus = _this.focusInput;
    _this.blur = _this.blurInput;
    _this.onChange = function(newValue, actionMeta) {
      var _this$props = _this.props, onChange2 = _this$props.onChange, name2 = _this$props.name;
      actionMeta.name = name2;
      _this.ariaOnChange(newValue, actionMeta);
      onChange2(newValue, actionMeta);
    };
    _this.setValue = function(newValue, action, option) {
      var _this$props2 = _this.props, closeMenuOnSelect = _this$props2.closeMenuOnSelect, isMulti = _this$props2.isMulti, inputValue = _this$props2.inputValue;
      _this.onInputChange("", {
        action: "set-value",
        prevInputValue: inputValue
      });
      if (closeMenuOnSelect) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      }
      _this.setState({
        clearFocusValueOnUpdate: true
      });
      _this.onChange(newValue, {
        action,
        option
      });
    };
    _this.selectOption = function(newValue) {
      var _this$props3 = _this.props, blurInputOnSelect = _this$props3.blurInputOnSelect, isMulti = _this$props3.isMulti, name2 = _this$props3.name;
      var selectValue = _this.state.selectValue;
      var deselected = isMulti && _this.isOptionSelected(newValue, selectValue);
      var isDisabled = _this.isOptionDisabled(newValue, selectValue);
      if (deselected) {
        var candidate = _this.getOptionValue(newValue);
        _this.setValue(multiValueAsValue(selectValue.filter(function(i2) {
          return _this.getOptionValue(i2) !== candidate;
        })), "deselect-option", newValue);
      } else if (!isDisabled) {
        if (isMulti) {
          _this.setValue(multiValueAsValue([].concat(_toConsumableArray3(selectValue), [newValue])), "select-option", newValue);
        } else {
          _this.setValue(singleValueAsValue(newValue), "select-option");
        }
      } else {
        _this.ariaOnChange(singleValueAsValue(newValue), {
          action: "select-option",
          option: newValue,
          name: name2
        });
        return;
      }
      if (blurInputOnSelect) {
        _this.blurInput();
      }
    };
    _this.removeValue = function(removedValue) {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var candidate = _this.getOptionValue(removedValue);
      var newValueArray = selectValue.filter(function(i2) {
        return _this.getOptionValue(i2) !== candidate;
      });
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: "remove-value",
        removedValue
      });
      _this.focusInput();
    };
    _this.clearValue = function() {
      var selectValue = _this.state.selectValue;
      _this.onChange(valueTernary(_this.props.isMulti, [], null), {
        action: "clear",
        removedValues: selectValue
      });
    };
    _this.popValue = function() {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var lastSelectedValue = selectValue[selectValue.length - 1];
      var newValueArray = selectValue.slice(0, selectValue.length - 1);
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: "pop-value",
        removedValue: lastSelectedValue
      });
    };
    _this.getValue = function() {
      return _this.state.selectValue;
    };
    _this.cx = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return classNames2.apply(void 0, [_this.props.classNamePrefix].concat(args));
    };
    _this.getOptionLabel = function(data) {
      return getOptionLabel2(_this.props, data);
    };
    _this.getOptionValue = function(data) {
      return getOptionValue2(_this.props, data);
    };
    _this.getStyles = function(key, props) {
      var unstyled = _this.props.unstyled;
      var base2 = defaultStyles[key](props, unstyled);
      base2.boxSizing = "border-box";
      var custom = _this.props.styles[key];
      return custom ? custom(base2, props) : base2;
    };
    _this.getClassNames = function(key, props) {
      var _this$props$className, _this$props$className2;
      return (_this$props$className = (_this$props$className2 = _this.props.classNames)[key]) === null || _this$props$className === void 0 ? void 0 : _this$props$className.call(_this$props$className2, props);
    };
    _this.getElementId = function(element) {
      return "".concat(_this.instancePrefix, "-").concat(element);
    };
    _this.getComponents = function() {
      return defaultComponents(_this.props);
    };
    _this.buildCategorizedOptions = function() {
      return buildCategorizedOptions(_this.props, _this.state.selectValue);
    };
    _this.getCategorizedOptions = function() {
      return _this.props.menuIsOpen ? _this.buildCategorizedOptions() : [];
    };
    _this.buildFocusableOptions = function() {
      return buildFocusableOptionsFromCategorizedOptions(_this.buildCategorizedOptions());
    };
    _this.getFocusableOptions = function() {
      return _this.props.menuIsOpen ? _this.buildFocusableOptions() : [];
    };
    _this.ariaOnChange = function(value, actionMeta) {
      _this.setState({
        ariaSelection: _objectSpread22({
          value
        }, actionMeta)
      });
    };
    _this.onMenuMouseDown = function(event) {
      if (event.button !== 0) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      _this.focusInput();
    };
    _this.onMenuMouseMove = function(event) {
      _this.blockOptionHover = false;
    };
    _this.onControlMouseDown = function(event) {
      if (event.defaultPrevented) {
        return;
      }
      var openMenuOnClick = _this.props.openMenuOnClick;
      if (!_this.state.isFocused) {
        if (openMenuOnClick) {
          _this.openAfterFocus = true;
        }
        _this.focusInput();
      } else if (!_this.props.menuIsOpen) {
        if (openMenuOnClick) {
          _this.openMenu("first");
        }
      } else {
        if (event.target.tagName !== "INPUT" && event.target.tagName !== "TEXTAREA") {
          _this.onMenuClose();
        }
      }
      if (event.target.tagName !== "INPUT" && event.target.tagName !== "TEXTAREA") {
        event.preventDefault();
      }
    };
    _this.onDropdownIndicatorMouseDown = function(event) {
      if (event && event.type === "mousedown" && event.button !== 0) {
        return;
      }
      if (_this.props.isDisabled)
        return;
      var _this$props4 = _this.props, isMulti = _this$props4.isMulti, menuIsOpen = _this$props4.menuIsOpen;
      _this.focusInput();
      if (menuIsOpen) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      } else {
        _this.openMenu("first");
      }
      event.preventDefault();
    };
    _this.onClearIndicatorMouseDown = function(event) {
      if (event && event.type === "mousedown" && event.button !== 0) {
        return;
      }
      _this.clearValue();
      event.preventDefault();
      _this.openAfterFocus = false;
      if (event.type === "touchend") {
        _this.focusInput();
      } else {
        setTimeout(function() {
          return _this.focusInput();
        });
      }
    };
    _this.onScroll = function(event) {
      if (typeof _this.props.closeMenuOnScroll === "boolean") {
        if (event.target instanceof HTMLElement && isDocumentElement(event.target)) {
          _this.props.onMenuClose();
        }
      } else if (typeof _this.props.closeMenuOnScroll === "function") {
        if (_this.props.closeMenuOnScroll(event)) {
          _this.props.onMenuClose();
        }
      }
    };
    _this.onCompositionStart = function() {
      _this.isComposing = true;
    };
    _this.onCompositionEnd = function() {
      _this.isComposing = false;
    };
    _this.onTouchStart = function(_ref23) {
      var touches = _ref23.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      _this.initialTouchX = touch.clientX;
      _this.initialTouchY = touch.clientY;
      _this.userIsDragging = false;
    };
    _this.onTouchMove = function(_ref32) {
      var touches = _ref32.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      var deltaX = Math.abs(touch.clientX - _this.initialTouchX);
      var deltaY = Math.abs(touch.clientY - _this.initialTouchY);
      var moveThreshold = 5;
      _this.userIsDragging = deltaX > moveThreshold || deltaY > moveThreshold;
    };
    _this.onTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      if (_this.controlRef && !_this.controlRef.contains(event.target) && _this.menuListRef && !_this.menuListRef.contains(event.target)) {
        _this.blurInput();
      }
      _this.initialTouchX = 0;
      _this.initialTouchY = 0;
    };
    _this.onControlTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      _this.onControlMouseDown(event);
    };
    _this.onClearIndicatorTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      _this.onClearIndicatorMouseDown(event);
    };
    _this.onDropdownIndicatorTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      _this.onDropdownIndicatorMouseDown(event);
    };
    _this.handleInputChange = function(event) {
      var prevInputValue = _this.props.inputValue;
      var inputValue = event.currentTarget.value;
      _this.setState({
        inputIsHiddenAfterUpdate: false
      });
      _this.onInputChange(inputValue, {
        action: "input-change",
        prevInputValue
      });
      if (!_this.props.menuIsOpen) {
        _this.onMenuOpen();
      }
    };
    _this.onInputFocus = function(event) {
      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
      _this.setState({
        inputIsHiddenAfterUpdate: false,
        isFocused: true
      });
      if (_this.openAfterFocus || _this.props.openMenuOnFocus) {
        _this.openMenu("first");
      }
      _this.openAfterFocus = false;
    };
    _this.onInputBlur = function(event) {
      var prevInputValue = _this.props.inputValue;
      if (_this.menuListRef && _this.menuListRef.contains(document.activeElement)) {
        _this.inputRef.focus();
        return;
      }
      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }
      _this.onInputChange("", {
        action: "input-blur",
        prevInputValue
      });
      _this.onMenuClose();
      _this.setState({
        focusedValue: null,
        isFocused: false
      });
    };
    _this.onOptionHover = function(focusedOption) {
      if (_this.blockOptionHover || _this.state.focusedOption === focusedOption) {
        return;
      }
      _this.setState({
        focusedOption
      });
    };
    _this.shouldHideSelectedOptions = function() {
      return shouldHideSelectedOptions(_this.props);
    };
    _this.onValueInputFocus = function(e4) {
      e4.preventDefault();
      e4.stopPropagation();
      _this.focus();
    };
    _this.onKeyDown = function(event) {
      var _this$props5 = _this.props, isMulti = _this$props5.isMulti, backspaceRemovesValue = _this$props5.backspaceRemovesValue, escapeClearsValue = _this$props5.escapeClearsValue, inputValue = _this$props5.inputValue, isClearable = _this$props5.isClearable, isDisabled = _this$props5.isDisabled, menuIsOpen = _this$props5.menuIsOpen, onKeyDown = _this$props5.onKeyDown, tabSelectsValue = _this$props5.tabSelectsValue, openMenuOnFocus = _this$props5.openMenuOnFocus;
      var _this$state = _this.state, focusedOption = _this$state.focusedOption, focusedValue = _this$state.focusedValue, selectValue = _this$state.selectValue;
      if (isDisabled)
        return;
      if (typeof onKeyDown === "function") {
        onKeyDown(event);
        if (event.defaultPrevented) {
          return;
        }
      }
      _this.blockOptionHover = true;
      switch (event.key) {
        case "ArrowLeft":
          if (!isMulti || inputValue)
            return;
          _this.focusValue("previous");
          break;
        case "ArrowRight":
          if (!isMulti || inputValue)
            return;
          _this.focusValue("next");
          break;
        case "Delete":
        case "Backspace":
          if (inputValue)
            return;
          if (focusedValue) {
            _this.removeValue(focusedValue);
          } else {
            if (!backspaceRemovesValue)
              return;
            if (isMulti) {
              _this.popValue();
            } else if (isClearable) {
              _this.clearValue();
            }
          }
          break;
        case "Tab":
          if (_this.isComposing)
            return;
          if (event.shiftKey || !menuIsOpen || !tabSelectsValue || !focusedOption || // don't capture the event if the menu opens on focus and the focused
          // option is already selected; it breaks the flow of navigation
          openMenuOnFocus && _this.isOptionSelected(focusedOption, selectValue)) {
            return;
          }
          _this.selectOption(focusedOption);
          break;
        case "Enter":
          if (event.keyCode === 229) {
            break;
          }
          if (menuIsOpen) {
            if (!focusedOption)
              return;
            if (_this.isComposing)
              return;
            _this.selectOption(focusedOption);
            break;
          }
          return;
        case "Escape":
          if (menuIsOpen) {
            _this.setState({
              inputIsHiddenAfterUpdate: false
            });
            _this.onInputChange("", {
              action: "menu-close",
              prevInputValue: inputValue
            });
            _this.onMenuClose();
          } else if (isClearable && escapeClearsValue) {
            _this.clearValue();
          }
          break;
        case " ":
          if (inputValue) {
            return;
          }
          if (!menuIsOpen) {
            _this.openMenu("first");
            break;
          }
          if (!focusedOption)
            return;
          _this.selectOption(focusedOption);
          break;
        case "ArrowUp":
          if (menuIsOpen) {
            _this.focusOption("up");
          } else {
            _this.openMenu("last");
          }
          break;
        case "ArrowDown":
          if (menuIsOpen) {
            _this.focusOption("down");
          } else {
            _this.openMenu("first");
          }
          break;
        case "PageUp":
          if (!menuIsOpen)
            return;
          _this.focusOption("pageup");
          break;
        case "PageDown":
          if (!menuIsOpen)
            return;
          _this.focusOption("pagedown");
          break;
        case "Home":
          if (!menuIsOpen)
            return;
          _this.focusOption("first");
          break;
        case "End":
          if (!menuIsOpen)
            return;
          _this.focusOption("last");
          break;
        default:
          return;
      }
      event.preventDefault();
    };
    _this.instancePrefix = "react-select-" + (_this.props.instanceId || ++instanceId);
    _this.state.selectValue = cleanValue(_props.value);
    if (_props.menuIsOpen && _this.state.selectValue.length) {
      var focusableOptions = _this.buildFocusableOptions();
      var optionIndex = focusableOptions.indexOf(_this.state.selectValue[0]);
      _this.state.focusedOption = focusableOptions[optionIndex];
    }
    return _this;
  }
  _createClass(Select2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.startListeningComposition();
      this.startListeningToTouch();
      if (this.props.closeMenuOnScroll && document && document.addEventListener) {
        document.addEventListener("scroll", this.onScroll, true);
      }
      if (this.props.autoFocus) {
        this.focusInput();
      }
      if (this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props6 = this.props, isDisabled = _this$props6.isDisabled, menuIsOpen = _this$props6.menuIsOpen;
      var isFocused = this.state.isFocused;
      if (
        // ensure focus is restored correctly when the control becomes enabled
        isFocused && !isDisabled && prevProps.isDisabled || // ensure focus is on the Input when the menu opens
        isFocused && menuIsOpen && !prevProps.menuIsOpen
      ) {
        this.focusInput();
      }
      if (isFocused && isDisabled && !prevProps.isDisabled) {
        this.setState({
          isFocused: false
        }, this.onMenuClose);
      } else if (!isFocused && !isDisabled && prevProps.isDisabled && this.inputRef === document.activeElement) {
        this.setState({
          isFocused: true
        });
      }
      if (this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
        this.scrollToFocusedOptionOnUpdate = false;
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.stopListeningComposition();
      this.stopListeningToTouch();
      document.removeEventListener("scroll", this.onScroll, true);
    }
    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function onMenuOpen() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function onMenuClose() {
      this.onInputChange("", {
        action: "menu-close",
        prevInputValue: this.props.inputValue
      });
      this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function onInputChange(newValue, actionMeta) {
      this.props.onInputChange(newValue, actionMeta);
    }
    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function focusInput() {
      if (!this.inputRef)
        return;
      this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function blurInput() {
      if (!this.inputRef)
        return;
      this.inputRef.blur();
    }
    // aliased for consumers
  }, {
    key: "openMenu",
    value: function openMenu(focusOption) {
      var _this2 = this;
      var _this$state2 = this.state, selectValue = _this$state2.selectValue, isFocused = _this$state2.isFocused;
      var focusableOptions = this.buildFocusableOptions();
      var openAtIndex = focusOption === "first" ? 0 : focusableOptions.length - 1;
      if (!this.props.isMulti) {
        var selectedIndex = focusableOptions.indexOf(selectValue[0]);
        if (selectedIndex > -1) {
          openAtIndex = selectedIndex;
        }
      }
      this.scrollToFocusedOptionOnUpdate = !(isFocused && this.menuListRef);
      this.setState({
        inputIsHiddenAfterUpdate: false,
        focusedValue: null,
        focusedOption: focusableOptions[openAtIndex]
      }, function() {
        return _this2.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function focusValue(direction) {
      var _this$state3 = this.state, selectValue = _this$state3.selectValue, focusedValue = _this$state3.focusedValue;
      if (!this.props.isMulti)
        return;
      this.setState({
        focusedOption: null
      });
      var focusedIndex = selectValue.indexOf(focusedValue);
      if (!focusedValue) {
        focusedIndex = -1;
      }
      var lastIndex = selectValue.length - 1;
      var nextFocus = -1;
      if (!selectValue.length)
        return;
      switch (direction) {
        case "previous":
          if (focusedIndex === 0) {
            nextFocus = 0;
          } else if (focusedIndex === -1) {
            nextFocus = lastIndex;
          } else {
            nextFocus = focusedIndex - 1;
          }
          break;
        case "next":
          if (focusedIndex > -1 && focusedIndex < lastIndex) {
            nextFocus = focusedIndex + 1;
          }
          break;
      }
      this.setState({
        inputIsHidden: nextFocus !== -1,
        focusedValue: selectValue[nextFocus]
      });
    }
  }, {
    key: "focusOption",
    value: function focusOption() {
      var direction = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first";
      var pageSize = this.props.pageSize;
      var focusedOption = this.state.focusedOption;
      var options2 = this.getFocusableOptions();
      if (!options2.length)
        return;
      var nextFocus = 0;
      var focusedIndex = options2.indexOf(focusedOption);
      if (!focusedOption) {
        focusedIndex = -1;
      }
      if (direction === "up") {
        nextFocus = focusedIndex > 0 ? focusedIndex - 1 : options2.length - 1;
      } else if (direction === "down") {
        nextFocus = (focusedIndex + 1) % options2.length;
      } else if (direction === "pageup") {
        nextFocus = focusedIndex - pageSize;
        if (nextFocus < 0)
          nextFocus = 0;
      } else if (direction === "pagedown") {
        nextFocus = focusedIndex + pageSize;
        if (nextFocus > options2.length - 1)
          nextFocus = options2.length - 1;
      } else if (direction === "last") {
        nextFocus = options2.length - 1;
      }
      this.scrollToFocusedOptionOnUpdate = true;
      this.setState({
        focusedOption: options2[nextFocus],
        focusedValue: null
      });
    }
  }, {
    key: "getTheme",
    value: (
      // ==============================
      // Getters
      // ==============================
      function getTheme3() {
        if (!this.props.theme) {
          return defaultTheme;
        }
        if (typeof this.props.theme === "function") {
          return this.props.theme(defaultTheme);
        }
        return _objectSpread22(_objectSpread22({}, defaultTheme), this.props.theme);
      }
    )
  }, {
    key: "getCommonProps",
    value: function getCommonProps() {
      var clearValue = this.clearValue, cx = this.cx, getStyles = this.getStyles, getClassNames = this.getClassNames, getValue = this.getValue, selectOption = this.selectOption, setValue = this.setValue, props = this.props;
      var isMulti = props.isMulti, isRtl = props.isRtl, options2 = props.options;
      var hasValue = this.hasValue();
      return {
        clearValue,
        cx,
        getStyles,
        getClassNames,
        getValue,
        hasValue,
        isMulti,
        isRtl,
        options: options2,
        selectOption,
        selectProps: props,
        setValue,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function hasValue() {
      var selectValue = this.state.selectValue;
      return selectValue.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function hasOptions() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function isClearable() {
      var _this$props7 = this.props, isClearable2 = _this$props7.isClearable, isMulti = _this$props7.isMulti;
      if (isClearable2 === void 0)
        return isMulti;
      return isClearable2;
    }
  }, {
    key: "isOptionDisabled",
    value: function isOptionDisabled3(option, selectValue) {
      return _isOptionDisabled(this.props, option, selectValue);
    }
  }, {
    key: "isOptionSelected",
    value: function isOptionSelected(option, selectValue) {
      return _isOptionSelected(this.props, option, selectValue);
    }
  }, {
    key: "filterOption",
    value: function filterOption(option, inputValue) {
      return _filterOption(this.props, option, inputValue);
    }
  }, {
    key: "formatOptionLabel",
    value: function formatOptionLabel(data, context) {
      if (typeof this.props.formatOptionLabel === "function") {
        var _inputValue = this.props.inputValue;
        var _selectValue = this.state.selectValue;
        return this.props.formatOptionLabel(data, {
          context,
          inputValue: _inputValue,
          selectValue: _selectValue
        });
      } else {
        return this.getOptionLabel(data);
      }
    }
  }, {
    key: "formatGroupLabel",
    value: function formatGroupLabel3(data) {
      return this.props.formatGroupLabel(data);
    }
    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value: (
      // ==============================
      // Composition Handlers
      // ==============================
      function startListeningComposition() {
        if (document && document.addEventListener) {
          document.addEventListener("compositionstart", this.onCompositionStart, false);
          document.addEventListener("compositionend", this.onCompositionEnd, false);
        }
      }
    )
  }, {
    key: "stopListeningComposition",
    value: function stopListeningComposition() {
      if (document && document.removeEventListener) {
        document.removeEventListener("compositionstart", this.onCompositionStart);
        document.removeEventListener("compositionend", this.onCompositionEnd);
      }
    }
  }, {
    key: "startListeningToTouch",
    value: (
      // ==============================
      // Touch Handlers
      // ==============================
      function startListeningToTouch() {
        if (document && document.addEventListener) {
          document.addEventListener("touchstart", this.onTouchStart, false);
          document.addEventListener("touchmove", this.onTouchMove, false);
          document.addEventListener("touchend", this.onTouchEnd, false);
        }
      }
    )
  }, {
    key: "stopListeningToTouch",
    value: function stopListeningToTouch() {
      if (document && document.removeEventListener) {
        document.removeEventListener("touchstart", this.onTouchStart);
        document.removeEventListener("touchmove", this.onTouchMove);
        document.removeEventListener("touchend", this.onTouchEnd);
      }
    }
  }, {
    key: "renderInput",
    value: (
      // ==============================
      // Renderers
      // ==============================
      function renderInput() {
        var _this$props8 = this.props, isDisabled = _this$props8.isDisabled, isSearchable = _this$props8.isSearchable, inputId = _this$props8.inputId, inputValue = _this$props8.inputValue, tabIndex = _this$props8.tabIndex, form = _this$props8.form, menuIsOpen = _this$props8.menuIsOpen, required = _this$props8.required;
        var _this$getComponents = this.getComponents(), Input3 = _this$getComponents.Input;
        var _this$state4 = this.state, inputIsHidden = _this$state4.inputIsHidden, ariaSelection = _this$state4.ariaSelection;
        var commonProps = this.commonProps;
        var id = inputId || this.getElementId("input");
        var ariaAttributes = _objectSpread22(_objectSpread22(_objectSpread22({
          "aria-autocomplete": "list",
          "aria-expanded": menuIsOpen,
          "aria-haspopup": true,
          "aria-errormessage": this.props["aria-errormessage"],
          "aria-invalid": this.props["aria-invalid"],
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-required": required,
          role: "combobox"
        }, menuIsOpen && {
          "aria-controls": this.getElementId("listbox"),
          "aria-owns": this.getElementId("listbox")
        }), !isSearchable && {
          "aria-readonly": true
        }), this.hasValue() ? (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus" && {
          "aria-describedby": this.getElementId("live-region")
        } : {
          "aria-describedby": this.getElementId("placeholder")
        });
        if (!isSearchable) {
          return React47.createElement(DummyInput, _extends2({
            id,
            innerRef: this.getInputRef,
            onBlur: this.onInputBlur,
            onChange: noop3,
            onFocus: this.onInputFocus,
            disabled: isDisabled,
            tabIndex,
            inputMode: "none",
            form,
            value: ""
          }, ariaAttributes));
        }
        return React47.createElement(Input3, _extends2({}, commonProps, {
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id,
          innerRef: this.getInputRef,
          isDisabled,
          isHidden: inputIsHidden,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex,
          form,
          type: "text",
          value: inputValue
        }, ariaAttributes));
      }
    )
  }, {
    key: "renderPlaceholderOrValue",
    value: function renderPlaceholderOrValue() {
      var _this3 = this;
      var _this$getComponents2 = this.getComponents(), MultiValue3 = _this$getComponents2.MultiValue, MultiValueContainer2 = _this$getComponents2.MultiValueContainer, MultiValueLabel2 = _this$getComponents2.MultiValueLabel, MultiValueRemove2 = _this$getComponents2.MultiValueRemove, SingleValue3 = _this$getComponents2.SingleValue, Placeholder4 = _this$getComponents2.Placeholder;
      var commonProps = this.commonProps;
      var _this$props9 = this.props, controlShouldRenderValue = _this$props9.controlShouldRenderValue, isDisabled = _this$props9.isDisabled, isMulti = _this$props9.isMulti, inputValue = _this$props9.inputValue, placeholder2 = _this$props9.placeholder;
      var _this$state5 = this.state, selectValue = _this$state5.selectValue, focusedValue = _this$state5.focusedValue, isFocused = _this$state5.isFocused;
      if (!this.hasValue() || !controlShouldRenderValue) {
        return inputValue ? null : React47.createElement(Placeholder4, _extends2({}, commonProps, {
          key: "placeholder",
          isDisabled,
          isFocused,
          innerProps: {
            id: this.getElementId("placeholder")
          }
        }), placeholder2);
      }
      if (isMulti) {
        return selectValue.map(function(opt, index4) {
          var isOptionFocused = opt === focusedValue;
          var key = "".concat(_this3.getOptionLabel(opt), "-").concat(_this3.getOptionValue(opt));
          return React47.createElement(MultiValue3, _extends2({}, commonProps, {
            components: {
              Container: MultiValueContainer2,
              Label: MultiValueLabel2,
              Remove: MultiValueRemove2
            },
            isFocused: isOptionFocused,
            isDisabled,
            key,
            index: index4,
            removeProps: {
              onClick: function onClick() {
                return _this3.removeValue(opt);
              },
              onTouchEnd: function onTouchEnd() {
                return _this3.removeValue(opt);
              },
              onMouseDown: function onMouseDown(e4) {
                e4.preventDefault();
              }
            },
            data: opt
          }), _this3.formatOptionLabel(opt, "value"));
        });
      }
      if (inputValue) {
        return null;
      }
      var singleValue = selectValue[0];
      return React47.createElement(SingleValue3, _extends2({}, commonProps, {
        data: singleValue,
        isDisabled
      }), this.formatOptionLabel(singleValue, "value"));
    }
  }, {
    key: "renderClearIndicator",
    value: function renderClearIndicator() {
      var _this$getComponents3 = this.getComponents(), ClearIndicator3 = _this$getComponents3.ClearIndicator;
      var commonProps = this.commonProps;
      var _this$props10 = this.props, isDisabled = _this$props10.isDisabled, isLoading = _this$props10.isLoading;
      var isFocused = this.state.isFocused;
      if (!this.isClearable() || !ClearIndicator3 || isDisabled || !this.hasValue() || isLoading) {
        return null;
      }
      var innerProps = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return React47.createElement(ClearIndicator3, _extends2({}, commonProps, {
        innerProps,
        isFocused
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function renderLoadingIndicator() {
      var _this$getComponents4 = this.getComponents(), LoadingIndicator3 = _this$getComponents4.LoadingIndicator;
      var commonProps = this.commonProps;
      var _this$props11 = this.props, isDisabled = _this$props11.isDisabled, isLoading = _this$props11.isLoading;
      var isFocused = this.state.isFocused;
      if (!LoadingIndicator3 || !isLoading)
        return null;
      var innerProps = {
        "aria-hidden": "true"
      };
      return React47.createElement(LoadingIndicator3, _extends2({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function renderIndicatorSeparator() {
      var _this$getComponents5 = this.getComponents(), DropdownIndicator3 = _this$getComponents5.DropdownIndicator, IndicatorSeparator3 = _this$getComponents5.IndicatorSeparator;
      if (!DropdownIndicator3 || !IndicatorSeparator3)
        return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      return React47.createElement(IndicatorSeparator3, _extends2({}, commonProps, {
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function renderDropdownIndicator() {
      var _this$getComponents6 = this.getComponents(), DropdownIndicator3 = _this$getComponents6.DropdownIndicator;
      if (!DropdownIndicator3)
        return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      var innerProps = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return React47.createElement(DropdownIndicator3, _extends2({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderMenu",
    value: function renderMenu() {
      var _this4 = this;
      var _this$getComponents7 = this.getComponents(), Group3 = _this$getComponents7.Group, GroupHeading3 = _this$getComponents7.GroupHeading, Menu4 = _this$getComponents7.Menu, MenuList3 = _this$getComponents7.MenuList, MenuPortal3 = _this$getComponents7.MenuPortal, LoadingMessage3 = _this$getComponents7.LoadingMessage, NoOptionsMessage3 = _this$getComponents7.NoOptionsMessage, Option4 = _this$getComponents7.Option;
      var commonProps = this.commonProps;
      var focusedOption = this.state.focusedOption;
      var _this$props12 = this.props, captureMenuScroll = _this$props12.captureMenuScroll, inputValue = _this$props12.inputValue, isLoading = _this$props12.isLoading, loadingMessage2 = _this$props12.loadingMessage, minMenuHeight = _this$props12.minMenuHeight, maxMenuHeight = _this$props12.maxMenuHeight, menuIsOpen = _this$props12.menuIsOpen, menuPlacement = _this$props12.menuPlacement, menuPosition = _this$props12.menuPosition, menuPortalTarget = _this$props12.menuPortalTarget, menuShouldBlockScroll = _this$props12.menuShouldBlockScroll, menuShouldScrollIntoView = _this$props12.menuShouldScrollIntoView, noOptionsMessage2 = _this$props12.noOptionsMessage, onMenuScrollToTop = _this$props12.onMenuScrollToTop, onMenuScrollToBottom = _this$props12.onMenuScrollToBottom;
      if (!menuIsOpen)
        return null;
      var render2 = function render3(props, id) {
        var type = props.type, data = props.data, isDisabled = props.isDisabled, isSelected = props.isSelected, label = props.label, value = props.value;
        var isFocused = focusedOption === data;
        var onHover = isDisabled ? void 0 : function() {
          return _this4.onOptionHover(data);
        };
        var onSelect = isDisabled ? void 0 : function() {
          return _this4.selectOption(data);
        };
        var optionId = "".concat(_this4.getElementId("option"), "-").concat(id);
        var innerProps = {
          id: optionId,
          onClick: onSelect,
          onMouseMove: onHover,
          onMouseOver: onHover,
          tabIndex: -1
        };
        return React47.createElement(Option4, _extends2({}, commonProps, {
          innerProps,
          data,
          isDisabled,
          isSelected,
          key: optionId,
          label,
          type,
          value,
          isFocused,
          innerRef: isFocused ? _this4.getFocusedOptionRef : void 0
        }), _this4.formatOptionLabel(props.data, "menu"));
      };
      var menuUI;
      if (this.hasOptions()) {
        menuUI = this.getCategorizedOptions().map(function(item) {
          if (item.type === "group") {
            var _data = item.data, options2 = item.options, groupIndex = item.index;
            var groupId = "".concat(_this4.getElementId("group"), "-").concat(groupIndex);
            var headingId = "".concat(groupId, "-heading");
            return React47.createElement(Group3, _extends2({}, commonProps, {
              key: groupId,
              data: _data,
              options: options2,
              Heading: GroupHeading3,
              headingProps: {
                id: headingId,
                data: item.data
              },
              label: _this4.formatGroupLabel(item.data)
            }), item.options.map(function(option) {
              return render2(option, "".concat(groupIndex, "-").concat(option.index));
            }));
          } else if (item.type === "option") {
            return render2(item, "".concat(item.index));
          }
        });
      } else if (isLoading) {
        var message = loadingMessage2({
          inputValue
        });
        if (message === null)
          return null;
        menuUI = React47.createElement(LoadingMessage3, commonProps, message);
      } else {
        var _message = noOptionsMessage2({
          inputValue
        });
        if (_message === null)
          return null;
        menuUI = React47.createElement(NoOptionsMessage3, commonProps, _message);
      }
      var menuPlacementProps = {
        minMenuHeight,
        maxMenuHeight,
        menuPlacement,
        menuPosition,
        menuShouldScrollIntoView
      };
      var menuElement = React47.createElement(MenuPlacer, _extends2({}, commonProps, menuPlacementProps), function(_ref4) {
        var ref = _ref4.ref, _ref4$placerProps = _ref4.placerProps, placement = _ref4$placerProps.placement, maxHeight = _ref4$placerProps.maxHeight;
        return React47.createElement(Menu4, _extends2({}, commonProps, menuPlacementProps, {
          innerRef: ref,
          innerProps: {
            onMouseDown: _this4.onMenuMouseDown,
            onMouseMove: _this4.onMenuMouseMove,
            id: _this4.getElementId("listbox")
          },
          isLoading,
          placement
        }), React47.createElement(ScrollManager, {
          captureEnabled: captureMenuScroll,
          onTopArrive: onMenuScrollToTop,
          onBottomArrive: onMenuScrollToBottom,
          lockEnabled: menuShouldBlockScroll
        }, function(scrollTargetRef) {
          return React47.createElement(MenuList3, _extends2({}, commonProps, {
            innerRef: function innerRef(instance) {
              _this4.getMenuListRef(instance);
              scrollTargetRef(instance);
            },
            isLoading,
            maxHeight,
            focusedOption
          }), menuUI);
        }));
      });
      return menuPortalTarget || menuPosition === "fixed" ? React47.createElement(MenuPortal3, _extends2({}, commonProps, {
        appendTo: menuPortalTarget,
        controlElement: this.controlRef,
        menuPlacement,
        menuPosition
      }), menuElement) : menuElement;
    }
  }, {
    key: "renderFormField",
    value: function renderFormField() {
      var _this5 = this;
      var _this$props13 = this.props, delimiter2 = _this$props13.delimiter, isDisabled = _this$props13.isDisabled, isMulti = _this$props13.isMulti, name2 = _this$props13.name, required = _this$props13.required;
      var selectValue = this.state.selectValue;
      if (!name2 || isDisabled)
        return;
      if (required && !this.hasValue()) {
        return React47.createElement(RequiredInput, {
          name: name2,
          onFocus: this.onValueInputFocus
        });
      }
      if (isMulti) {
        if (delimiter2) {
          var value = selectValue.map(function(opt) {
            return _this5.getOptionValue(opt);
          }).join(delimiter2);
          return React47.createElement("input", {
            name: name2,
            type: "hidden",
            value
          });
        } else {
          var input = selectValue.length > 0 ? selectValue.map(function(opt, i2) {
            return React47.createElement("input", {
              key: "i-".concat(i2),
              name: name2,
              type: "hidden",
              value: _this5.getOptionValue(opt)
            });
          }) : React47.createElement("input", {
            name: name2,
            type: "hidden",
            value: ""
          });
          return React47.createElement("div", null, input);
        }
      } else {
        var _value = selectValue[0] ? this.getOptionValue(selectValue[0]) : "";
        return React47.createElement("input", {
          name: name2,
          type: "hidden",
          value: _value
        });
      }
    }
  }, {
    key: "renderLiveRegion",
    value: function renderLiveRegion() {
      var commonProps = this.commonProps;
      var _this$state6 = this.state, ariaSelection = _this$state6.ariaSelection, focusedOption = _this$state6.focusedOption, focusedValue = _this$state6.focusedValue, isFocused = _this$state6.isFocused, selectValue = _this$state6.selectValue;
      var focusableOptions = this.getFocusableOptions();
      return React47.createElement(LiveRegion, _extends2({}, commonProps, {
        id: this.getElementId("live-region"),
        ariaSelection,
        focusedOption,
        focusedValue,
        isFocused,
        selectValue,
        focusableOptions
      }));
    }
  }, {
    key: "render",
    value: function render2() {
      var _this$getComponents8 = this.getComponents(), Control3 = _this$getComponents8.Control, IndicatorsContainer3 = _this$getComponents8.IndicatorsContainer, SelectContainer3 = _this$getComponents8.SelectContainer, ValueContainer3 = _this$getComponents8.ValueContainer;
      var _this$props14 = this.props, className = _this$props14.className, id = _this$props14.id, isDisabled = _this$props14.isDisabled, menuIsOpen = _this$props14.menuIsOpen;
      var isFocused = this.state.isFocused;
      var commonProps = this.commonProps = this.getCommonProps();
      return React47.createElement(SelectContainer3, _extends2({}, commonProps, {
        className,
        innerProps: {
          id,
          onKeyDown: this.onKeyDown
        },
        isDisabled,
        isFocused
      }), this.renderLiveRegion(), React47.createElement(Control3, _extends2({}, commonProps, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled,
        isFocused,
        menuIsOpen
      }), React47.createElement(ValueContainer3, _extends2({}, commonProps, {
        isDisabled
      }), this.renderPlaceholderOrValue(), this.renderInput()), React47.createElement(IndicatorsContainer3, _extends2({}, commonProps, {
        isDisabled
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      var prevProps = state.prevProps, clearFocusValueOnUpdate = state.clearFocusValueOnUpdate, inputIsHiddenAfterUpdate = state.inputIsHiddenAfterUpdate, ariaSelection = state.ariaSelection, isFocused = state.isFocused, prevWasFocused = state.prevWasFocused;
      var options2 = props.options, value = props.value, menuIsOpen = props.menuIsOpen, inputValue = props.inputValue, isMulti = props.isMulti;
      var selectValue = cleanValue(value);
      var newMenuOptionsState = {};
      if (prevProps && (value !== prevProps.value || options2 !== prevProps.options || menuIsOpen !== prevProps.menuIsOpen || inputValue !== prevProps.inputValue)) {
        var focusableOptions = menuIsOpen ? buildFocusableOptions(props, selectValue) : [];
        var focusedValue = clearFocusValueOnUpdate ? getNextFocusedValue(state, selectValue) : null;
        var focusedOption = getNextFocusedOption(state, focusableOptions);
        newMenuOptionsState = {
          selectValue,
          focusedOption,
          focusedValue,
          clearFocusValueOnUpdate: false
        };
      }
      var newInputIsHiddenState = inputIsHiddenAfterUpdate != null && props !== prevProps ? {
        inputIsHidden: inputIsHiddenAfterUpdate,
        inputIsHiddenAfterUpdate: void 0
      } : {};
      var newAriaSelection = ariaSelection;
      var hasKeptFocus = isFocused && prevWasFocused;
      if (isFocused && !hasKeptFocus) {
        newAriaSelection = {
          value: valueTernary(isMulti, selectValue, selectValue[0] || null),
          options: selectValue,
          action: "initial-input-focus"
        };
        hasKeptFocus = !prevWasFocused;
      }
      if ((ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus") {
        newAriaSelection = null;
      }
      return _objectSpread22(_objectSpread22(_objectSpread22({}, newMenuOptionsState), newInputIsHiddenState), {}, {
        prevProps: props,
        ariaSelection: newAriaSelection,
        prevWasFocused: hasKeptFocus
      });
    }
  }]);
  return Select2;
}(import_react154.Component);
Select.defaultProps = defaultProps2;

// node_modules/react-select/dist/useStateManager-7e1e8489.esm.js
var import_react156 = __toESM(require_react());
var _excluded7 = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function useStateManager(_ref4) {
  var _ref$defaultInputValu = _ref4.defaultInputValue, defaultInputValue = _ref$defaultInputValu === void 0 ? "" : _ref$defaultInputValu, _ref$defaultMenuIsOpe = _ref4.defaultMenuIsOpen, defaultMenuIsOpen = _ref$defaultMenuIsOpe === void 0 ? false : _ref$defaultMenuIsOpe, _ref$defaultValue = _ref4.defaultValue, defaultValue = _ref$defaultValue === void 0 ? null : _ref$defaultValue, propsInputValue = _ref4.inputValue, propsMenuIsOpen = _ref4.menuIsOpen, propsOnChange = _ref4.onChange, propsOnInputChange = _ref4.onInputChange, propsOnMenuClose = _ref4.onMenuClose, propsOnMenuOpen = _ref4.onMenuOpen, propsValue = _ref4.value, restSelectProps = _objectWithoutProperties2(_ref4, _excluded7);
  var _useState = (0, import_react156.useState)(propsInputValue !== void 0 ? propsInputValue : defaultInputValue), _useState2 = _slicedToArray3(_useState, 2), stateInputValue = _useState2[0], setStateInputValue = _useState2[1];
  var _useState3 = (0, import_react156.useState)(propsMenuIsOpen !== void 0 ? propsMenuIsOpen : defaultMenuIsOpen), _useState4 = _slicedToArray3(_useState3, 2), stateMenuIsOpen = _useState4[0], setStateMenuIsOpen = _useState4[1];
  var _useState5 = (0, import_react156.useState)(propsValue !== void 0 ? propsValue : defaultValue), _useState6 = _slicedToArray3(_useState5, 2), stateValue = _useState6[0], setStateValue = _useState6[1];
  var onChange2 = (0, import_react156.useCallback)(function(value2, actionMeta) {
    if (typeof propsOnChange === "function") {
      propsOnChange(value2, actionMeta);
    }
    setStateValue(value2);
  }, [propsOnChange]);
  var onInputChange = (0, import_react156.useCallback)(function(value2, actionMeta) {
    var newValue;
    if (typeof propsOnInputChange === "function") {
      newValue = propsOnInputChange(value2, actionMeta);
    }
    setStateInputValue(newValue !== void 0 ? newValue : value2);
  }, [propsOnInputChange]);
  var onMenuOpen = (0, import_react156.useCallback)(function() {
    if (typeof propsOnMenuOpen === "function") {
      propsOnMenuOpen();
    }
    setStateMenuIsOpen(true);
  }, [propsOnMenuOpen]);
  var onMenuClose = (0, import_react156.useCallback)(function() {
    if (typeof propsOnMenuClose === "function") {
      propsOnMenuClose();
    }
    setStateMenuIsOpen(false);
  }, [propsOnMenuClose]);
  var inputValue = propsInputValue !== void 0 ? propsInputValue : stateInputValue;
  var menuIsOpen = propsMenuIsOpen !== void 0 ? propsMenuIsOpen : stateMenuIsOpen;
  var value = propsValue !== void 0 ? propsValue : stateValue;
  return _objectSpread22(_objectSpread22({}, restSelectProps), {}, {
    inputValue,
    menuIsOpen,
    onChange: onChange2,
    onInputChange,
    onMenuClose,
    onMenuOpen,
    value
  });
}

// node_modules/react-select/dist/useCreatable-36230047.esm.js
var import_react157 = __toESM(require_react());
var _excluded8 = ["allowCreateWhileLoading", "createOptionPosition", "formatCreateLabel", "isValidNewOption", "getNewOptionData", "onCreateOption", "options", "onChange"];
var compareOption = function compareOption2() {
  var inputValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  var option = arguments.length > 1 ? arguments[1] : void 0;
  var accessors = arguments.length > 2 ? arguments[2] : void 0;
  var candidate = String(inputValue).toLowerCase();
  var optionValue = String(accessors.getOptionValue(option)).toLowerCase();
  var optionLabel = String(accessors.getOptionLabel(option)).toLowerCase();
  return optionValue === candidate || optionLabel === candidate;
};
var builtins = {
  formatCreateLabel: function formatCreateLabel(inputValue) {
    return 'Create "'.concat(inputValue, '"');
  },
  isValidNewOption: function isValidNewOption(inputValue, selectValue, selectOptions, accessors) {
    return !(!inputValue || selectValue.some(function(option) {
      return compareOption(inputValue, option, accessors);
    }) || selectOptions.some(function(option) {
      return compareOption(inputValue, option, accessors);
    }));
  },
  getNewOptionData: function getNewOptionData(inputValue, optionLabel) {
    return {
      label: optionLabel,
      value: inputValue,
      __isNew__: true
    };
  }
};
function useCreatable(_ref4) {
  var _ref$allowCreateWhile = _ref4.allowCreateWhileLoading, allowCreateWhileLoading = _ref$allowCreateWhile === void 0 ? false : _ref$allowCreateWhile, _ref$createOptionPosi = _ref4.createOptionPosition, createOptionPosition = _ref$createOptionPosi === void 0 ? "last" : _ref$createOptionPosi, _ref$formatCreateLabe = _ref4.formatCreateLabel, formatCreateLabel2 = _ref$formatCreateLabe === void 0 ? builtins.formatCreateLabel : _ref$formatCreateLabe, _ref$isValidNewOption = _ref4.isValidNewOption, isValidNewOption2 = _ref$isValidNewOption === void 0 ? builtins.isValidNewOption : _ref$isValidNewOption, _ref$getNewOptionData = _ref4.getNewOptionData, getNewOptionData2 = _ref$getNewOptionData === void 0 ? builtins.getNewOptionData : _ref$getNewOptionData, onCreateOption = _ref4.onCreateOption, _ref$options = _ref4.options, propsOptions = _ref$options === void 0 ? [] : _ref$options, propsOnChange = _ref4.onChange, restSelectProps = _objectWithoutProperties2(_ref4, _excluded8);
  var _restSelectProps$getO = restSelectProps.getOptionValue, getOptionValue$12 = _restSelectProps$getO === void 0 ? getOptionValue$1 : _restSelectProps$getO, _restSelectProps$getO2 = restSelectProps.getOptionLabel, getOptionLabel$12 = _restSelectProps$getO2 === void 0 ? getOptionLabel$1 : _restSelectProps$getO2, inputValue = restSelectProps.inputValue, isLoading = restSelectProps.isLoading, isMulti = restSelectProps.isMulti, value = restSelectProps.value, name2 = restSelectProps.name;
  var newOption = (0, import_react157.useMemo)(function() {
    return isValidNewOption2(inputValue, cleanValue(value), propsOptions, {
      getOptionValue: getOptionValue$12,
      getOptionLabel: getOptionLabel$12
    }) ? getNewOptionData2(inputValue, formatCreateLabel2(inputValue)) : void 0;
  }, [formatCreateLabel2, getNewOptionData2, getOptionLabel$12, getOptionValue$12, inputValue, isValidNewOption2, propsOptions, value]);
  var options2 = (0, import_react157.useMemo)(function() {
    return (allowCreateWhileLoading || !isLoading) && newOption ? createOptionPosition === "first" ? [newOption].concat(_toConsumableArray3(propsOptions)) : [].concat(_toConsumableArray3(propsOptions), [newOption]) : propsOptions;
  }, [allowCreateWhileLoading, createOptionPosition, isLoading, newOption, propsOptions]);
  var onChange2 = (0, import_react157.useCallback)(function(newValue, actionMeta) {
    if (actionMeta.action !== "select-option") {
      return propsOnChange(newValue, actionMeta);
    }
    var valueArray = Array.isArray(newValue) ? newValue : [newValue];
    if (valueArray[valueArray.length - 1] === newOption) {
      if (onCreateOption)
        onCreateOption(inputValue);
      else {
        var newOptionData = getNewOptionData2(inputValue, inputValue);
        var newActionMeta = {
          action: "create-option",
          name: name2,
          option: newOptionData
        };
        propsOnChange(valueTernary(isMulti, [].concat(_toConsumableArray3(cleanValue(value)), [newOptionData]), newOptionData), newActionMeta);
      }
      return;
    }
    propsOnChange(newValue, actionMeta);
  }, [getNewOptionData2, inputValue, isMulti, name2, newOption, onCreateOption, propsOnChange, value]);
  return _objectSpread22(_objectSpread22({}, restSelectProps), {}, {
    options: options2,
    onChange: onChange2
  });
}

// node_modules/react-select/creatable/dist/react-select-creatable.esm.js
var import_react_dom8 = __toESM(require_react_dom());
var CreatableSelect = (0, import_react158.forwardRef)(function(props, ref) {
  var creatableProps = useStateManager(props);
  var selectProps = useCreatable(creatableProps);
  return React48.createElement(Select, _extends2({
    ref
  }, selectProps));
});
var react_select_creatable_esm_default = CreatableSelect;

// node_modules/react-select/async/dist/react-select-async.esm.js
var React49 = __toESM(require_react());
var import_react161 = __toESM(require_react());

// node_modules/react-select/dist/useAsync-fd9b28d9.esm.js
var import_react160 = __toESM(require_react());
var _excluded9 = ["defaultOptions", "cacheOptions", "loadOptions", "options", "isLoading", "onInputChange", "filterOption"];
function useAsync2(_ref4) {
  var _ref$defaultOptions = _ref4.defaultOptions, propsDefaultOptions = _ref$defaultOptions === void 0 ? false : _ref$defaultOptions, _ref$cacheOptions = _ref4.cacheOptions, cacheOptions = _ref$cacheOptions === void 0 ? false : _ref$cacheOptions, propsLoadOptions = _ref4.loadOptions;
  _ref4.options;
  var _ref$isLoading = _ref4.isLoading, propsIsLoading = _ref$isLoading === void 0 ? false : _ref$isLoading, propsOnInputChange = _ref4.onInputChange, _ref$filterOption = _ref4.filterOption, filterOption = _ref$filterOption === void 0 ? null : _ref$filterOption, restSelectProps = _objectWithoutProperties2(_ref4, _excluded9);
  var propsInputValue = restSelectProps.inputValue;
  var lastRequest = (0, import_react160.useRef)(void 0);
  var mounted = (0, import_react160.useRef)(false);
  var _useState = (0, import_react160.useState)(Array.isArray(propsDefaultOptions) ? propsDefaultOptions : void 0), _useState2 = _slicedToArray3(_useState, 2), defaultOptions3 = _useState2[0], setDefaultOptions3 = _useState2[1];
  var _useState3 = (0, import_react160.useState)(typeof propsInputValue !== "undefined" ? propsInputValue : ""), _useState4 = _slicedToArray3(_useState3, 2), stateInputValue = _useState4[0], setStateInputValue = _useState4[1];
  var _useState5 = (0, import_react160.useState)(propsDefaultOptions === true), _useState6 = _slicedToArray3(_useState5, 2), isLoading = _useState6[0], setIsLoading = _useState6[1];
  var _useState7 = (0, import_react160.useState)(void 0), _useState8 = _slicedToArray3(_useState7, 2), loadedInputValue = _useState8[0], setLoadedInputValue = _useState8[1];
  var _useState9 = (0, import_react160.useState)([]), _useState10 = _slicedToArray3(_useState9, 2), loadedOptions = _useState10[0], setLoadedOptions = _useState10[1];
  var _useState11 = (0, import_react160.useState)(false), _useState12 = _slicedToArray3(_useState11, 2), passEmptyOptions = _useState12[0], setPassEmptyOptions = _useState12[1];
  var _useState13 = (0, import_react160.useState)({}), _useState14 = _slicedToArray3(_useState13, 2), optionsCache = _useState14[0], setOptionsCache = _useState14[1];
  var _useState15 = (0, import_react160.useState)(void 0), _useState16 = _slicedToArray3(_useState15, 2), prevDefaultOptions = _useState16[0], setPrevDefaultOptions = _useState16[1];
  var _useState17 = (0, import_react160.useState)(void 0), _useState18 = _slicedToArray3(_useState17, 2), prevCacheOptions = _useState18[0], setPrevCacheOptions = _useState18[1];
  if (cacheOptions !== prevCacheOptions) {
    setOptionsCache({});
    setPrevCacheOptions(cacheOptions);
  }
  if (propsDefaultOptions !== prevDefaultOptions) {
    setDefaultOptions3(Array.isArray(propsDefaultOptions) ? propsDefaultOptions : void 0);
    setPrevDefaultOptions(propsDefaultOptions);
  }
  (0, import_react160.useEffect)(function() {
    mounted.current = true;
    return function() {
      mounted.current = false;
    };
  }, []);
  var loadOptions = (0, import_react160.useCallback)(function(inputValue, callback) {
    if (!propsLoadOptions)
      return callback();
    var loader4 = propsLoadOptions(inputValue, callback);
    if (loader4 && typeof loader4.then === "function") {
      loader4.then(callback, function() {
        return callback();
      });
    }
  }, [propsLoadOptions]);
  (0, import_react160.useEffect)(function() {
    if (propsDefaultOptions === true) {
      loadOptions(stateInputValue, function(options3) {
        if (!mounted.current)
          return;
        setDefaultOptions3(options3 || []);
        setIsLoading(!!lastRequest.current);
      });
    }
  }, []);
  var onInputChange = (0, import_react160.useCallback)(function(newValue, actionMeta) {
    var inputValue = handleInputChange(newValue, actionMeta, propsOnInputChange);
    if (!inputValue) {
      lastRequest.current = void 0;
      setStateInputValue("");
      setLoadedInputValue("");
      setLoadedOptions([]);
      setIsLoading(false);
      setPassEmptyOptions(false);
      return;
    }
    if (cacheOptions && optionsCache[inputValue]) {
      setStateInputValue(inputValue);
      setLoadedInputValue(inputValue);
      setLoadedOptions(optionsCache[inputValue]);
      setIsLoading(false);
      setPassEmptyOptions(false);
    } else {
      var request = lastRequest.current = {};
      setStateInputValue(inputValue);
      setIsLoading(true);
      setPassEmptyOptions(!loadedInputValue);
      loadOptions(inputValue, function(options3) {
        if (!mounted)
          return;
        if (request !== lastRequest.current)
          return;
        lastRequest.current = void 0;
        setIsLoading(false);
        setLoadedInputValue(inputValue);
        setLoadedOptions(options3 || []);
        setPassEmptyOptions(false);
        setOptionsCache(options3 ? _objectSpread22(_objectSpread22({}, optionsCache), {}, _defineProperty({}, inputValue, options3)) : optionsCache);
      });
    }
  }, [cacheOptions, loadOptions, loadedInputValue, optionsCache, propsOnInputChange]);
  var options2 = passEmptyOptions ? [] : stateInputValue && loadedInputValue ? loadedOptions : defaultOptions3 || [];
  return _objectSpread22(_objectSpread22({}, restSelectProps), {}, {
    options: options2,
    isLoading: isLoading || propsIsLoading,
    onInputChange,
    filterOption
  });
}

// node_modules/react-select/async/dist/react-select-async.esm.js
var import_react_dom9 = __toESM(require_react_dom());
var AsyncSelect = (0, import_react161.forwardRef)(function(props, ref) {
  var stateManagedProps = useAsync2(props);
  var selectProps = useStateManager(stateManagedProps);
  return React49.createElement(Select, _extends2({
    ref
  }, selectProps));
});
var react_select_async_esm_default = AsyncSelect;

// node_modules/@neo4j-ndl/react/lib/esm/dropdown/Overrides.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime());

// node_modules/react-select/dist/react-select.esm.js
var React50 = __toESM(require_react());
var import_react163 = __toESM(require_react());
var import_react_dom10 = __toESM(require_react_dom());
var StateManagedSelect = (0, import_react163.forwardRef)(function(props, ref) {
  var baseSelectProps = useStateManager(props);
  return React50.createElement(Select, _extends2({
    ref
  }, baseSelectProps));
});
var react_select_esm_default = StateManagedSelect;

// node_modules/@neo4j-ndl/react/lib/esm/dropdown/Overrides.js
var __rest26 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var DropdownIndicatorCurrying = ({ errorText, size: size3 }) => function Component4(props) {
  const { isDisabled, selectProps } = props;
  const classes = classNames("ndl-dropdown-icon", {
    "ndl-small": size3 === "small",
    "ndl-medium": size3 === "medium",
    "ndl-large": size3 === "large",
    "ndl-disabled": isDisabled
  });
  return (0, import_jsx_runtime37.jsx)(components.DropdownIndicator, Object.assign({}, props, { children: (0, import_jsx_runtime37.jsxs)("div", { className: "n-flex n-flex-row n-gap-3", children: [(0, import_jsx_runtime37.jsx)(import_ChevronDownIcon.default, { className: classes, style: {
    transform: selectProps.menuIsOpen ? "rotate(180deg)" : "rotate(0deg)",
    transitionDuration: tokens.transitions.values.duration.quick
  } }), errorText && (0, import_jsx_runtime37.jsxs)(import_jsx_runtime37.Fragment, { children: [(0, import_jsx_runtime37.jsx)("div", { className: "ndl-indicator" }), (0, import_jsx_runtime37.jsx)(import_ExclamationCircleIcon2.default, { className: `ndl-error-icon ${classes}`, role: "img", type: "solid" })] })] }) }));
};
var CustomClearIndication = ({ errorText, size: size3 }) => function Component4(props) {
  return (0, import_jsx_runtime37.jsx)(components.ClearIndicator, Object.assign({}, props, { children: (0, import_jsx_runtime37.jsxs)("div", { className: "n-flex n-flex-row n-gap-3", children: [(0, import_jsx_runtime37.jsx)(import_XMarkIcon.default, { className: "n-w-5 n-h-5 n-text-palette-neutral-text-weak n-cursor-pointer" }), (0, import_jsx_runtime37.jsx)("div", { className: "ndl-indicator" })] }) }));
};
var CustomMultiValueRemove = ({ errorText, size: size3 }) => function Component4(props) {
  return (0, import_jsx_runtime37.jsx)(components.MultiValueRemove, Object.assign({}, props, { children: (0, import_jsx_runtime37.jsx)(import_XMarkIcon.default, { className: "n-text-palette-neutral-text-weak", style: {
    height: size3 === "small" ? "16px" : "20px"
  } }) }));
};
var CustomPlaceholder = ({ errorText, size: size3 }) => function Component4(_a2) {
  var { children } = _a2, restProps = __rest26(_a2, ["children"]);
  return (0, import_jsx_runtime37.jsx)(components.Placeholder, Object.assign({}, restProps, { children: (0, import_jsx_runtime37.jsx)("div", { className: "ndl-placeholder", children }) }));
};
var CustomOption = ({ errorText, size: size3 }) => function Component4(_a2) {
  var { children } = _a2, restProps = __rest26(_a2, ["children"]);
  const classes = classNames("ndl-dropdown-option", restProps.className, {
    "n-body-medium": size3 === "small" || size3 === "medium",
    "n-body-large": size3 === "large"
  });
  return (0, import_jsx_runtime37.jsx)(components.Option, Object.assign({}, restProps, { className: classes, children }));
};

// node_modules/@neo4j-ndl/react/lib/esm/dropdown/Dropdown.js
var __rest27 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var overrideComponents = (props) => ({
  DropdownIndicator: DropdownIndicatorCurrying(props),
  IndicatorSeparator: null,
  ClearIndicator: CustomClearIndication(props),
  MultiValueRemove: CustomMultiValueRemove(props),
  Placeholder: CustomPlaceholder(props),
  Option: CustomOption(props)
});
var customStyles = ({ errorText, size: size3 }) => {
  const focusedBorderColor = errorText ? "rgb(var(--theme-palette-danger-border-strong))" : "rgb(var(--theme-palette-primary-focus))";
  const defaultBorder = errorText ? "rgb(var(--theme-palette-danger-border-strong))" : "rgb(var(--theme-palette-neutral-border-strong))";
  const OUTER_BORDER_WIDTH = (state) => state.isFocused || errorText ? 2 : 1;
  const BORDER_WIDTH = 1;
  const SMALL_TARGET_HEIGHT = 24;
  const MEDIUM_TARGET_HEIGHT = 36;
  const LARGE_TARGET_HEIGHT = 48;
  const getTargetHeight = (size4) => {
    let targetHeight = SMALL_TARGET_HEIGHT;
    if (size4 === "small") {
      targetHeight = SMALL_TARGET_HEIGHT;
    } else if (size4 === "medium") {
      targetHeight = MEDIUM_TARGET_HEIGHT;
    } else if (size4 === "large") {
      targetHeight = LARGE_TARGET_HEIGHT;
    }
    return targetHeight;
  };
  const getFontSize = (size4) => {
    if (size4 === "small" || size4 === "medium")
      return "14px";
    if (size4 === "large")
      return "16px";
    return "16px";
  };
  const getLineHeight = (size4) => {
    if (size4 === "small" || size4 === "medium")
      return "20px";
    if (size4 === "large")
      return "24px";
    return "24px";
  };
  return {
    control: (provided, state) => Object.assign(Object.assign({}, provided), {
      minHeight: getTargetHeight(size3),
      // Avoid shifting with border of 2px
      // Source: https://stackoverflow.com/a/9612782/3247715
      boxShadow: state.isFocused ? `0 0 0 ${OUTER_BORDER_WIDTH(state)}px ${focusedBorderColor}` : "none",
      fontSize: getFontSize(size3),
      lineHeight: getLineHeight(size3),
      backgroundColor: "rgb(var(--theme-palette-neutral-bg-weak))",
      outline: "none",
      borderWidth: BORDER_WIDTH,
      borderStyle: "solid",
      borderColor: state.isFocused ? focusedBorderColor : defaultBorder,
      "&:hover": {
        borderColor: state.isFocused ? focusedBorderColor : defaultBorder
      }
    }),
    singleValue: (provided, state) => Object.assign(Object.assign({}, provided), { color: state.isDisabled ? "rgb(var(--theme-palette-neutral-text-weakest))" : "rgb(var(--theme-palette-neutral-text-default))" }),
    multiValue: (provided) => Object.assign(Object.assign({}, provided), { borderRadius: "4px", maxWidth: "95%", backgroundColor: "rgb(var(--theme-palette-neutral-bg-strong))", color: "rgb(var(--theme-palette-neutral-text-default))" }),
    multiValueLabel: (provided) => Object.assign(Object.assign({}, provided), { color: "rgb(var(--theme-palette-neutral-text-default))" }),
    multiValueRemove: (provided) => Object.assign(Object.assign({}, provided), { "&:hover": {
      cursor: "pointer !important",
      backgroundColor: "rgb(var(--theme-palette-danger-hover-weak))"
    } }),
    dropdownIndicator: (provided) => Object.assign(Object.assign({}, provided), {
      cursor: "pointer",
      // 16 is icon size
      padding: size3 === "small" ? `${(getTargetHeight(size3) - 16 - 2 * BORDER_WIDTH) / 2}px` : "7px"
    }),
    indicatorsContainer: (provided) => Object.assign(Object.assign({}, provided), {
      /**
       * The right icon has padding of 8px so:
       * padding-right: 8px+desired
       */
      paddingRight: size3 === "small" || size3 === "medium" ? "4px" : "8px"
    }),
    clearIndicator: (provided) => Object.assign(Object.assign({}, provided), {
      // 16 is icon size
      padding: size3 === "small" ? `${(getTargetHeight(size3) - 16 - 2 * BORDER_WIDTH) / 2}px` : "0px"
    }),
    /**
     * Only for multi-select, make the padding
     * 2px everywhere when we have at least one
     * value selected
     */
    valueContainer: (provided, state) => Object.assign(Object.assign({}, provided), { padding: size3 === "small" ? "0 8px" : state.isMulti && state.hasValue ? "2px" : "2px 8px" }),
    menu: (provided) => Object.assign(Object.assign({}, provided), { backgroundColor: "rgb(var(--theme-palette-neutral-bg-weak))", zIndex: "var(--z-index-30)" }),
    menuPortal: (provided) => Object.assign(Object.assign({}, provided), { zIndex: "var(--z-index-30)" }),
    menuList: (provided) => Object.assign(Object.assign({}, provided), { cursor: "auto !important", padding: "8px" }),
    option: (provided, state) => {
      let backgroundColor;
      let color;
      switch (true) {
        case state.isSelected:
          backgroundColor = "rgb(var(--theme-palette-primary-bg-selected))";
          break;
        case (state.isFocused && !state.isSelected && !state.isDisabled):
          backgroundColor = "rgb(var(--theme-palette-neutral-hover))";
          break;
        default:
          backgroundColor = "transparent";
      }
      switch (true) {
        case state.isDisabled:
          color = "rgb(var(--theme-palette-neutral-text-weakest))";
          break;
        case state.isSelected:
          color = "rgb(var(--theme-palette-primary-text))";
          break;
        default:
          color = "rgb(var(--theme-palette-neutral-text-default))";
      }
      return Object.assign(Object.assign(Object.assign(Object.assign({}, provided), {
        position: "relative",
        borderRadius: "8px",
        marginBottom: "2px",
        cursor: state.isDisabled ? "not-allowed !important" : "pointer !important",
        /** Pass undefined to allow CSS rules to apply */
        fontSize: void 0,
        lineHeight: void 0,
        backgroundColor,
        color,
        "&:hover": {
          backgroundColor
        }
      }), state.isSelected && {
        "&::before": {
          content: '""',
          position: "absolute",
          width: "4px",
          height: "100%",
          backgroundColor: "rgb(var(--theme-palette-primary-bg-strong))",
          borderRadius: "0 100px 100px 0",
          left: "-8px",
          top: "0px"
        }
      }), { overflowWrap: "break-word" });
    },
    input: (provided) => Object.assign(Object.assign({}, provided), { padding: size3 === "small" ? "0px" : void 0, margin: size3 === "small" ? "0px" : void 0, lineHeight: getLineHeight(size3), height: size3 === "small" ? `${getTargetHeight(size3) - 2 * BORDER_WIDTH}px` : void 0, color: "rgb(var(--theme-palette-neutral-text-default))" }),
    placeholder: (provided) => Object.assign(Object.assign({}, provided), { height: size3 === "small" ? `${getTargetHeight(size3) - 2 * BORDER_WIDTH}px` : void 0, color: "rgb(var(--theme-palette-neutral-text-weaker))" })
  };
};
var Dropdown = forwardRef(function Dropdown2(props, ref) {
  const { as, label, helpText, errorText, fluid = true, size: size3 = "small", type = "select", "aria-label": ariaLabel, selectProps = {} } = props, rest = __rest27(props, ["as", "label", "helpText", "errorText", "fluid", "size", "type", "aria-label", "selectProps"]);
  const Component4 = as || "div";
  const ComponentOverrides = (0, import_react165.useMemo)(() => overrideComponents({ errorText, size: size3 }), [errorText, size3]);
  const StyleOverrides = (0, import_react165.useMemo)(() => customStyles({ errorText, size: size3 }), [errorText, size3]);
  const identifier3 = (0, import_react165.useMemo)(() => {
    if (typeof label === "string")
      return label;
    if (ariaLabel)
      return ariaLabel;
    needleWarningMessage("Consider adding an aria-label to make the select more accessible");
    return Math.random().toString(36).slice(2, 9);
  }, [label, ariaLabel]);
  let SelectElement;
  switch (type) {
    case "async": {
      SelectElement = (0, import_jsx_runtime38.jsx)(react_select_async_esm_default, Object.assign({ name: identifier3, inputId: identifier3 }, selectProps, { styles: Object.assign(Object.assign({}, StyleOverrides), selectProps.styles), components: Object.assign(Object.assign({}, ComponentOverrides), selectProps.components) }));
      break;
    }
    case "creatable":
      SelectElement = (0, import_jsx_runtime38.jsx)(react_select_creatable_esm_default, Object.assign({ name: identifier3, inputId: identifier3 }, selectProps, { styles: Object.assign(Object.assign({}, StyleOverrides), selectProps.styles), components: Object.assign(Object.assign({}, ComponentOverrides), selectProps.components) }));
      break;
    default:
      SelectElement = (0, import_jsx_runtime38.jsx)(react_select_esm_default, Object.assign({ name: identifier3, inputId: identifier3 }, selectProps, { styles: Object.assign(Object.assign({}, StyleOverrides), selectProps.styles), components: Object.assign(Object.assign({}, ComponentOverrides), selectProps.components) }));
  }
  const classes = classNames("ndl-dropdown", props.className, {
    "ndl-small": size3 === "small",
    "ndl-large": size3 === "large",
    "ndl-fluid": fluid,
    "ndl-disabled": selectProps.isDisabled,
    "ndl-multi": selectProps.isMulti,
    "ndl-creatable": type === "creatable"
  });
  return (0, import_jsx_runtime38.jsxs)(Component4, Object.assign({}, rest, { "aria-label": ariaLabel, ref, className: classes, children: [label && (0, import_jsx_runtime38.jsx)("label", { htmlFor: identifier3, children: label }), SelectElement, helpText && !errorText && (0, import_jsx_runtime38.jsx)("span", { className: "ndl-sub-text", children: helpText }), errorText && (0, import_jsx_runtime38.jsx)("span", { className: "ndl-sub-text ndl-error-text", children: errorText })] }));
});

// node_modules/@neo4j-ndl/react/lib/esm/tag/Tag.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime());
var import_react166 = __toESM(require_react());
var __rest28 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var Tag = import_react166.default.forwardRef(function Tag2(props, ref) {
  const { children, type = "default", removeable, onRemove } = props, restProps = __rest28(props, ["children", "type", "removeable", "onRemove"]);
  if (removeable && typeof onRemove !== "function") {
    needleWarningMessage("Tag element is removable but onRemove prop is not a function or provided");
  }
  const classes = classNames(`ndl-tag`, props.className, {
    "ndl-default": type === "default",
    "ndl-destructive": type === "destructive",
    "ndl-removeable": removeable
  });
  const keyDownHandler = (0, import_react166.useCallback)((e4) => {
    if (e4.key === "Enter") {
      onRemove && onRemove(e4);
    }
  }, [onRemove]);
  return (0, import_jsx_runtime39.jsxs)("div", Object.assign({}, restProps, { className: classes, ref, children: [children, removeable && (0, import_jsx_runtime39.jsx)("button", { type: "button", className: "ndl-remove-icon", onKeyDown: keyDownHandler, onClick: onRemove, "aria-label": "Remove tag", children: (0, import_jsx_runtime39.jsx)(import_XMarkIcon.default, {}) })] }));
});

// node_modules/@neo4j-ndl/react/lib/esm/widget/Widget.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime());
var import_react167 = __toESM(require_react());
var __rest29 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var Widget = (0, import_react167.forwardRef)(function Widget2(_a2, ref) {
  var _b;
  var { header, subheader, leftMenu, rightMenu, isElevated = false, isResizeable = false, resizeableProps, children, className } = _a2, restProps = __rest29(_a2, ["header", "subheader", "leftMenu", "rightMenu", "isElevated", "isResizeable", "resizeableProps", "children", "className"]);
  const classes = classNames("ndl-widget", className, {
    "ndl-leftmenu": leftMenu,
    "ndl-elevated": isElevated
  });
  return (0, import_jsx_runtime40.jsxs)("div", Object.assign({ className: classes, ref }, restProps, { children: [(0, import_jsx_runtime40.jsxs)("header", { className: "ndl-header-wrapper", children: [(0, import_jsx_runtime40.jsxs)("div", { className: "ndl-header-left", children: [leftMenu, (0, import_jsx_runtime40.jsxs)("div", { className: "ndl-headers n-flex n-flex-col", children: [(0, import_jsx_runtime40.jsx)("div", { className: "ndl-header", children: header }), (0, import_jsx_runtime40.jsx)("div", { className: "ndl-subheader", children: subheader })] })] }), rightMenu] }), (0, import_jsx_runtime40.jsx)("div", { className: "ndl-widget-content n-flex-grow", children }), isResizeable && (0, import_jsx_runtime40.jsx)("button", Object.assign({ "aria-label": "Resizing handle" }, resizeableProps, { className: `ndl-resize-handle ${(_b = resizeableProps === null || resizeableProps === void 0 ? void 0 : resizeableProps.className) !== null && _b !== void 0 ? _b : ""}`, children: (0, import_jsx_runtime40.jsx)(ResizeCorner_default, {}) }))] }));
});
var Widget_default = Widget;

// node_modules/@neo4j-ndl/react/lib/esm/wizard/Wizard.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime());
var __rest30 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var getStatus = (activeStep, stepIndex) => stepIndex + 1 === activeStep ? "active" : activeStep < stepIndex + 1 ? "incomplete" : "complete";
var Circle = ({ status, number: number2, text, type }) => {
  const statusClasses = classNames({
    "ndl-active": status === "active",
    "ndl-complete": status === "complete",
    "ndl-incomplete": status === "incomplete"
  });
  const typeClasses = classNames({
    "ndl-horizontal": type === "horizontal",
    "ndl-vertical": type === "vertical"
  });
  return (0, import_jsx_runtime41.jsxs)("div", { className: "ndl-wizard-circle", children: [(0, import_jsx_runtime41.jsx)("div", { className: "n-relative", children: (0, import_jsx_runtime41.jsx)("div", { className: `ndl-text ${typeClasses}`, children: text }) }), (0, import_jsx_runtime41.jsxs)("svg", { className: `n-h-10 n-w-10 ${statusClasses}`, children: [status === "active" && (0, import_jsx_runtime41.jsxs)("g", { children: [(0, import_jsx_runtime41.jsx)("circle", { className: "n-fill-palette-primary-text", cx: "20", cy: "20", r: "20" }), (0, import_jsx_runtime41.jsx)("circle", { className: "n-fill-neutral-10", cx: "20", cy: "20", r: "18" })] }), (0, import_jsx_runtime41.jsx)("circle", { className: `${status === "complete" || status === "active" ? "n-fill-palette-primary-text" : "n-fill-palette-neutral-text-weakest"}`, cx: "20", cy: "20", r: "16" }), (0, import_jsx_runtime41.jsx)("text", { x: "50%", y: "50%", className: "n-fill-neutral-10", textAnchor: "middle", dy: "0.3em", children: number2 })] })] });
};
var Line = ({ status, type }) => {
  const classes = classNames("ndl-wizard-line", {
    "ndl-active": status === "active",
    "ndl-complete": status === "complete",
    "ndl-incomplete": status === "incomplete",
    "ndl-horizontal": type === "horizontal",
    "ndl-vertical": type === "vertical"
  });
  return (0, import_jsx_runtime41.jsx)("div", { "aria-hidden": true, className: classes });
};
var Horizontal = (_a2) => {
  var { activeStep, steps, className } = _a2, restProps = __rest30(_a2, ["activeStep", "steps", "className"]);
  const components2 = [];
  for (let i2 = 0; i2 < steps.length; i2++) {
    const text = steps[i2];
    components2.push((0, import_jsx_runtime41.jsx)(Circle, { type: "horizontal", number: i2 + 1, text, status: getStatus(activeStep, i2) }, `circle-${i2}-step-${randomId(4)}`));
    if (i2 < steps.length - 1) {
      components2.push((0, import_jsx_runtime41.jsx)(Line, { type: "horizontal", status: getStatus(activeStep, i2) }, `line-${i2}-step-${randomId(4)}`));
    }
  }
  return (0, import_jsx_runtime41.jsx)("div", Object.assign({}, restProps, { className: classNames("ndl-horizontal-wizard", className), role: "navigation", children: components2 }));
};
var Vertical = (_a2) => {
  var { activeStep, steps, className } = _a2, restProps = __rest30(_a2, ["activeStep", "steps", "className"]);
  const components2 = [];
  for (let i2 = 0; i2 < steps.length; i2++) {
    const text = steps[i2];
    components2.push((0, import_jsx_runtime41.jsx)(Circle, { type: "vertical", number: i2 + 1, text, status: getStatus(activeStep, i2) }, `circle-${i2}-step-${randomId(4)}`));
    i2 < steps.length - 1 && components2.push((0, import_jsx_runtime41.jsx)(Line, { type: "vertical", status: getStatus(activeStep, i2) }, `line-${i2}-step-${randomId(4)}`));
  }
  return (0, import_jsx_runtime41.jsx)("div", Object.assign({}, restProps, { className: classNames("ndl-vertical-wizard ", className), role: "navigation", children: components2 }));
};
var Footer = (_a2) => {
  var { activeStep, steps, className } = _a2, restProps = __rest30(_a2, ["activeStep", "steps", "className"]);
  return (0, import_jsx_runtime41.jsx)("div", Object.assign({}, restProps, { className: classNames("ndl-footer-wizard", className), role: "navigation", children: (0, import_jsx_runtime41.jsxs)("div", { className: "n-flex n-items-center", children: [(0, import_jsx_runtime41.jsx)("div", { className: "n-w-32 n-mr-6 n-h-[1px] n-bg-palette-neutral-border-strong" }), steps.map((v, i2) => (0, import_jsx_runtime41.jsx)("div", { className: "n-items-center n-justify-center n-flex n-px-[2px]", children: (0, import_jsx_runtime41.jsxs)("svg", { className: `n-h-2 n-w-2 footer-circle ${getStatus(activeStep, i2)}`, children: [getStatus(activeStep, i2) === "active" && (0, import_jsx_runtime41.jsx)("g", { children: (0, import_jsx_runtime41.jsx)("circle", { className: "n-fill-palette-primary-text", cx: "4", cy: "4", r: "4" }) }), (0, import_jsx_runtime41.jsx)("circle", { className: `${getStatus(activeStep, i2) === "active" ? "n-fill-palette-primary-text" : "n-fill-palette-neutral-border-strong"}`, cx: "4", cy: "4", r: "3" })] }) }, i2)), (0, import_jsx_runtime41.jsx)("div", { className: "n-w-32 n-ml-6 n-h-[1px] n-bg-palette-neutral-border-strong" })] }) }));
};
var Wizard = (_a2) => {
  var { type = "horizontal", activeStep = 0, steps = [] } = _a2, restProps = __rest30(_a2, ["type", "activeStep", "steps"]);
  const allProps = Object.assign({ activeStep, steps }, restProps);
  switch (type) {
    case "vertical":
      return (0, import_jsx_runtime41.jsx)(Vertical, Object.assign({}, allProps));
    case "footer":
      return (0, import_jsx_runtime41.jsx)(Footer, Object.assign({}, allProps));
    default:
      return (0, import_jsx_runtime41.jsx)(Horizontal, Object.assign({}, allProps));
  }
};

// node_modules/@neo4j-ndl/react/lib/esm/graph-label/GraphLabel.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime());
var import_react168 = __toESM(require_react());

// node_modules/tinycolor2/esm/tinycolor.js
function _typeof2(obj) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof2(obj);
}
var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color, opts) {
  color = color ? color : "";
  opts = opts || {};
  if (color instanceof tinycolor) {
    return color;
  }
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color, opts);
  }
  var rgb = inputToRGB(color);
  this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
  this._gradientType = opts.gradientType;
  if (this._r < 1)
    this._r = Math.round(this._r);
  if (this._g < 1)
    this._g = Math.round(this._g);
  if (this._b < 1)
    this._b = Math.round(this._b);
  this._ok = rgb.ok;
}
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid2() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
  },
  getLuminance: function getLuminance() {
    var rgb = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R2, G2, B2;
    RsRGB = rgb.r / 255;
    GsRGB = rgb.g / 255;
    BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928)
      R2 = RsRGB / 12.92;
    else
      R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928)
      G2 = GsRGB / 12.92;
    else
      G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928)
      B2 = BsRGB / 12.92;
    else
      B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
  },
  setAlpha: function setAlpha(value) {
    this._a = boundAlpha(value);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    var h3 = Math.round(hsv.h * 360), s3 = Math.round(hsv.s * 100), v = Math.round(hsv.v * 100);
    return this._a == 1 ? "hsv(" + h3 + ", " + s3 + "%, " + v + "%)" : "hsva(" + h3 + ", " + s3 + "%, " + v + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl.h * 360,
      s: hsl.s,
      l: hsl.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    var h3 = Math.round(hsl.h * 360), s3 = Math.round(hsl.s * 100), l = Math.round(hsl.l * 100);
    return this._a == 1 ? "hsl(" + h3 + ", " + s3 + "%, " + l + "%)" : "hsla(" + h3 + ", " + s3 + "%, " + l + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s3 = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s3._r, s3._g, s3._b, s3._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString(format3) {
    var formatSet = !!format3;
    format3 = format3 || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format3 === "hex" || format3 === "hex6" || format3 === "hex3" || format3 === "hex4" || format3 === "hex8" || format3 === "name");
    if (needsAlphaFormat) {
      if (format3 === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format3 === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format3 === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format3 === "hex" || format3 === "hex6") {
      formattedString = this.toHexString();
    }
    if (format3 === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format3 === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format3 === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format3 === "name") {
      formattedString = this.toName();
    }
    if (format3 === "hsl") {
      formattedString = this.toHslString();
    }
    if (format3 === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn2, args) {
    var color = fn2.apply(null, [this].concat([].slice.call(args)));
    this._r = color._r;
    this._g = color._g;
    this._b = color._b;
    this.setAlpha(color._a);
    return this;
  },
  lighten: function lighten() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn2, args) {
    return fn2.apply(null, [this].concat([].slice.call(args)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};
tinycolor.fromRatio = function(color, opts) {
  if (_typeof2(color) == "object") {
    var newColor = {};
    for (var i2 in color) {
      if (color.hasOwnProperty(i2)) {
        if (i2 === "a") {
          newColor[i2] = color[i2];
        } else {
          newColor[i2] = convertToPercentage(color[i2]);
        }
      }
    }
    color = newColor;
  }
  return tinycolor(color, opts);
};
function inputToRGB(color) {
  var rgb = {
    r: 0,
    g: 0,
    b: 0
  };
  var a3 = 1;
  var s3 = null;
  var v = null;
  var l = null;
  var ok = false;
  var format3 = false;
  if (typeof color == "string") {
    color = stringInputToObject(color);
  }
  if (_typeof2(color) == "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format3 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s3 = convertToPercentage(color.s);
      v = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s3, v);
      ok = true;
      format3 = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s3 = convertToPercentage(color.s);
      l = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s3, l);
      ok = true;
      format3 = "hsl";
    }
    if (color.hasOwnProperty("a")) {
      a3 = color.a;
    }
  }
  a3 = boundAlpha(a3);
  return {
    ok,
    format: color.format || format3,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a: a3
  };
}
function rgbToRgb(r2, g, b2) {
  return {
    r: bound01(r2, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b2, 255) * 255
  };
}
function rgbToHsl(r2, g, b2) {
  r2 = bound01(r2, 255);
  g = bound01(g, 255);
  b2 = bound01(b2, 255);
  var max4 = Math.max(r2, g, b2), min4 = Math.min(r2, g, b2);
  var h3, s3, l = (max4 + min4) / 2;
  if (max4 == min4) {
    h3 = s3 = 0;
  } else {
    var d3 = max4 - min4;
    s3 = l > 0.5 ? d3 / (2 - max4 - min4) : d3 / (max4 + min4);
    switch (max4) {
      case r2:
        h3 = (g - b2) / d3 + (g < b2 ? 6 : 0);
        break;
      case g:
        h3 = (b2 - r2) / d3 + 2;
        break;
      case b2:
        h3 = (r2 - g) / d3 + 4;
        break;
    }
    h3 /= 6;
  }
  return {
    h: h3,
    s: s3,
    l
  };
}
function hslToRgb(h3, s3, l) {
  var r2, g, b2;
  h3 = bound01(h3, 360);
  s3 = bound01(s3, 100);
  l = bound01(l, 100);
  function hue2rgb(p2, q3, t4) {
    if (t4 < 0)
      t4 += 1;
    if (t4 > 1)
      t4 -= 1;
    if (t4 < 1 / 6)
      return p2 + (q3 - p2) * 6 * t4;
    if (t4 < 1 / 2)
      return q3;
    if (t4 < 2 / 3)
      return p2 + (q3 - p2) * (2 / 3 - t4) * 6;
    return p2;
  }
  if (s3 === 0) {
    r2 = g = b2 = l;
  } else {
    var q2 = l < 0.5 ? l * (1 + s3) : l + s3 - l * s3;
    var p = 2 * l - q2;
    r2 = hue2rgb(p, q2, h3 + 1 / 3);
    g = hue2rgb(p, q2, h3);
    b2 = hue2rgb(p, q2, h3 - 1 / 3);
  }
  return {
    r: r2 * 255,
    g: g * 255,
    b: b2 * 255
  };
}
function rgbToHsv(r2, g, b2) {
  r2 = bound01(r2, 255);
  g = bound01(g, 255);
  b2 = bound01(b2, 255);
  var max4 = Math.max(r2, g, b2), min4 = Math.min(r2, g, b2);
  var h3, s3, v = max4;
  var d3 = max4 - min4;
  s3 = max4 === 0 ? 0 : d3 / max4;
  if (max4 == min4) {
    h3 = 0;
  } else {
    switch (max4) {
      case r2:
        h3 = (g - b2) / d3 + (g < b2 ? 6 : 0);
        break;
      case g:
        h3 = (b2 - r2) / d3 + 2;
        break;
      case b2:
        h3 = (r2 - g) / d3 + 4;
        break;
    }
    h3 /= 6;
  }
  return {
    h: h3,
    s: s3,
    v
  };
}
function hsvToRgb(h3, s3, v) {
  h3 = bound01(h3, 360) * 6;
  s3 = bound01(s3, 100);
  v = bound01(v, 100);
  var i2 = Math.floor(h3), f = h3 - i2, p = v * (1 - s3), q2 = v * (1 - f * s3), t4 = v * (1 - (1 - f) * s3), mod = i2 % 6, r2 = [v, q2, p, p, t4, v][mod], g = [t4, v, v, q2, p, p][mod], b2 = [p, p, t4, v, v, q2][mod];
  return {
    r: r2 * 255,
    g: g * 255,
    b: b2 * 255
  };
}
function rgbToHex(r2, g, b2, allow3Char) {
  var hex = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b2).toString(16))];
  if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function rgbaToHex(r2, g, b2, a3, allow4Char) {
  var hex = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b2).toString(16)), pad2(convertDecimalToHex(a3))];
  if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}
function rgbaToArgbHex(r2, g, b2, a3) {
  var hex = [pad2(convertDecimalToHex(a3)), pad2(Math.round(r2).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b2).toString(16))];
  return hex.join("");
}
tinycolor.equals = function(color1, color2) {
  if (!color1 || !color2)
    return false;
  return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};
tinycolor.random = function() {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function _desaturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s -= amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _saturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s += amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _greyscale(color) {
  return tinycolor(color).desaturate(100);
}
function _lighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l += amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _brighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb = tinycolor(color).toRgb();
  rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
  rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
  rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb);
}
function _darken(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l -= amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _spin(color, amount) {
  var hsl = tinycolor(color).toHsl();
  var hue = (hsl.h + amount) % 360;
  hsl.h = hue < 0 ? 360 + hue : hue;
  return tinycolor(hsl);
}
function _complement(color) {
  var hsl = tinycolor(color).toHsl();
  hsl.h = (hsl.h + 180) % 360;
  return tinycolor(hsl);
}
function polyad(color, number2) {
  if (isNaN(number2) || number2 <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl = tinycolor(color).toHsl();
  var result = [tinycolor(color)];
  var step = 360 / number2;
  for (var i2 = 1; i2 < number2; i2++) {
    result.push(tinycolor({
      h: (hsl.h + i2 * step) % 360,
      s: hsl.s,
      l: hsl.l
    }));
  }
  return result;
}
function _splitcomplement(color) {
  var hsl = tinycolor(color).toHsl();
  var h3 = hsl.h;
  return [tinycolor(color), tinycolor({
    h: (h3 + 72) % 360,
    s: hsl.s,
    l: hsl.l
  }), tinycolor({
    h: (h3 + 216) % 360,
    s: hsl.s,
    l: hsl.l
  })];
}
function _analogous(color, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl = tinycolor(color).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color)];
  for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
    hsl.h = (hsl.h + part) % 360;
    ret.push(tinycolor(hsl));
  }
  return ret;
}
function _monochromatic(color, results) {
  results = results || 6;
  var hsv = tinycolor(color).toHsv();
  var h3 = hsv.h, s3 = hsv.s, v = hsv.v;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h: h3,
      s: s3,
      v
    }));
    v = (v + modification) % 1;
  }
  return ret;
}
tinycolor.mix = function(color1, color2, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb2 = tinycolor(color2).toRgb();
  var p = amount / 100;
  var rgba = {
    r: (rgb2.r - rgb1.r) * p + rgb1.r,
    g: (rgb2.g - rgb1.g) * p + rgb1.g,
    b: (rgb2.b - rgb1.b) * p + rgb1.b,
    a: (rgb2.a - rgb1.a) * p + rgb1.a
  };
  return tinycolor(rgba);
};
tinycolor.readability = function(color1, color2) {
  var c1 = tinycolor(color1);
  var c2 = tinycolor(color2);
  return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
};
tinycolor.isReadable = function(color1, color2, wcag2) {
  var readability = tinycolor.readability(color1, color2);
  var wcag2Parms, out;
  out = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out = readability >= 4.5;
      break;
    case "AAlarge":
      out = readability >= 3;
      break;
    case "AAAsmall":
      out = readability >= 7;
      break;
  }
  return out;
};
tinycolor.mostReadable = function(baseColor, colorList, args) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size3;
  args = args || {};
  includeFallbackColors = args.includeFallbackColors;
  level = args.level;
  size3 = args.size;
  for (var i2 = 0; i2 < colorList.length; i2++) {
    readability = tinycolor.readability(baseColor, colorList[i2]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i2]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level,
    size: size3
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
  }
};
var names = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
var hexNames = tinycolor.hexNames = flip4(names);
function flip4(o) {
  var flipped = {};
  for (var i2 in o) {
    if (o.hasOwnProperty(i2)) {
      flipped[o[i2]] = i2;
    }
  }
  return flipped;
}
function boundAlpha(a3) {
  a3 = parseFloat(a3);
  if (isNaN(a3) || a3 < 0 || a3 > 1) {
    a3 = 1;
  }
  return a3;
}
function bound01(n, max4) {
  if (isOnePointZero(n))
    n = "100%";
  var processPercent = isPercentage(n);
  n = Math.min(max4, Math.max(0, parseFloat(n)));
  if (processPercent) {
    n = parseInt(n * max4, 10) / 100;
  }
  if (Math.abs(n - max4) < 1e-6) {
    return 1;
  }
  return n % max4 / parseFloat(max4);
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function isOnePointZero(n) {
  return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
}
function isPercentage(n) {
  return typeof n === "string" && n.indexOf("%") != -1;
}
function pad2(c2) {
  return c2.length == 1 ? "0" + c2 : "" + c2;
}
function convertToPercentage(n) {
  if (n <= 1) {
    n = n * 100 + "%";
  }
  return n;
}
function convertDecimalToHex(d3) {
  return Math.round(parseFloat(d3) * 255).toString(16);
}
function convertHexToDecimal(h3) {
  return parseIntFromHex(h3) / 255;
}
var matchers = function() {
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function isValidCSSUnit(color) {
  return !!matchers.CSS_UNIT.exec(color);
}
function stringInputToObject(color) {
  color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }
  var match3;
  if (match3 = matchers.rgb.exec(color)) {
    return {
      r: match3[1],
      g: match3[2],
      b: match3[3]
    };
  }
  if (match3 = matchers.rgba.exec(color)) {
    return {
      r: match3[1],
      g: match3[2],
      b: match3[3],
      a: match3[4]
    };
  }
  if (match3 = matchers.hsl.exec(color)) {
    return {
      h: match3[1],
      s: match3[2],
      l: match3[3]
    };
  }
  if (match3 = matchers.hsla.exec(color)) {
    return {
      h: match3[1],
      s: match3[2],
      l: match3[3],
      a: match3[4]
    };
  }
  if (match3 = matchers.hsv.exec(color)) {
    return {
      h: match3[1],
      s: match3[2],
      v: match3[3]
    };
  }
  if (match3 = matchers.hsva.exec(color)) {
    return {
      h: match3[1],
      s: match3[2],
      v: match3[3],
      a: match3[4]
    };
  }
  if (match3 = matchers.hex8.exec(color)) {
    return {
      r: parseIntFromHex(match3[1]),
      g: parseIntFromHex(match3[2]),
      b: parseIntFromHex(match3[3]),
      a: convertHexToDecimal(match3[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match3 = matchers.hex6.exec(color)) {
    return {
      r: parseIntFromHex(match3[1]),
      g: parseIntFromHex(match3[2]),
      b: parseIntFromHex(match3[3]),
      format: named ? "name" : "hex"
    };
  }
  if (match3 = matchers.hex4.exec(color)) {
    return {
      r: parseIntFromHex(match3[1] + "" + match3[1]),
      g: parseIntFromHex(match3[2] + "" + match3[2]),
      b: parseIntFromHex(match3[3] + "" + match3[3]),
      a: convertHexToDecimal(match3[4] + "" + match3[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match3 = matchers.hex3.exec(color)) {
    return {
      r: parseIntFromHex(match3[1] + "" + match3[1]),
      g: parseIntFromHex(match3[2] + "" + match3[2]),
      b: parseIntFromHex(match3[3] + "" + match3[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function validateWCAG2Parms(parms) {
  var level, size3;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size3 = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size3 !== "small" && size3 !== "large") {
    size3 = "small";
  }
  return {
    level,
    size: size3
  };
}

// node_modules/@neo4j-ndl/react/lib/esm/graph-label/color.js
var getTextColorFromBackground = (color) => {
  return tinycolor.mostReadable(color, [
    tokens.theme.light.palette.neutral.text.default,
    tokens.theme.light.palette.neutral.text.inverse
  ], {
    includeFallbackColors: true
  }).toString();
};
var getHoverColor = (color) => {
  const hslColor = tinycolor(color).toHsl();
  if (hslColor.l < 0.5) {
    return tinycolor(color).lighten(10).toString();
  }
  return tinycolor(color).darken(10).toString();
};
var getDisabledTextColor = (backgroundColor) => {
  const inverseTextColor = "#8e887f";
  return tinycolor.mostReadable(backgroundColor, [
    inverseTextColor,
    tokens.theme.light.palette.neutral.text.weakest,
    tokens.theme.light.palette.neutral.text.weak,
    tokens.theme.light.palette.neutral.text.weaker
  ]).toString();
};
var getDisabledColor = (color) => {
  const hslColor = tinycolor(color).toHsl();
  if (hslColor.l < 0.5) {
    return tinycolor(color).lighten(15).toString();
  }
  return tinycolor(color).darken(15).toString();
};

// node_modules/@neo4j-ndl/react/lib/esm/graph-label/GraphLabel.js
var __rest31 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var HexagonEnd = ({ direction = "left", color }) => {
  const classes = classNames("ndl-hexagon-end", {
    "ndl-left": direction === "left",
    "ndl-right": direction === "right"
  });
  return (0, import_jsx_runtime42.jsxs)("div", { className: classes, children: [(0, import_jsx_runtime42.jsx)("svg", { width: "8", height: "24", viewBox: "0 0 7 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, import_jsx_runtime42.jsx)("path", { className: "ndl-hexagon-end-inner", style: { fill: color }, fillRule: "evenodd", clipRule: "evenodd", d: "M5.73024 1.03676C6.08165 0.397331 6.75338 0 7.48301 0H9V24H7.483C6.75338 24 6.08165 23.6027 5.73024 22.9632L0.315027 13.1094C-0.105009 12.4376 -0.105009 11.5624 0.315026 10.8906L5.73024 1.03676Z" }) }), (0, import_jsx_runtime42.jsx)("svg", { className: "ndl-hexagon-end-active", width: "13", height: "30", viewBox: "0 0 13 30", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, import_jsx_runtime42.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.075 2C9.12474 2 8.24318 2.54521 7.74867 3.43873L2.21419 13.4387C1.68353 14.3976 1.68353 15.6024 2.21419 16.5613L7.74867 26.5613C8.24318 27.4548 9.12474 28 10.075 28H13V30H10.075C8.49126 30 7.022 29.0913 6.1978 27.6021L0.663324 17.6021C-0.221109 16.0041 -0.221108 13.9959 0.663325 12.3979L6.1978 2.39789C7.022 0.90869 8.49126 0 10.075 0H13V2H10.075Z" }) })] });
};
var MAX_WIDTH = 200;
var GraphLabel = import_react168.default.forwardRef(function GraphLabel2(_a2, ref) {
  var { type = "node", color, disabled = false, selected = false, as, onClick, onMouseEnter, onMouseLeave, className, style, children } = _a2, restProps = __rest31(_a2, ["type", "color", "disabled", "selected", "as", "onClick", "onMouseEnter", "onMouseLeave", "className", "style", "children"]);
  const [isHover, setIsHover] = (0, import_react168.useState)(false);
  const handleMouseEnter = (event) => {
    setIsHover(true);
    onMouseEnter && onMouseEnter(event);
  };
  const handleMouseLeave = (event) => {
    setIsHover(false);
    onMouseLeave && onMouseLeave(event);
  };
  const handleClick = (e4) => {
    if (disabled) {
      e4.preventDefault();
      e4.stopPropagation();
      return;
    }
    if (onClick) {
      onClick(e4);
    }
  };
  let backgroundColor = (0, import_react168.useMemo)(() => {
    if (!color) {
      switch (type) {
        case "node":
          return tokens.palette.graph["1"];
        case "relationship":
          return tokens.theme.light.palette.neutral.bg.strong;
        default:
          return tokens.theme.light.palette.neutral.bg.strongest;
      }
    }
    return color;
  }, [color, type]);
  const hoverColor = (0, import_react168.useMemo)(() => getHoverColor(backgroundColor ? backgroundColor : tokens.colors.lemon[40]), [backgroundColor]);
  const textColor = (0, import_react168.useMemo)(() => getTextColorFromBackground(backgroundColor ? backgroundColor : tokens.colors.lemon[40]), [backgroundColor]);
  const disabledTextColor = (0, import_react168.useMemo)(() => getDisabledTextColor(backgroundColor ? backgroundColor : tokens.colors.lemon[40]), [backgroundColor]);
  if (isHover && !disabled)
    backgroundColor = hoverColor;
  if (disabled)
    backgroundColor = getDisabledColor(backgroundColor);
  let Component4 = "button";
  if (as) {
    Component4 = as;
  }
  const commonClasses = classNames(className, {
    "ndl-disabled": disabled,
    "ndl-selected": selected
  });
  if (type === "node") {
    const classes = `ndl-node-label ${commonClasses}`;
    return (0, import_jsx_runtime42.jsx)(Component4, Object.assign({}, restProps, { className: classes, ref, style: Object.assign({ backgroundColor, color: disabled ? disabledTextColor : textColor, maxWidth: MAX_WIDTH }, style), onClick: handleClick, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, children: (0, import_jsx_runtime42.jsx)("div", { className: "ndl-node-label-content", children }) }));
  } else if (type === "relationship") {
    const classes = `ndl-relationship-label ${commonClasses}`;
    return (0, import_jsx_runtime42.jsxs)(Component4, Object.assign({}, restProps, { style: Object.assign(Object.assign({ maxWidth: MAX_WIDTH }, style), { color: disabled ? disabledTextColor : textColor }), className: classes, onClick: handleClick, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, ref, children: [(0, import_jsx_runtime42.jsx)("svg", { style: { display: "none" }, children: (0, import_jsx_runtime42.jsx)("mask", { id: "ndl-relationship-label-mask-outer-border", fill: "white", children: (0, import_jsx_runtime42.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.73024 1.03676C6.08165 0.397331 6.75338 0 7.48301 0H9V24H7.483C6.75338 24 6.08165 23.6027 5.73024 22.9632L0.315027 13.1094C-0.105009 12.4376 -0.105009 11.5624 0.315026 10.8906L5.73024 1.03676Z" }) }) }), (0, import_jsx_runtime42.jsx)(HexagonEnd, { direction: "left", color: backgroundColor }), (0, import_jsx_runtime42.jsx)("div", { className: "ndl-relationship-label-container", style: {
      backgroundColor
    }, children: (0, import_jsx_runtime42.jsx)("div", { className: "ndl-relationship-label-content", children }) }), (0, import_jsx_runtime42.jsx)(HexagonEnd, { direction: "right", color: backgroundColor })] }));
  } else {
    const classes = `ndl-property-key-label ${commonClasses}`;
    return (0, import_jsx_runtime42.jsx)(Component4, Object.assign({}, restProps, { style: Object.assign({ backgroundColor, color: disabled ? disabledTextColor : textColor, maxWidth: MAX_WIDTH }, style), className: classes, onClick: handleClick, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, ref, children: (0, import_jsx_runtime42.jsx)("div", { className: "ndl-property-key-label-content", children }) }));
  }
});
var GraphLabel_default = GraphLabel;

// node_modules/@neo4j-ndl/react/lib/esm/code-block/CodeBlock.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime());
var import_react173 = __toESM(require_react());

// node_modules/react-syntax-highlighter/dist/esm/highlight.js
var import_react170 = __toESM(require_react());

// node_modules/react-syntax-highlighter/dist/esm/create-element.js
var import_react169 = __toESM(require_react());
function ownKeys4(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys4(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function powerSetPermutations(arr) {
  var arrLength = arr.length;
  if (arrLength === 0 || arrLength === 1)
    return arr;
  if (arrLength === 2) {
    return [arr[0], arr[1], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0])];
  }
  if (arrLength === 3) {
    return [arr[0], arr[1], arr[2], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
  }
  if (arrLength >= 4) {
    return [arr[0], arr[1], arr[2], arr[3], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3]), "".concat(arr[3], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
  }
}
var classNameCombinations = {};
function getClassNameCombinations(classNames3) {
  if (classNames3.length === 0 || classNames3.length === 1)
    return classNames3;
  var key = classNames3.join(".");
  if (!classNameCombinations[key]) {
    classNameCombinations[key] = powerSetPermutations(classNames3);
  }
  return classNameCombinations[key];
}
function createStyleObject(classNames3) {
  var elementStyle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var stylesheet = arguments.length > 2 ? arguments[2] : void 0;
  var nonTokenClassNames = classNames3.filter(function(className) {
    return className !== "token";
  });
  var classNamesCombinations = getClassNameCombinations(nonTokenClassNames);
  return classNamesCombinations.reduce(function(styleObject, className) {
    return _objectSpread3(_objectSpread3({}, styleObject), stylesheet[className]);
  }, elementStyle);
}
function createClassNameString(classNames3) {
  return classNames3.join(" ");
}
function createChildren(stylesheet, useInlineStyles) {
  var childrenCount = 0;
  return function(children) {
    childrenCount += 1;
    return children.map(function(child, i2) {
      return createElement25({
        node: child,
        stylesheet,
        useInlineStyles,
        key: "code-segment-".concat(childrenCount, "-").concat(i2)
      });
    });
  };
}
function createElement25(_ref4) {
  var node3 = _ref4.node, stylesheet = _ref4.stylesheet, _ref$style = _ref4.style, style = _ref$style === void 0 ? {} : _ref$style, useInlineStyles = _ref4.useInlineStyles, key = _ref4.key;
  var properties = node3.properties, type = node3.type, TagName = node3.tagName, value = node3.value;
  if (type === "text") {
    return value;
  } else if (TagName) {
    var childrenCreator = createChildren(stylesheet, useInlineStyles);
    var props;
    if (!useInlineStyles) {
      props = _objectSpread3(_objectSpread3({}, properties), {}, {
        className: createClassNameString(properties.className)
      });
    } else {
      var allStylesheetSelectors = Object.keys(stylesheet).reduce(function(classes, selector) {
        selector.split(".").forEach(function(className2) {
          if (!classes.includes(className2))
            classes.push(className2);
        });
        return classes;
      }, []);
      var startingClassName = properties.className && properties.className.includes("token") ? ["token"] : [];
      var className = properties.className && startingClassName.concat(properties.className.filter(function(className2) {
        return !allStylesheetSelectors.includes(className2);
      }));
      props = _objectSpread3(_objectSpread3({}, properties), {}, {
        className: createClassNameString(className) || void 0,
        style: createStyleObject(properties.className, Object.assign({}, properties.style, style), stylesheet)
      });
    }
    var children = childrenCreator(node3.children);
    return import_react169.default.createElement(TagName, _extends2({
      key
    }, props), children);
  }
}

// node_modules/react-syntax-highlighter/dist/esm/checkForListedLanguage.js
var checkForListedLanguage_default = function(astGenerator, language2) {
  var langs = astGenerator.listLanguages();
  return langs.indexOf(language2) !== -1;
};

// node_modules/react-syntax-highlighter/dist/esm/highlight.js
var _excluded10 = ["language", "children", "style", "customStyle", "codeTagProps", "useInlineStyles", "showLineNumbers", "showInlineLineNumbers", "startingLineNumber", "lineNumberContainerStyle", "lineNumberStyle", "wrapLines", "wrapLongLines", "lineProps", "renderer", "PreTag", "CodeTag", "code", "astGenerator"];
function ownKeys5(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread4(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys5(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys5(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var newLineRegex = /\n/g;
function getNewLines(str) {
  return str.match(newLineRegex);
}
function getAllLineNumbers(_ref4) {
  var lines = _ref4.lines, startingLineNumber = _ref4.startingLineNumber, style = _ref4.style;
  return lines.map(function(_, i2) {
    var number2 = i2 + startingLineNumber;
    return import_react170.default.createElement("span", {
      key: "line-".concat(i2),
      className: "react-syntax-highlighter-line-number",
      style: typeof style === "function" ? style(number2) : style
    }, "".concat(number2, "\n"));
  });
}
function AllLineNumbers(_ref23) {
  var codeString = _ref23.codeString, codeStyle = _ref23.codeStyle, _ref2$containerStyle = _ref23.containerStyle, containerStyle2 = _ref2$containerStyle === void 0 ? {
    "float": "left",
    paddingRight: "10px"
  } : _ref2$containerStyle, _ref2$numberStyle = _ref23.numberStyle, numberStyle = _ref2$numberStyle === void 0 ? {} : _ref2$numberStyle, startingLineNumber = _ref23.startingLineNumber;
  return import_react170.default.createElement("code", {
    style: Object.assign({}, codeStyle, containerStyle2)
  }, getAllLineNumbers({
    lines: codeString.replace(/\n$/, "").split("\n"),
    style: numberStyle,
    startingLineNumber
  }));
}
function getEmWidthOfNumber(num) {
  return "".concat(num.toString().length, ".25em");
}
function getInlineLineNumber(lineNumber, inlineLineNumberStyle) {
  return {
    type: "element",
    tagName: "span",
    properties: {
      key: "line-number--".concat(lineNumber),
      className: ["comment", "linenumber", "react-syntax-highlighter-line-number"],
      style: inlineLineNumberStyle
    },
    children: [{
      type: "text",
      value: lineNumber
    }]
  };
}
function assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber) {
  var defaultLineNumberStyle = {
    display: "inline-block",
    minWidth: getEmWidthOfNumber(largestLineNumber),
    paddingRight: "1em",
    textAlign: "right",
    userSelect: "none"
  };
  var customLineNumberStyle = typeof lineNumberStyle === "function" ? lineNumberStyle(lineNumber) : lineNumberStyle;
  var assembledStyle = _objectSpread4(_objectSpread4({}, defaultLineNumberStyle), customLineNumberStyle);
  return assembledStyle;
}
function createLineElement(_ref32) {
  var children = _ref32.children, lineNumber = _ref32.lineNumber, lineNumberStyle = _ref32.lineNumberStyle, largestLineNumber = _ref32.largestLineNumber, showInlineLineNumbers = _ref32.showInlineLineNumbers, _ref3$lineProps = _ref32.lineProps, lineProps = _ref3$lineProps === void 0 ? {} : _ref3$lineProps, _ref3$className = _ref32.className, className = _ref3$className === void 0 ? [] : _ref3$className, showLineNumbers = _ref32.showLineNumbers, wrapLongLines = _ref32.wrapLongLines;
  var properties = typeof lineProps === "function" ? lineProps(lineNumber) : lineProps;
  properties["className"] = className;
  if (lineNumber && showInlineLineNumbers) {
    var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber);
    children.unshift(getInlineLineNumber(lineNumber, inlineLineNumberStyle));
  }
  if (wrapLongLines & showLineNumbers) {
    properties.style = _objectSpread4(_objectSpread4({}, properties.style), {}, {
      display: "flex"
    });
  }
  return {
    type: "element",
    tagName: "span",
    properties,
    children
  };
}
function flattenCodeTree(tree) {
  var className = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var newTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  for (var i2 = 0; i2 < tree.length; i2++) {
    var node3 = tree[i2];
    if (node3.type === "text") {
      newTree.push(createLineElement({
        children: [node3],
        className: _toConsumableArray3(new Set(className))
      }));
    } else if (node3.children) {
      var classNames3 = className.concat(node3.properties.className);
      flattenCodeTree(node3.children, classNames3).forEach(function(i3) {
        return newTree.push(i3);
      });
    }
  }
  return newTree;
}
function processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines) {
  var _ref4;
  var tree = flattenCodeTree(codeTree.value);
  var newTree = [];
  var lastLineBreakIndex = -1;
  var index4 = 0;
  function createWrappedLine(children2, lineNumber2) {
    var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return createLineElement({
      children: children2,
      lineNumber: lineNumber2,
      lineNumberStyle,
      largestLineNumber,
      showInlineLineNumbers,
      lineProps,
      className,
      showLineNumbers,
      wrapLongLines
    });
  }
  function createUnwrappedLine(children2, lineNumber2) {
    if (showLineNumbers && lineNumber2 && showInlineLineNumbers) {
      var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber2, largestLineNumber);
      children2.unshift(getInlineLineNumber(lineNumber2, inlineLineNumberStyle));
    }
    return children2;
  }
  function createLine(children2, lineNumber2) {
    var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return wrapLines || className.length > 0 ? createWrappedLine(children2, lineNumber2, className) : createUnwrappedLine(children2, lineNumber2);
  }
  var _loop = function _loop2() {
    var node3 = tree[index4];
    var value = node3.children[0].value;
    var newLines = getNewLines(value);
    if (newLines) {
      var splitValue = value.split("\n");
      splitValue.forEach(function(text, i2) {
        var lineNumber2 = showLineNumbers && newTree.length + startingLineNumber;
        var newChild = {
          type: "text",
          value: "".concat(text, "\n")
        };
        if (i2 === 0) {
          var _children = tree.slice(lastLineBreakIndex + 1, index4).concat(createLineElement({
            children: [newChild],
            className: node3.properties.className
          }));
          var _line = createLine(_children, lineNumber2);
          newTree.push(_line);
        } else if (i2 === splitValue.length - 1) {
          var stringChild = tree[index4 + 1] && tree[index4 + 1].children && tree[index4 + 1].children[0];
          var lastLineInPreviousSpan = {
            type: "text",
            value: "".concat(text)
          };
          if (stringChild) {
            var newElem = createLineElement({
              children: [lastLineInPreviousSpan],
              className: node3.properties.className
            });
            tree.splice(index4 + 1, 0, newElem);
          } else {
            var _children2 = [lastLineInPreviousSpan];
            var _line2 = createLine(_children2, lineNumber2, node3.properties.className);
            newTree.push(_line2);
          }
        } else {
          var _children3 = [newChild];
          var _line3 = createLine(_children3, lineNumber2, node3.properties.className);
          newTree.push(_line3);
        }
      });
      lastLineBreakIndex = index4;
    }
    index4++;
  };
  while (index4 < tree.length) {
    _loop();
  }
  if (lastLineBreakIndex !== tree.length - 1) {
    var children = tree.slice(lastLineBreakIndex + 1, tree.length);
    if (children && children.length) {
      var lineNumber = showLineNumbers && newTree.length + startingLineNumber;
      var line2 = createLine(children, lineNumber);
      newTree.push(line2);
    }
  }
  return wrapLines ? newTree : (_ref4 = []).concat.apply(_ref4, newTree);
}
function defaultRenderer(_ref5) {
  var rows = _ref5.rows, stylesheet = _ref5.stylesheet, useInlineStyles = _ref5.useInlineStyles;
  return rows.map(function(node3, i2) {
    return createElement25({
      node: node3,
      stylesheet,
      useInlineStyles,
      key: "code-segement".concat(i2)
    });
  });
}
function isHighlightJs(astGenerator) {
  return astGenerator && typeof astGenerator.highlightAuto !== "undefined";
}
function getCodeTree(_ref6) {
  var astGenerator = _ref6.astGenerator, language2 = _ref6.language, code = _ref6.code, defaultCodeValue = _ref6.defaultCodeValue;
  if (isHighlightJs(astGenerator)) {
    var hasLanguage = checkForListedLanguage_default(astGenerator, language2);
    if (language2 === "text") {
      return {
        value: defaultCodeValue,
        language: "text"
      };
    } else if (hasLanguage) {
      return astGenerator.highlight(language2, code);
    } else {
      return astGenerator.highlightAuto(code);
    }
  }
  try {
    return language2 && language2 !== "text" ? {
      value: astGenerator.highlight(code, language2)
    } : {
      value: defaultCodeValue
    };
  } catch (e4) {
    return {
      value: defaultCodeValue
    };
  }
}
function highlight_default(defaultAstGenerator, defaultStyle) {
  return function SyntaxHighlighter3(_ref7) {
    var language2 = _ref7.language, children = _ref7.children, _ref7$style = _ref7.style, style = _ref7$style === void 0 ? defaultStyle : _ref7$style, _ref7$customStyle = _ref7.customStyle, customStyle = _ref7$customStyle === void 0 ? {} : _ref7$customStyle, _ref7$codeTagProps = _ref7.codeTagProps, codeTagProps = _ref7$codeTagProps === void 0 ? {
      className: language2 ? "language-".concat(language2) : void 0,
      style: _objectSpread4(_objectSpread4({}, style['code[class*="language-"]']), style['code[class*="language-'.concat(language2, '"]')])
    } : _ref7$codeTagProps, _ref7$useInlineStyles = _ref7.useInlineStyles, useInlineStyles = _ref7$useInlineStyles === void 0 ? true : _ref7$useInlineStyles, _ref7$showLineNumbers = _ref7.showLineNumbers, showLineNumbers = _ref7$showLineNumbers === void 0 ? false : _ref7$showLineNumbers, _ref7$showInlineLineN = _ref7.showInlineLineNumbers, showInlineLineNumbers = _ref7$showInlineLineN === void 0 ? true : _ref7$showInlineLineN, _ref7$startingLineNum = _ref7.startingLineNumber, startingLineNumber = _ref7$startingLineNum === void 0 ? 1 : _ref7$startingLineNum, lineNumberContainerStyle = _ref7.lineNumberContainerStyle, _ref7$lineNumberStyle = _ref7.lineNumberStyle, lineNumberStyle = _ref7$lineNumberStyle === void 0 ? {} : _ref7$lineNumberStyle, wrapLines = _ref7.wrapLines, _ref7$wrapLongLines = _ref7.wrapLongLines, wrapLongLines = _ref7$wrapLongLines === void 0 ? false : _ref7$wrapLongLines, _ref7$lineProps = _ref7.lineProps, lineProps = _ref7$lineProps === void 0 ? {} : _ref7$lineProps, renderer = _ref7.renderer, _ref7$PreTag = _ref7.PreTag, PreTag = _ref7$PreTag === void 0 ? "pre" : _ref7$PreTag, _ref7$CodeTag = _ref7.CodeTag, CodeTag = _ref7$CodeTag === void 0 ? "code" : _ref7$CodeTag, _ref7$code = _ref7.code, code = _ref7$code === void 0 ? (Array.isArray(children) ? children[0] : children) || "" : _ref7$code, astGenerator = _ref7.astGenerator, rest = _objectWithoutProperties2(_ref7, _excluded10);
    astGenerator = astGenerator || defaultAstGenerator;
    var allLineNumbers = showLineNumbers ? import_react170.default.createElement(AllLineNumbers, {
      containerStyle: lineNumberContainerStyle,
      codeStyle: codeTagProps.style || {},
      numberStyle: lineNumberStyle,
      startingLineNumber,
      codeString: code
    }) : null;
    var defaultPreStyle = style.hljs || style['pre[class*="language-"]'] || {
      backgroundColor: "#fff"
    };
    var generatorClassName = isHighlightJs(astGenerator) ? "hljs" : "prismjs";
    var preProps = useInlineStyles ? Object.assign({}, rest, {
      style: Object.assign({}, defaultPreStyle, customStyle)
    }) : Object.assign({}, rest, {
      className: rest.className ? "".concat(generatorClassName, " ").concat(rest.className) : generatorClassName,
      style: Object.assign({}, customStyle)
    });
    if (wrapLongLines) {
      codeTagProps.style = _objectSpread4(_objectSpread4({}, codeTagProps.style), {}, {
        whiteSpace: "pre-wrap"
      });
    } else {
      codeTagProps.style = _objectSpread4(_objectSpread4({}, codeTagProps.style), {}, {
        whiteSpace: "pre"
      });
    }
    if (!astGenerator) {
      return import_react170.default.createElement(PreTag, preProps, allLineNumbers, import_react170.default.createElement(CodeTag, codeTagProps, code));
    }
    if (wrapLines === void 0 && renderer || wrapLongLines)
      wrapLines = true;
    renderer = renderer || defaultRenderer;
    var defaultCodeValue = [{
      type: "text",
      value: code
    }];
    var codeTree = getCodeTree({
      astGenerator,
      language: language2,
      code,
      defaultCodeValue
    });
    if (codeTree.language === null) {
      codeTree.value = defaultCodeValue;
    }
    var largestLineNumber = codeTree.value.length + startingLineNumber;
    var rows = processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines);
    return import_react170.default.createElement(PreTag, preProps, import_react170.default.createElement(CodeTag, codeTagProps, !showInlineLineNumbers && allLineNumbers, renderer({
      rows,
      stylesheet: style,
      useInlineStyles
    })));
  };
}

// node_modules/react-syntax-highlighter/dist/esm/styles/hljs/default-style.js
var default_style_default = {
  "hljs": {
    "display": "block",
    "overflowX": "auto",
    "padding": "0.5em",
    "background": "#F0F0F0",
    "color": "#444"
  },
  "hljs-subst": {
    "color": "#444"
  },
  "hljs-comment": {
    "color": "#888888"
  },
  "hljs-keyword": {
    "fontWeight": "bold"
  },
  "hljs-attribute": {
    "fontWeight": "bold"
  },
  "hljs-selector-tag": {
    "fontWeight": "bold"
  },
  "hljs-meta-keyword": {
    "fontWeight": "bold"
  },
  "hljs-doctag": {
    "fontWeight": "bold"
  },
  "hljs-name": {
    "fontWeight": "bold"
  },
  "hljs-type": {
    "color": "#880000"
  },
  "hljs-string": {
    "color": "#880000"
  },
  "hljs-number": {
    "color": "#880000"
  },
  "hljs-selector-id": {
    "color": "#880000"
  },
  "hljs-selector-class": {
    "color": "#880000"
  },
  "hljs-quote": {
    "color": "#880000"
  },
  "hljs-template-tag": {
    "color": "#880000"
  },
  "hljs-deletion": {
    "color": "#880000"
  },
  "hljs-title": {
    "color": "#880000",
    "fontWeight": "bold"
  },
  "hljs-section": {
    "color": "#880000",
    "fontWeight": "bold"
  },
  "hljs-regexp": {
    "color": "#BC6060"
  },
  "hljs-symbol": {
    "color": "#BC6060"
  },
  "hljs-variable": {
    "color": "#BC6060"
  },
  "hljs-template-variable": {
    "color": "#BC6060"
  },
  "hljs-link": {
    "color": "#BC6060"
  },
  "hljs-selector-attr": {
    "color": "#BC6060"
  },
  "hljs-selector-pseudo": {
    "color": "#BC6060"
  },
  "hljs-literal": {
    "color": "#78A960"
  },
  "hljs-built_in": {
    "color": "#397300"
  },
  "hljs-bullet": {
    "color": "#397300"
  },
  "hljs-code": {
    "color": "#397300"
  },
  "hljs-addition": {
    "color": "#397300"
  },
  "hljs-meta": {
    "color": "#1f7199"
  },
  "hljs-meta-string": {
    "color": "#4d99bf"
  },
  "hljs-emphasis": {
    "fontStyle": "italic"
  },
  "hljs-strong": {
    "fontWeight": "bold"
  }
};

// node_modules/react-syntax-highlighter/dist/esm/default-highlight.js
var import_lowlight = __toESM(require_lowlight());

// node_modules/react-syntax-highlighter/dist/esm/languages/hljs/supported-languages.js
var supported_languages_default = ["1c", "abnf", "accesslog", "actionscript", "ada", "angelscript", "apache", "applescript", "arcade", "arduino", "armasm", "asciidoc", "aspectj", "autohotkey", "autoit", "avrasm", "awk", "axapta", "bash", "basic", "bnf", "brainfuck", "c-like", "c", "cal", "capnproto", "ceylon", "clean", "clojure-repl", "clojure", "cmake", "coffeescript", "coq", "cos", "cpp", "crmsh", "crystal", "csharp", "csp", "css", "d", "dart", "delphi", "diff", "django", "dns", "dockerfile", "dos", "dsconfig", "dts", "dust", "ebnf", "elixir", "elm", "erb", "erlang-repl", "erlang", "excel", "fix", "flix", "fortran", "fsharp", "gams", "gauss", "gcode", "gherkin", "glsl", "gml", "go", "golo", "gradle", "groovy", "haml", "handlebars", "haskell", "haxe", "hsp", "htmlbars", "http", "hy", "inform7", "ini", "irpf90", "isbl", "java", "javascript", "jboss-cli", "json", "julia-repl", "julia", "kotlin", "lasso", "latex", "ldif", "leaf", "less", "lisp", "livecodeserver", "livescript", "llvm", "lsl", "lua", "makefile", "markdown", "mathematica", "matlab", "maxima", "mel", "mercury", "mipsasm", "mizar", "mojolicious", "monkey", "moonscript", "n1ql", "nginx", "nim", "nix", "node-repl", "nsis", "objectivec", "ocaml", "openscad", "oxygene", "parser3", "perl", "pf", "pgsql", "php-template", "php", "plaintext", "pony", "powershell", "processing", "profile", "prolog", "properties", "protobuf", "puppet", "purebasic", "python-repl", "python", "q", "qml", "r", "reasonml", "rib", "roboconf", "routeros", "rsl", "ruby", "ruleslanguage", "rust", "sas", "scala", "scheme", "scilab", "scss", "shell", "smali", "smalltalk", "sml", "sqf", "sql", "sql_more", "stan", "stata", "step21", "stylus", "subunit", "swift", "taggerscript", "tap", "tcl", "thrift", "tp", "twig", "typescript", "vala", "vbnet", "vbscript-html", "vbscript", "verilog", "vhdl", "vim", "x86asm", "xl", "xml", "xquery", "yaml", "zephir"];

// node_modules/react-syntax-highlighter/dist/esm/default-highlight.js
var highlighter = highlight_default(import_lowlight.default, default_style_default);
highlighter.supportedLanguages = supported_languages_default;

// node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn2) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn2.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}

// node_modules/react-syntax-highlighter/dist/esm/async-syntax-highlighter.js
var import_regenerator = __toESM(require_regenerator());
var import_react171 = __toESM(require_react());
function _createSuper2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e4) {
    return false;
  }
}
var async_syntax_highlighter_default = function(options2) {
  var loader4 = options2.loader, isLanguageRegistered3 = options2.isLanguageRegistered, registerLanguage3 = options2.registerLanguage, languageLoaders = options2.languageLoaders, noAsyncLoadingLanguages = options2.noAsyncLoadingLanguages;
  var ReactAsyncHighlighter = function(_React$PureComponent) {
    _inherits(ReactAsyncHighlighter2, _React$PureComponent);
    var _super = _createSuper2(ReactAsyncHighlighter2);
    function ReactAsyncHighlighter2() {
      _classCallCheck(this, ReactAsyncHighlighter2);
      return _super.apply(this, arguments);
    }
    _createClass(ReactAsyncHighlighter2, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        if (!ReactAsyncHighlighter2.isRegistered(this.props.language) && languageLoaders) {
          this.loadLanguage();
        }
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this = this;
        if (!ReactAsyncHighlighter2.astGeneratorPromise) {
          ReactAsyncHighlighter2.loadAstGenerator();
        }
        if (!ReactAsyncHighlighter2.astGenerator) {
          ReactAsyncHighlighter2.astGeneratorPromise.then(function() {
            _this.forceUpdate();
          });
        }
        if (!ReactAsyncHighlighter2.isRegistered(this.props.language) && languageLoaders) {
          this.loadLanguage();
        }
      }
    }, {
      key: "loadLanguage",
      value: function loadLanguage() {
        var _this2 = this;
        var language2 = this.props.language;
        if (language2 === "text") {
          return;
        }
        ReactAsyncHighlighter2.loadLanguage(language2).then(function() {
          return _this2.forceUpdate();
        })["catch"](function() {
        });
      }
    }, {
      key: "normalizeLanguage",
      value: function normalizeLanguage(language2) {
        return ReactAsyncHighlighter2.isSupportedLanguage(language2) ? language2 : "text";
      }
    }, {
      key: "render",
      value: function render2() {
        return import_react171.default.createElement(ReactAsyncHighlighter2.highlightInstance, _extends2({}, this.props, {
          language: this.normalizeLanguage(this.props.language),
          astGenerator: ReactAsyncHighlighter2.astGenerator
        }));
      }
    }], [{
      key: "preload",
      value: function preload() {
        return ReactAsyncHighlighter2.loadAstGenerator();
      }
    }, {
      key: "loadLanguage",
      value: function() {
        var _loadLanguage = _asyncToGenerator(import_regenerator.default.mark(function _callee(language2) {
          var languageLoader;
          return import_regenerator.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  languageLoader = languageLoaders[language2];
                  if (!(typeof languageLoader === "function")) {
                    _context.next = 5;
                    break;
                  }
                  return _context.abrupt("return", languageLoader(ReactAsyncHighlighter2.registerLanguage));
                case 5:
                  throw new Error("Language ".concat(language2, " not supported"));
                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        function loadLanguage(_x) {
          return _loadLanguage.apply(this, arguments);
        }
        return loadLanguage;
      }()
    }, {
      key: "isSupportedLanguage",
      value: function isSupportedLanguage(language2) {
        return ReactAsyncHighlighter2.isRegistered(language2) || typeof languageLoaders[language2] === "function";
      }
    }, {
      key: "loadAstGenerator",
      value: function loadAstGenerator() {
        ReactAsyncHighlighter2.astGeneratorPromise = loader4().then(function(astGenerator) {
          ReactAsyncHighlighter2.astGenerator = astGenerator;
          if (registerLanguage3) {
            ReactAsyncHighlighter2.languages.forEach(function(language2, name2) {
              return registerLanguage3(astGenerator, name2, language2);
            });
          }
        });
        return ReactAsyncHighlighter2.astGeneratorPromise;
      }
    }]);
    return ReactAsyncHighlighter2;
  }(import_react171.default.PureComponent);
  _defineProperty(ReactAsyncHighlighter, "astGenerator", null);
  _defineProperty(ReactAsyncHighlighter, "highlightInstance", highlight_default(null, {}));
  _defineProperty(ReactAsyncHighlighter, "astGeneratorPromise", null);
  _defineProperty(ReactAsyncHighlighter, "languages", /* @__PURE__ */ new Map());
  _defineProperty(ReactAsyncHighlighter, "supportedLanguages", options2.supportedLanguages || Object.keys(languageLoaders || {}));
  _defineProperty(ReactAsyncHighlighter, "isRegistered", function(language2) {
    if (noAsyncLoadingLanguages) {
      return true;
    }
    if (!registerLanguage3) {
      throw new Error("Current syntax highlighter doesn't support registration of languages");
    }
    if (!ReactAsyncHighlighter.astGenerator) {
      return ReactAsyncHighlighter.languages.has(language2);
    }
    return isLanguageRegistered3(ReactAsyncHighlighter.astGenerator, language2);
  });
  _defineProperty(ReactAsyncHighlighter, "registerLanguage", function(name2, language2) {
    if (!registerLanguage3) {
      throw new Error("Current syntax highlighter doesn't support registration of languages");
    }
    if (ReactAsyncHighlighter.astGenerator) {
      return registerLanguage3(ReactAsyncHighlighter.astGenerator, name2, language2);
    } else {
      ReactAsyncHighlighter.languages.set(name2, language2);
    }
  });
  return ReactAsyncHighlighter;
};

// node_modules/react-syntax-highlighter/dist/esm/async-languages/create-language-async-loader.js
var import_regenerator2 = __toESM(require_regenerator());
var create_language_async_loader_default = function(name2, loader4) {
  return function() {
    var _ref4 = _asyncToGenerator(import_regenerator2.default.mark(function _callee(registerLanguage3) {
      var module;
      return import_regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return loader4();
            case 2:
              module = _context.sent;
              registerLanguage3(name2, module["default"] || module);
            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return function(_x) {
      return _ref4.apply(this, arguments);
    };
  }();
};

// node_modules/react-syntax-highlighter/dist/esm/async-languages/hljs.js
var hljs_default = {
  oneC: create_language_async_loader_default("oneC", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_oneC" */
      "./1c-TBUBWSP5.js"
    );
  }),
  abnf: create_language_async_loader_default("abnf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_abnf" */
      "./abnf-LGOS6QKS.js"
    );
  }),
  accesslog: create_language_async_loader_default("accesslog", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_accesslog" */
      "./accesslog-OBSFR5HS.js"
    );
  }),
  actionscript: create_language_async_loader_default("actionscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_actionscript" */
      "./actionscript-ETTEEOII.js"
    );
  }),
  ada: create_language_async_loader_default("ada", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ada" */
      "./ada-JROM37Q5.js"
    );
  }),
  angelscript: create_language_async_loader_default("angelscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_angelscript" */
      "./angelscript-KZ3QALD6.js"
    );
  }),
  apache: create_language_async_loader_default("apache", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_apache" */
      "./apache-AOGONMFN.js"
    );
  }),
  applescript: create_language_async_loader_default("applescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_applescript" */
      "./applescript-EKRL7OZE.js"
    );
  }),
  arcade: create_language_async_loader_default("arcade", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_arcade" */
      "./arcade-TH7VB2L5.js"
    );
  }),
  arduino: create_language_async_loader_default("arduino", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_arduino" */
      "./arduino-NCSZX3HL.js"
    );
  }),
  armasm: create_language_async_loader_default("armasm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_armasm" */
      "./armasm-NETK4FVX.js"
    );
  }),
  asciidoc: create_language_async_loader_default("asciidoc", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_asciidoc" */
      "./asciidoc-X5WCXP5F.js"
    );
  }),
  aspectj: create_language_async_loader_default("aspectj", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_aspectj" */
      "./aspectj-VXTAWT2S.js"
    );
  }),
  autohotkey: create_language_async_loader_default("autohotkey", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_autohotkey" */
      "./autohotkey-5IYVFKVF.js"
    );
  }),
  autoit: create_language_async_loader_default("autoit", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_autoit" */
      "./autoit-VUZD3QHX.js"
    );
  }),
  avrasm: create_language_async_loader_default("avrasm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_avrasm" */
      "./avrasm-IIVJKKO6.js"
    );
  }),
  awk: create_language_async_loader_default("awk", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_awk" */
      "./awk-GP2DBDVA.js"
    );
  }),
  axapta: create_language_async_loader_default("axapta", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_axapta" */
      "./axapta-JUVL2PSF.js"
    );
  }),
  bash: create_language_async_loader_default("bash", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_bash" */
      "./bash-P6OBOSKP.js"
    );
  }),
  basic: create_language_async_loader_default("basic", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_basic" */
      "./basic-CNIVXMUP.js"
    );
  }),
  bnf: create_language_async_loader_default("bnf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_bnf" */
      "./bnf-MWHNHB6P.js"
    );
  }),
  brainfuck: create_language_async_loader_default("brainfuck", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_brainfuck" */
      "./brainfuck-XBGFB44K.js"
    );
  }),
  cLike: create_language_async_loader_default("cLike", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cLike" */
      "./c-like-GXT53REC.js"
    );
  }),
  c: create_language_async_loader_default("c", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_c" */
      "./c-6L5Z3BD7.js"
    );
  }),
  cal: create_language_async_loader_default("cal", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cal" */
      "./cal-JY62ALOQ.js"
    );
  }),
  capnproto: create_language_async_loader_default("capnproto", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_capnproto" */
      "./capnproto-KDLDELT3.js"
    );
  }),
  ceylon: create_language_async_loader_default("ceylon", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ceylon" */
      "./ceylon-KTXFRVW3.js"
    );
  }),
  clean: create_language_async_loader_default("clean", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_clean" */
      "./clean-RDMQ4CZU.js"
    );
  }),
  clojureRepl: create_language_async_loader_default("clojureRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_clojureRepl" */
      "./clojure-repl-ISUPX37B.js"
    );
  }),
  clojure: create_language_async_loader_default("clojure", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_clojure" */
      "./clojure-7DMCF357.js"
    );
  }),
  cmake: create_language_async_loader_default("cmake", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cmake" */
      "./cmake-YJFPIHL7.js"
    );
  }),
  coffeescript: create_language_async_loader_default("coffeescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_coffeescript" */
      "./coffeescript-HTUOXHMP.js"
    );
  }),
  coq: create_language_async_loader_default("coq", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_coq" */
      "./coq-AOZXERNC.js"
    );
  }),
  cos: create_language_async_loader_default("cos", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cos" */
      "./cos-7IYSXBWA.js"
    );
  }),
  cpp: create_language_async_loader_default("cpp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cpp" */
      "./cpp-272L6PHO.js"
    );
  }),
  crmsh: create_language_async_loader_default("crmsh", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_crmsh" */
      "./crmsh-5Z4DTCBA.js"
    );
  }),
  crystal: create_language_async_loader_default("crystal", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_crystal" */
      "./crystal-KNHMDGMH.js"
    );
  }),
  csharp: create_language_async_loader_default("csharp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_csharp" */
      "./csharp-WSPYI3K3.js"
    );
  }),
  csp: create_language_async_loader_default("csp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_csp" */
      "./csp-3AIH6MVV.js"
    );
  }),
  css: create_language_async_loader_default("css", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_css" */
      "./css-P52N3AUS.js"
    );
  }),
  d: create_language_async_loader_default("d", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_d" */
      "./d-C6FVAZSU.js"
    );
  }),
  dart: create_language_async_loader_default("dart", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dart" */
      "./dart-ECSQUQGY.js"
    );
  }),
  delphi: create_language_async_loader_default("delphi", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_delphi" */
      "./delphi-4PXQCVO4.js"
    );
  }),
  diff: create_language_async_loader_default("diff", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_diff" */
      "./diff-OVA4WINH.js"
    );
  }),
  django: create_language_async_loader_default("django", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_django" */
      "./django-3UDBVSE6.js"
    );
  }),
  dns: create_language_async_loader_default("dns", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dns" */
      "./dns-VF2NFKP7.js"
    );
  }),
  dockerfile: create_language_async_loader_default("dockerfile", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dockerfile" */
      "./dockerfile-AGPU3ODI.js"
    );
  }),
  dos: create_language_async_loader_default("dos", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dos" */
      "./dos-XBWVQHGF.js"
    );
  }),
  dsconfig: create_language_async_loader_default("dsconfig", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dsconfig" */
      "./dsconfig-ZRUJ6ETU.js"
    );
  }),
  dts: create_language_async_loader_default("dts", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dts" */
      "./dts-WKRWLLZX.js"
    );
  }),
  dust: create_language_async_loader_default("dust", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dust" */
      "./dust-OBT32GKY.js"
    );
  }),
  ebnf: create_language_async_loader_default("ebnf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ebnf" */
      "./ebnf-RE7WXAGH.js"
    );
  }),
  elixir: create_language_async_loader_default("elixir", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_elixir" */
      "./elixir-DCJFUGH3.js"
    );
  }),
  elm: create_language_async_loader_default("elm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_elm" */
      "./elm-7PXHQPAQ.js"
    );
  }),
  erb: create_language_async_loader_default("erb", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_erb" */
      "./erb-JOCLPVYS.js"
    );
  }),
  erlangRepl: create_language_async_loader_default("erlangRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_erlangRepl" */
      "./erlang-repl-AG6I5MEG.js"
    );
  }),
  erlang: create_language_async_loader_default("erlang", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_erlang" */
      "./erlang-VYKMF4S2.js"
    );
  }),
  excel: create_language_async_loader_default("excel", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_excel" */
      "./excel-Z6HB5LHW.js"
    );
  }),
  fix: create_language_async_loader_default("fix", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_fix" */
      "./fix-YNQ3YMO2.js"
    );
  }),
  flix: create_language_async_loader_default("flix", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_flix" */
      "./flix-3KUETVA4.js"
    );
  }),
  fortran: create_language_async_loader_default("fortran", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_fortran" */
      "./fortran-5OISJ6NY.js"
    );
  }),
  fsharp: create_language_async_loader_default("fsharp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_fsharp" */
      "./fsharp-BZQNFZUZ.js"
    );
  }),
  gams: create_language_async_loader_default("gams", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gams" */
      "./gams-JWXA4OFR.js"
    );
  }),
  gauss: create_language_async_loader_default("gauss", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gauss" */
      "./gauss-2UWK6YGU.js"
    );
  }),
  gcode: create_language_async_loader_default("gcode", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gcode" */
      "./gcode-C42QXACX.js"
    );
  }),
  gherkin: create_language_async_loader_default("gherkin", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gherkin" */
      "./gherkin-XPPIPNCD.js"
    );
  }),
  glsl: create_language_async_loader_default("glsl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_glsl" */
      "./glsl-3GSME22C.js"
    );
  }),
  gml: create_language_async_loader_default("gml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gml" */
      "./gml-VUQ7UADV.js"
    );
  }),
  go: create_language_async_loader_default("go", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_go" */
      "./go-AO57TX3G.js"
    );
  }),
  golo: create_language_async_loader_default("golo", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_golo" */
      "./golo-SZ4XKMC3.js"
    );
  }),
  gradle: create_language_async_loader_default("gradle", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gradle" */
      "./gradle-HYYQZPR5.js"
    );
  }),
  groovy: create_language_async_loader_default("groovy", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_groovy" */
      "./groovy-ZC6U3HS4.js"
    );
  }),
  haml: create_language_async_loader_default("haml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_haml" */
      "./haml-EHPYPKC2.js"
    );
  }),
  handlebars: create_language_async_loader_default("handlebars", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_handlebars" */
      "./handlebars-FHDUUAD4.js"
    );
  }),
  haskell: create_language_async_loader_default("haskell", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_haskell" */
      "./haskell-UTWDQO6B.js"
    );
  }),
  haxe: create_language_async_loader_default("haxe", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_haxe" */
      "./haxe-HL72K6ZH.js"
    );
  }),
  hsp: create_language_async_loader_default("hsp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_hsp" */
      "./hsp-RI2DCUZI.js"
    );
  }),
  htmlbars: create_language_async_loader_default("htmlbars", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_htmlbars" */
      "./htmlbars-3GPC5KPW.js"
    );
  }),
  http: create_language_async_loader_default("http", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_http" */
      "./http-WQDTTQ36.js"
    );
  }),
  hy: create_language_async_loader_default("hy", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_hy" */
      "./hy-4EPYCXTX.js"
    );
  }),
  inform7: create_language_async_loader_default("inform7", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_inform7" */
      "./inform7-RTDOAP6T.js"
    );
  }),
  ini: create_language_async_loader_default("ini", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ini" */
      "./ini-JAAUTTC2.js"
    );
  }),
  irpf90: create_language_async_loader_default("irpf90", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_irpf90" */
      "./irpf90-XIZE74VA.js"
    );
  }),
  isbl: create_language_async_loader_default("isbl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_isbl" */
      "./isbl-XGEG2VEV.js"
    );
  }),
  java: create_language_async_loader_default("java", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_java" */
      "./java-NGSWJGMJ.js"
    );
  }),
  javascript: create_language_async_loader_default("javascript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_javascript" */
      "./javascript-Q6FB7DQM.js"
    );
  }),
  jbossCli: create_language_async_loader_default("jbossCli", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_jbossCli" */
      "./jboss-cli-SGFKYB66.js"
    );
  }),
  json: create_language_async_loader_default("json", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_json" */
      "./json-I2ZCFEEP.js"
    );
  }),
  juliaRepl: create_language_async_loader_default("juliaRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_juliaRepl" */
      "./julia-repl-K3YCTA4B.js"
    );
  }),
  julia: create_language_async_loader_default("julia", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_julia" */
      "./julia-2BQKV7NM.js"
    );
  }),
  kotlin: create_language_async_loader_default("kotlin", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_kotlin" */
      "./kotlin-COG6SJ3B.js"
    );
  }),
  lasso: create_language_async_loader_default("lasso", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_lasso" */
      "./lasso-DTLPTDYA.js"
    );
  }),
  latex: create_language_async_loader_default("latex", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_latex" */
      "./latex-W5VAKCX7.js"
    );
  }),
  ldif: create_language_async_loader_default("ldif", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ldif" */
      "./ldif-MWBGQ5XJ.js"
    );
  }),
  leaf: create_language_async_loader_default("leaf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_leaf" */
      "./leaf-4IXPWVJ3.js"
    );
  }),
  less: create_language_async_loader_default("less", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_less" */
      "./less-PFTPFP2X.js"
    );
  }),
  lisp: create_language_async_loader_default("lisp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_lisp" */
      "./lisp-FEPJJBBZ.js"
    );
  }),
  livecodeserver: create_language_async_loader_default("livecodeserver", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_livecodeserver" */
      "./livecodeserver-MIGJYWGS.js"
    );
  }),
  livescript: create_language_async_loader_default("livescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_livescript" */
      "./livescript-HERKZHC6.js"
    );
  }),
  llvm: create_language_async_loader_default("llvm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_llvm" */
      "./llvm-HWINXPHO.js"
    );
  }),
  lsl: create_language_async_loader_default("lsl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_lsl" */
      "./lsl-AK7VSDOY.js"
    );
  }),
  lua: create_language_async_loader_default("lua", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_lua" */
      "./lua-MBVGQFXP.js"
    );
  }),
  makefile: create_language_async_loader_default("makefile", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_makefile" */
      "./makefile-HULBSGIF.js"
    );
  }),
  markdown: create_language_async_loader_default("markdown", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_markdown" */
      "./markdown-X6O4MG54.js"
    );
  }),
  mathematica: create_language_async_loader_default("mathematica", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mathematica" */
      "./mathematica-NZIFVBBO.js"
    );
  }),
  matlab: create_language_async_loader_default("matlab", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_matlab" */
      "./matlab-AKNSNVVT.js"
    );
  }),
  maxima: create_language_async_loader_default("maxima", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_maxima" */
      "./maxima-LVID77K6.js"
    );
  }),
  mel: create_language_async_loader_default("mel", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mel" */
      "./mel-UMQDUS2C.js"
    );
  }),
  mercury: create_language_async_loader_default("mercury", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mercury" */
      "./mercury-D2GVZ5MW.js"
    );
  }),
  mipsasm: create_language_async_loader_default("mipsasm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mipsasm" */
      "./mipsasm-GOWYSIQP.js"
    );
  }),
  mizar: create_language_async_loader_default("mizar", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mizar" */
      "./mizar-Q3GSVSEN.js"
    );
  }),
  mojolicious: create_language_async_loader_default("mojolicious", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mojolicious" */
      "./mojolicious-RCURFZDD.js"
    );
  }),
  monkey: create_language_async_loader_default("monkey", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_monkey" */
      "./monkey-VG73KHVX.js"
    );
  }),
  moonscript: create_language_async_loader_default("moonscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_moonscript" */
      "./moonscript-LEDQHPR6.js"
    );
  }),
  n1ql: create_language_async_loader_default("n1ql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_n1ql" */
      "./n1ql-BLL5TSIE.js"
    );
  }),
  nginx: create_language_async_loader_default("nginx", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nginx" */
      "./nginx-JUNFMNJS.js"
    );
  }),
  nim: create_language_async_loader_default("nim", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nim" */
      "./nim-CVDYQJJO.js"
    );
  }),
  nix: create_language_async_loader_default("nix", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nix" */
      "./nix-T2CDJ7YG.js"
    );
  }),
  nodeRepl: create_language_async_loader_default("nodeRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nodeRepl" */
      "./node-repl-QHPIMDPV.js"
    );
  }),
  nsis: create_language_async_loader_default("nsis", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nsis" */
      "./nsis-ZVGMULDI.js"
    );
  }),
  objectivec: create_language_async_loader_default("objectivec", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_objectivec" */
      "./objectivec-N3WJTBD2.js"
    );
  }),
  ocaml: create_language_async_loader_default("ocaml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ocaml" */
      "./ocaml-I5QMKRJJ.js"
    );
  }),
  openscad: create_language_async_loader_default("openscad", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_openscad" */
      "./openscad-EIHAX62O.js"
    );
  }),
  oxygene: create_language_async_loader_default("oxygene", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_oxygene" */
      "./oxygene-DUC3UWIC.js"
    );
  }),
  parser3: create_language_async_loader_default("parser3", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_parser3" */
      "./parser3-IK25VITY.js"
    );
  }),
  perl: create_language_async_loader_default("perl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_perl" */
      "./perl-AFMIPHXC.js"
    );
  }),
  pf: create_language_async_loader_default("pf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_pf" */
      "./pf-AIQGM5RR.js"
    );
  }),
  pgsql: create_language_async_loader_default("pgsql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_pgsql" */
      "./pgsql-PEZ2QGY5.js"
    );
  }),
  phpTemplate: create_language_async_loader_default("phpTemplate", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_phpTemplate" */
      "./php-template-PGQ6Q4M3.js"
    );
  }),
  php: create_language_async_loader_default("php", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_php" */
      "./php-ZLO3PWLG.js"
    );
  }),
  plaintext: create_language_async_loader_default("plaintext", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_plaintext" */
      "./plaintext-NPVUUSFS.js"
    );
  }),
  pony: create_language_async_loader_default("pony", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_pony" */
      "./pony-4X4TWAKT.js"
    );
  }),
  powershell: create_language_async_loader_default("powershell", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_powershell" */
      "./powershell-WOPMXZJM.js"
    );
  }),
  processing: create_language_async_loader_default("processing", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_processing" */
      "./processing-M5DPPGNY.js"
    );
  }),
  profile: create_language_async_loader_default("profile", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_profile" */
      "./profile-5RBNE3Y3.js"
    );
  }),
  prolog: create_language_async_loader_default("prolog", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_prolog" */
      "./prolog-OCY5OXPO.js"
    );
  }),
  properties: create_language_async_loader_default("properties", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_properties" */
      "./properties-KPU5RVFB.js"
    );
  }),
  protobuf: create_language_async_loader_default("protobuf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_protobuf" */
      "./protobuf-MW6LAPKK.js"
    );
  }),
  puppet: create_language_async_loader_default("puppet", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_puppet" */
      "./puppet-HSII5NOM.js"
    );
  }),
  purebasic: create_language_async_loader_default("purebasic", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_purebasic" */
      "./purebasic-SFWAO25B.js"
    );
  }),
  pythonRepl: create_language_async_loader_default("pythonRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_pythonRepl" */
      "./python-repl-7YJSFNA3.js"
    );
  }),
  python: create_language_async_loader_default("python", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_python" */
      "./python-L4G2HDVH.js"
    );
  }),
  q: create_language_async_loader_default("q", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_q" */
      "./q-ZEZ4QU3X.js"
    );
  }),
  qml: create_language_async_loader_default("qml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_qml" */
      "./qml-MZCVGTA5.js"
    );
  }),
  r: create_language_async_loader_default("r", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_r" */
      "./r-5K7WZW37.js"
    );
  }),
  reasonml: create_language_async_loader_default("reasonml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_reasonml" */
      "./reasonml-LGQAIPO6.js"
    );
  }),
  rib: create_language_async_loader_default("rib", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_rib" */
      "./rib-O7JIVMEL.js"
    );
  }),
  roboconf: create_language_async_loader_default("roboconf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_roboconf" */
      "./roboconf-MDOUVCOE.js"
    );
  }),
  routeros: create_language_async_loader_default("routeros", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_routeros" */
      "./routeros-RVYJMTY7.js"
    );
  }),
  rsl: create_language_async_loader_default("rsl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_rsl" */
      "./rsl-K5KTQY26.js"
    );
  }),
  ruby: create_language_async_loader_default("ruby", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ruby" */
      "./ruby-NHD6A3J2.js"
    );
  }),
  ruleslanguage: create_language_async_loader_default("ruleslanguage", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ruleslanguage" */
      "./ruleslanguage-DDD5AQ2U.js"
    );
  }),
  rust: create_language_async_loader_default("rust", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_rust" */
      "./rust-5GCYAYPC.js"
    );
  }),
  sas: create_language_async_loader_default("sas", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sas" */
      "./sas-PGXNB6U7.js"
    );
  }),
  scala: create_language_async_loader_default("scala", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_scala" */
      "./scala-HSWUC3S4.js"
    );
  }),
  scheme: create_language_async_loader_default("scheme", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_scheme" */
      "./scheme-MXEDDEGA.js"
    );
  }),
  scilab: create_language_async_loader_default("scilab", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_scilab" */
      "./scilab-MLX7PIBL.js"
    );
  }),
  scss: create_language_async_loader_default("scss", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_scss" */
      "./scss-PD3ZAGJE.js"
    );
  }),
  shell: create_language_async_loader_default("shell", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_shell" */
      "./shell-MOWMWW2E.js"
    );
  }),
  smali: create_language_async_loader_default("smali", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_smali" */
      "./smali-KSYW4UK6.js"
    );
  }),
  smalltalk: create_language_async_loader_default("smalltalk", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_smalltalk" */
      "./smalltalk-C6FOXJK5.js"
    );
  }),
  sml: create_language_async_loader_default("sml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sml" */
      "./sml-K7T35BQB.js"
    );
  }),
  sqf: create_language_async_loader_default("sqf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sqf" */
      "./sqf-RMQ4NLGI.js"
    );
  }),
  sql: create_language_async_loader_default("sql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sql" */
      "./sql-WBX3MBRH.js"
    );
  }),
  sqlMore: create_language_async_loader_default("sqlMore", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sqlMore" */
      "./sql_more-YUUQT34E.js"
    );
  }),
  stan: create_language_async_loader_default("stan", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_stan" */
      "./stan-JLPPKIJM.js"
    );
  }),
  stata: create_language_async_loader_default("stata", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_stata" */
      "./stata-EJZ7JW4Y.js"
    );
  }),
  step21: create_language_async_loader_default("step21", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_step21" */
      "./step21-CZ7HJF3U.js"
    );
  }),
  stylus: create_language_async_loader_default("stylus", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_stylus" */
      "./stylus-CKAL6NLC.js"
    );
  }),
  subunit: create_language_async_loader_default("subunit", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_subunit" */
      "./subunit-AGP6RKUZ.js"
    );
  }),
  swift: create_language_async_loader_default("swift", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_swift" */
      "./swift-GZNKZZKP.js"
    );
  }),
  taggerscript: create_language_async_loader_default("taggerscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_taggerscript" */
      "./taggerscript-F5DSRMKJ.js"
    );
  }),
  tap: create_language_async_loader_default("tap", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_tap" */
      "./tap-7T63YQJ7.js"
    );
  }),
  tcl: create_language_async_loader_default("tcl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_tcl" */
      "./tcl-BO4FG6AT.js"
    );
  }),
  thrift: create_language_async_loader_default("thrift", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_thrift" */
      "./thrift-7DKI3ZKN.js"
    );
  }),
  tp: create_language_async_loader_default("tp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_tp" */
      "./tp-QSAPQST3.js"
    );
  }),
  twig: create_language_async_loader_default("twig", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_twig" */
      "./twig-T5XOVCOJ.js"
    );
  }),
  typescript: create_language_async_loader_default("typescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_typescript" */
      "./typescript-BEEXEOTT.js"
    );
  }),
  vala: create_language_async_loader_default("vala", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vala" */
      "./vala-XZ6AYKAU.js"
    );
  }),
  vbnet: create_language_async_loader_default("vbnet", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vbnet" */
      "./vbnet-JM252G7Y.js"
    );
  }),
  vbscriptHtml: create_language_async_loader_default("vbscriptHtml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vbscriptHtml" */
      "./vbscript-html-6XDXZTF5.js"
    );
  }),
  vbscript: create_language_async_loader_default("vbscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vbscript" */
      "./vbscript-2SMICTIM.js"
    );
  }),
  verilog: create_language_async_loader_default("verilog", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_verilog" */
      "./verilog-SEHCJ7HF.js"
    );
  }),
  vhdl: create_language_async_loader_default("vhdl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vhdl" */
      "./vhdl-SA4LRSLP.js"
    );
  }),
  vim: create_language_async_loader_default("vim", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vim" */
      "./vim-7LTXTVJ7.js"
    );
  }),
  x86asm: create_language_async_loader_default("x86asm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_x86asm" */
      "./x86asm-HWZCZNWI.js"
    );
  }),
  xl: create_language_async_loader_default("xl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_xl" */
      "./xl-XSFU6U4Z.js"
    );
  }),
  xml: create_language_async_loader_default("xml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_xml" */
      "./xml-OQXCRD24.js"
    );
  }),
  xquery: create_language_async_loader_default("xquery", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_xquery" */
      "./xquery-3LZ2ZC6A.js"
    );
  }),
  yaml: create_language_async_loader_default("yaml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_yaml" */
      "./yaml-3LQ2CYZF.js"
    );
  }),
  zephir: create_language_async_loader_default("zephir", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_zephir" */
      "./zephir-PLGVUPQT.js"
    );
  })
};

// node_modules/react-syntax-highlighter/dist/esm/light-async.js
var light_async_default = async_syntax_highlighter_default({
  loader: function loader() {
    return import(
      /* webpackChunkName:"react-syntax-highlighter/lowlight-import" */
      "./core-VATSBYYL.js"
    ).then(function(module) {
      return module["default"] || module;
    });
  },
  isLanguageRegistered: function isLanguageRegistered(instance, language2) {
    return !!checkForListedLanguage_default(instance, language2);
  },
  languageLoaders: hljs_default,
  registerLanguage: function registerLanguage(instance, name2, language2) {
    return instance.registerLanguage(name2, language2);
  }
});

// node_modules/react-syntax-highlighter/dist/esm/light.js
var import_core5 = __toESM(require_core());
var SyntaxHighlighter = highlight_default(import_core5.default, {});
SyntaxHighlighter.registerLanguage = import_core5.default.registerLanguage;

// node_modules/react-syntax-highlighter/dist/esm/async-languages/prism.js
var prism_default = {
  abap: create_language_async_loader_default("abap", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_abap" */
      "./abap-JYBKJ5EJ.js"
    );
  }),
  abnf: create_language_async_loader_default("abnf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_abnf" */
      "./abnf-HCA3DW5A.js"
    );
  }),
  actionscript: create_language_async_loader_default("actionscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_actionscript" */
      "./actionscript-TN3Z2R7J.js"
    );
  }),
  ada: create_language_async_loader_default("ada", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_ada" */
      "./ada-VX7DOO6M.js"
    );
  }),
  agda: create_language_async_loader_default("agda", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_agda" */
      "./agda-O7TNXFRX.js"
    );
  }),
  al: create_language_async_loader_default("al", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_al" */
      "./al-AJEMUUVY.js"
    );
  }),
  antlr4: create_language_async_loader_default("antlr4", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_antlr4" */
      "./antlr4-PN363AKD.js"
    );
  }),
  apacheconf: create_language_async_loader_default("apacheconf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_apacheconf" */
      "./apacheconf-AXW3HMEO.js"
    );
  }),
  apex: create_language_async_loader_default("apex", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_apex" */
      "./apex-MG4VXFI5.js"
    );
  }),
  apl: create_language_async_loader_default("apl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_apl" */
      "./apl-NXO4XUPQ.js"
    );
  }),
  applescript: create_language_async_loader_default("applescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_applescript" */
      "./applescript-OLRNL5VP.js"
    );
  }),
  aql: create_language_async_loader_default("aql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_aql" */
      "./aql-TQRX5TMV.js"
    );
  }),
  arduino: create_language_async_loader_default("arduino", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_arduino" */
      "./arduino-N3JS5LOT.js"
    );
  }),
  arff: create_language_async_loader_default("arff", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_arff" */
      "./arff-Q43FPGC2.js"
    );
  }),
  asciidoc: create_language_async_loader_default("asciidoc", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_asciidoc" */
      "./asciidoc-HLPP7YHF.js"
    );
  }),
  asm6502: create_language_async_loader_default("asm6502", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_asm6502" */
      "./asm6502-BRVPWQC5.js"
    );
  }),
  asmatmel: create_language_async_loader_default("asmatmel", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_asmatmel" */
      "./asmatmel-7TRZOG6J.js"
    );
  }),
  aspnet: create_language_async_loader_default("aspnet", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_aspnet" */
      "./aspnet-7KVGAMXF.js"
    );
  }),
  autohotkey: create_language_async_loader_default("autohotkey", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_autohotkey" */
      "./autohotkey-RWNNJUHS.js"
    );
  }),
  autoit: create_language_async_loader_default("autoit", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_autoit" */
      "./autoit-L5DP2V6T.js"
    );
  }),
  avisynth: create_language_async_loader_default("avisynth", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_avisynth" */
      "./avisynth-NAI7VX42.js"
    );
  }),
  avroIdl: create_language_async_loader_default("avroIdl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_avroIdl" */
      "./avro-idl-26IDRRP3.js"
    );
  }),
  bash: create_language_async_loader_default("bash", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_bash" */
      "./bash-HN7JI7RB.js"
    );
  }),
  basic: create_language_async_loader_default("basic", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_basic" */
      "./basic-7E7WVX7R.js"
    );
  }),
  batch: create_language_async_loader_default("batch", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_batch" */
      "./batch-O5ZBAANU.js"
    );
  }),
  bbcode: create_language_async_loader_default("bbcode", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_bbcode" */
      "./bbcode-RM6EMWJ4.js"
    );
  }),
  bicep: create_language_async_loader_default("bicep", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_bicep" */
      "./bicep-ZEFFHYI6.js"
    );
  }),
  birb: create_language_async_loader_default("birb", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_birb" */
      "./birb-MGU5PENX.js"
    );
  }),
  bison: create_language_async_loader_default("bison", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_bison" */
      "./bison-XGLH2AFE.js"
    );
  }),
  bnf: create_language_async_loader_default("bnf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_bnf" */
      "./bnf-ZCCC72VY.js"
    );
  }),
  brainfuck: create_language_async_loader_default("brainfuck", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_brainfuck" */
      "./brainfuck-R475P37Q.js"
    );
  }),
  brightscript: create_language_async_loader_default("brightscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_brightscript" */
      "./brightscript-NXK652UI.js"
    );
  }),
  bro: create_language_async_loader_default("bro", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_bro" */
      "./bro-ZBYRSUHR.js"
    );
  }),
  bsl: create_language_async_loader_default("bsl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_bsl" */
      "./bsl-F6WEJ6FR.js"
    );
  }),
  c: create_language_async_loader_default("c", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_c" */
      "./c-NVVLGWUK.js"
    );
  }),
  cfscript: create_language_async_loader_default("cfscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_cfscript" */
      "./cfscript-WHSM56Z5.js"
    );
  }),
  chaiscript: create_language_async_loader_default("chaiscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_chaiscript" */
      "./chaiscript-OPZJTEZD.js"
    );
  }),
  cil: create_language_async_loader_default("cil", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_cil" */
      "./cil-LZYWSFGD.js"
    );
  }),
  clike: create_language_async_loader_default("clike", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_clike" */
      "./clike-OCLA5OWS.js"
    );
  }),
  clojure: create_language_async_loader_default("clojure", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_clojure" */
      "./clojure-CWSE3VYA.js"
    );
  }),
  cmake: create_language_async_loader_default("cmake", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_cmake" */
      "./cmake-3BJRX2SF.js"
    );
  }),
  cobol: create_language_async_loader_default("cobol", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_cobol" */
      "./cobol-6CYUAPMF.js"
    );
  }),
  coffeescript: create_language_async_loader_default("coffeescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_coffeescript" */
      "./coffeescript-LZGM7VG7.js"
    );
  }),
  concurnas: create_language_async_loader_default("concurnas", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_concurnas" */
      "./concurnas-RAGTDQMN.js"
    );
  }),
  coq: create_language_async_loader_default("coq", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_coq" */
      "./coq-ODJCH2KB.js"
    );
  }),
  cpp: create_language_async_loader_default("cpp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_cpp" */
      "./cpp-B4MG67X3.js"
    );
  }),
  crystal: create_language_async_loader_default("crystal", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_crystal" */
      "./crystal-NNFBHSYT.js"
    );
  }),
  csharp: create_language_async_loader_default("csharp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_csharp" */
      "./csharp-ZHFAJ5I3.js"
    );
  }),
  cshtml: create_language_async_loader_default("cshtml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_cshtml" */
      "./cshtml-NNCAA6YW.js"
    );
  }),
  csp: create_language_async_loader_default("csp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_csp" */
      "./csp-EJ7JWWN4.js"
    );
  }),
  cssExtras: create_language_async_loader_default("cssExtras", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_cssExtras" */
      "./css-extras-TYGUN5X6.js"
    );
  }),
  css: create_language_async_loader_default("css", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_css" */
      "./css-WNBSNHNI.js"
    );
  }),
  csv: create_language_async_loader_default("csv", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_csv" */
      "./csv-DG6KAMQP.js"
    );
  }),
  cypher: create_language_async_loader_default("cypher", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_cypher" */
      "./cypher-YD3H6X36.js"
    );
  }),
  d: create_language_async_loader_default("d", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_d" */
      "./d-G6TS7K4Q.js"
    );
  }),
  dart: create_language_async_loader_default("dart", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_dart" */
      "./dart-4ZMFZUG4.js"
    );
  }),
  dataweave: create_language_async_loader_default("dataweave", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_dataweave" */
      "./dataweave-SWISNJCC.js"
    );
  }),
  dax: create_language_async_loader_default("dax", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_dax" */
      "./dax-MJGTOIXI.js"
    );
  }),
  dhall: create_language_async_loader_default("dhall", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_dhall" */
      "./dhall-YOLOZC5X.js"
    );
  }),
  diff: create_language_async_loader_default("diff", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_diff" */
      "./diff-7EZTT4SI.js"
    );
  }),
  django: create_language_async_loader_default("django", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_django" */
      "./django-Q4XNGUSY.js"
    );
  }),
  dnsZoneFile: create_language_async_loader_default("dnsZoneFile", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_dnsZoneFile" */
      "./dns-zone-file-CGXYGQJJ.js"
    );
  }),
  docker: create_language_async_loader_default("docker", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_docker" */
      "./docker-L6GBWZ4M.js"
    );
  }),
  dot: create_language_async_loader_default("dot", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_dot" */
      "./dot-A5N3R63P.js"
    );
  }),
  ebnf: create_language_async_loader_default("ebnf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_ebnf" */
      "./ebnf-HEXJF76W.js"
    );
  }),
  editorconfig: create_language_async_loader_default("editorconfig", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_editorconfig" */
      "./editorconfig-TG33D4YS.js"
    );
  }),
  eiffel: create_language_async_loader_default("eiffel", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_eiffel" */
      "./eiffel-ACWLM6CC.js"
    );
  }),
  ejs: create_language_async_loader_default("ejs", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_ejs" */
      "./ejs-55C46Q55.js"
    );
  }),
  elixir: create_language_async_loader_default("elixir", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_elixir" */
      "./elixir-M7MUQPLA.js"
    );
  }),
  elm: create_language_async_loader_default("elm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_elm" */
      "./elm-VJLK5GNE.js"
    );
  }),
  erb: create_language_async_loader_default("erb", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_erb" */
      "./erb-TFJZ3PIW.js"
    );
  }),
  erlang: create_language_async_loader_default("erlang", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_erlang" */
      "./erlang-S7Q7ZJBQ.js"
    );
  }),
  etlua: create_language_async_loader_default("etlua", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_etlua" */
      "./etlua-PVOSU5BE.js"
    );
  }),
  excelFormula: create_language_async_loader_default("excelFormula", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_excelFormula" */
      "./excel-formula-DXJYE22E.js"
    );
  }),
  factor: create_language_async_loader_default("factor", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_factor" */
      "./factor-2HOVT73L.js"
    );
  }),
  falselang: create_language_async_loader_default("falselang", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_falselang" */
      "./false-PF5YXZN2.js"
    );
  }),
  firestoreSecurityRules: create_language_async_loader_default("firestoreSecurityRules", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_firestoreSecurityRules" */
      "./firestore-security-rules-BRIFLBWI.js"
    );
  }),
  flow: create_language_async_loader_default("flow", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_flow" */
      "./flow-OFPDEJP7.js"
    );
  }),
  fortran: create_language_async_loader_default("fortran", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_fortran" */
      "./fortran-OJ65BR56.js"
    );
  }),
  fsharp: create_language_async_loader_default("fsharp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_fsharp" */
      "./fsharp-GDY5YO4S.js"
    );
  }),
  ftl: create_language_async_loader_default("ftl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_ftl" */
      "./ftl-7LMOFWEM.js"
    );
  }),
  gap: create_language_async_loader_default("gap", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_gap" */
      "./gap-WWN7FDKK.js"
    );
  }),
  gcode: create_language_async_loader_default("gcode", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_gcode" */
      "./gcode-JBY3DORB.js"
    );
  }),
  gdscript: create_language_async_loader_default("gdscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_gdscript" */
      "./gdscript-INZR5LZ3.js"
    );
  }),
  gedcom: create_language_async_loader_default("gedcom", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_gedcom" */
      "./gedcom-NHGUPNDJ.js"
    );
  }),
  gherkin: create_language_async_loader_default("gherkin", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_gherkin" */
      "./gherkin-LZDZD2RZ.js"
    );
  }),
  git: create_language_async_loader_default("git", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_git" */
      "./git-WI3MFYNT.js"
    );
  }),
  glsl: create_language_async_loader_default("glsl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_glsl" */
      "./glsl-MAX4JQ5T.js"
    );
  }),
  gml: create_language_async_loader_default("gml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_gml" */
      "./gml-M54A756O.js"
    );
  }),
  gn: create_language_async_loader_default("gn", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_gn" */
      "./gn-BYQQEPIL.js"
    );
  }),
  goModule: create_language_async_loader_default("goModule", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_goModule" */
      "./go-module-DE6V3MQS.js"
    );
  }),
  go: create_language_async_loader_default("go", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_go" */
      "./go-GOGSRAOK.js"
    );
  }),
  graphql: create_language_async_loader_default("graphql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_graphql" */
      "./graphql-N4ESGC3Q.js"
    );
  }),
  groovy: create_language_async_loader_default("groovy", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_groovy" */
      "./groovy-56YESK6G.js"
    );
  }),
  haml: create_language_async_loader_default("haml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_haml" */
      "./haml-LYIYM3WW.js"
    );
  }),
  handlebars: create_language_async_loader_default("handlebars", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_handlebars" */
      "./handlebars-HHV3PXLZ.js"
    );
  }),
  haskell: create_language_async_loader_default("haskell", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_haskell" */
      "./haskell-OA7TBD6O.js"
    );
  }),
  haxe: create_language_async_loader_default("haxe", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_haxe" */
      "./haxe-MMGEGGR2.js"
    );
  }),
  hcl: create_language_async_loader_default("hcl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_hcl" */
      "./hcl-6XLE2M4K.js"
    );
  }),
  hlsl: create_language_async_loader_default("hlsl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_hlsl" */
      "./hlsl-JEGPHR7P.js"
    );
  }),
  hoon: create_language_async_loader_default("hoon", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_hoon" */
      "./hoon-5AGSBXUH.js"
    );
  }),
  hpkp: create_language_async_loader_default("hpkp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_hpkp" */
      "./hpkp-BZTWQSH7.js"
    );
  }),
  hsts: create_language_async_loader_default("hsts", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_hsts" */
      "./hsts-G6NFVWDD.js"
    );
  }),
  http: create_language_async_loader_default("http", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_http" */
      "./http-E7BPCS6I.js"
    );
  }),
  ichigojam: create_language_async_loader_default("ichigojam", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_ichigojam" */
      "./ichigojam-XP4OXGP3.js"
    );
  }),
  icon: create_language_async_loader_default("icon", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_icon" */
      "./icon-TBIEXOIT.js"
    );
  }),
  icuMessageFormat: create_language_async_loader_default("icuMessageFormat", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_icuMessageFormat" */
      "./icu-message-format-PI64SVKP.js"
    );
  }),
  idris: create_language_async_loader_default("idris", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_idris" */
      "./idris-XTJ3FOT2.js"
    );
  }),
  iecst: create_language_async_loader_default("iecst", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_iecst" */
      "./iecst-J6V7INE5.js"
    );
  }),
  ignore: create_language_async_loader_default("ignore", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_ignore" */
      "./ignore-6ZPWHW4J.js"
    );
  }),
  inform7: create_language_async_loader_default("inform7", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_inform7" */
      "./inform7-DY7NRPYJ.js"
    );
  }),
  ini: create_language_async_loader_default("ini", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_ini" */
      "./ini-47RPKUQV.js"
    );
  }),
  io: create_language_async_loader_default("io", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_io" */
      "./io-E2S75PUD.js"
    );
  }),
  j: create_language_async_loader_default("j", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_j" */
      "./j-LQHGHS2H.js"
    );
  }),
  java: create_language_async_loader_default("java", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_java" */
      "./java-UXQARQV7.js"
    );
  }),
  javadoc: create_language_async_loader_default("javadoc", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_javadoc" */
      "./javadoc-6AFXRN63.js"
    );
  }),
  javadoclike: create_language_async_loader_default("javadoclike", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_javadoclike" */
      "./javadoclike-M4JODDC4.js"
    );
  }),
  javascript: create_language_async_loader_default("javascript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_javascript" */
      "./javascript-Z65IW7M6.js"
    );
  }),
  javastacktrace: create_language_async_loader_default("javastacktrace", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_javastacktrace" */
      "./javastacktrace-NWSPUMMN.js"
    );
  }),
  jexl: create_language_async_loader_default("jexl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_jexl" */
      "./jexl-GDO6BXGU.js"
    );
  }),
  jolie: create_language_async_loader_default("jolie", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_jolie" */
      "./jolie-HE2SO4QE.js"
    );
  }),
  jq: create_language_async_loader_default("jq", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_jq" */
      "./jq-JZ2L7MPM.js"
    );
  }),
  jsExtras: create_language_async_loader_default("jsExtras", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_jsExtras" */
      "./js-extras-4CWD4FHY.js"
    );
  }),
  jsTemplates: create_language_async_loader_default("jsTemplates", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_jsTemplates" */
      "./js-templates-CPNLXEMX.js"
    );
  }),
  jsdoc: create_language_async_loader_default("jsdoc", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_jsdoc" */
      "./jsdoc-C244PNZW.js"
    );
  }),
  json: create_language_async_loader_default("json", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_json" */
      "./json-MQU6XM76.js"
    );
  }),
  json5: create_language_async_loader_default("json5", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_json5" */
      "./json5-AP3IYNHT.js"
    );
  }),
  jsonp: create_language_async_loader_default("jsonp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_jsonp" */
      "./jsonp-YCNZBFX2.js"
    );
  }),
  jsstacktrace: create_language_async_loader_default("jsstacktrace", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_jsstacktrace" */
      "./jsstacktrace-OXUYGMO5.js"
    );
  }),
  jsx: create_language_async_loader_default("jsx", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_jsx" */
      "./jsx-V2AVXPEE.js"
    );
  }),
  julia: create_language_async_loader_default("julia", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_julia" */
      "./julia-PZMXSXUS.js"
    );
  }),
  keepalived: create_language_async_loader_default("keepalived", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_keepalived" */
      "./keepalived-KY57WIIL.js"
    );
  }),
  keyman: create_language_async_loader_default("keyman", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_keyman" */
      "./keyman-PVNW7S6P.js"
    );
  }),
  kotlin: create_language_async_loader_default("kotlin", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_kotlin" */
      "./kotlin-F7KGWR7Q.js"
    );
  }),
  kumir: create_language_async_loader_default("kumir", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_kumir" */
      "./kumir-3K6NIT6G.js"
    );
  }),
  kusto: create_language_async_loader_default("kusto", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_kusto" */
      "./kusto-PPJDMD72.js"
    );
  }),
  latex: create_language_async_loader_default("latex", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_latex" */
      "./latex-SZTTDNP3.js"
    );
  }),
  latte: create_language_async_loader_default("latte", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_latte" */
      "./latte-WFQAHQOU.js"
    );
  }),
  less: create_language_async_loader_default("less", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_less" */
      "./less-632AO64X.js"
    );
  }),
  lilypond: create_language_async_loader_default("lilypond", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_lilypond" */
      "./lilypond-KPVJV6TT.js"
    );
  }),
  liquid: create_language_async_loader_default("liquid", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_liquid" */
      "./liquid-UHSAFOST.js"
    );
  }),
  lisp: create_language_async_loader_default("lisp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_lisp" */
      "./lisp-FVWEEUBV.js"
    );
  }),
  livescript: create_language_async_loader_default("livescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_livescript" */
      "./livescript-7ENNHSSN.js"
    );
  }),
  llvm: create_language_async_loader_default("llvm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_llvm" */
      "./llvm-CQNEDS6P.js"
    );
  }),
  log: create_language_async_loader_default("log", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_log" */
      "./log-V4PUINN4.js"
    );
  }),
  lolcode: create_language_async_loader_default("lolcode", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_lolcode" */
      "./lolcode-RXI4K6NZ.js"
    );
  }),
  lua: create_language_async_loader_default("lua", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_lua" */
      "./lua-UYPWPUGT.js"
    );
  }),
  magma: create_language_async_loader_default("magma", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_magma" */
      "./magma-6LHIDDYF.js"
    );
  }),
  makefile: create_language_async_loader_default("makefile", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_makefile" */
      "./makefile-KRFBQGPN.js"
    );
  }),
  markdown: create_language_async_loader_default("markdown", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_markdown" */
      "./markdown-SSKCK3KD.js"
    );
  }),
  markupTemplating: create_language_async_loader_default("markupTemplating", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_markupTemplating" */
      "./markup-templating-AIY3DNYE.js"
    );
  }),
  markup: create_language_async_loader_default("markup", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_markup" */
      "./markup-SCTMF7C6.js"
    );
  }),
  matlab: create_language_async_loader_default("matlab", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_matlab" */
      "./matlab-DB6BTYUN.js"
    );
  }),
  maxscript: create_language_async_loader_default("maxscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_maxscript" */
      "./maxscript-OHSQXEHA.js"
    );
  }),
  mel: create_language_async_loader_default("mel", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_mel" */
      "./mel-2F4CQRFB.js"
    );
  }),
  mermaid: create_language_async_loader_default("mermaid", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_mermaid" */
      "./mermaid-XLWU5VZP.js"
    );
  }),
  mizar: create_language_async_loader_default("mizar", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_mizar" */
      "./mizar-6UZGK52E.js"
    );
  }),
  mongodb: create_language_async_loader_default("mongodb", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_mongodb" */
      "./mongodb-E6I7JY4R.js"
    );
  }),
  monkey: create_language_async_loader_default("monkey", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_monkey" */
      "./monkey-77NA4F3G.js"
    );
  }),
  moonscript: create_language_async_loader_default("moonscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_moonscript" */
      "./moonscript-CF75AP2J.js"
    );
  }),
  n1ql: create_language_async_loader_default("n1ql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_n1ql" */
      "./n1ql-55ZSXDHQ.js"
    );
  }),
  n4js: create_language_async_loader_default("n4js", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_n4js" */
      "./n4js-3ED7VTEH.js"
    );
  }),
  nand2tetrisHdl: create_language_async_loader_default("nand2tetrisHdl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_nand2tetrisHdl" */
      "./nand2tetris-hdl-AHTQL6SO.js"
    );
  }),
  naniscript: create_language_async_loader_default("naniscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_naniscript" */
      "./naniscript-QUYQOBCI.js"
    );
  }),
  nasm: create_language_async_loader_default("nasm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_nasm" */
      "./nasm-KBVNAUPI.js"
    );
  }),
  neon: create_language_async_loader_default("neon", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_neon" */
      "./neon-BYRTOCJS.js"
    );
  }),
  nevod: create_language_async_loader_default("nevod", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_nevod" */
      "./nevod-QQ5JPVKE.js"
    );
  }),
  nginx: create_language_async_loader_default("nginx", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_nginx" */
      "./nginx-FD5HIVR7.js"
    );
  }),
  nim: create_language_async_loader_default("nim", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_nim" */
      "./nim-4ACLPU7T.js"
    );
  }),
  nix: create_language_async_loader_default("nix", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_nix" */
      "./nix-OML3KF3D.js"
    );
  }),
  nsis: create_language_async_loader_default("nsis", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_nsis" */
      "./nsis-7XB5UUQP.js"
    );
  }),
  objectivec: create_language_async_loader_default("objectivec", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_objectivec" */
      "./objectivec-JUT4EYVE.js"
    );
  }),
  ocaml: create_language_async_loader_default("ocaml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_ocaml" */
      "./ocaml-2HNYGFCM.js"
    );
  }),
  opencl: create_language_async_loader_default("opencl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_opencl" */
      "./opencl-SCXXD3UL.js"
    );
  }),
  openqasm: create_language_async_loader_default("openqasm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_openqasm" */
      "./openqasm-X2HEXVFE.js"
    );
  }),
  oz: create_language_async_loader_default("oz", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_oz" */
      "./oz-AJMYVCIJ.js"
    );
  }),
  parigp: create_language_async_loader_default("parigp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_parigp" */
      "./parigp-K5RRFGC2.js"
    );
  }),
  parser: create_language_async_loader_default("parser", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_parser" */
      "./parser-MM6HJJ4E.js"
    );
  }),
  pascal: create_language_async_loader_default("pascal", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_pascal" */
      "./pascal-L2CA6PWI.js"
    );
  }),
  pascaligo: create_language_async_loader_default("pascaligo", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_pascaligo" */
      "./pascaligo-473DWISV.js"
    );
  }),
  pcaxis: create_language_async_loader_default("pcaxis", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_pcaxis" */
      "./pcaxis-QKI2LTM7.js"
    );
  }),
  peoplecode: create_language_async_loader_default("peoplecode", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_peoplecode" */
      "./peoplecode-DHB3W22F.js"
    );
  }),
  perl: create_language_async_loader_default("perl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_perl" */
      "./perl-MQTHBDWX.js"
    );
  }),
  phpExtras: create_language_async_loader_default("phpExtras", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_phpExtras" */
      "./php-extras-QLFQQAGY.js"
    );
  }),
  php: create_language_async_loader_default("php", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_php" */
      "./php-YTTSSXYW.js"
    );
  }),
  phpdoc: create_language_async_loader_default("phpdoc", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_phpdoc" */
      "./phpdoc-LE6NMSOS.js"
    );
  }),
  plsql: create_language_async_loader_default("plsql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_plsql" */
      "./plsql-NWT54VBC.js"
    );
  }),
  powerquery: create_language_async_loader_default("powerquery", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_powerquery" */
      "./powerquery-7EZSSAJC.js"
    );
  }),
  powershell: create_language_async_loader_default("powershell", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_powershell" */
      "./powershell-WM4WWZZU.js"
    );
  }),
  processing: create_language_async_loader_default("processing", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_processing" */
      "./processing-SFH35MMG.js"
    );
  }),
  prolog: create_language_async_loader_default("prolog", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_prolog" */
      "./prolog-325CLFP3.js"
    );
  }),
  promql: create_language_async_loader_default("promql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_promql" */
      "./promql-QZXLHVG6.js"
    );
  }),
  properties: create_language_async_loader_default("properties", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_properties" */
      "./properties-RPY4PNFN.js"
    );
  }),
  protobuf: create_language_async_loader_default("protobuf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_protobuf" */
      "./protobuf-SHAFCTZJ.js"
    );
  }),
  psl: create_language_async_loader_default("psl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_psl" */
      "./psl-MRPF6627.js"
    );
  }),
  pug: create_language_async_loader_default("pug", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_pug" */
      "./pug-QDDUJTDL.js"
    );
  }),
  puppet: create_language_async_loader_default("puppet", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_puppet" */
      "./puppet-4TB6XVHZ.js"
    );
  }),
  pure: create_language_async_loader_default("pure", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_pure" */
      "./pure-RCX756FK.js"
    );
  }),
  purebasic: create_language_async_loader_default("purebasic", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_purebasic" */
      "./purebasic-HRSCSMH6.js"
    );
  }),
  purescript: create_language_async_loader_default("purescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_purescript" */
      "./purescript-P6GGU4AT.js"
    );
  }),
  python: create_language_async_loader_default("python", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_python" */
      "./python-VMBMZA4Q.js"
    );
  }),
  q: create_language_async_loader_default("q", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_q" */
      "./q-IYVLQCDY.js"
    );
  }),
  qml: create_language_async_loader_default("qml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_qml" */
      "./qml-3U6GG54M.js"
    );
  }),
  qore: create_language_async_loader_default("qore", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_qore" */
      "./qore-E2GITTIE.js"
    );
  }),
  qsharp: create_language_async_loader_default("qsharp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_qsharp" */
      "./qsharp-LAEMYH5I.js"
    );
  }),
  r: create_language_async_loader_default("r", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_r" */
      "./r-FPB6C4LY.js"
    );
  }),
  racket: create_language_async_loader_default("racket", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_racket" */
      "./racket-LNIVTBGV.js"
    );
  }),
  reason: create_language_async_loader_default("reason", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_reason" */
      "./reason-RQKTOSJK.js"
    );
  }),
  regex: create_language_async_loader_default("regex", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_regex" */
      "./regex-A3F4LZAO.js"
    );
  }),
  rego: create_language_async_loader_default("rego", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_rego" */
      "./rego-EBI7AHJ2.js"
    );
  }),
  renpy: create_language_async_loader_default("renpy", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_renpy" */
      "./renpy-AUCDGX47.js"
    );
  }),
  rest: create_language_async_loader_default("rest", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_rest" */
      "./rest-RBVUUS3B.js"
    );
  }),
  rip: create_language_async_loader_default("rip", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_rip" */
      "./rip-TIBZA36N.js"
    );
  }),
  roboconf: create_language_async_loader_default("roboconf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_roboconf" */
      "./roboconf-FNRZW57T.js"
    );
  }),
  robotframework: create_language_async_loader_default("robotframework", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_robotframework" */
      "./robotframework-QKZU46JR.js"
    );
  }),
  ruby: create_language_async_loader_default("ruby", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_ruby" */
      "./ruby-TBU7GPEL.js"
    );
  }),
  rust: create_language_async_loader_default("rust", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_rust" */
      "./rust-4O2X6W6M.js"
    );
  }),
  sas: create_language_async_loader_default("sas", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_sas" */
      "./sas-LUMYE2JM.js"
    );
  }),
  sass: create_language_async_loader_default("sass", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_sass" */
      "./sass-DG3HUOTV.js"
    );
  }),
  scala: create_language_async_loader_default("scala", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_scala" */
      "./scala-U2UKKXBD.js"
    );
  }),
  scheme: create_language_async_loader_default("scheme", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_scheme" */
      "./scheme-S3QFMI35.js"
    );
  }),
  scss: create_language_async_loader_default("scss", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_scss" */
      "./scss-DXC6NW6O.js"
    );
  }),
  shellSession: create_language_async_loader_default("shellSession", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_shellSession" */
      "./shell-session-7Q6AKWVN.js"
    );
  }),
  smali: create_language_async_loader_default("smali", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_smali" */
      "./smali-EDHKE5ET.js"
    );
  }),
  smalltalk: create_language_async_loader_default("smalltalk", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_smalltalk" */
      "./smalltalk-BUPBVICL.js"
    );
  }),
  smarty: create_language_async_loader_default("smarty", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_smarty" */
      "./smarty-5ZVGT7JK.js"
    );
  }),
  sml: create_language_async_loader_default("sml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_sml" */
      "./sml-WQOM7TJP.js"
    );
  }),
  solidity: create_language_async_loader_default("solidity", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_solidity" */
      "./solidity-SBJOXCWJ.js"
    );
  }),
  solutionFile: create_language_async_loader_default("solutionFile", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_solutionFile" */
      "./solution-file-5YTZVLK4.js"
    );
  }),
  soy: create_language_async_loader_default("soy", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_soy" */
      "./soy-NK4VIRKW.js"
    );
  }),
  sparql: create_language_async_loader_default("sparql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_sparql" */
      "./sparql-MK4AFUIO.js"
    );
  }),
  splunkSpl: create_language_async_loader_default("splunkSpl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_splunkSpl" */
      "./splunk-spl-J5TD72UI.js"
    );
  }),
  sqf: create_language_async_loader_default("sqf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_sqf" */
      "./sqf-2QVL47PU.js"
    );
  }),
  sql: create_language_async_loader_default("sql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_sql" */
      "./sql-NY2MEO7N.js"
    );
  }),
  squirrel: create_language_async_loader_default("squirrel", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_squirrel" */
      "./squirrel-GPVWI77K.js"
    );
  }),
  stan: create_language_async_loader_default("stan", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_stan" */
      "./stan-JO3YI2MO.js"
    );
  }),
  stylus: create_language_async_loader_default("stylus", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_stylus" */
      "./stylus-ZJBBWMKH.js"
    );
  }),
  swift: create_language_async_loader_default("swift", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_swift" */
      "./swift-BM3IWT4A.js"
    );
  }),
  systemd: create_language_async_loader_default("systemd", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_systemd" */
      "./systemd-U25CLQ7E.js"
    );
  }),
  t4Cs: create_language_async_loader_default("t4Cs", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_t4Cs" */
      "./t4-cs-T2GJZ6AI.js"
    );
  }),
  t4Templating: create_language_async_loader_default("t4Templating", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_t4Templating" */
      "./t4-templating-GYDSTGWR.js"
    );
  }),
  t4Vb: create_language_async_loader_default("t4Vb", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_t4Vb" */
      "./t4-vb-OHF7ZCGP.js"
    );
  }),
  tap: create_language_async_loader_default("tap", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_tap" */
      "./tap-O3LQ2OAK.js"
    );
  }),
  tcl: create_language_async_loader_default("tcl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_tcl" */
      "./tcl-OLSVWCVT.js"
    );
  }),
  textile: create_language_async_loader_default("textile", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_textile" */
      "./textile-IGDXT3KU.js"
    );
  }),
  toml: create_language_async_loader_default("toml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_toml" */
      "./toml-NGY5HROR.js"
    );
  }),
  tremor: create_language_async_loader_default("tremor", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_tremor" */
      "./tremor-L7FBHM2H.js"
    );
  }),
  tsx: create_language_async_loader_default("tsx", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_tsx" */
      "./tsx-GQP2HHCY.js"
    );
  }),
  tt2: create_language_async_loader_default("tt2", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_tt2" */
      "./tt2-UDUAMR6W.js"
    );
  }),
  turtle: create_language_async_loader_default("turtle", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_turtle" */
      "./turtle-DOR7MPW5.js"
    );
  }),
  twig: create_language_async_loader_default("twig", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_twig" */
      "./twig-CXP77K3R.js"
    );
  }),
  typescript: create_language_async_loader_default("typescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_typescript" */
      "./typescript-KBZS5NSQ.js"
    );
  }),
  typoscript: create_language_async_loader_default("typoscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_typoscript" */
      "./typoscript-6LAFNCJF.js"
    );
  }),
  unrealscript: create_language_async_loader_default("unrealscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_unrealscript" */
      "./unrealscript-MAZXRG4S.js"
    );
  }),
  uorazor: create_language_async_loader_default("uorazor", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_uorazor" */
      "./uorazor-433FPKQR.js"
    );
  }),
  uri: create_language_async_loader_default("uri", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_uri" */
      "./uri-TBBN7A77.js"
    );
  }),
  v: create_language_async_loader_default("v", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_v" */
      "./v-G6EMVIHB.js"
    );
  }),
  vala: create_language_async_loader_default("vala", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_vala" */
      "./vala-BWCPWKQY.js"
    );
  }),
  vbnet: create_language_async_loader_default("vbnet", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_vbnet" */
      "./vbnet-R7EB5JGX.js"
    );
  }),
  velocity: create_language_async_loader_default("velocity", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_velocity" */
      "./velocity-KGWTWWMY.js"
    );
  }),
  verilog: create_language_async_loader_default("verilog", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_verilog" */
      "./verilog-XINJP4KX.js"
    );
  }),
  vhdl: create_language_async_loader_default("vhdl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_vhdl" */
      "./vhdl-M6FHGX4M.js"
    );
  }),
  vim: create_language_async_loader_default("vim", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_vim" */
      "./vim-KAPPRYQG.js"
    );
  }),
  visualBasic: create_language_async_loader_default("visualBasic", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_visualBasic" */
      "./visual-basic-VAEBJS62.js"
    );
  }),
  warpscript: create_language_async_loader_default("warpscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_warpscript" */
      "./warpscript-3X32IV7Z.js"
    );
  }),
  wasm: create_language_async_loader_default("wasm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_wasm" */
      "./wasm-2G4E36SJ.js"
    );
  }),
  webIdl: create_language_async_loader_default("webIdl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_webIdl" */
      "./web-idl-CBDA7LKV.js"
    );
  }),
  wiki: create_language_async_loader_default("wiki", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_wiki" */
      "./wiki-4T2TAC6I.js"
    );
  }),
  wolfram: create_language_async_loader_default("wolfram", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_wolfram" */
      "./wolfram-Z7EHW3JJ.js"
    );
  }),
  wren: create_language_async_loader_default("wren", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_wren" */
      "./wren-AGSIGTZU.js"
    );
  }),
  xeora: create_language_async_loader_default("xeora", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_xeora" */
      "./xeora-Q7UKCNBD.js"
    );
  }),
  xmlDoc: create_language_async_loader_default("xmlDoc", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_xmlDoc" */
      "./xml-doc-XCWVVC6P.js"
    );
  }),
  xojo: create_language_async_loader_default("xojo", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_xojo" */
      "./xojo-OZLERNXC.js"
    );
  }),
  xquery: create_language_async_loader_default("xquery", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_xquery" */
      "./xquery-TOUFVT3P.js"
    );
  }),
  yaml: create_language_async_loader_default("yaml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_yaml" */
      "./yaml-3V275NBT.js"
    );
  }),
  yang: create_language_async_loader_default("yang", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_yang" */
      "./yang-ICMZHQXJ.js"
    );
  }),
  zig: create_language_async_loader_default("zig", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_zig" */
      "./zig-QOBFAUEC.js"
    );
  })
};

// node_modules/react-syntax-highlighter/dist/esm/prism-async-light.js
var prism_async_light_default = async_syntax_highlighter_default({
  loader: function loader2() {
    return import(
      /* webpackChunkName:"react-syntax-highlighter/refractor-core-import" */
      "./core-RTSGZGTE.js"
    ).then(function(module) {
      return module["default"] || module;
    });
  },
  isLanguageRegistered: function isLanguageRegistered2(instance, language2) {
    return instance.registered(language2);
  },
  languageLoaders: prism_default,
  registerLanguage: function registerLanguage2(instance, name2, language2) {
    return instance.register(language2);
  }
});

// node_modules/react-syntax-highlighter/dist/esm/languages/prism/supported-languages.js
var supported_languages_default2 = ["abap", "abnf", "actionscript", "ada", "agda", "al", "antlr4", "apacheconf", "apex", "apl", "applescript", "aql", "arduino", "arff", "asciidoc", "asm6502", "asmatmel", "aspnet", "autohotkey", "autoit", "avisynth", "avro-idl", "bash", "basic", "batch", "bbcode", "bicep", "birb", "bison", "bnf", "brainfuck", "brightscript", "bro", "bsl", "c", "cfscript", "chaiscript", "cil", "clike", "clojure", "cmake", "cobol", "coffeescript", "concurnas", "coq", "cpp", "crystal", "csharp", "cshtml", "csp", "css-extras", "css", "csv", "cypher", "d", "dart", "dataweave", "dax", "dhall", "diff", "django", "dns-zone-file", "docker", "dot", "ebnf", "editorconfig", "eiffel", "ejs", "elixir", "elm", "erb", "erlang", "etlua", "excel-formula", "factor", "false", "firestore-security-rules", "flow", "fortran", "fsharp", "ftl", "gap", "gcode", "gdscript", "gedcom", "gherkin", "git", "glsl", "gml", "gn", "go-module", "go", "graphql", "groovy", "haml", "handlebars", "haskell", "haxe", "hcl", "hlsl", "hoon", "hpkp", "hsts", "http", "ichigojam", "icon", "icu-message-format", "idris", "iecst", "ignore", "inform7", "ini", "io", "j", "java", "javadoc", "javadoclike", "javascript", "javastacktrace", "jexl", "jolie", "jq", "js-extras", "js-templates", "jsdoc", "json", "json5", "jsonp", "jsstacktrace", "jsx", "julia", "keepalived", "keyman", "kotlin", "kumir", "kusto", "latex", "latte", "less", "lilypond", "liquid", "lisp", "livescript", "llvm", "log", "lolcode", "lua", "magma", "makefile", "markdown", "markup-templating", "markup", "matlab", "maxscript", "mel", "mermaid", "mizar", "mongodb", "monkey", "moonscript", "n1ql", "n4js", "nand2tetris-hdl", "naniscript", "nasm", "neon", "nevod", "nginx", "nim", "nix", "nsis", "objectivec", "ocaml", "opencl", "openqasm", "oz", "parigp", "parser", "pascal", "pascaligo", "pcaxis", "peoplecode", "perl", "php-extras", "php", "phpdoc", "plsql", "powerquery", "powershell", "processing", "prolog", "promql", "properties", "protobuf", "psl", "pug", "puppet", "pure", "purebasic", "purescript", "python", "q", "qml", "qore", "qsharp", "r", "racket", "reason", "regex", "rego", "renpy", "rest", "rip", "roboconf", "robotframework", "ruby", "rust", "sas", "sass", "scala", "scheme", "scss", "shell-session", "smali", "smalltalk", "smarty", "sml", "solidity", "solution-file", "soy", "sparql", "splunk-spl", "sqf", "sql", "squirrel", "stan", "stylus", "swift", "systemd", "t4-cs", "t4-templating", "t4-vb", "tap", "tcl", "textile", "toml", "tremor", "tsx", "tt2", "turtle", "twig", "typescript", "typoscript", "unrealscript", "uorazor", "uri", "v", "vala", "vbnet", "velocity", "verilog", "vhdl", "vim", "visual-basic", "warpscript", "wasm", "web-idl", "wiki", "wolfram", "wren", "xeora", "xml-doc", "xojo", "xquery", "yaml", "yang", "zig"];

// node_modules/react-syntax-highlighter/dist/esm/prism-async.js
var prism_async_default = async_syntax_highlighter_default({
  loader: function loader3() {
    return import(
      /* webpackChunkName:"react-syntax-highlighter/refractor-import" */
      "./refractor-VV2P56HS.js"
    ).then(function(module) {
      return module["default"] || module;
    });
  },
  noAsyncLoadingLanguages: true,
  supportedLanguages: supported_languages_default2
});

// node_modules/react-syntax-highlighter/dist/esm/prism-light.js
var import_core6 = __toESM(require_core2());
var SyntaxHighlighter2 = highlight_default(import_core6.default, {});
SyntaxHighlighter2.registerLanguage = function(_, language2) {
  return import_core6.default.register(language2);
};
SyntaxHighlighter2.alias = function(name2, aliases) {
  return import_core6.default.alias(name2, aliases);
};

// node_modules/react-syntax-highlighter/dist/esm/styles/prism/prism.js
var prism_default2 = {
  'code[class*="language-"]': {
    "color": "black",
    "background": "none",
    "textShadow": "0 1px white",
    "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
    "fontSize": "1em",
    "textAlign": "left",
    "whiteSpace": "pre",
    "wordSpacing": "normal",
    "wordBreak": "normal",
    "wordWrap": "normal",
    "lineHeight": "1.5",
    "MozTabSize": "4",
    "OTabSize": "4",
    "tabSize": "4",
    "WebkitHyphens": "none",
    "MozHyphens": "none",
    "msHyphens": "none",
    "hyphens": "none"
  },
  'pre[class*="language-"]': {
    "color": "black",
    "background": "#f5f2f0",
    "textShadow": "0 1px white",
    "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
    "fontSize": "1em",
    "textAlign": "left",
    "whiteSpace": "pre",
    "wordSpacing": "normal",
    "wordBreak": "normal",
    "wordWrap": "normal",
    "lineHeight": "1.5",
    "MozTabSize": "4",
    "OTabSize": "4",
    "tabSize": "4",
    "WebkitHyphens": "none",
    "MozHyphens": "none",
    "msHyphens": "none",
    "hyphens": "none",
    "padding": "1em",
    "margin": ".5em 0",
    "overflow": "auto"
  },
  'pre[class*="language-"]::-moz-selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  'pre[class*="language-"] ::-moz-selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  'code[class*="language-"]::-moz-selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  'code[class*="language-"] ::-moz-selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  'pre[class*="language-"]::selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  'pre[class*="language-"] ::selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  'code[class*="language-"]::selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  'code[class*="language-"] ::selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  ':not(pre) > code[class*="language-"]': {
    "background": "#f5f2f0",
    "padding": ".1em",
    "borderRadius": ".3em",
    "whiteSpace": "normal"
  },
  "comment": {
    "color": "slategray"
  },
  "prolog": {
    "color": "slategray"
  },
  "doctype": {
    "color": "slategray"
  },
  "cdata": {
    "color": "slategray"
  },
  "punctuation": {
    "color": "#999"
  },
  "namespace": {
    "Opacity": ".7"
  },
  "property": {
    "color": "#905"
  },
  "tag": {
    "color": "#905"
  },
  "boolean": {
    "color": "#905"
  },
  "number": {
    "color": "#905"
  },
  "constant": {
    "color": "#905"
  },
  "symbol": {
    "color": "#905"
  },
  "deleted": {
    "color": "#905"
  },
  "selector": {
    "color": "#690"
  },
  "attr-name": {
    "color": "#690"
  },
  "string": {
    "color": "#690"
  },
  "char": {
    "color": "#690"
  },
  "builtin": {
    "color": "#690"
  },
  "inserted": {
    "color": "#690"
  },
  "operator": {
    "color": "#9a6e3a",
    "background": "hsla(0, 0%, 100%, .5)"
  },
  "entity": {
    "color": "#9a6e3a",
    "background": "hsla(0, 0%, 100%, .5)",
    "cursor": "help"
  },
  "url": {
    "color": "#9a6e3a",
    "background": "hsla(0, 0%, 100%, .5)"
  },
  ".language-css .token.string": {
    "color": "#9a6e3a",
    "background": "hsla(0, 0%, 100%, .5)"
  },
  ".style .token.string": {
    "color": "#9a6e3a",
    "background": "hsla(0, 0%, 100%, .5)"
  },
  "atrule": {
    "color": "#07a"
  },
  "attr-value": {
    "color": "#07a"
  },
  "keyword": {
    "color": "#07a"
  },
  "function": {
    "color": "#DD4A68"
  },
  "class-name": {
    "color": "#DD4A68"
  },
  "regex": {
    "color": "#e90"
  },
  "important": {
    "color": "#e90",
    "fontWeight": "bold"
  },
  "variable": {
    "color": "#e90"
  },
  "bold": {
    "fontWeight": "bold"
  },
  "italic": {
    "fontStyle": "italic"
  }
};

// node_modules/react-syntax-highlighter/dist/esm/prism.js
var import_refractor = __toESM(require_refractor());
var highlighter2 = highlight_default(import_refractor.default, prism_default2);
highlighter2.supportedLanguages = supported_languages_default2;
var prism_default3 = highlighter2;

// node_modules/@neo4j-ndl/react/lib/esm/code-block/CodeBlock.js
var import_prism4 = __toESM(require_prism2());

// node_modules/@neo4j-ndl/react/lib/esm/_common/CodeBlockWrapper.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime());
var import_react172 = __toESM(require_react());
var CodeBlockWrapper = import_react172.default.forwardRef(function CodeBlockWrapper2({ as, maxHeight, code, headerTitle, children, disabled, actions, shouldShowExpandButton, setShouldShowExpandButton }, ref) {
  const Component4 = as || "div";
  const syntaxHighlighterWrapperRef = (0, import_react172.useRef)(null);
  const [containerHeight, setContainerHeight] = (0, import_react172.useState)(`${maxHeight}px`);
  const [isExpanded, setIsExpanded] = (0, import_react172.useState)(maxHeight === void 0);
  (0, import_react172.useEffect)(() => {
    var _a2, _b;
    if ((((_a2 = syntaxHighlighterWrapperRef.current) === null || _a2 === void 0 ? void 0 : _a2.scrollHeight) || 0) <= (((_b = syntaxHighlighterWrapperRef.current) === null || _b === void 0 ? void 0 : _b.clientHeight) || 0)) {
      setIsExpanded(true);
    } else {
      setIsExpanded(false);
    }
  }, []);
  (0, import_react172.useLayoutEffect)(() => {
    var _a2, _b;
    if ((((_a2 = syntaxHighlighterWrapperRef.current) === null || _a2 === void 0 ? void 0 : _a2.clientHeight) || 0) >= (((_b = syntaxHighlighterWrapperRef.current) === null || _b === void 0 ? void 0 : _b.scrollHeight) || 0)) {
      setContainerHeight(`fit-content`);
      setShouldShowExpandButton(false);
    } else {
      setContainerHeight(`${maxHeight}px`);
      setShouldShowExpandButton(true);
    }
  }, [maxHeight, code, setShouldShowExpandButton]);
  return (0, import_jsx_runtime43.jsxs)(Component4, { ref, className: "ndl-code-block-container", style: { height: containerHeight }, children: [(0, import_jsx_runtime43.jsxs)("div", { className: "n-flex n-flex-col n-h-full", children: [headerTitle && (0, import_jsx_runtime43.jsx)("div", { className: classNames("ndl-code-block-title", {
    "ndl-disabled": disabled
  }), style: {
    maxWidth: `calc(100% - ${((actions === null || actions === void 0 ? void 0 : actions.length) || 0) * 36 + 20}px)`
  }, "data-testid": "ndl-code-block-title", children: headerTitle }), (0, import_jsx_runtime43.jsxs)("div", { className: classNames("ndl-code-content-container", {
    "ndl-disabled": disabled
  }), style: {
    height: headerTitle ? "calc(100% - 24px - 12px)" : "100%"
  }, children: [(0, import_jsx_runtime43.jsx)("div", { className: "ndl-code-pseudo-element" }), (0, import_jsx_runtime43.jsx)("div", { ref: syntaxHighlighterWrapperRef, className: "ndl-highlight-wrapper", role: "textbox", "aria-label": "code-snippet", tabIndex: 0, children }), (0, import_jsx_runtime43.jsx)("div", { className: "ndl-code-pseudo-element" })] })] }), (0, import_jsx_runtime43.jsx)("div", { className: classNames("ndl-code-block-actions", {
    "ndl-disabled": disabled
  }), children: actions === null || actions === void 0 ? void 0 : actions.map((iconButtonProps, i2) => (0, import_jsx_runtime43.jsx)(IconButton, Object.assign({ "data-testid": `ndl-action-button-${i2}`, clean: true, "aria-label": `${iconButtonProps["aria-label"] || "CodeBlock Action"}`, disabled }, iconButtonProps), i2)) }), shouldShowExpandButton && (0, import_jsx_runtime43.jsx)("div", { className: "ndl-code-block-expand-button", children: (0, import_jsx_runtime43.jsx)(IconButton, { "aria-label": "Expand/Collapse", onClick: () => {
    if (isExpanded) {
      setContainerHeight(`${maxHeight}px`);
      setIsExpanded(false);
    } else {
      setContainerHeight(`fit-content`);
      setIsExpanded(true);
    }
  }, clean: true, children: isExpanded ? (0, import_jsx_runtime43.jsx)(import_ChevronUpIcon.default, {}) : (0, import_jsx_runtime43.jsx)(import_ChevronDownIcon.default, {}) }) })] });
});

// node_modules/@neo4j-ndl/react/lib/esm/code-block/CodeBlock.js
var __rest32 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var CodeBlock = import_react173.default.forwardRef(function CodeBlock2(_a2, ref) {
  var { maxHeight, code, language: language2, showLineNumbers, theme: theme2, headerTitle, actions, disabled } = _a2, rest = __rest32(_a2, ["maxHeight", "code", "language", "showLineNumbers", "theme", "headerTitle", "actions", "disabled"]);
  const [shouldShowExpandButton, setShouldShowExpandButton] = (0, import_react173.useState)(maxHeight !== void 0);
  const getTheme3 = () => {
    switch (theme2) {
      case "vs":
        return import_prism4.vs;
      case "base16-ateliersulphurpool.light":
        return import_prism4.base16AteliersulphurpoolLight;
      case "coy":
        return import_prism4.coy;
      case "duotone-light":
        return import_prism4.duotoneLight;
      case "ghcolors":
        return import_prism4.ghcolors;
      case "prism":
        return import_prism4.prism;
      case "solarizedlight":
        return import_prism4.solarizedlight;
      default:
        return import_prism4.base16AteliersulphurpoolLight;
    }
  };
  return (0, import_jsx_runtime44.jsx)(CodeBlockWrapper, { ref, maxHeight, code, headerTitle, disabled, actions, shouldShowExpandButton, setShouldShowExpandButton, children: (0, import_jsx_runtime44.jsx)(prism_default3, {
    language: language2,
    style: Object.assign(Object.assign({}, getTheme3()), { 'pre[class*="language-"]': {
      color: "rgb(var(--theme-palette-neutral-text-default))",
      lineHeight: "1",
      width: "100%",
      border: 0,
      padding: `0 calc(0.75em + ${headerTitle === void 0 || headerTitle === "" ? ((actions === null || actions === void 0 ? void 0 : actions.length) || (shouldShowExpandButton ? 1 : 0)) * 36 : (shouldShowExpandButton ? 1 : 0) * 36}px) 0.75em 0.75em`,
      overflowX: "auto",
      overflowY: "auto"
    } }),
    // Turn on 'showLineNumbers' & 'wrapLongLines' at the same time, the display is wrong
    // https://github.com/react-syntax-highlighter/react-syntax-highlighter/issues/402
    // wrapLongLines
    codeTagProps: { className: "n-code" },
    showLineNumbers,
    children: code
  }) });
});

// node_modules/@neo4j-ndl/react/lib/esm/cypher-code-block/CypherCodeBlock.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime());
var import_react175 = __toESM(require_react());

// node_modules/@neo4j-cypher/react-codemirror/es/CypherEditor.js
var import_react174 = __toESM(require_react());

// node_modules/@codemirror/state/dist/index.js
var Text = class _Text {
  /**
  Get the line description around the given position.
  */
  lineAt(pos) {
    if (pos < 0 || pos > this.length)
      throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
    return this.lineInner(pos, false, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(n) {
    if (n < 1 || n > this.lines)
      throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
    return this.lineInner(n, true, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(from2, to, text) {
    [from2, to] = clip(this, from2, to);
    let parts = [];
    this.decompose(
      0,
      from2,
      parts,
      2
      /* Open.To */
    );
    if (text.length)
      text.decompose(
        0,
        text.length,
        parts,
        1 | 2
        /* Open.To */
      );
    this.decompose(
      to,
      this.length,
      parts,
      1
      /* Open.From */
    );
    return TextNode.from(parts, this.length - (to - from2) + text.length);
  }
  /**
  Append another document to this one.
  */
  append(other) {
    return this.replace(this.length, this.length, other);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(from2, to = this.length) {
    [from2, to] = clip(this, from2, to);
    let parts = [];
    this.decompose(from2, to, parts, 0);
    return TextNode.from(parts, to - from2);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(other) {
    if (other == this)
      return true;
    if (other.length != this.length || other.lines != this.lines)
      return false;
    let start2 = this.scanIdentical(other, 1), end2 = this.length - this.scanIdentical(other, -1);
    let a3 = new RawTextCursor(this), b2 = new RawTextCursor(other);
    for (let skip = start2, pos = start2; ; ) {
      a3.next(skip);
      b2.next(skip);
      skip = 0;
      if (a3.lineBreak != b2.lineBreak || a3.done != b2.done || a3.value != b2.value)
        return false;
      pos += a3.value.length;
      if (a3.done || pos >= end2)
        return true;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(dir = 1) {
    return new RawTextCursor(this, dir);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(from2, to = this.length) {
    return new PartialTextCursor(this, from2, to);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(from2, to) {
    let inner;
    if (from2 == null) {
      inner = this.iter();
    } else {
      if (to == null)
        to = this.lines + 1;
      let start2 = this.line(from2).from;
      inner = this.iterRange(start2, Math.max(start2, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
    }
    return new LineCursor(inner);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let lines = [];
    this.flatten(lines);
    return lines;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(text) {
    if (text.length == 0)
      throw new RangeError("A document must have at least one line");
    if (text.length == 1 && !text[0])
      return _Text.empty;
    return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
  }
};
var TextLeaf = class _TextLeaf extends Text {
  constructor(text, length2 = textLength(text)) {
    super();
    this.text = text;
    this.length = length2;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(target, isLine, line2, offset3) {
    for (let i2 = 0; ; i2++) {
      let string3 = this.text[i2], end2 = offset3 + string3.length;
      if ((isLine ? line2 : end2) >= target)
        return new Line2(offset3, end2, line2, string3);
      offset3 = end2 + 1;
      line2++;
    }
  }
  decompose(from2, to, target, open) {
    let text = from2 <= 0 && to >= this.length ? this : new _TextLeaf(sliceText(this.text, from2, to), Math.min(to, this.length) - Math.max(0, from2));
    if (open & 1) {
      let prev2 = target.pop();
      let joined = appendText(text.text, prev2.text.slice(), 0, text.length);
      if (joined.length <= 32) {
        target.push(new _TextLeaf(joined, prev2.length + text.length));
      } else {
        let mid = joined.length >> 1;
        target.push(new _TextLeaf(joined.slice(0, mid)), new _TextLeaf(joined.slice(mid)));
      }
    } else {
      target.push(text);
    }
  }
  replace(from2, to, text) {
    if (!(text instanceof _TextLeaf))
      return super.replace(from2, to, text);
    [from2, to] = clip(this, from2, to);
    let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from2)), to);
    let newLen = this.length + text.length - (to - from2);
    if (lines.length <= 32)
      return new _TextLeaf(lines, newLen);
    return TextNode.from(_TextLeaf.split(lines, []), newLen);
  }
  sliceString(from2, to = this.length, lineSep = "\n") {
    [from2, to] = clip(this, from2, to);
    let result = "";
    for (let pos = 0, i2 = 0; pos <= to && i2 < this.text.length; i2++) {
      let line2 = this.text[i2], end2 = pos + line2.length;
      if (pos > from2 && i2)
        result += lineSep;
      if (from2 < end2 && to > pos)
        result += line2.slice(Math.max(0, from2 - pos), to - pos);
      pos = end2 + 1;
    }
    return result;
  }
  flatten(target) {
    for (let line2 of this.text)
      target.push(line2);
  }
  scanIdentical() {
    return 0;
  }
  static split(text, target) {
    let part = [], len = -1;
    for (let line2 of text) {
      part.push(line2);
      len += line2.length + 1;
      if (part.length == 32) {
        target.push(new _TextLeaf(part, len));
        part = [];
        len = -1;
      }
    }
    if (len > -1)
      target.push(new _TextLeaf(part, len));
    return target;
  }
};
var TextNode = class _TextNode extends Text {
  constructor(children, length2) {
    super();
    this.children = children;
    this.length = length2;
    this.lines = 0;
    for (let child of children)
      this.lines += child.lines;
  }
  lineInner(target, isLine, line2, offset3) {
    for (let i2 = 0; ; i2++) {
      let child = this.children[i2], end2 = offset3 + child.length, endLine = line2 + child.lines - 1;
      if ((isLine ? endLine : end2) >= target)
        return child.lineInner(target, isLine, line2, offset3);
      offset3 = end2 + 1;
      line2 = endLine + 1;
    }
  }
  decompose(from2, to, target, open) {
    for (let i2 = 0, pos = 0; pos <= to && i2 < this.children.length; i2++) {
      let child = this.children[i2], end2 = pos + child.length;
      if (from2 <= end2 && to >= pos) {
        let childOpen = open & ((pos <= from2 ? 1 : 0) | (end2 >= to ? 2 : 0));
        if (pos >= from2 && end2 <= to && !childOpen)
          target.push(child);
        else
          child.decompose(from2 - pos, to - pos, target, childOpen);
      }
      pos = end2 + 1;
    }
  }
  replace(from2, to, text) {
    [from2, to] = clip(this, from2, to);
    if (text.lines < this.lines)
      for (let i2 = 0, pos = 0; i2 < this.children.length; i2++) {
        let child = this.children[i2], end2 = pos + child.length;
        if (from2 >= pos && to <= end2) {
          let updated = child.replace(from2 - pos, to - pos, text);
          let totalLines = this.lines - child.lines + updated.lines;
          if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
            let copy2 = this.children.slice();
            copy2[i2] = updated;
            return new _TextNode(copy2, this.length - (to - from2) + text.length);
          }
          return super.replace(pos, end2, updated);
        }
        pos = end2 + 1;
      }
    return super.replace(from2, to, text);
  }
  sliceString(from2, to = this.length, lineSep = "\n") {
    [from2, to] = clip(this, from2, to);
    let result = "";
    for (let i2 = 0, pos = 0; i2 < this.children.length && pos <= to; i2++) {
      let child = this.children[i2], end2 = pos + child.length;
      if (pos > from2 && i2)
        result += lineSep;
      if (from2 < end2 && to > pos)
        result += child.sliceString(from2 - pos, to - pos, lineSep);
      pos = end2 + 1;
    }
    return result;
  }
  flatten(target) {
    for (let child of this.children)
      child.flatten(target);
  }
  scanIdentical(other, dir) {
    if (!(other instanceof _TextNode))
      return 0;
    let length2 = 0;
    let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
    for (; ; iA += dir, iB += dir) {
      if (iA == eA || iB == eB)
        return length2;
      let chA = this.children[iA], chB = other.children[iB];
      if (chA != chB)
        return length2 + chA.scanIdentical(chB, dir);
      length2 += chA.length + 1;
    }
  }
  static from(children, length2 = children.reduce((l, ch) => l + ch.length + 1, -1)) {
    let lines = 0;
    for (let ch of children)
      lines += ch.lines;
    if (lines < 32) {
      let flat = [];
      for (let ch of children)
        ch.flatten(flat);
      return new TextLeaf(flat, length2);
    }
    let chunk = Math.max(
      32,
      lines >> 5
      /* Tree.BranchShift */
    ), maxChunk = chunk << 1, minChunk = chunk >> 1;
    let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
    function add3(child) {
      let last;
      if (child.lines > maxChunk && child instanceof _TextNode) {
        for (let node3 of child.children)
          add3(node3);
      } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
        flush();
        chunked.push(child);
      } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
      } else {
        if (currentLines + child.lines > chunk)
          flush();
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk.push(child);
      }
    }
    function flush() {
      if (currentLines == 0)
        return;
      chunked.push(currentChunk.length == 1 ? currentChunk[0] : _TextNode.from(currentChunk, currentLen));
      currentLen = -1;
      currentLines = currentChunk.length = 0;
    }
    for (let child of children)
      add3(child);
    flush();
    return chunked.length == 1 ? chunked[0] : new _TextNode(chunked, length2);
  }
};
Text.empty = new TextLeaf([""], 0);
function textLength(text) {
  let length2 = -1;
  for (let line2 of text)
    length2 += line2.length + 1;
  return length2;
}
function appendText(text, target, from2 = 0, to = 1e9) {
  for (let pos = 0, i2 = 0, first = true; i2 < text.length && pos <= to; i2++) {
    let line2 = text[i2], end2 = pos + line2.length;
    if (end2 >= from2) {
      if (end2 > to)
        line2 = line2.slice(0, to - pos);
      if (pos < from2)
        line2 = line2.slice(from2 - pos);
      if (first) {
        target[target.length - 1] += line2;
        first = false;
      } else
        target.push(line2);
    }
    pos = end2 + 1;
  }
  return target;
}
function sliceText(text, from2, to) {
  return appendText(text, [""], from2, to);
}
var RawTextCursor = class {
  constructor(text, dir = 1) {
    this.dir = dir;
    this.done = false;
    this.lineBreak = false;
    this.value = "";
    this.nodes = [text];
    this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
  }
  nextInner(skip, dir) {
    this.done = this.lineBreak = false;
    for (; ; ) {
      let last = this.nodes.length - 1;
      let top3 = this.nodes[last], offsetValue = this.offsets[last], offset3 = offsetValue >> 1;
      let size3 = top3 instanceof TextLeaf ? top3.text.length : top3.children.length;
      if (offset3 == (dir > 0 ? size3 : 0)) {
        if (last == 0) {
          this.done = true;
          this.value = "";
          return this;
        }
        if (dir > 0)
          this.offsets[last - 1]++;
        this.nodes.pop();
        this.offsets.pop();
      } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
        this.offsets[last] += dir;
        if (skip == 0) {
          this.lineBreak = true;
          this.value = "\n";
          return this;
        }
        skip--;
      } else if (top3 instanceof TextLeaf) {
        let next2 = top3.text[offset3 + (dir < 0 ? -1 : 0)];
        this.offsets[last] += dir;
        if (next2.length > Math.max(0, skip)) {
          this.value = skip == 0 ? next2 : dir > 0 ? next2.slice(skip) : next2.slice(0, next2.length - skip);
          return this;
        }
        skip -= next2.length;
      } else {
        let next2 = top3.children[offset3 + (dir < 0 ? -1 : 0)];
        if (skip > next2.length) {
          skip -= next2.length;
          this.offsets[last] += dir;
        } else {
          if (dir < 0)
            this.offsets[last]--;
          this.nodes.push(next2);
          this.offsets.push(dir > 0 ? 1 : (next2 instanceof TextLeaf ? next2.text.length : next2.children.length) << 1);
        }
      }
    }
  }
  next(skip = 0) {
    if (skip < 0) {
      this.nextInner(-skip, -this.dir);
      skip = this.value.length;
    }
    return this.nextInner(skip, this.dir);
  }
};
var PartialTextCursor = class {
  constructor(text, start2, end2) {
    this.value = "";
    this.done = false;
    this.cursor = new RawTextCursor(text, start2 > end2 ? -1 : 1);
    this.pos = start2 > end2 ? text.length : 0;
    this.from = Math.min(start2, end2);
    this.to = Math.max(start2, end2);
  }
  nextInner(skip, dir) {
    if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
      this.value = "";
      this.done = true;
      return this;
    }
    skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
    let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
    if (skip > limit)
      skip = limit;
    limit -= skip;
    let { value } = this.cursor.next(skip);
    this.pos += (value.length + skip) * dir;
    this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
    this.done = !this.value;
    return this;
  }
  next(skip = 0) {
    if (skip < 0)
      skip = Math.max(skip, this.from - this.pos);
    else if (skip > 0)
      skip = Math.min(skip, this.to - this.pos);
    return this.nextInner(skip, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
};
var LineCursor = class {
  constructor(inner) {
    this.inner = inner;
    this.afterBreak = true;
    this.value = "";
    this.done = false;
  }
  next(skip = 0) {
    let { done, lineBreak, value } = this.inner.next(skip);
    if (done && this.afterBreak) {
      this.value = "";
      this.afterBreak = false;
    } else if (done) {
      this.done = true;
      this.value = "";
    } else if (lineBreak) {
      if (this.afterBreak) {
        this.value = "";
      } else {
        this.afterBreak = true;
        this.next();
      }
    } else {
      this.value = value;
      this.afterBreak = false;
    }
    return this;
  }
  get lineBreak() {
    return false;
  }
};
if (typeof Symbol != "undefined") {
  Text.prototype[Symbol.iterator] = function() {
    return this.iter();
  };
  RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
var Line2 = class {
  /**
  @internal
  */
  constructor(from2, to, number2, text) {
    this.from = from2;
    this.to = to;
    this.number = number2;
    this.text = text;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
};
function clip(text, from2, to) {
  from2 = Math.max(0, Math.min(text.length, from2));
  return [from2, Math.max(from2, Math.min(text.length, to))];
}
var extend = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s3) => s3 ? parseInt(s3, 36) : 1);
for (let i2 = 1; i2 < extend.length; i2++)
  extend[i2] += extend[i2 - 1];
function isExtendingChar(code) {
  for (let i2 = 1; i2 < extend.length; i2 += 2)
    if (extend[i2] > code)
      return extend[i2 - 1] <= code;
  return false;
}
function isRegionalIndicator(code) {
  return code >= 127462 && code <= 127487;
}
var ZWJ = 8205;
function findClusterBreak(str, pos, forward = true, includeExtending = true) {
  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
}
function nextClusterBreak(str, pos, includeExtending) {
  if (pos == str.length)
    return pos;
  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
    pos--;
  let prev2 = codePointAt(str, pos);
  pos += codePointSize(prev2);
  while (pos < str.length) {
    let next2 = codePointAt(str, pos);
    if (prev2 == ZWJ || next2 == ZWJ || includeExtending && isExtendingChar(next2)) {
      pos += codePointSize(next2);
      prev2 = next2;
    } else if (isRegionalIndicator(next2)) {
      let countBefore = 0, i2 = pos - 2;
      while (i2 >= 0 && isRegionalIndicator(codePointAt(str, i2))) {
        countBefore++;
        i2 -= 2;
      }
      if (countBefore % 2 == 0)
        break;
      else
        pos += 2;
    } else {
      break;
    }
  }
  return pos;
}
function prevClusterBreak(str, pos, includeExtending) {
  while (pos > 0) {
    let found = nextClusterBreak(str, pos - 2, includeExtending);
    if (found < pos)
      return found;
    pos--;
  }
  return 0;
}
function surrogateLow(ch) {
  return ch >= 56320 && ch < 57344;
}
function surrogateHigh(ch) {
  return ch >= 55296 && ch < 56320;
}
function codePointAt(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh(code0) || pos + 1 == str.length)
    return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow(code1))
    return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function fromCodePoint(code) {
  if (code <= 65535)
    return String.fromCharCode(code);
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
function codePointSize(code) {
  return code < 65536 ? 1 : 2;
}
var DefaultSplit = /\r\n?|\n/;
var MapMode = function(MapMode2) {
  MapMode2[MapMode2["Simple"] = 0] = "Simple";
  MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
  MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
  MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
  return MapMode2;
}(MapMode || (MapMode = {}));
var ChangeDesc = class _ChangeDesc {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(sections) {
    this.sections = sections;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let result = 0;
    for (let i2 = 0; i2 < this.sections.length; i2 += 2)
      result += this.sections[i2];
    return result;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let result = 0;
    for (let i2 = 0; i2 < this.sections.length; i2 += 2) {
      let ins = this.sections[i2 + 1];
      result += ins < 0 ? this.sections[i2] : ins;
    }
    return result;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(f) {
    for (let i2 = 0, posA = 0, posB = 0; i2 < this.sections.length; ) {
      let len = this.sections[i2++], ins = this.sections[i2++];
      if (ins < 0) {
        f(posA, posB, len);
        posB += len;
      } else {
        posB += ins;
      }
      posA += len;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let sections = [];
    for (let i2 = 0; i2 < this.sections.length; ) {
      let len = this.sections[i2++], ins = this.sections[i2++];
      if (ins < 0)
        sections.push(len, ins);
      else
        sections.push(ins, len);
    }
    return new _ChangeDesc(sections);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(other, before = false) {
    return other.empty ? this : mapSet(this, other, before);
  }
  mapPos(pos, assoc = -1, mode = MapMode.Simple) {
    let posA = 0, posB = 0;
    for (let i2 = 0; i2 < this.sections.length; ) {
      let len = this.sections[i2++], ins = this.sections[i2++], endA = posA + len;
      if (ins < 0) {
        if (endA > pos)
          return posB + (pos - posA);
        posB += len;
      } else {
        if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
          return null;
        if (endA > pos || endA == pos && assoc < 0 && !len)
          return pos == posA || assoc < 0 ? posB : posB + ins;
        posB += ins;
      }
      posA = endA;
    }
    if (pos > posA)
      throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
    return posB;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(from2, to = from2) {
    for (let i2 = 0, pos = 0; i2 < this.sections.length && pos <= to; ) {
      let len = this.sections[i2++], ins = this.sections[i2++], end2 = pos + len;
      if (ins >= 0 && pos <= to && end2 >= from2)
        return pos < from2 && end2 > to ? "cover" : true;
      pos = end2;
    }
    return false;
  }
  /**
  @internal
  */
  toString() {
    let result = "";
    for (let i2 = 0; i2 < this.sections.length; ) {
      let len = this.sections[i2++], ins = this.sections[i2++];
      result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
    }
    return result;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(json) {
    if (!Array.isArray(json) || json.length % 2 || json.some((a3) => typeof a3 != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new _ChangeDesc(json);
  }
  /**
  @internal
  */
  static create(sections) {
    return new _ChangeDesc(sections);
  }
};
var ChangeSet = class _ChangeSet extends ChangeDesc {
  constructor(sections, inserted) {
    super(sections);
    this.inserted = inserted;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(doc2) {
    if (this.length != doc2.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    iterChanges(this, (fromA, toA, fromB, _toB, text) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text), false);
    return doc2;
  }
  mapDesc(other, before = false) {
    return mapSet(this, other, before, true);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(doc2) {
    let sections = this.sections.slice(), inserted = [];
    for (let i2 = 0, pos = 0; i2 < sections.length; i2 += 2) {
      let len = sections[i2], ins = sections[i2 + 1];
      if (ins >= 0) {
        sections[i2] = ins;
        sections[i2 + 1] = len;
        let index4 = i2 >> 1;
        while (inserted.length < index4)
          inserted.push(Text.empty);
        inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
      }
      pos += len;
    }
    return new _ChangeSet(sections, inserted);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA`  `docB` and `other` represents `docB`  `docC`, the
  returned value will represent the change `docA`  `docC`.
  */
  compose(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other, true);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(other, before = false) {
    return other.empty ? this : mapSet(this, other, before, true);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return ChangeDesc.create(this.sections);
  }
  /**
  @internal
  */
  filter(ranges) {
    let resultSections = [], resultInserted = [], filteredSections = [];
    let iter = new SectionIter(this);
    done:
      for (let i2 = 0, pos = 0; ; ) {
        let next2 = i2 == ranges.length ? 1e9 : ranges[i2++];
        while (pos < next2 || pos == next2 && iter.len == 0) {
          if (iter.done)
            break done;
          let len = Math.min(iter.len, next2 - pos);
          addSection(filteredSections, len, -1);
          let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
          addSection(resultSections, len, ins);
          if (ins > 0)
            addInsert(resultInserted, resultSections, iter.text);
          iter.forward(len);
          pos += len;
        }
        let end2 = ranges[i2++];
        while (pos < end2) {
          if (iter.done)
            break done;
          let len = Math.min(iter.len, end2 - pos);
          addSection(resultSections, len, -1);
          addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
          iter.forward(len);
          pos += len;
        }
      }
    return {
      changes: new _ChangeSet(resultSections, resultInserted),
      filtered: ChangeDesc.create(filteredSections)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let parts = [];
    for (let i2 = 0; i2 < this.sections.length; i2 += 2) {
      let len = this.sections[i2], ins = this.sections[i2 + 1];
      if (ins < 0)
        parts.push(len);
      else if (ins == 0)
        parts.push([len]);
      else
        parts.push([len].concat(this.inserted[i2 >> 1].toJSON()));
    }
    return parts;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(changes, length2, lineSep) {
    let sections = [], inserted = [], pos = 0;
    let total = null;
    function flush(force = false) {
      if (!force && !sections.length)
        return;
      if (pos < length2)
        addSection(sections, length2 - pos, -1);
      let set2 = new _ChangeSet(sections, inserted);
      total = total ? total.compose(set2.map(total)) : set2;
      sections = [];
      inserted = [];
      pos = 0;
    }
    function process2(spec) {
      if (Array.isArray(spec)) {
        for (let sub2 of spec)
          process2(sub2);
      } else if (spec instanceof _ChangeSet) {
        if (spec.length != length2)
          throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length2})`);
        flush();
        total = total ? total.compose(spec.map(total)) : spec;
      } else {
        let { from: from2, to = from2, insert: insert2 } = spec;
        if (from2 > to || from2 < 0 || to > length2)
          throw new RangeError(`Invalid change range ${from2} to ${to} (in doc of length ${length2})`);
        let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
        let insLen = insText.length;
        if (from2 == to && insLen == 0)
          return;
        if (from2 < pos)
          flush();
        if (from2 > pos)
          addSection(sections, from2 - pos, -1);
        addSection(sections, to - from2, insLen);
        addInsert(inserted, sections, insText);
        pos = to;
      }
    }
    process2(changes);
    flush(!total);
    return total;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(length2) {
    return new _ChangeSet(length2 ? [length2, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(json) {
    if (!Array.isArray(json))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let sections = [], inserted = [];
    for (let i2 = 0; i2 < json.length; i2++) {
      let part = json[i2];
      if (typeof part == "number") {
        sections.push(part, -1);
      } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e4, i3) => i3 && typeof e4 != "string")) {
        throw new RangeError("Invalid JSON representation of ChangeSet");
      } else if (part.length == 1) {
        sections.push(part[0], 0);
      } else {
        while (inserted.length < i2)
          inserted.push(Text.empty);
        inserted[i2] = Text.of(part.slice(1));
        sections.push(part[0], inserted[i2].length);
      }
    }
    return new _ChangeSet(sections, inserted);
  }
  /**
  @internal
  */
  static createSet(sections, inserted) {
    return new _ChangeSet(sections, inserted);
  }
};
function addSection(sections, len, ins, forceJoin = false) {
  if (len == 0 && ins <= 0)
    return;
  let last = sections.length - 2;
  if (last >= 0 && ins <= 0 && ins == sections[last + 1])
    sections[last] += len;
  else if (len == 0 && sections[last] == 0)
    sections[last + 1] += ins;
  else if (forceJoin) {
    sections[last] += len;
    sections[last + 1] += ins;
  } else
    sections.push(len, ins);
}
function addInsert(values, sections, value) {
  if (value.length == 0)
    return;
  let index4 = sections.length - 2 >> 1;
  if (index4 < values.length) {
    values[values.length - 1] = values[values.length - 1].append(value);
  } else {
    while (values.length < index4)
      values.push(Text.empty);
    values.push(value);
  }
}
function iterChanges(desc, f, individual) {
  let inserted = desc.inserted;
  for (let posA = 0, posB = 0, i2 = 0; i2 < desc.sections.length; ) {
    let len = desc.sections[i2++], ins = desc.sections[i2++];
    if (ins < 0) {
      posA += len;
      posB += len;
    } else {
      let endA = posA, endB = posB, text = Text.empty;
      for (; ; ) {
        endA += len;
        endB += ins;
        if (ins && inserted)
          text = text.append(inserted[i2 - 2 >> 1]);
        if (individual || i2 == desc.sections.length || desc.sections[i2 + 1] < 0)
          break;
        len = desc.sections[i2++];
        ins = desc.sections[i2++];
      }
      f(posA, endA, posB, endB, text);
      posA = endA;
      posB = endB;
    }
  }
}
function mapSet(setA, setB, before, mkSet = false) {
  let sections = [], insert2 = mkSet ? [] : null;
  let a3 = new SectionIter(setA), b2 = new SectionIter(setB);
  for (let inserted = -1; ; ) {
    if (a3.ins == -1 && b2.ins == -1) {
      let len = Math.min(a3.len, b2.len);
      addSection(sections, len, -1);
      a3.forward(len);
      b2.forward(len);
    } else if (b2.ins >= 0 && (a3.ins < 0 || inserted == a3.i || a3.off == 0 && (b2.len < a3.len || b2.len == a3.len && !before))) {
      let len = b2.len;
      addSection(sections, b2.ins, -1);
      while (len) {
        let piece = Math.min(a3.len, len);
        if (a3.ins >= 0 && inserted < a3.i && a3.len <= piece) {
          addSection(sections, 0, a3.ins);
          if (insert2)
            addInsert(insert2, sections, a3.text);
          inserted = a3.i;
        }
        a3.forward(piece);
        len -= piece;
      }
      b2.next();
    } else if (a3.ins >= 0) {
      let len = 0, left2 = a3.len;
      while (left2) {
        if (b2.ins == -1) {
          let piece = Math.min(left2, b2.len);
          len += piece;
          left2 -= piece;
          b2.forward(piece);
        } else if (b2.ins == 0 && b2.len < left2) {
          left2 -= b2.len;
          b2.next();
        } else {
          break;
        }
      }
      addSection(sections, len, inserted < a3.i ? a3.ins : 0);
      if (insert2 && inserted < a3.i)
        addInsert(insert2, sections, a3.text);
      inserted = a3.i;
      a3.forward(a3.len - left2);
    } else if (a3.done && b2.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else {
      throw new Error("Mismatched change set lengths");
    }
  }
}
function composeSets(setA, setB, mkSet = false) {
  let sections = [];
  let insert2 = mkSet ? [] : null;
  let a3 = new SectionIter(setA), b2 = new SectionIter(setB);
  for (let open = false; ; ) {
    if (a3.done && b2.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else if (a3.ins == 0) {
      addSection(sections, a3.len, 0, open);
      a3.next();
    } else if (b2.len == 0 && !b2.done) {
      addSection(sections, 0, b2.ins, open);
      if (insert2)
        addInsert(insert2, sections, b2.text);
      b2.next();
    } else if (a3.done || b2.done) {
      throw new Error("Mismatched change set lengths");
    } else {
      let len = Math.min(a3.len2, b2.len), sectionLen = sections.length;
      if (a3.ins == -1) {
        let insB = b2.ins == -1 ? -1 : b2.off ? 0 : b2.ins;
        addSection(sections, len, insB, open);
        if (insert2 && insB)
          addInsert(insert2, sections, b2.text);
      } else if (b2.ins == -1) {
        addSection(sections, a3.off ? 0 : a3.len, len, open);
        if (insert2)
          addInsert(insert2, sections, a3.textBit(len));
      } else {
        addSection(sections, a3.off ? 0 : a3.len, b2.off ? 0 : b2.ins, open);
        if (insert2 && !b2.off)
          addInsert(insert2, sections, b2.text);
      }
      open = (a3.ins > len || b2.ins >= 0 && b2.len > len) && (open || sections.length > sectionLen);
      a3.forward2(len);
      b2.forward(len);
    }
  }
}
var SectionIter = class {
  constructor(set2) {
    this.set = set2;
    this.i = 0;
    this.next();
  }
  next() {
    let { sections } = this.set;
    if (this.i < sections.length) {
      this.len = sections[this.i++];
      this.ins = sections[this.i++];
    } else {
      this.len = 0;
      this.ins = -2;
    }
    this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted } = this.set, index4 = this.i - 2 >> 1;
    return index4 >= inserted.length ? Text.empty : inserted[index4];
  }
  textBit(len) {
    let { inserted } = this.set, index4 = this.i - 2 >> 1;
    return index4 >= inserted.length && !len ? Text.empty : inserted[index4].slice(this.off, len == null ? void 0 : this.off + len);
  }
  forward(len) {
    if (len == this.len)
      this.next();
    else {
      this.len -= len;
      this.off += len;
    }
  }
  forward2(len) {
    if (this.ins == -1)
      this.forward(len);
    else if (len == this.ins)
      this.next();
    else {
      this.ins -= len;
      this.off += len;
    }
  }
};
var SelectionRange = class _SelectionRange {
  constructor(from2, to, flags) {
    this.from = from2;
    this.to = to;
    this.flags = flags;
  }
  /**
  The anchor of the rangethe side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let level = this.flags & 7;
    return level == 7 ? null : level;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let value = this.flags >> 6;
    return value == 16777215 ? void 0 : value;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(change, assoc = -1) {
    let from2, to;
    if (this.empty) {
      from2 = to = change.mapPos(this.from, assoc);
    } else {
      from2 = change.mapPos(this.from, 1);
      to = change.mapPos(this.to, -1);
    }
    return from2 == this.from && to == this.to ? this : new _SelectionRange(from2, to, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(from2, to = from2) {
    if (from2 <= this.anchor && to >= this.anchor)
      return EditorSelection.range(from2, to);
    let head = Math.abs(from2 - this.anchor) > Math.abs(to - this.anchor) ? from2 : to;
    return EditorSelection.range(this.anchor, head);
  }
  /**
  Compare this range to another range.
  */
  eq(other, includeAssoc = false) {
    return this.anchor == other.anchor && this.head == other.head && (!includeAssoc || !this.empty || this.assoc == other.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(json) {
    if (!json || typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return EditorSelection.range(json.anchor, json.head);
  }
  /**
  @internal
  */
  static create(from2, to, flags) {
    return new _SelectionRange(from2, to, flags);
  }
};
var EditorSelection = class _EditorSelection {
  constructor(ranges, mainIndex) {
    this.ranges = ranges;
    this.mainIndex = mainIndex;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(change, assoc = -1) {
    if (change.empty)
      return this;
    return _EditorSelection.create(this.ranges.map((r2) => r2.map(change, assoc)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(other, includeAssoc = false) {
    if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
      return false;
    for (let i2 = 0; i2 < this.ranges.length; i2++)
      if (!this.ranges[i2].eq(other.ranges[i2], includeAssoc))
        return false;
    return true;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new _EditorSelection([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(range, main2 = true) {
    return _EditorSelection.create([range].concat(this.ranges), main2 ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(range, which = this.mainIndex) {
    let ranges = this.ranges.slice();
    ranges[which] = range;
    return _EditorSelection.create(ranges, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((r2) => r2.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(json) {
    if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new _EditorSelection(json.ranges.map((r2) => SelectionRange.fromJSON(r2)), json.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(anchor, head = anchor) {
    return new _EditorSelection([_EditorSelection.range(anchor, head)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(ranges, mainIndex = 0) {
    if (ranges.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let pos = 0, i2 = 0; i2 < ranges.length; i2++) {
      let range = ranges[i2];
      if (range.empty ? range.from <= pos : range.from < pos)
        return _EditorSelection.normalized(ranges.slice(), mainIndex);
      pos = range.to;
    }
    return new _EditorSelection(ranges, mainIndex);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
    return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 : 16) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(anchor, head, goalColumn, bidiLevel) {
    let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6 | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
    return head < anchor ? SelectionRange.create(head, anchor, 32 | 16 | flags) : SelectionRange.create(anchor, head, (head > anchor ? 8 : 0) | flags);
  }
  /**
  @internal
  */
  static normalized(ranges, mainIndex = 0) {
    let main2 = ranges[mainIndex];
    ranges.sort((a3, b2) => a3.from - b2.from);
    mainIndex = ranges.indexOf(main2);
    for (let i2 = 1; i2 < ranges.length; i2++) {
      let range = ranges[i2], prev2 = ranges[i2 - 1];
      if (range.empty ? range.from <= prev2.to : range.from < prev2.to) {
        let from2 = prev2.from, to = Math.max(range.to, prev2.to);
        if (i2 <= mainIndex)
          mainIndex--;
        ranges.splice(--i2, 2, range.anchor > range.head ? _EditorSelection.range(to, from2) : _EditorSelection.range(from2, to));
      }
    }
    return new _EditorSelection(ranges, mainIndex);
  }
};
function checkSelection(selection, docLength) {
  for (let range of selection.ranges)
    if (range.to > docLength)
      throw new RangeError("Selection points outside of document");
}
var nextID = 0;
var Facet = class _Facet {
  constructor(combine2, compareInput, compare2, isStatic, enables) {
    this.combine = combine2;
    this.compareInput = compareInput;
    this.compare = compare2;
    this.isStatic = isStatic;
    this.id = nextID++;
    this.default = combine2([]);
    this.extensions = typeof enables == "function" ? enables(this) : enables;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(config2 = {}) {
    return new _Facet(config2.combine || ((a3) => a3), config2.compareInput || ((a3, b2) => a3 === b2), config2.compare || (!config2.combine ? sameArray : (a3, b2) => a3 === b2), !!config2.static, config2.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(value) {
    return new FacetProvider([], this, 0, value);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(deps, get2) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 1, get2);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(deps, get2) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 2, get2);
  }
  from(field, get2) {
    if (!get2)
      get2 = (x2) => x2;
    return this.compute([field], (state) => get2(state.field(field)));
  }
};
function sameArray(a3, b2) {
  return a3 == b2 || a3.length == b2.length && a3.every((e4, i2) => e4 === b2[i2]);
}
var FacetProvider = class {
  constructor(dependencies, facet, type, value) {
    this.dependencies = dependencies;
    this.facet = facet;
    this.type = type;
    this.value = value;
    this.id = nextID++;
  }
  dynamicSlot(addresses) {
    var _a2;
    let getter = this.value;
    let compare2 = this.facet.compareInput;
    let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2;
    let depDoc = false, depSel = false, depAddrs = [];
    for (let dep of this.dependencies) {
      if (dep == "doc")
        depDoc = true;
      else if (dep == "selection")
        depSel = true;
      else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0)
        depAddrs.push(addresses[dep.id]);
    }
    return {
      create(state) {
        state.values[idx] = getter(state);
        return 1;
      },
      update(state, tr2) {
        if (depDoc && tr2.docChanged || depSel && (tr2.docChanged || tr2.selection) || ensureAll(state, depAddrs)) {
          let newVal = getter(state);
          if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
            state.values[idx] = newVal;
            return 1;
          }
        }
        return 0;
      },
      reconfigure: (state, oldState) => {
        let newVal, oldAddr = oldState.config.address[id];
        if (oldAddr != null) {
          let oldVal = getAddr(oldState, oldAddr);
          if (this.dependencies.every((dep) => {
            return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
          }) || (multi ? compareArray(newVal = getter(state), oldVal, compare2) : compare2(newVal = getter(state), oldVal))) {
            state.values[idx] = oldVal;
            return 0;
          }
        } else {
          newVal = getter(state);
        }
        state.values[idx] = newVal;
        return 1;
      }
    };
  }
};
function compareArray(a3, b2, compare2) {
  if (a3.length != b2.length)
    return false;
  for (let i2 = 0; i2 < a3.length; i2++)
    if (!compare2(a3[i2], b2[i2]))
      return false;
  return true;
}
function ensureAll(state, addrs) {
  let changed = false;
  for (let addr of addrs)
    if (ensureAddr(state, addr) & 1)
      changed = true;
  return changed;
}
function dynamicFacetSlot(addresses, facet, providers) {
  let providerAddrs = providers.map((p) => addresses[p.id]);
  let providerTypes = providers.map((p) => p.type);
  let dynamic = providerAddrs.filter((p) => !(p & 1));
  let idx = addresses[facet.id] >> 1;
  function get2(state) {
    let values = [];
    for (let i2 = 0; i2 < providerAddrs.length; i2++) {
      let value = getAddr(state, providerAddrs[i2]);
      if (providerTypes[i2] == 2)
        for (let val of value)
          values.push(val);
      else
        values.push(value);
    }
    return facet.combine(values);
  }
  return {
    create(state) {
      for (let addr of providerAddrs)
        ensureAddr(state, addr);
      state.values[idx] = get2(state);
      return 1;
    },
    update(state, tr2) {
      if (!ensureAll(state, dynamic))
        return 0;
      let value = get2(state);
      if (facet.compare(value, state.values[idx]))
        return 0;
      state.values[idx] = value;
      return 1;
    },
    reconfigure(state, oldState) {
      let depChanged = ensureAll(state, providerAddrs);
      let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
      if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
        state.values[idx] = oldValue;
        return 0;
      }
      let value = get2(state);
      if (facet.compare(value, oldValue)) {
        state.values[idx] = oldValue;
        return 0;
      }
      state.values[idx] = value;
      return 1;
    }
  };
}
var initField = Facet.define({ static: true });
var StateField = class _StateField {
  constructor(id, createF, updateF, compareF, spec) {
    this.id = id;
    this.createF = createF;
    this.updateF = updateF;
    this.compareF = compareF;
    this.spec = spec;
    this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(config2) {
    let field = new _StateField(nextID++, config2.create, config2.update, config2.compare || ((a3, b2) => a3 === b2), config2);
    if (config2.provide)
      field.provides = config2.provide(field);
    return field;
  }
  create(state) {
    let init = state.facet(initField).find((i2) => i2.field == this);
    return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
  }
  /**
  @internal
  */
  slot(addresses) {
    let idx = addresses[this.id] >> 1;
    return {
      create: (state) => {
        state.values[idx] = this.create(state);
        return 1;
      },
      update: (state, tr2) => {
        let oldVal = state.values[idx];
        let value = this.updateF(oldVal, tr2);
        if (this.compareF(oldVal, value))
          return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure: (state, oldState) => {
        if (oldState.config.address[this.id] != null) {
          state.values[idx] = oldState.field(this);
          return 0;
        }
        state.values[idx] = this.create(state);
        return 1;
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(create2) {
    return [this, initField.of({ field: this, create: create2 })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
};
var Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function prec(value) {
  return (ext) => new PrecExtension(ext, value);
}
var Prec = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: prec(Prec_.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: prec(Prec_.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: prec(Prec_.default),
  /**
  A lower-than-default precedence.
  */
  low: prec(Prec_.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: prec(Prec_.lowest)
};
var PrecExtension = class {
  constructor(inner, prec2) {
    this.inner = inner;
    this.prec = prec2;
  }
};
var Compartment = class _Compartment {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(ext) {
    return new CompartmentInstance(this, ext);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(content2) {
    return _Compartment.reconfigure.of({ compartment: this, extension: content2 });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(state) {
    return state.config.compartments.get(this);
  }
};
var CompartmentInstance = class {
  constructor(compartment, inner) {
    this.compartment = compartment;
    this.inner = inner;
  }
};
var Configuration = class _Configuration {
  constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
    this.base = base2;
    this.compartments = compartments;
    this.dynamicSlots = dynamicSlots;
    this.address = address;
    this.staticValues = staticValues;
    this.facets = facets;
    this.statusTemplate = [];
    while (this.statusTemplate.length < dynamicSlots.length)
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(facet) {
    let addr = this.address[facet.id];
    return addr == null ? facet.default : this.staticValues[addr >> 1];
  }
  static resolve(base2, compartments, oldState) {
    let fields = [];
    let facets = /* @__PURE__ */ Object.create(null);
    let newCompartments = /* @__PURE__ */ new Map();
    for (let ext of flatten2(base2, compartments, newCompartments)) {
      if (ext instanceof StateField)
        fields.push(ext);
      else
        (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
    }
    let address = /* @__PURE__ */ Object.create(null);
    let staticValues = [];
    let dynamicSlots = [];
    for (let field of fields) {
      address[field.id] = dynamicSlots.length << 1;
      dynamicSlots.push((a3) => field.slot(a3));
    }
    let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
    for (let id in facets) {
      let providers = facets[id], facet = providers[0].facet;
      let oldProviders = oldFacets && oldFacets[id] || [];
      if (providers.every(
        (p) => p.type == 0
        /* Provider.Static */
      )) {
        address[facet.id] = staticValues.length << 1 | 1;
        if (sameArray(oldProviders, providers)) {
          staticValues.push(oldState.facet(facet));
        } else {
          let value = facet.combine(providers.map((p) => p.value));
          staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
        }
      } else {
        for (let p of providers) {
          if (p.type == 0) {
            address[p.id] = staticValues.length << 1 | 1;
            staticValues.push(p.value);
          } else {
            address[p.id] = dynamicSlots.length << 1;
            dynamicSlots.push((a3) => p.dynamicSlot(a3));
          }
        }
        address[facet.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a3) => dynamicFacetSlot(a3, facet, providers));
      }
    }
    let dynamic = dynamicSlots.map((f) => f(address));
    return new _Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
  }
};
function flatten2(extension, compartments, newCompartments) {
  let result = [[], [], [], [], []];
  let seen = /* @__PURE__ */ new Map();
  function inner(ext, prec2) {
    let known = seen.get(ext);
    if (known != null) {
      if (known <= prec2)
        return;
      let found = result[known].indexOf(ext);
      if (found > -1)
        result[known].splice(found, 1);
      if (ext instanceof CompartmentInstance)
        newCompartments.delete(ext.compartment);
    }
    seen.set(ext, prec2);
    if (Array.isArray(ext)) {
      for (let e4 of ext)
        inner(e4, prec2);
    } else if (ext instanceof CompartmentInstance) {
      if (newCompartments.has(ext.compartment))
        throw new RangeError(`Duplicate use of compartment in extensions`);
      let content2 = compartments.get(ext.compartment) || ext.inner;
      newCompartments.set(ext.compartment, content2);
      inner(content2, prec2);
    } else if (ext instanceof PrecExtension) {
      inner(ext.inner, ext.prec);
    } else if (ext instanceof StateField) {
      result[prec2].push(ext);
      if (ext.provides)
        inner(ext.provides, prec2);
    } else if (ext instanceof FacetProvider) {
      result[prec2].push(ext);
      if (ext.facet.extensions)
        inner(ext.facet.extensions, Prec_.default);
    } else {
      let content2 = ext.extension;
      if (!content2)
        throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      inner(content2, prec2);
    }
  }
  inner(extension, Prec_.default);
  return result.reduce((a3, b2) => a3.concat(b2));
}
function ensureAddr(state, addr) {
  if (addr & 1)
    return 2;
  let idx = addr >> 1;
  let status = state.status[idx];
  if (status == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (status & 2)
    return status;
  state.status[idx] = 4;
  let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
  return state.status[idx] = 2 | changed;
}
function getAddr(state, addr) {
  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}
var languageData = Facet.define();
var allowMultipleSelections = Facet.define({
  combine: (values) => values.some((v) => v),
  static: true
});
var lineSeparator = Facet.define({
  combine: (values) => values.length ? values[0] : void 0,
  static: true
});
var changeFilter = Facet.define();
var transactionFilter = Facet.define();
var transactionExtender = Facet.define();
var readOnly = Facet.define({
  combine: (values) => values.length ? values[0] : false
});
var Annotation = class {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new AnnotationType();
  }
};
var AnnotationType = class {
  /**
  Create an instance of this annotation.
  */
  of(value) {
    return new Annotation(this, value);
  }
};
var StateEffectType = class {
  /**
  @internal
  */
  constructor(map) {
    this.map = map;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(value) {
    return new StateEffect(this, value);
  }
};
var StateEffect = class _StateEffect {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(mapping) {
    let mapped = this.type.map(this.value, mapping);
    return mapped === void 0 ? void 0 : mapped == this.value ? this : new _StateEffect(this.type, mapped);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(type) {
    return this.type == type;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(spec = {}) {
    return new StateEffectType(spec.map || ((v) => v));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(effects, mapping) {
    if (!effects.length)
      return effects;
    let result = [];
    for (let effect4 of effects) {
      let mapped = effect4.map(mapping);
      if (mapped)
        result.push(mapped);
    }
    return result;
  }
};
StateEffect.reconfigure = StateEffect.define();
StateEffect.appendConfig = StateEffect.define();
var Transaction = class _Transaction {
  constructor(startState, changes, selection, effects, annotations, scrollIntoView4) {
    this.startState = startState;
    this.changes = changes;
    this.selection = selection;
    this.effects = effects;
    this.annotations = annotations;
    this.scrollIntoView = scrollIntoView4;
    this._doc = null;
    this._state = null;
    if (selection)
      checkSelection(selection, changes.newLength);
    if (!annotations.some((a3) => a3.type == _Transaction.time))
      this.annotations = annotations.concat(_Transaction.time.of(Date.now()));
  }
  /**
  @internal
  */
  static create(startState, changes, selection, effects, annotations, scrollIntoView4) {
    return new _Transaction(startState, changes, selection, effects, annotations, scrollIntoView4);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    if (!this._state)
      this.startState.applyTransaction(this);
    return this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(type) {
    for (let ann of this.annotations)
      if (ann.type == type)
        return ann.value;
    return void 0;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(event) {
    let e4 = this.annotation(_Transaction.userEvent);
    return !!(e4 && (e4 == event || e4.length > event.length && e4.slice(0, event.length) == event && e4[event.length] == "."));
  }
};
Transaction.time = Annotation.define();
Transaction.userEvent = Annotation.define();
Transaction.addToHistory = Annotation.define();
Transaction.remote = Annotation.define();
function joinRanges(a3, b2) {
  let result = [];
  for (let iA = 0, iB = 0; ; ) {
    let from2, to;
    if (iA < a3.length && (iB == b2.length || b2[iB] >= a3[iA])) {
      from2 = a3[iA++];
      to = a3[iA++];
    } else if (iB < b2.length) {
      from2 = b2[iB++];
      to = b2[iB++];
    } else
      return result;
    if (!result.length || result[result.length - 1] < from2)
      result.push(from2, to);
    else if (result[result.length - 1] < to)
      result[result.length - 1] = to;
  }
}
function mergeTransaction(a3, b2, sequential) {
  var _a2;
  let mapForA, mapForB, changes;
  if (sequential) {
    mapForA = b2.changes;
    mapForB = ChangeSet.empty(b2.changes.length);
    changes = a3.changes.compose(b2.changes);
  } else {
    mapForA = b2.changes.map(a3.changes);
    mapForB = a3.changes.mapDesc(b2.changes, true);
    changes = a3.changes.compose(mapForA);
  }
  return {
    changes,
    selection: b2.selection ? b2.selection.map(mapForB) : (_a2 = a3.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
    effects: StateEffect.mapEffects(a3.effects, mapForA).concat(StateEffect.mapEffects(b2.effects, mapForB)),
    annotations: a3.annotations.length ? a3.annotations.concat(b2.annotations) : b2.annotations,
    scrollIntoView: a3.scrollIntoView || b2.scrollIntoView
  };
}
function resolveTransactionInner(state, spec, docSize) {
  let sel = spec.selection, annotations = asArray2(spec.annotations);
  if (spec.userEvent)
    annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
  return {
    changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
    selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
    effects: asArray2(spec.effects),
    annotations,
    scrollIntoView: !!spec.scrollIntoView
  };
}
function resolveTransaction(state, specs, filter) {
  let s3 = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
  if (specs.length && specs[0].filter === false)
    filter = false;
  for (let i2 = 1; i2 < specs.length; i2++) {
    if (specs[i2].filter === false)
      filter = false;
    let seq = !!specs[i2].sequential;
    s3 = mergeTransaction(s3, resolveTransactionInner(state, specs[i2], seq ? s3.changes.newLength : state.doc.length), seq);
  }
  let tr2 = Transaction.create(state, s3.changes, s3.selection, s3.effects, s3.annotations, s3.scrollIntoView);
  return extendTransaction(filter ? filterTransaction(tr2) : tr2);
}
function filterTransaction(tr2) {
  let state = tr2.startState;
  let result = true;
  for (let filter of state.facet(changeFilter)) {
    let value = filter(tr2);
    if (value === false) {
      result = false;
      break;
    }
    if (Array.isArray(value))
      result = result === true ? value : joinRanges(result, value);
  }
  if (result !== true) {
    let changes, back;
    if (result === false) {
      back = tr2.changes.invertedDesc;
      changes = ChangeSet.empty(state.doc.length);
    } else {
      let filtered = tr2.changes.filter(result);
      changes = filtered.changes;
      back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
    }
    tr2 = Transaction.create(state, changes, tr2.selection && tr2.selection.map(back), StateEffect.mapEffects(tr2.effects, back), tr2.annotations, tr2.scrollIntoView);
  }
  let filters = state.facet(transactionFilter);
  for (let i2 = filters.length - 1; i2 >= 0; i2--) {
    let filtered = filters[i2](tr2);
    if (filtered instanceof Transaction)
      tr2 = filtered;
    else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
      tr2 = filtered[0];
    else
      tr2 = resolveTransaction(state, asArray2(filtered), false);
  }
  return tr2;
}
function extendTransaction(tr2) {
  let state = tr2.startState, extenders = state.facet(transactionExtender), spec = tr2;
  for (let i2 = extenders.length - 1; i2 >= 0; i2--) {
    let extension = extenders[i2](tr2);
    if (extension && Object.keys(extension).length)
      spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr2.changes.newLength), true);
  }
  return spec == tr2 ? tr2 : Transaction.create(state, tr2.changes, tr2.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
var none = [];
function asArray2(value) {
  return value == null ? none : Array.isArray(value) ? value : [value];
}
var CharCategory = function(CharCategory2) {
  CharCategory2[CharCategory2["Word"] = 0] = "Word";
  CharCategory2[CharCategory2["Space"] = 1] = "Space";
  CharCategory2[CharCategory2["Other"] = 2] = "Other";
  return CharCategory2;
}(CharCategory || (CharCategory = {}));
var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
var wordChar;
try {
  wordChar = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch (_) {
}
function hasWordChar(str) {
  if (wordChar)
    return wordChar.test(str);
  for (let i2 = 0; i2 < str.length; i2++) {
    let ch = str[i2];
    if (/\w/.test(ch) || ch > "" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
      return true;
  }
  return false;
}
function makeCategorizer(wordChars) {
  return (char2) => {
    if (!/\S/.test(char2))
      return CharCategory.Space;
    if (hasWordChar(char2))
      return CharCategory.Word;
    for (let i2 = 0; i2 < wordChars.length; i2++)
      if (char2.indexOf(wordChars[i2]) > -1)
        return CharCategory.Word;
    return CharCategory.Other;
  };
}
var EditorState = class _EditorState {
  constructor(config2, doc2, selection, values, computeSlot, tr2) {
    this.config = config2;
    this.doc = doc2;
    this.selection = selection;
    this.values = values;
    this.status = config2.statusTemplate.slice();
    this.computeSlot = computeSlot;
    if (tr2)
      tr2._state = this;
    for (let i2 = 0; i2 < this.config.dynamicSlots.length; i2++)
      ensureAddr(this, i2 << 1);
    this.computeSlot = null;
  }
  field(field, require2 = true) {
    let addr = this.config.address[field.id];
    if (addr == null) {
      if (require2)
        throw new RangeError("Field is not present in this state");
      return void 0;
    }
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...specs) {
    return resolveTransaction(this, specs, true);
  }
  /**
  @internal
  */
  applyTransaction(tr2) {
    let conf = this.config, { base: base2, compartments } = conf;
    for (let effect4 of tr2.effects) {
      if (effect4.is(Compartment.reconfigure)) {
        if (conf) {
          compartments = /* @__PURE__ */ new Map();
          conf.compartments.forEach((val, key) => compartments.set(key, val));
          conf = null;
        }
        compartments.set(effect4.value.compartment, effect4.value.extension);
      } else if (effect4.is(StateEffect.reconfigure)) {
        conf = null;
        base2 = effect4.value;
      } else if (effect4.is(StateEffect.appendConfig)) {
        conf = null;
        base2 = asArray2(base2).concat(effect4.value);
      }
    }
    let startValues;
    if (!conf) {
      conf = Configuration.resolve(base2, compartments, this);
      let intermediateState = new _EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
      startValues = intermediateState.values;
    } else {
      startValues = tr2.startState.values.slice();
    }
    let selection = tr2.startState.facet(allowMultipleSelections) ? tr2.newSelection : tr2.newSelection.asSingle();
    new _EditorState(conf, tr2.newDoc, selection, startValues, (state, slot) => slot.update(state, tr2), tr2);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(text) {
    if (typeof text == "string")
      text = this.toText(text);
    return this.changeByRange((range) => ({
      changes: { from: range.from, to: range.to, insert: text },
      range: EditorSelection.cursor(range.from + text.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(f) {
    let sel = this.selection;
    let result1 = f(sel.ranges[0]);
    let changes = this.changes(result1.changes), ranges = [result1.range];
    let effects = asArray2(result1.effects);
    for (let i2 = 1; i2 < sel.ranges.length; i2++) {
      let result = f(sel.ranges[i2]);
      let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
      for (let j = 0; j < i2; j++)
        ranges[j] = ranges[j].map(newMapped);
      let mapBy = changes.mapDesc(newChanges, true);
      ranges.push(result.range.map(mapBy));
      changes = changes.compose(newMapped);
      effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray2(result.effects), mapBy));
    }
    return {
      changes,
      selection: EditorSelection.create(ranges, sel.mainIndex),
      effects
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(spec = []) {
    if (spec instanceof ChangeSet)
      return spec;
    return ChangeSet.of(spec, this.doc.length, this.facet(_EditorState.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(string3) {
    return Text.of(string3.split(this.facet(_EditorState.lineSeparator) || DefaultSplit));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(from2 = 0, to = this.doc.length) {
    return this.doc.sliceString(from2, to, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(facet) {
    let addr = this.config.address[facet.id];
    if (addr == null)
      return facet.default;
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(fields) {
    let result = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (fields)
      for (let prop in fields) {
        let value = fields[prop];
        if (value instanceof StateField && this.config.address[value.id] != null)
          result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
      }
    return result;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(json, config2 = {}, fields) {
    if (!json || typeof json.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let fieldInit = [];
    if (fields)
      for (let prop in fields) {
        if (Object.prototype.hasOwnProperty.call(json, prop)) {
          let field = fields[prop], value = json[prop];
          fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
        }
      }
    return _EditorState.create({
      doc: json.doc,
      selection: EditorSelection.fromJSON(json.selection),
      extensions: config2.extensions ? fieldInit.concat([config2.extensions]) : fieldInit
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editorupdated states are created by applying
  transactions.
  */
  static create(config2 = {}) {
    let configuration = Configuration.resolve(config2.extensions || [], /* @__PURE__ */ new Map());
    let doc2 = config2.doc instanceof Text ? config2.doc : Text.of((config2.doc || "").split(configuration.staticFacet(_EditorState.lineSeparator) || DefaultSplit));
    let selection = !config2.selection ? EditorSelection.single(0) : config2.selection instanceof EditorSelection ? config2.selection : EditorSelection.single(config2.selection.anchor, config2.selection.head);
    checkSelection(selection, doc2.length);
    if (!configuration.staticFacet(allowMultipleSelections))
      selection = selection.asSingle();
    return new _EditorState(configuration, doc2, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(_EditorState.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(_EditorState.lineSeparator) || "\n";
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(readOnly);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(phrase2, ...insert2) {
    for (let map of this.facet(_EditorState.phrases))
      if (Object.prototype.hasOwnProperty.call(map, phrase2)) {
        phrase2 = map[phrase2];
        break;
      }
    if (insert2.length)
      phrase2 = phrase2.replace(/\$(\$|\d*)/g, (m3, i2) => {
        if (i2 == "$")
          return "$";
        let n = +(i2 || 1);
        return !n || n > insert2.length ? m3 : insert2[n - 1];
      });
    return phrase2;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(name2, pos, side = -1) {
    let values = [];
    for (let provider of this.facet(languageData)) {
      for (let result of provider(this, pos, side)) {
        if (Object.prototype.hasOwnProperty.call(result, name2))
          values.push(result[name2]);
      }
    }
    return values;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(at2) {
    return makeCategorizer(this.languageDataAt("wordChars", at2).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(pos) {
    let { text, from: from2, length: length2 } = this.doc.lineAt(pos);
    let cat = this.charCategorizer(pos);
    let start2 = pos - from2, end2 = pos - from2;
    while (start2 > 0) {
      let prev2 = findClusterBreak(text, start2, false);
      if (cat(text.slice(prev2, start2)) != CharCategory.Word)
        break;
      start2 = prev2;
    }
    while (end2 < length2) {
      let next2 = findClusterBreak(text, end2);
      if (cat(text.slice(end2, next2)) != CharCategory.Word)
        break;
      end2 = next2;
    }
    return start2 == end2 ? null : EditorSelection.range(start2 + from2, end2 + from2);
  }
};
EditorState.allowMultipleSelections = allowMultipleSelections;
EditorState.tabSize = Facet.define({
  combine: (values) => values.length ? values[0] : 4
});
EditorState.lineSeparator = lineSeparator;
EditorState.readOnly = readOnly;
EditorState.phrases = Facet.define({
  compare(a3, b2) {
    let kA = Object.keys(a3), kB = Object.keys(b2);
    return kA.length == kB.length && kA.every((k2) => a3[k2] == b2[k2]);
  }
});
EditorState.languageData = languageData;
EditorState.changeFilter = changeFilter;
EditorState.transactionFilter = transactionFilter;
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = StateEffect.define();
function combineConfig(configs, defaults3, combine2 = {}) {
  let result = {};
  for (let config2 of configs)
    for (let key of Object.keys(config2)) {
      let value = config2[key], current = result[key];
      if (current === void 0)
        result[key] = value;
      else if (current === value || value === void 0)
        ;
      else if (Object.hasOwnProperty.call(combine2, key))
        result[key] = combine2[key](current, value);
      else
        throw new Error("Config merge conflict for field " + key);
    }
  for (let key in defaults3)
    if (result[key] === void 0)
      result[key] = defaults3[key];
  return result;
}
var RangeValue = class {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(other) {
    return this == other;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(from2, to = from2) {
    return Range.create(from2, to, this);
  }
};
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = MapMode.TrackDel;
var Range = class _Range {
  constructor(from2, to, value) {
    this.from = from2;
    this.to = to;
    this.value = value;
  }
  /**
  @internal
  */
  static create(from2, to, value) {
    return new _Range(from2, to, value);
  }
};
function cmpRange(a3, b2) {
  return a3.from - b2.from || a3.value.startSide - b2.value.startSide;
}
var Chunk = class _Chunk {
  constructor(from2, to, value, maxPoint) {
    this.from = from2;
    this.to = to;
    this.value = value;
    this.maxPoint = maxPoint;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(pos, side, end2, startAt = 0) {
    let arr = end2 ? this.to : this.from;
    for (let lo = startAt, hi = arr.length; ; ) {
      if (lo == hi)
        return lo;
      let mid = lo + hi >> 1;
      let diff = arr[mid] - pos || (end2 ? this.value[mid].endSide : this.value[mid].startSide) - side;
      if (mid == lo)
        return diff >= 0 ? lo : hi;
      if (diff >= 0)
        hi = mid;
      else
        lo = mid + 1;
    }
  }
  between(offset3, from2, to, f) {
    for (let i2 = this.findIndex(from2, -1e9, true), e4 = this.findIndex(to, 1e9, false, i2); i2 < e4; i2++)
      if (f(this.from[i2] + offset3, this.to[i2] + offset3, this.value[i2]) === false)
        return false;
  }
  map(offset3, changes) {
    let value = [], from2 = [], to = [], newPos = -1, maxPoint = -1;
    for (let i2 = 0; i2 < this.value.length; i2++) {
      let val = this.value[i2], curFrom = this.from[i2] + offset3, curTo = this.to[i2] + offset3, newFrom, newTo;
      if (curFrom == curTo) {
        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
        if (mapped == null)
          continue;
        newFrom = newTo = mapped;
        if (val.startSide != val.endSide) {
          newTo = changes.mapPos(curFrom, val.endSide);
          if (newTo < newFrom)
            continue;
        }
      } else {
        newFrom = changes.mapPos(curFrom, val.startSide);
        newTo = changes.mapPos(curTo, val.endSide);
        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
          continue;
      }
      if ((newTo - newFrom || val.endSide - val.startSide) < 0)
        continue;
      if (newPos < 0)
        newPos = newFrom;
      if (val.point)
        maxPoint = Math.max(maxPoint, newTo - newFrom);
      value.push(val);
      from2.push(newFrom - newPos);
      to.push(newTo - newPos);
    }
    return { mapped: value.length ? new _Chunk(from2, to, value, maxPoint) : null, pos: newPos };
  }
};
var RangeSet = class _RangeSet {
  constructor(chunkPos, chunk, nextLayer, maxPoint) {
    this.chunkPos = chunkPos;
    this.chunk = chunk;
    this.nextLayer = nextLayer;
    this.maxPoint = maxPoint;
  }
  /**
  @internal
  */
  static create(chunkPos, chunk, nextLayer, maxPoint) {
    return new _RangeSet(chunkPos, chunk, nextLayer, maxPoint);
  }
  /**
  @internal
  */
  get length() {
    let last = this.chunk.length - 1;
    return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let size3 = this.nextLayer.size;
    for (let chunk of this.chunk)
      size3 += chunk.value.length;
    return size3;
  }
  /**
  @internal
  */
  chunkEnd(index4) {
    return this.chunkPos[index4] + this.chunk[index4].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(updateSpec) {
    let { add: add3 = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
    let filter = updateSpec.filter;
    if (add3.length == 0 && !filter)
      return this;
    if (sort)
      add3 = add3.slice().sort(cmpRange);
    if (this.isEmpty)
      return add3.length ? _RangeSet.of(add3) : this;
    let cur2 = new LayerCursor(this, null, -1).goto(0), i2 = 0, spill = [];
    let builder = new RangeSetBuilder();
    while (cur2.value || i2 < add3.length) {
      if (i2 < add3.length && (cur2.from - add3[i2].from || cur2.startSide - add3[i2].value.startSide) >= 0) {
        let range = add3[i2++];
        if (!builder.addInner(range.from, range.to, range.value))
          spill.push(range);
      } else if (cur2.rangeIndex == 1 && cur2.chunkIndex < this.chunk.length && (i2 == add3.length || this.chunkEnd(cur2.chunkIndex) < add3[i2].from) && (!filter || filterFrom > this.chunkEnd(cur2.chunkIndex) || filterTo < this.chunkPos[cur2.chunkIndex]) && builder.addChunk(this.chunkPos[cur2.chunkIndex], this.chunk[cur2.chunkIndex])) {
        cur2.nextChunk();
      } else {
        if (!filter || filterFrom > cur2.to || filterTo < cur2.from || filter(cur2.from, cur2.to, cur2.value)) {
          if (!builder.addInner(cur2.from, cur2.to, cur2.value))
            spill.push(Range.create(cur2.from, cur2.to, cur2.value));
        }
        cur2.next();
      }
    }
    return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? _RangeSet.empty : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(changes) {
    if (changes.empty || this.isEmpty)
      return this;
    let chunks = [], chunkPos = [], maxPoint = -1;
    for (let i2 = 0; i2 < this.chunk.length; i2++) {
      let start2 = this.chunkPos[i2], chunk = this.chunk[i2];
      let touch = changes.touchesRange(start2, start2 + chunk.length);
      if (touch === false) {
        maxPoint = Math.max(maxPoint, chunk.maxPoint);
        chunks.push(chunk);
        chunkPos.push(changes.mapPos(start2));
      } else if (touch === true) {
        let { mapped, pos } = chunk.map(start2, changes);
        if (mapped) {
          maxPoint = Math.max(maxPoint, mapped.maxPoint);
          chunks.push(mapped);
          chunkPos.push(pos);
        }
      }
    }
    let next2 = this.nextLayer.map(changes);
    return chunks.length == 0 ? next2 : new _RangeSet(chunkPos, chunks, next2 || _RangeSet.empty, maxPoint);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(from2, to, f) {
    if (this.isEmpty)
      return;
    for (let i2 = 0; i2 < this.chunk.length; i2++) {
      let start2 = this.chunkPos[i2], chunk = this.chunk[i2];
      if (to >= start2 && from2 <= start2 + chunk.length && chunk.between(start2, from2 - start2, to - start2, f) === false)
        return;
    }
    this.nextLayer.between(from2, to, f);
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(from2 = 0) {
    return HeapCursor.from([this]).goto(from2);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(sets, from2 = 0) {
    return HeapCursor.from(sets).goto(from2);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
    let a3 = oldSets.filter((set2) => set2.maxPoint > 0 || !set2.isEmpty && set2.maxPoint >= minPointSize);
    let b2 = newSets.filter((set2) => set2.maxPoint > 0 || !set2.isEmpty && set2.maxPoint >= minPointSize);
    let sharedChunks = findSharedChunks(a3, b2, textDiff);
    let sideA = new SpanCursor(a3, sharedChunks, minPointSize);
    let sideB = new SpanCursor(b2, sharedChunks, minPointSize);
    textDiff.iterGaps((fromA, fromB, length2) => compare(sideA, fromA, sideB, fromB, length2, comparator));
    if (textDiff.empty && textDiff.length == 0)
      compare(sideA, 0, sideB, 0, 0, comparator);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(oldSets, newSets, from2 = 0, to) {
    if (to == null)
      to = 1e9 - 1;
    let a3 = oldSets.filter((set2) => !set2.isEmpty && newSets.indexOf(set2) < 0);
    let b2 = newSets.filter((set2) => !set2.isEmpty && oldSets.indexOf(set2) < 0);
    if (a3.length != b2.length)
      return false;
    if (!a3.length)
      return true;
    let sharedChunks = findSharedChunks(a3, b2);
    let sideA = new SpanCursor(a3, sharedChunks, 0).goto(from2), sideB = new SpanCursor(b2, sharedChunks, 0).goto(from2);
    for (; ; ) {
      if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
        return false;
      if (sideA.to > to)
        return true;
      sideA.next();
      sideB.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(sets, from2, to, iterator, minPointSize = -1) {
    let cursor2 = new SpanCursor(sets, null, minPointSize).goto(from2), pos = from2;
    let openRanges = cursor2.openStart;
    for (; ; ) {
      let curTo = Math.min(cursor2.to, to);
      if (cursor2.point) {
        let active = cursor2.activeForPoint(cursor2.to);
        let openCount = cursor2.pointFrom < from2 ? active.length + 1 : Math.min(active.length, openRanges);
        iterator.point(pos, curTo, cursor2.point, active, openCount, cursor2.pointRank);
        openRanges = Math.min(cursor2.openEnd(curTo), active.length);
      } else if (curTo > pos) {
        iterator.span(pos, curTo, cursor2.active, openRanges);
        openRanges = cursor2.openEnd(curTo);
      }
      if (cursor2.to > to)
        return openRanges + (cursor2.point && cursor2.to > to ? 1 : 0);
      pos = cursor2.to;
      cursor2.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(ranges, sort = false) {
    let build = new RangeSetBuilder();
    for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)
      build.add(range.from, range.to, range.value);
    return build.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(sets) {
    if (!sets.length)
      return _RangeSet.empty;
    let result = sets[sets.length - 1];
    for (let i2 = sets.length - 2; i2 >= 0; i2--) {
      for (let layer2 = sets[i2]; layer2 != _RangeSet.empty; layer2 = layer2.nextLayer)
        result = new _RangeSet(layer2.chunkPos, layer2.chunk, result, Math.max(layer2.maxPoint, result.maxPoint));
    }
    return result;
  }
};
RangeSet.empty = new RangeSet([], [], null, -1);
function lazySort(ranges) {
  if (ranges.length > 1)
    for (let prev2 = ranges[0], i2 = 1; i2 < ranges.length; i2++) {
      let cur2 = ranges[i2];
      if (cmpRange(prev2, cur2) > 0)
        return ranges.slice().sort(cmpRange);
      prev2 = cur2;
    }
  return ranges;
}
RangeSet.empty.nextLayer = RangeSet.empty;
var RangeSetBuilder = class _RangeSetBuilder {
  finishChunk(newArrays) {
    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
    this.chunkPos.push(this.chunkStart);
    this.chunkStart = -1;
    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
    this.maxPoint = -1;
    if (newArrays) {
      this.from = [];
      this.to = [];
      this.value = [];
    }
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [];
    this.chunkPos = [];
    this.chunkStart = -1;
    this.last = null;
    this.lastFrom = -1e9;
    this.lastTo = -1e9;
    this.from = [];
    this.to = [];
    this.value = [];
    this.maxPoint = -1;
    this.setMaxPoint = -1;
    this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(from2, to, value) {
    if (!this.addInner(from2, to, value))
      (this.nextLayer || (this.nextLayer = new _RangeSetBuilder())).add(from2, to, value);
  }
  /**
  @internal
  */
  addInner(from2, to, value) {
    let diff = from2 - this.lastTo || value.startSide - this.last.endSide;
    if (diff <= 0 && (from2 - this.lastFrom || value.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    if (diff < 0)
      return false;
    if (this.from.length == 250)
      this.finishChunk(true);
    if (this.chunkStart < 0)
      this.chunkStart = from2;
    this.from.push(from2 - this.chunkStart);
    this.to.push(to - this.chunkStart);
    this.last = value;
    this.lastFrom = from2;
    this.lastTo = to;
    this.value.push(value);
    if (value.point)
      this.maxPoint = Math.max(this.maxPoint, to - from2);
    return true;
  }
  /**
  @internal
  */
  addChunk(from2, chunk) {
    if ((from2 - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
      return false;
    if (this.from.length)
      this.finishChunk(true);
    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
    this.chunks.push(chunk);
    this.chunkPos.push(from2);
    let last = chunk.value.length - 1;
    this.last = chunk.value[last];
    this.lastFrom = chunk.from[last] + from2;
    this.lastTo = chunk.to[last] + from2;
    return true;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(RangeSet.empty);
  }
  /**
  @internal
  */
  finishInner(next2) {
    if (this.from.length)
      this.finishChunk(false);
    if (this.chunks.length == 0)
      return next2;
    let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next2) : next2, this.setMaxPoint);
    this.from = null;
    return result;
  }
};
function findSharedChunks(a3, b2, textDiff) {
  let inA = /* @__PURE__ */ new Map();
  for (let set2 of a3)
    for (let i2 = 0; i2 < set2.chunk.length; i2++)
      if (set2.chunk[i2].maxPoint <= 0)
        inA.set(set2.chunk[i2], set2.chunkPos[i2]);
  let shared = /* @__PURE__ */ new Set();
  for (let set2 of b2)
    for (let i2 = 0; i2 < set2.chunk.length; i2++) {
      let known = inA.get(set2.chunk[i2]);
      if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set2.chunkPos[i2] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set2.chunk[i2].length)))
        shared.add(set2.chunk[i2]);
    }
  return shared;
}
var LayerCursor = class {
  constructor(layer2, skip, minPoint, rank = 0) {
    this.layer = layer2;
    this.skip = skip;
    this.minPoint = minPoint;
    this.rank = rank;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(pos, side = -1e9) {
    this.chunkIndex = this.rangeIndex = 0;
    this.gotoInner(pos, side, false);
    return this;
  }
  gotoInner(pos, side, forward) {
    while (this.chunkIndex < this.layer.chunk.length) {
      let next2 = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(next2) || this.layer.chunkEnd(this.chunkIndex) < pos || next2.maxPoint < this.minPoint))
        break;
      this.chunkIndex++;
      forward = false;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
      if (!forward || this.rangeIndex < rangeIndex)
        this.setRangeIndex(rangeIndex);
    }
    this.next();
  }
  forward(pos, side) {
    if ((this.to - pos || this.endSide - side) < 0)
      this.gotoInner(pos, side, true);
  }
  next() {
    for (; ; ) {
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9;
        this.value = null;
        break;
      } else {
        let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
        let from2 = chunkPos + chunk.from[this.rangeIndex];
        this.from = from2;
        this.to = chunkPos + chunk.to[this.rangeIndex];
        this.value = chunk.value[this.rangeIndex];
        this.setRangeIndex(this.rangeIndex + 1);
        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
    }
  }
  setRangeIndex(index4) {
    if (index4 == this.layer.chunk[this.chunkIndex].value.length) {
      this.chunkIndex++;
      if (this.skip) {
        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
          this.chunkIndex++;
      }
      this.rangeIndex = 0;
    } else {
      this.rangeIndex = index4;
    }
  }
  nextChunk() {
    this.chunkIndex++;
    this.rangeIndex = 0;
    this.next();
  }
  compare(other) {
    return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
  }
};
var HeapCursor = class _HeapCursor {
  constructor(heap) {
    this.heap = heap;
  }
  static from(sets, skip = null, minPoint = -1) {
    let heap = [];
    for (let i2 = 0; i2 < sets.length; i2++) {
      for (let cur2 = sets[i2]; !cur2.isEmpty; cur2 = cur2.nextLayer) {
        if (cur2.maxPoint >= minPoint)
          heap.push(new LayerCursor(cur2, skip, minPoint, i2));
      }
    }
    return heap.length == 1 ? heap[0] : new _HeapCursor(heap);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(pos, side = -1e9) {
    for (let cur2 of this.heap)
      cur2.goto(pos, side);
    for (let i2 = this.heap.length >> 1; i2 >= 0; i2--)
      heapBubble(this.heap, i2);
    this.next();
    return this;
  }
  forward(pos, side) {
    for (let cur2 of this.heap)
      cur2.forward(pos, side);
    for (let i2 = this.heap.length >> 1; i2 >= 0; i2--)
      heapBubble(this.heap, i2);
    if ((this.to - pos || this.value.endSide - side) < 0)
      this.next();
  }
  next() {
    if (this.heap.length == 0) {
      this.from = this.to = 1e9;
      this.value = null;
      this.rank = -1;
    } else {
      let top3 = this.heap[0];
      this.from = top3.from;
      this.to = top3.to;
      this.value = top3.value;
      this.rank = top3.rank;
      if (top3.value)
        top3.next();
      heapBubble(this.heap, 0);
    }
  }
};
function heapBubble(heap, index4) {
  for (let cur2 = heap[index4]; ; ) {
    let childIndex = (index4 << 1) + 1;
    if (childIndex >= heap.length)
      break;
    let child = heap[childIndex];
    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
      child = heap[childIndex + 1];
      childIndex++;
    }
    if (cur2.compare(child) < 0)
      break;
    heap[childIndex] = cur2;
    heap[index4] = child;
    index4 = childIndex;
  }
}
var SpanCursor = class {
  constructor(sets, skip, minPoint) {
    this.minPoint = minPoint;
    this.active = [];
    this.activeTo = [];
    this.activeRank = [];
    this.minActive = -1;
    this.point = null;
    this.pointFrom = 0;
    this.pointRank = 0;
    this.to = -1e9;
    this.endSide = 0;
    this.openStart = -1;
    this.cursor = HeapCursor.from(sets, skip, minPoint);
  }
  goto(pos, side = -1e9) {
    this.cursor.goto(pos, side);
    this.active.length = this.activeTo.length = this.activeRank.length = 0;
    this.minActive = -1;
    this.to = pos;
    this.endSide = side;
    this.openStart = -1;
    this.next();
    return this;
  }
  forward(pos, side) {
    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
      this.removeActive(this.minActive);
    this.cursor.forward(pos, side);
  }
  removeActive(index4) {
    remove(this.active, index4);
    remove(this.activeTo, index4);
    remove(this.activeRank, index4);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  addActive(trackOpen) {
    let i2 = 0, { value, to, rank } = this.cursor;
    while (i2 < this.activeRank.length && (rank - this.activeRank[i2] || to - this.activeTo[i2]) > 0)
      i2++;
    insert(this.active, i2, value);
    insert(this.activeTo, i2, to);
    insert(this.activeRank, i2, rank);
    if (trackOpen)
      insert(trackOpen, i2, this.cursor.from);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let from2 = this.to, wasPoint = this.point;
    this.point = null;
    let trackOpen = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let a3 = this.minActive;
      if (a3 > -1 && (this.activeTo[a3] - this.cursor.from || this.active[a3].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[a3] > from2) {
          this.to = this.activeTo[a3];
          this.endSide = this.active[a3].endSide;
          break;
        }
        this.removeActive(a3);
        if (trackOpen)
          remove(trackOpen, a3);
      } else if (!this.cursor.value) {
        this.to = this.endSide = 1e9;
        break;
      } else if (this.cursor.from > from2) {
        this.to = this.cursor.from;
        this.endSide = this.cursor.startSide;
        break;
      } else {
        let nextVal = this.cursor.value;
        if (!nextVal.point) {
          this.addActive(trackOpen);
          this.cursor.next();
        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
          this.cursor.next();
        } else {
          this.point = nextVal;
          this.pointFrom = this.cursor.from;
          this.pointRank = this.cursor.rank;
          this.to = this.cursor.to;
          this.endSide = nextVal.endSide;
          this.cursor.next();
          this.forward(this.to, this.endSide);
          break;
        }
      }
    }
    if (trackOpen) {
      this.openStart = 0;
      for (let i2 = trackOpen.length - 1; i2 >= 0 && trackOpen[i2] < from2; i2--)
        this.openStart++;
    }
  }
  activeForPoint(to) {
    if (!this.active.length)
      return this.active;
    let active = [];
    for (let i2 = this.active.length - 1; i2 >= 0; i2--) {
      if (this.activeRank[i2] < this.pointRank)
        break;
      if (this.activeTo[i2] > to || this.activeTo[i2] == to && this.active[i2].endSide >= this.point.endSide)
        active.push(this.active[i2]);
    }
    return active.reverse();
  }
  openEnd(to) {
    let open = 0;
    for (let i2 = this.activeTo.length - 1; i2 >= 0 && this.activeTo[i2] > to; i2--)
      open++;
    return open;
  }
};
function compare(a3, startA, b2, startB, length2, comparator) {
  a3.goto(startA);
  b2.goto(startB);
  let endB = startB + length2;
  let pos = startB, dPos = startB - startA;
  for (; ; ) {
    let diff = a3.to + dPos - b2.to || a3.endSide - b2.endSide;
    let end2 = diff < 0 ? a3.to + dPos : b2.to, clipEnd = Math.min(end2, endB);
    if (a3.point || b2.point) {
      if (!(a3.point && b2.point && (a3.point == b2.point || a3.point.eq(b2.point)) && sameValues(a3.activeForPoint(a3.to), b2.activeForPoint(b2.to))))
        comparator.comparePoint(pos, clipEnd, a3.point, b2.point);
    } else {
      if (clipEnd > pos && !sameValues(a3.active, b2.active))
        comparator.compareRange(pos, clipEnd, a3.active, b2.active);
    }
    if (end2 > endB)
      break;
    pos = end2;
    if (diff <= 0)
      a3.next();
    if (diff >= 0)
      b2.next();
  }
}
function sameValues(a3, b2) {
  if (a3.length != b2.length)
    return false;
  for (let i2 = 0; i2 < a3.length; i2++)
    if (a3[i2] != b2[i2] && !a3[i2].eq(b2[i2]))
      return false;
  return true;
}
function remove(array, index4) {
  for (let i2 = index4, e4 = array.length - 1; i2 < e4; i2++)
    array[i2] = array[i2 + 1];
  array.pop();
}
function insert(array, index4, value) {
  for (let i2 = array.length - 1; i2 >= index4; i2--)
    array[i2 + 1] = array[i2];
  array[index4] = value;
}
function findMinIndex(value, array) {
  let found = -1, foundPos = 1e9;
  for (let i2 = 0; i2 < array.length; i2++)
    if ((array[i2] - foundPos || value[i2].endSide - value[found].endSide) < 0) {
      found = i2;
      foundPos = array[i2];
    }
  return found;
}
function countColumn(string3, tabSize, to = string3.length) {
  let n = 0;
  for (let i2 = 0; i2 < to; ) {
    if (string3.charCodeAt(i2) == 9) {
      n += tabSize - n % tabSize;
      i2++;
    } else {
      n++;
      i2 = findClusterBreak(string3, i2);
    }
  }
  return n;
}
function findColumn(string3, col, tabSize, strict) {
  for (let i2 = 0, n = 0; ; ) {
    if (n >= col)
      return i2;
    if (i2 == string3.length)
      break;
    n += string3.charCodeAt(i2) == 9 ? tabSize - n % tabSize : 1;
    i2 = findClusterBreak(string3, i2);
  }
  return strict === true ? -1 : string3.length;
}

// node_modules/style-mod/src/style-mod.js
var C = "";
var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
var top2 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
var StyleModule = class {
  // :: (Object<Style>, ?{finish: ?(string)  string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(spec, options2) {
    this.rules = [];
    let { finish } = options2 || {};
    function splitSelector(selector) {
      return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
    }
    function render2(selectors, spec2, target, isKeyframes) {
      let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes3 = isAt && isAt[1] == "keyframes";
      if (isAt && spec2 == null)
        return target.push(selectors[0] + ";");
      for (let prop in spec2) {
        let value = spec2[prop];
        if (/&/.test(prop)) {
          render2(
            prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a3, b2) => a3.concat(b2)),
            value,
            target
          );
        } else if (value && typeof value == "object") {
          if (!isAt)
            throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
          render2(splitSelector(prop), value, local, keyframes3);
        } else if (value != null) {
          local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l) => "-" + l.toLowerCase()) + ": " + value + ";");
        }
      }
      if (local.length || keyframes3) {
        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
      }
    }
    for (let prop in spec)
      render2(splitSelector(prop), spec[prop], this.rules);
  }
  // :: ()  string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join("\n");
  }
  // :: ()  string
  // Generate a new unique CSS class name.
  static newName() {
    let id = top2[COUNT] || 1;
    top2[COUNT] = id + 1;
    return C + id.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(root, modules, options2) {
    let set2 = root[SET], nonce = options2 && options2.nonce;
    if (!set2)
      set2 = new StyleSet(root, nonce);
    else if (nonce)
      set2.setNonce(nonce);
    set2.mount(Array.isArray(modules) ? modules : [modules]);
  }
};
var adoptedSet = /* @__PURE__ */ new Map();
var StyleSet = class {
  constructor(root, nonce) {
    let doc2 = root.ownerDocument || root, win = doc2.defaultView;
    if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
      let adopted = adoptedSet.get(doc2);
      if (adopted) {
        root.adoptedStyleSheets = [adopted.sheet, ...root.adoptedStyleSheets];
        return root[SET] = adopted;
      }
      this.sheet = new win.CSSStyleSheet();
      root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets];
      adoptedSet.set(doc2, this);
    } else {
      this.styleTag = doc2.createElement("style");
      if (nonce)
        this.styleTag.setAttribute("nonce", nonce);
      let target = root.head || root;
      target.insertBefore(this.styleTag, target.firstChild);
    }
    this.modules = [];
    root[SET] = this;
  }
  mount(modules) {
    let sheet = this.sheet;
    let pos = 0, j = 0;
    for (let i2 = 0; i2 < modules.length; i2++) {
      let mod = modules[i2], index4 = this.modules.indexOf(mod);
      if (index4 < j && index4 > -1) {
        this.modules.splice(index4, 1);
        j--;
        index4 = -1;
      }
      if (index4 == -1) {
        this.modules.splice(j++, 0, mod);
        if (sheet)
          for (let k2 = 0; k2 < mod.rules.length; k2++)
            sheet.insertRule(mod.rules[k2], pos++);
      } else {
        while (j < index4)
          pos += this.modules[j++].rules.length;
        pos += mod.rules.length;
        j++;
      }
    }
    if (!sheet) {
      let text = "";
      for (let i2 = 0; i2 < this.modules.length; i2++)
        text += this.modules[i2].getRules() + "\n";
      this.styleTag.textContent = text;
    }
  }
  setNonce(nonce) {
    if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce)
      this.styleTag.setAttribute("nonce", nonce);
  }
};

// node_modules/w3c-keyname/index.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift3 = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (i2 = 0; i2 < 10; i2++)
  base[48 + i2] = base[96 + i2] = String(i2);
var i2;
for (i2 = 1; i2 <= 24; i2++)
  base[i2 + 111] = "F" + i2;
var i2;
for (i2 = 65; i2 <= 90; i2++) {
  base[i2] = String.fromCharCode(i2 + 32);
  shift3[i2] = String.fromCharCode(i2);
}
var i2;
for (code in base)
  if (!shift3.hasOwnProperty(code))
    shift3[code] = base[code];
var code;
function keyName(event) {
  var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name2 = !ignoreKey && event.key || (event.shiftKey ? shift3 : base)[event.keyCode] || event.key || "Unidentified";
  if (name2 == "Esc")
    name2 = "Escape";
  if (name2 == "Del")
    name2 = "Delete";
  if (name2 == "Left")
    name2 = "ArrowLeft";
  if (name2 == "Up")
    name2 = "ArrowUp";
  if (name2 == "Right")
    name2 = "ArrowRight";
  if (name2 == "Down")
    name2 = "ArrowDown";
  return name2;
}

// node_modules/@codemirror/view/dist/index.js
function getSelection(root) {
  let target;
  if (root.nodeType == 11) {
    target = root.getSelection ? root : root.ownerDocument;
  } else {
    target = root;
  }
  return target.getSelection();
}
function contains4(dom, node3) {
  return node3 ? dom == node3 || dom.contains(node3.nodeType != 1 ? node3.parentNode : node3) : false;
}
function deepActiveElement(doc2) {
  let elt = doc2.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function hasSelection(dom, selection) {
  if (!selection.anchorNode)
    return false;
  try {
    return contains4(dom, selection.anchorNode);
  } catch (_) {
    return false;
  }
}
function clientRectsFor(dom) {
  if (dom.nodeType == 3)
    return textRange(dom, 0, dom.nodeValue.length).getClientRects();
  else if (dom.nodeType == 1)
    return dom.getClientRects();
  else
    return [];
}
function isEquivalentPosition(node3, off2, targetNode, targetOff) {
  return targetNode ? scanFor(node3, off2, targetNode, targetOff, -1) || scanFor(node3, off2, targetNode, targetOff, 1) : false;
}
function domIndex(node3) {
  for (var index4 = 0; ; index4++) {
    node3 = node3.previousSibling;
    if (!node3)
      return index4;
  }
}
function scanFor(node3, off2, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node3 == targetNode && off2 == targetOff)
      return true;
    if (off2 == (dir < 0 ? 0 : maxOffset(node3))) {
      if (node3.nodeName == "DIV")
        return false;
      let parent = node3.parentNode;
      if (!parent || parent.nodeType != 1)
        return false;
      off2 = domIndex(node3) + (dir < 0 ? 0 : 1);
      node3 = parent;
    } else if (node3.nodeType == 1) {
      node3 = node3.childNodes[off2 + (dir < 0 ? -1 : 0)];
      if (node3.nodeType == 1 && node3.contentEditable == "false")
        return false;
      off2 = dir < 0 ? maxOffset(node3) : 0;
    } else {
      return false;
    }
  }
}
function maxOffset(node3) {
  return node3.nodeType == 3 ? node3.nodeValue.length : node3.childNodes.length;
}
function flattenRect(rect, left2) {
  let x2 = left2 ? rect.left : rect.right;
  return { left: x2, right: x2, top: rect.top, bottom: rect.bottom };
}
function windowRect(win) {
  return {
    left: 0,
    right: win.innerWidth,
    top: 0,
    bottom: win.innerHeight
  };
}
function getScale2(elt, rect) {
  let scaleX = rect.width / elt.offsetWidth;
  let scaleY = rect.height / elt.offsetHeight;
  if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1)
    scaleX = 1;
  if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1)
    scaleY = 1;
  return { scaleX, scaleY };
}
function scrollRectIntoView(dom, rect, side, x2, y3, xMargin, yMargin, ltr) {
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  for (let cur2 = dom, stop = false; cur2 && !stop; ) {
    if (cur2.nodeType == 1) {
      let bounding, top3 = cur2 == doc2.body;
      let scaleX = 1, scaleY = 1;
      if (top3) {
        bounding = windowRect(win);
      } else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(cur2).position))
          stop = true;
        if (cur2.scrollHeight <= cur2.clientHeight && cur2.scrollWidth <= cur2.clientWidth) {
          cur2 = cur2.assignedSlot || cur2.parentNode;
          continue;
        }
        let rect2 = cur2.getBoundingClientRect();
        ({ scaleX, scaleY } = getScale2(cur2, rect2));
        bounding = {
          left: rect2.left,
          right: rect2.left + cur2.clientWidth * scaleX,
          top: rect2.top,
          bottom: rect2.top + cur2.clientHeight * scaleY
        };
      }
      let moveX = 0, moveY = 0;
      if (y3 == "nearest") {
        if (rect.top < bounding.top) {
          moveY = -(bounding.top - rect.top + yMargin);
          if (side > 0 && rect.bottom > bounding.bottom + moveY)
            moveY = rect.bottom - bounding.bottom + moveY + yMargin;
        } else if (rect.bottom > bounding.bottom) {
          moveY = rect.bottom - bounding.bottom + yMargin;
          if (side < 0 && rect.top - moveY < bounding.top)
            moveY = -(bounding.top + moveY - rect.top + yMargin);
        }
      } else {
        let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
        let targetTop = y3 == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y3 == "start" || y3 == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
        moveY = targetTop - bounding.top;
      }
      if (x2 == "nearest") {
        if (rect.left < bounding.left) {
          moveX = -(bounding.left - rect.left + xMargin);
          if (side > 0 && rect.right > bounding.right + moveX)
            moveX = rect.right - bounding.right + moveX + xMargin;
        } else if (rect.right > bounding.right) {
          moveX = rect.right - bounding.right + xMargin;
          if (side < 0 && rect.left < bounding.left + moveX)
            moveX = -(bounding.left + moveX - rect.left + xMargin);
        }
      } else {
        let targetLeft = x2 == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x2 == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
        moveX = targetLeft - bounding.left;
      }
      if (moveX || moveY) {
        if (top3) {
          win.scrollBy(moveX, moveY);
        } else {
          let movedX = 0, movedY = 0;
          if (moveY) {
            let start2 = cur2.scrollTop;
            cur2.scrollTop += moveY / scaleY;
            movedY = (cur2.scrollTop - start2) * scaleY;
          }
          if (moveX) {
            let start2 = cur2.scrollLeft;
            cur2.scrollLeft += moveX / scaleX;
            movedX = (cur2.scrollLeft - start2) * scaleX;
          }
          rect = {
            left: rect.left - movedX,
            top: rect.top - movedY,
            right: rect.right - movedX,
            bottom: rect.bottom - movedY
          };
          if (movedX && Math.abs(movedX - moveX) < 1)
            x2 = "nearest";
          if (movedY && Math.abs(movedY - moveY) < 1)
            y3 = "nearest";
        }
      }
      if (top3)
        break;
      cur2 = cur2.assignedSlot || cur2.parentNode;
    } else if (cur2.nodeType == 11) {
      cur2 = cur2.host;
    } else {
      break;
    }
  }
}
function scrollableParent(dom) {
  let doc2 = dom.ownerDocument;
  for (let cur2 = dom.parentNode; cur2; ) {
    if (cur2 == doc2.body) {
      break;
    } else if (cur2.nodeType == 1) {
      if (cur2.scrollHeight > cur2.clientHeight || cur2.scrollWidth > cur2.clientWidth)
        return cur2;
      cur2 = cur2.assignedSlot || cur2.parentNode;
    } else if (cur2.nodeType == 11) {
      cur2 = cur2.host;
    } else {
      break;
    }
  }
  return null;
}
var DOMSelectionState = class {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  eq(domSel) {
    return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
  }
  setRange(range) {
    let { anchorNode, focusNode } = range;
    this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));
  }
  set(anchorNode, anchorOffset, focusNode, focusOffset) {
    this.anchorNode = anchorNode;
    this.anchorOffset = anchorOffset;
    this.focusNode = focusNode;
    this.focusOffset = focusOffset;
  }
};
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stack = [];
  for (let cur2 = dom; cur2; cur2 = cur2.parentNode) {
    stack.push(cur2, cur2.scrollTop, cur2.scrollLeft);
    if (cur2 == cur2.ownerDocument)
      break;
  }
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    for (let i2 = 0; i2 < stack.length; ) {
      let elt = stack[i2++], top3 = stack[i2++], left2 = stack[i2++];
      if (elt.scrollTop != top3)
        elt.scrollTop = top3;
      if (elt.scrollLeft != left2)
        elt.scrollLeft = left2;
    }
  }
}
var scratchRange;
function textRange(node3, from2, to = from2) {
  let range = scratchRange || (scratchRange = document.createRange());
  range.setEnd(node3, to);
  range.setStart(node3, from2);
  return range;
}
function dispatchKey(elt, name2, code) {
  let options2 = { key: name2, code: name2, keyCode: code, which: code, cancelable: true };
  let down = new KeyboardEvent("keydown", options2);
  down.synthetic = true;
  elt.dispatchEvent(down);
  let up = new KeyboardEvent("keyup", options2);
  up.synthetic = true;
  elt.dispatchEvent(up);
  return down.defaultPrevented || up.defaultPrevented;
}
function getRoot(node3) {
  while (node3) {
    if (node3 && (node3.nodeType == 9 || node3.nodeType == 11 && node3.host))
      return node3;
    node3 = node3.assignedSlot || node3.parentNode;
  }
  return null;
}
function clearAttributes(node3) {
  while (node3.attributes.length)
    node3.removeAttributeNode(node3.attributes[0]);
}
function atElementStart(doc2, selection) {
  let node3 = selection.focusNode, offset3 = selection.focusOffset;
  if (!node3 || selection.anchorNode != node3 || selection.anchorOffset != offset3)
    return false;
  offset3 = Math.min(offset3, maxOffset(node3));
  for (; ; ) {
    if (offset3) {
      if (node3.nodeType != 1)
        return false;
      let prev2 = node3.childNodes[offset3 - 1];
      if (prev2.contentEditable == "false")
        offset3--;
      else {
        node3 = prev2;
        offset3 = maxOffset(node3);
      }
    } else if (node3 == doc2) {
      return true;
    } else {
      offset3 = domIndex(node3);
      node3 = node3.parentNode;
    }
  }
}
function isScrolledToBottom(elt) {
  return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
}
var DOMPos = class _DOMPos {
  constructor(node3, offset3, precise = true) {
    this.node = node3;
    this.offset = offset3;
    this.precise = precise;
  }
  static before(dom, precise) {
    return new _DOMPos(dom.parentNode, domIndex(dom), precise);
  }
  static after(dom, precise) {
    return new _DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
  }
};
var noChildren = [];
var ContentView = class _ContentView {
  constructor() {
    this.parent = null;
    this.dom = null;
    this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(view) {
    let pos = this.posAtStart;
    for (let child of this.children) {
      if (child == view)
        return pos;
      pos += child.length + child.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(view) {
    return this.posBefore(view) + view.length;
  }
  sync(view, track) {
    if (this.flags & 2) {
      let parent = this.dom;
      let prev2 = null, next2;
      for (let child of this.children) {
        if (child.flags & 7) {
          if (!child.dom && (next2 = prev2 ? prev2.nextSibling : parent.firstChild)) {
            let contentView = _ContentView.get(next2);
            if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
              child.reuseDOM(next2);
          }
          child.sync(view, track);
          child.flags &= ~7;
        }
        next2 = prev2 ? prev2.nextSibling : parent.firstChild;
        if (track && !track.written && track.node == parent && next2 != child.dom)
          track.written = true;
        if (child.dom.parentNode == parent) {
          while (next2 && next2 != child.dom)
            next2 = rm$1(next2);
        } else {
          parent.insertBefore(child.dom, next2);
        }
        prev2 = child.dom;
      }
      next2 = prev2 ? prev2.nextSibling : parent.firstChild;
      if (next2 && track && track.node == parent)
        track.written = true;
      while (next2)
        next2 = rm$1(next2);
    } else if (this.flags & 1) {
      for (let child of this.children)
        if (child.flags & 7) {
          child.sync(view, track);
          child.flags &= ~7;
        }
    }
  }
  reuseDOM(_dom) {
  }
  localPosFromDOM(node3, offset3) {
    let after;
    if (node3 == this.dom) {
      after = this.dom.childNodes[offset3];
    } else {
      let bias = maxOffset(node3) == 0 ? 0 : offset3 == 0 ? -1 : 1;
      for (; ; ) {
        let parent = node3.parentNode;
        if (parent == this.dom)
          break;
        if (bias == 0 && parent.firstChild != parent.lastChild) {
          if (node3 == parent.firstChild)
            bias = -1;
          else
            bias = 1;
        }
        node3 = parent;
      }
      if (bias < 0)
        after = node3;
      else
        after = node3.nextSibling;
    }
    if (after == this.dom.firstChild)
      return 0;
    while (after && !_ContentView.get(after))
      after = after.nextSibling;
    if (!after)
      return this.length;
    for (let i2 = 0, pos = 0; ; i2++) {
      let child = this.children[i2];
      if (child.dom == after)
        return pos;
      pos += child.length + child.breakAfter;
    }
  }
  domBoundsAround(from2, to, offset3 = 0) {
    let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
    for (let i2 = 0, pos = offset3, prevEnd = offset3; i2 < this.children.length; i2++) {
      let child = this.children[i2], end2 = pos + child.length;
      if (pos < from2 && end2 > to)
        return child.domBoundsAround(from2, to, pos);
      if (end2 >= from2 && fromI == -1) {
        fromI = i2;
        fromStart = pos;
      }
      if (pos > to && child.dom.parentNode == this.dom) {
        toI = i2;
        toEnd = prevEnd;
        break;
      }
      prevEnd = end2;
      pos = end2 + child.breakAfter;
    }
    return {
      from: fromStart,
      to: toEnd < 0 ? offset3 + this.length : toEnd,
      startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
    };
  }
  markDirty(andParent = false) {
    this.flags |= 2;
    this.markParentsDirty(andParent);
  }
  markParentsDirty(childList) {
    for (let parent = this.parent; parent; parent = parent.parent) {
      if (childList)
        parent.flags |= 2;
      if (parent.flags & 1)
        return;
      parent.flags |= 1;
      childList = false;
    }
  }
  setParent(parent) {
    if (this.parent != parent) {
      this.parent = parent;
      if (this.flags & 7)
        this.markParentsDirty(true);
    }
  }
  setDOM(dom) {
    if (this.dom == dom)
      return;
    if (this.dom)
      this.dom.cmView = null;
    this.dom = dom;
    dom.cmView = this;
  }
  get rootView() {
    for (let v = this; ; ) {
      let parent = v.parent;
      if (!parent)
        return v;
      v = parent;
    }
  }
  replaceChildren(from2, to, children = noChildren) {
    this.markDirty();
    for (let i2 = from2; i2 < to; i2++) {
      let child = this.children[i2];
      if (child.parent == this && children.indexOf(child) < 0)
        child.destroy();
    }
    this.children.splice(from2, to - from2, ...children);
    for (let i2 = 0; i2 < children.length; i2++)
      children[i2].setParent(this);
  }
  ignoreMutation(_rec) {
    return false;
  }
  ignoreEvent(_event) {
    return false;
  }
  childCursor(pos = this.length) {
    return new ChildCursor(this.children, pos, this.children.length);
  }
  childPos(pos, bias = 1) {
    return this.childCursor().findPos(pos, bias);
  }
  toString() {
    let name2 = this.constructor.name.replace("View", "");
    return name2 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name2 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(node3) {
    return node3.cmView;
  }
  get isEditable() {
    return true;
  }
  get isWidget() {
    return false;
  }
  get isHidden() {
    return false;
  }
  merge(from2, to, source, hasStart, openStart, openEnd) {
    return false;
  }
  become(other) {
    return false;
  }
  canReuseDOM(other) {
    return other.constructor == this.constructor && !((this.flags | other.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let child of this.children)
      if (child.parent == this)
        child.destroy();
    this.parent = null;
  }
};
ContentView.prototype.breakAfter = 0;
function rm$1(dom) {
  let next2 = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next2;
}
var ChildCursor = class {
  constructor(children, pos, i2) {
    this.children = children;
    this.pos = pos;
    this.i = i2;
    this.off = 0;
  }
  findPos(pos, bias = 1) {
    for (; ; ) {
      if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
        this.off = pos - this.pos;
        return this;
      }
      let next2 = this.children[--this.i];
      this.pos -= next2.length + next2.breakAfter;
    }
  }
};
function replaceRange(parent, fromI, fromOff, toI, toOff, insert2, breakAtStart, openStart, openEnd) {
  let { children } = parent;
  let before = children.length ? children[fromI] : null;
  let last = insert2.length ? insert2[insert2.length - 1] : null;
  let breakAtEnd = last ? last.breakAfter : breakAtStart;
  if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert2.length < 2 && before.merge(fromOff, toOff, insert2.length ? last : null, fromOff == 0, openStart, openEnd))
    return;
  if (toI < children.length) {
    let after = children[toI];
    if (after && (toOff < after.length || after.breakAfter && (last === null || last === void 0 ? void 0 : last.breakAfter))) {
      if (fromI == toI) {
        after = after.split(toOff);
        toOff = 0;
      }
      if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
        insert2[insert2.length - 1] = after;
      } else {
        if (toOff || after.children.length && !after.children[0].length)
          after.merge(0, toOff, null, false, 0, openEnd);
        insert2.push(after);
      }
    } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
      if (last)
        last.breakAfter = 1;
      else
        breakAtStart = 1;
    }
    toI++;
  }
  if (before) {
    before.breakAfter = breakAtStart;
    if (fromOff > 0) {
      if (!breakAtStart && insert2.length && before.merge(fromOff, before.length, insert2[0], false, openStart, 0)) {
        before.breakAfter = insert2.shift().breakAfter;
      } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
        before.merge(fromOff, before.length, null, false, openStart, 0);
      }
      fromI++;
    }
  }
  while (fromI < toI && insert2.length) {
    if (children[toI - 1].become(insert2[insert2.length - 1])) {
      toI--;
      insert2.pop();
      openEnd = insert2.length ? 0 : openStart;
    } else if (children[fromI].become(insert2[0])) {
      fromI++;
      insert2.shift();
      openStart = insert2.length ? 0 : openEnd;
    } else {
      break;
    }
  }
  if (!insert2.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
    fromI--;
  if (fromI < toI || insert2.length)
    parent.replaceChildren(fromI, toI, insert2);
}
function mergeChildrenInto(parent, from2, to, insert2, openStart, openEnd) {
  let cur2 = parent.childCursor();
  let { i: toI, off: toOff } = cur2.findPos(to, 1);
  let { i: fromI, off: fromOff } = cur2.findPos(from2, -1);
  let dLen = from2 - to;
  for (let view of insert2)
    dLen += view.length;
  parent.length += dLen;
  replaceRange(parent, fromI, fromOff, toI, toOff, insert2, 0, openStart, openEnd);
}
var nav3 = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
var doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
var ie_edge = /Edge\/(\d+)/.exec(nav3.userAgent);
var ie_upto10 = /MSIE \d/.test(nav3.userAgent);
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav3.userAgent);
var ie2 = !!(ie_upto10 || ie_11up || ie_edge);
var gecko = !ie2 && /gecko\/(\d+)/i.test(nav3.userAgent);
var chrome = !ie2 && /Chrome\/(\d+)/.exec(nav3.userAgent);
var webkit = "webkitFontSmoothing" in doc.documentElement.style;
var safari = !ie2 && /Apple Computer/.test(nav3.vendor);
var ios = safari && (/Mobile\/\w+/.test(nav3.userAgent) || nav3.maxTouchPoints > 2);
var browser2 = {
  mac: ios || /Mac/.test(nav3.platform),
  windows: /Win/.test(nav3.platform),
  linux: /Linux|X11/.test(nav3.platform),
  ie: ie2,
  ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
  gecko,
  gecko_version: gecko ? +(/Firefox\/(\d+)/.exec(nav3.userAgent) || [0, 0])[1] : 0,
  chrome: !!chrome,
  chrome_version: chrome ? +chrome[1] : 0,
  ios,
  android: /Android\b/.test(nav3.userAgent),
  webkit,
  safari,
  webkit_version: webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
var MaxJoinLen = 256;
var TextView = class _TextView extends ContentView {
  constructor(text) {
    super();
    this.text = text;
  }
  get length() {
    return this.text.length;
  }
  createDOM(textDOM) {
    this.setDOM(textDOM || document.createTextNode(this.text));
  }
  sync(view, track) {
    if (!this.dom)
      this.createDOM();
    if (this.dom.nodeValue != this.text) {
      if (track && track.node == this.dom)
        track.written = true;
      this.dom.nodeValue = this.text;
    }
  }
  reuseDOM(dom) {
    if (dom.nodeType == 3)
      this.createDOM(dom);
  }
  merge(from2, to, source) {
    if (this.flags & 8 || source && (!(source instanceof _TextView) || this.length - (to - from2) + source.length > MaxJoinLen || source.flags & 8))
      return false;
    this.text = this.text.slice(0, from2) + (source ? source.text : "") + this.text.slice(to);
    this.markDirty();
    return true;
  }
  split(from2) {
    let result = new _TextView(this.text.slice(from2));
    this.text = this.text.slice(0, from2);
    this.markDirty();
    result.flags |= this.flags & 8;
    return result;
  }
  localPosFromDOM(node3, offset3) {
    return node3 == this.dom ? offset3 : offset3 ? this.text.length : 0;
  }
  domAtPos(pos) {
    return new DOMPos(this.dom, pos);
  }
  domBoundsAround(_from, _to, offset3) {
    return { from: offset3, to: offset3 + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(pos, side) {
    return textCoords(this.dom, pos, side);
  }
};
var MarkView = class _MarkView extends ContentView {
  constructor(mark, children = [], length2 = 0) {
    super();
    this.mark = mark;
    this.children = children;
    this.length = length2;
    for (let ch of children)
      ch.setParent(this);
  }
  setAttrs(dom) {
    clearAttributes(dom);
    if (this.mark.class)
      dom.className = this.mark.class;
    if (this.mark.attrs)
      for (let name2 in this.mark.attrs)
        dom.setAttribute(name2, this.mark.attrs[name2]);
    return dom;
  }
  canReuseDOM(other) {
    return super.canReuseDOM(other) && !((this.flags | other.flags) & 8);
  }
  reuseDOM(node3) {
    if (node3.nodeName == this.mark.tagName.toUpperCase()) {
      this.setDOM(node3);
      this.flags |= 4 | 2;
    }
  }
  sync(view, track) {
    if (!this.dom)
      this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
    else if (this.flags & 4)
      this.setAttrs(this.dom);
    super.sync(view, track);
  }
  merge(from2, to, source, _hasStart, openStart, openEnd) {
    if (source && (!(source instanceof _MarkView && source.mark.eq(this.mark)) || from2 && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    mergeChildrenInto(this, from2, to, source ? source.children.slice() : [], openStart - 1, openEnd - 1);
    this.markDirty();
    return true;
  }
  split(from2) {
    let result = [], off2 = 0, detachFrom = -1, i2 = 0;
    for (let elt of this.children) {
      let end2 = off2 + elt.length;
      if (end2 > from2)
        result.push(off2 < from2 ? elt.split(from2 - off2) : elt);
      if (detachFrom < 0 && off2 >= from2)
        detachFrom = i2;
      off2 = end2;
      i2++;
    }
    let length2 = this.length - from2;
    this.length = from2;
    if (detachFrom > -1) {
      this.children.length = detachFrom;
      this.markDirty();
    }
    return new _MarkView(this.mark, result, length2);
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this, pos);
  }
  coordsAt(pos, side) {
    return coordsInChildren(this, pos, side);
  }
};
function textCoords(text, pos, side) {
  let length2 = text.nodeValue.length;
  if (pos > length2)
    pos = length2;
  let from2 = pos, to = pos, flatten3 = 0;
  if (pos == 0 && side < 0 || pos == length2 && side >= 0) {
    if (!(browser2.chrome || browser2.gecko)) {
      if (pos) {
        from2--;
        flatten3 = 1;
      } else if (to < length2) {
        to++;
        flatten3 = -1;
      }
    }
  } else {
    if (side < 0)
      from2--;
    else if (to < length2)
      to++;
  }
  let rects = textRange(text, from2, to).getClientRects();
  if (!rects.length)
    return null;
  let rect = rects[(flatten3 ? flatten3 < 0 : side >= 0) ? 0 : rects.length - 1];
  if (browser2.safari && !flatten3 && rect.width == 0)
    rect = Array.prototype.find.call(rects, (r2) => r2.width) || rect;
  return flatten3 ? flattenRect(rect, flatten3 < 0) : rect || null;
}
var WidgetView = class _WidgetView extends ContentView {
  static create(widget, length2, side) {
    return new _WidgetView(widget, length2, side);
  }
  constructor(widget, length2, side) {
    super();
    this.widget = widget;
    this.length = length2;
    this.side = side;
    this.prevWidget = null;
  }
  split(from2) {
    let result = _WidgetView.create(this.widget, this.length - from2, this.side);
    this.length -= from2;
    return result;
  }
  sync(view) {
    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
      if (this.dom && this.prevWidget)
        this.prevWidget.destroy(this.dom);
      this.prevWidget = null;
      this.setDOM(this.widget.toDOM(view));
      if (!this.widget.editable)
        this.dom.contentEditable = "false";
    }
  }
  getSide() {
    return this.side;
  }
  merge(from2, to, source, hasStart, openStart, openEnd) {
    if (source && (!(source instanceof _WidgetView) || !this.widget.compare(source.widget) || from2 > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    this.length = from2 + (source ? source.length : 0) + (this.length - to);
    return true;
  }
  become(other) {
    if (other instanceof _WidgetView && other.side == this.side && this.widget.constructor == other.widget.constructor) {
      if (!this.widget.compare(other.widget))
        this.markDirty(true);
      if (this.dom && !this.prevWidget)
        this.prevWidget = this.widget;
      this.widget = other.widget;
      this.length = other.length;
      return true;
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event) {
    return this.widget.ignoreEvent(event);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Text.empty;
    let top3 = this;
    while (top3.parent)
      top3 = top3.parent;
    let { view } = top3, text = view && view.state.doc, start2 = this.posAtStart;
    return text ? text.slice(start2, start2 + this.length) : Text.empty;
  }
  domAtPos(pos) {
    return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos, side) {
    let custom = this.widget.coordsAt(this.dom, pos, side);
    if (custom)
      return custom;
    let rects = this.dom.getClientRects(), rect = null;
    if (!rects.length)
      return null;
    let fromBack = this.side ? this.side < 0 : pos > 0;
    for (let i2 = fromBack ? rects.length - 1 : 0; ; i2 += fromBack ? -1 : 1) {
      rect = rects[i2];
      if (pos > 0 ? i2 == 0 : i2 == rects.length - 1 || rect.top < rect.bottom)
        break;
    }
    return flattenRect(rect, !fromBack);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy();
    if (this.dom)
      this.widget.destroy(this.dom);
  }
};
var WidgetBufferView = class _WidgetBufferView extends ContentView {
  constructor(side) {
    super();
    this.side = side;
  }
  get length() {
    return 0;
  }
  merge() {
    return false;
  }
  become(other) {
    return other instanceof _WidgetBufferView && other.side == this.side;
  }
  split() {
    return new _WidgetBufferView(this.side);
  }
  sync() {
    if (!this.dom) {
      let dom = document.createElement("img");
      dom.className = "cm-widgetBuffer";
      dom.setAttribute("aria-hidden", "true");
      this.setDOM(dom);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(pos) {
    return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Text.empty;
  }
  get isHidden() {
    return true;
  }
};
TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
function inlineDOMAtPos(parent, pos) {
  let dom = parent.dom, { children } = parent, i2 = 0;
  for (let off2 = 0; i2 < children.length; i2++) {
    let child = children[i2], end2 = off2 + child.length;
    if (end2 == off2 && child.getSide() <= 0)
      continue;
    if (pos > off2 && pos < end2 && child.dom.parentNode == dom)
      return child.domAtPos(pos - off2);
    if (pos <= off2)
      break;
    off2 = end2;
  }
  for (let j = i2; j > 0; j--) {
    let prev2 = children[j - 1];
    if (prev2.dom.parentNode == dom)
      return prev2.domAtPos(prev2.length);
  }
  for (let j = i2; j < children.length; j++) {
    let next2 = children[j];
    if (next2.dom.parentNode == dom)
      return next2.domAtPos(0);
  }
  return new DOMPos(dom, 0);
}
function joinInlineInto(parent, view, open) {
  let last, { children } = parent;
  if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
    joinInlineInto(last, view.children[0], open - 1);
  } else {
    children.push(view);
    view.setParent(parent);
  }
  parent.length += view.length;
}
function coordsInChildren(view, pos, side) {
  let before = null, beforePos = -1, after = null, afterPos = -1;
  function scan(view2, pos2) {
    for (let i2 = 0, off2 = 0; i2 < view2.children.length && off2 <= pos2; i2++) {
      let child = view2.children[i2], end2 = off2 + child.length;
      if (end2 >= pos2) {
        if (child.children.length) {
          scan(child, pos2 - off2);
        } else if ((!after || after.isHidden && side > 0) && (end2 > pos2 || off2 == end2 && child.getSide() > 0)) {
          after = child;
          afterPos = pos2 - off2;
        } else if (off2 < pos2 || off2 == end2 && child.getSide() < 0 && !child.isHidden) {
          before = child;
          beforePos = pos2 - off2;
        }
      }
      off2 = end2;
    }
  }
  scan(view, pos);
  let target = (side < 0 ? before : after) || before || after;
  if (target)
    return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
  return fallbackRect(view);
}
function fallbackRect(view) {
  let last = view.dom.lastChild;
  if (!last)
    return view.dom.getBoundingClientRect();
  let rects = clientRectsFor(last);
  return rects[rects.length - 1] || null;
}
function combineAttrs(source, target) {
  for (let name2 in source) {
    if (name2 == "class" && target.class)
      target.class += " " + source.class;
    else if (name2 == "style" && target.style)
      target.style += ";" + source.style;
    else
      target[name2] = source[name2];
  }
  return target;
}
var noAttrs = /* @__PURE__ */ Object.create(null);
function attrsEq(a3, b2, ignore) {
  if (a3 == b2)
    return true;
  if (!a3)
    a3 = noAttrs;
  if (!b2)
    b2 = noAttrs;
  let keysA = Object.keys(a3), keysB = Object.keys(b2);
  if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0))
    return false;
  for (let key of keysA) {
    if (key != ignore && (keysB.indexOf(key) == -1 || a3[key] !== b2[key]))
      return false;
  }
  return true;
}
function updateAttrs(dom, prev2, attrs) {
  let changed = false;
  if (prev2) {
    for (let name2 in prev2)
      if (!(attrs && name2 in attrs)) {
        changed = true;
        if (name2 == "style")
          dom.style.cssText = "";
        else
          dom.removeAttribute(name2);
      }
  }
  if (attrs) {
    for (let name2 in attrs)
      if (!(prev2 && prev2[name2] == attrs[name2])) {
        changed = true;
        if (name2 == "style")
          dom.style.cssText = attrs[name2];
        else
          dom.setAttribute(name2, attrs[name2]);
      }
  }
  return changed;
}
function getAttrs(dom) {
  let attrs = /* @__PURE__ */ Object.create(null);
  for (let i2 = 0; i2 < dom.attributes.length; i2++) {
    let attr = dom.attributes[i2];
    attrs[attr.name] = attr.value;
  }
  return attrs;
}
var LineView = class _LineView extends ContentView {
  constructor() {
    super(...arguments);
    this.children = [];
    this.length = 0;
    this.prevAttrs = void 0;
    this.attrs = null;
    this.breakAfter = 0;
  }
  // Consumes source
  merge(from2, to, source, hasStart, openStart, openEnd) {
    if (source) {
      if (!(source instanceof _LineView))
        return false;
      if (!this.dom)
        source.transferDOM(this);
    }
    if (hasStart)
      this.setDeco(source ? source.attrs : null);
    mergeChildrenInto(this, from2, to, source ? source.children.slice() : [], openStart, openEnd);
    return true;
  }
  split(at2) {
    let end2 = new _LineView();
    end2.breakAfter = this.breakAfter;
    if (this.length == 0)
      return end2;
    let { i: i2, off: off2 } = this.childPos(at2);
    if (off2) {
      end2.append(this.children[i2].split(off2), 0);
      this.children[i2].merge(off2, this.children[i2].length, null, false, 0, 0);
      i2++;
    }
    for (let j = i2; j < this.children.length; j++)
      end2.append(this.children[j], 0);
    while (i2 > 0 && this.children[i2 - 1].length == 0)
      this.children[--i2].destroy();
    this.children.length = i2;
    this.markDirty();
    this.length = at2;
    return end2;
  }
  transferDOM(other) {
    if (!this.dom)
      return;
    this.markDirty();
    other.setDOM(this.dom);
    other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
    this.prevAttrs = void 0;
    this.dom = null;
  }
  setDeco(attrs) {
    if (!attrsEq(this.attrs, attrs)) {
      if (this.dom) {
        this.prevAttrs = this.attrs;
        this.markDirty();
      }
      this.attrs = attrs;
    }
  }
  append(child, openStart) {
    joinInlineInto(this, child, openStart);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(deco) {
    let attrs = deco.spec.attributes, cls = deco.spec.class;
    if (attrs)
      this.attrs = combineAttrs(attrs, this.attrs || {});
    if (cls)
      this.attrs = combineAttrs({ class: cls }, this.attrs || {});
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this, pos);
  }
  reuseDOM(node3) {
    if (node3.nodeName == "DIV") {
      this.setDOM(node3);
      this.flags |= 4 | 2;
    }
  }
  sync(view, track) {
    var _a2;
    if (!this.dom) {
      this.setDOM(document.createElement("div"));
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : void 0;
    } else if (this.flags & 4) {
      clearAttributes(this.dom);
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : void 0;
    }
    if (this.prevAttrs !== void 0) {
      updateAttrs(this.dom, this.prevAttrs, this.attrs);
      this.dom.classList.add("cm-line");
      this.prevAttrs = void 0;
    }
    super.sync(view, track);
    let last = this.dom.lastChild;
    while (last && ContentView.get(last) instanceof MarkView)
      last = last.lastChild;
    if (!last || !this.length || last.nodeName != "BR" && ((_a2 = ContentView.get(last)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) == false && (!browser2.ios || !this.children.some((ch) => ch instanceof TextView))) {
      let hack = document.createElement("BR");
      hack.cmIgnore = true;
      this.dom.appendChild(hack);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let totalWidth = 0, textHeight;
    for (let child of this.children) {
      if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
        return null;
      let rects = clientRectsFor(child.dom);
      if (rects.length != 1)
        return null;
      totalWidth += rects[0].width;
      textHeight = rects[0].height;
    }
    return !totalWidth ? null : {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: totalWidth / this.length,
      textHeight
    };
  }
  coordsAt(pos, side) {
    let rect = coordsInChildren(this, pos, side);
    if (!this.children.length && rect && this.parent) {
      let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;
      if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
        let dist2 = (height - heightOracle.textHeight) / 2;
        return { top: rect.top + dist2, bottom: rect.bottom - dist2, left: rect.left, right: rect.left };
      }
    }
    return rect;
  }
  become(_other) {
    return false;
  }
  covers() {
    return true;
  }
  static find(docView, pos) {
    for (let i2 = 0, off2 = 0; i2 < docView.children.length; i2++) {
      let block = docView.children[i2], end2 = off2 + block.length;
      if (end2 >= pos) {
        if (block instanceof _LineView)
          return block;
        if (end2 > pos)
          break;
      }
      off2 = end2 + block.breakAfter;
    }
    return null;
  }
};
var BlockWidgetView = class _BlockWidgetView extends ContentView {
  constructor(widget, length2, deco) {
    super();
    this.widget = widget;
    this.length = length2;
    this.deco = deco;
    this.breakAfter = 0;
    this.prevWidget = null;
  }
  merge(from2, to, source, _takeDeco, openStart, openEnd) {
    if (source && (!(source instanceof _BlockWidgetView) || !this.widget.compare(source.widget) || from2 > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    this.length = from2 + (source ? source.length : 0) + (this.length - to);
    return true;
  }
  domAtPos(pos) {
    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  split(at2) {
    let len = this.length - at2;
    this.length = at2;
    let end2 = new _BlockWidgetView(this.widget, len, this.deco);
    end2.breakAfter = this.breakAfter;
    return end2;
  }
  get children() {
    return noChildren;
  }
  sync(view) {
    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
      if (this.dom && this.prevWidget)
        this.prevWidget.destroy(this.dom);
      this.prevWidget = null;
      this.setDOM(this.widget.toDOM(view));
      if (!this.widget.editable)
        this.dom.contentEditable = "false";
    }
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(other) {
    if (other instanceof _BlockWidgetView && other.widget.constructor == this.widget.constructor) {
      if (!other.widget.compare(this.widget))
        this.markDirty(true);
      if (this.dom && !this.prevWidget)
        this.prevWidget = this.widget;
      this.widget = other.widget;
      this.length = other.length;
      this.deco = other.deco;
      this.breakAfter = other.breakAfter;
      return true;
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event) {
    return this.widget.ignoreEvent(event);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  coordsAt(pos, side) {
    return this.widget.coordsAt(this.dom, pos, side);
  }
  destroy() {
    super.destroy();
    if (this.dom)
      this.widget.destroy(this.dom);
  }
  covers(side) {
    let { startSide, endSide } = this.deco;
    return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;
  }
};
var WidgetType = class {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(widget) {
    return false;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(dom, view) {
    return false;
  }
  /**
  @internal
  */
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(event) {
    return true;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedless than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(dom, pos, side) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return false;
  }
  /**
  @internal
  */
  get editable() {
    return false;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(dom) {
  }
};
var BlockType = function(BlockType2) {
  BlockType2[BlockType2["Text"] = 0] = "Text";
  BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
  BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
  BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
  return BlockType2;
}(BlockType || (BlockType = {}));
var Decoration = class extends RangeValue {
  constructor(startSide, endSide, widget, spec) {
    super();
    this.startSide = startSide;
    this.endSide = endSide;
    this.widget = widget;
    this.spec = spec;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return false;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(spec) {
    return new MarkDecoration(spec);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(spec) {
    let side = Math.max(-1e4, Math.min(1e4, spec.side || 0)), block = !!spec.block;
    side += block && !spec.inlineOrder ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
    return new PointDecoration(spec, side, side, block, spec.widget || null, false);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(spec) {
    let block = !!spec.block, startSide, endSide;
    if (spec.isBlockGap) {
      startSide = -5e8;
      endSide = 4e8;
    } else {
      let { start: start2, end: end2 } = getInclusive(spec, block);
      startSide = (start2 ? block ? -3e8 : -1 : 5e8) - 1;
      endSide = (end2 ? block ? 2e8 : 1 : -6e8) + 1;
    }
    return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(spec) {
    return new LineDecoration(spec);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(of, sort = false) {
    return RangeSet.of(of, sort);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : false;
  }
};
Decoration.none = RangeSet.empty;
var MarkDecoration = class _MarkDecoration extends Decoration {
  constructor(spec) {
    let { start: start2, end: end2 } = getInclusive(spec);
    super(start2 ? -1 : 5e8, end2 ? 1 : -6e8, null, spec);
    this.tagName = spec.tagName || "span";
    this.class = spec.class || "";
    this.attrs = spec.attributes || null;
  }
  eq(other) {
    var _a2, _b;
    return this == other || other instanceof _MarkDecoration && this.tagName == other.tagName && (this.class || ((_a2 = this.attrs) === null || _a2 === void 0 ? void 0 : _a2.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) && attrsEq(this.attrs, other.attrs, "class");
  }
  range(from2, to = from2) {
    if (from2 >= to)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(from2, to);
  }
};
MarkDecoration.prototype.point = false;
var LineDecoration = class _LineDecoration extends Decoration {
  constructor(spec) {
    super(-2e8, -2e8, null, spec);
  }
  eq(other) {
    return other instanceof _LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);
  }
  range(from2, to = from2) {
    if (to != from2)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(from2, to);
  }
};
LineDecoration.prototype.mapMode = MapMode.TrackBefore;
LineDecoration.prototype.point = true;
var PointDecoration = class _PointDecoration extends Decoration {
  constructor(spec, startSide, endSide, block, widget, isReplace) {
    super(startSide, endSide, widget, spec);
    this.block = block;
    this.isReplace = isReplace;
    this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(other) {
    return other instanceof _PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
  }
  range(from2, to = from2) {
    if (this.isReplace && (from2 > to || from2 == to && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && to != from2)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(from2, to);
  }
};
PointDecoration.prototype.point = true;
function getInclusive(spec, block = false) {
  let { inclusiveStart: start2, inclusiveEnd: end2 } = spec;
  if (start2 == null)
    start2 = spec.inclusive;
  if (end2 == null)
    end2 = spec.inclusive;
  return { start: start2 !== null && start2 !== void 0 ? start2 : block, end: end2 !== null && end2 !== void 0 ? end2 : block };
}
function widgetsEq(a3, b2) {
  return a3 == b2 || !!(a3 && b2 && a3.compare(b2));
}
function addRange(from2, to, ranges, margin = 0) {
  let last = ranges.length - 1;
  if (last >= 0 && ranges[last] + margin >= from2)
    ranges[last] = Math.max(ranges[last], to);
  else
    ranges.push(from2, to);
}
var ContentBuilder = class _ContentBuilder {
  constructor(doc2, pos, end2, disallowBlockEffectsFor) {
    this.doc = doc2;
    this.pos = pos;
    this.end = end2;
    this.disallowBlockEffectsFor = disallowBlockEffectsFor;
    this.content = [];
    this.curLine = null;
    this.breakAtStart = 0;
    this.pendingBuffer = 0;
    this.bufferMarks = [];
    this.atCursorPos = true;
    this.openStart = -1;
    this.openEnd = -1;
    this.text = "";
    this.textOff = 0;
    this.cursor = doc2.iter();
    this.skip = pos;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let last = this.content[this.content.length - 1];
    return !(last.breakAfter || last instanceof BlockWidgetView && last.deco.endSide < 0);
  }
  getLine() {
    if (!this.curLine) {
      this.content.push(this.curLine = new LineView());
      this.atCursorPos = true;
    }
    return this.curLine;
  }
  flushBuffer(active = this.bufferMarks) {
    if (this.pendingBuffer) {
      this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
      this.pendingBuffer = 0;
    }
  }
  addBlockWidget(view) {
    this.flushBuffer();
    this.curLine = null;
    this.content.push(view);
  }
  finish(openEnd) {
    if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
      this.flushBuffer();
    else
      this.pendingBuffer = 0;
    if (!this.posCovered() && !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView))
      this.getLine();
  }
  buildText(length2, active, openStart) {
    while (length2 > 0) {
      if (this.textOff == this.text.length) {
        let { value, lineBreak, done } = this.cursor.next(this.skip);
        this.skip = 0;
        if (done)
          throw new Error("Ran out of text content when drawing inline views");
        if (lineBreak) {
          if (!this.posCovered())
            this.getLine();
          if (this.content.length)
            this.content[this.content.length - 1].breakAfter = 1;
          else
            this.breakAtStart = 1;
          this.flushBuffer();
          this.curLine = null;
          this.atCursorPos = true;
          length2--;
          continue;
        } else {
          this.text = value;
          this.textOff = 0;
        }
      }
      let take = Math.min(
        this.text.length - this.textOff,
        length2,
        512
        /* T.Chunk */
      );
      this.flushBuffer(active.slice(active.length - openStart));
      this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
      this.atCursorPos = true;
      this.textOff += take;
      length2 -= take;
      openStart = 0;
    }
  }
  span(from2, to, active, openStart) {
    this.buildText(to - from2, active, openStart);
    this.pos = to;
    if (this.openStart < 0)
      this.openStart = openStart;
  }
  point(from2, to, deco, active, openStart, index4) {
    if (this.disallowBlockEffectsFor[index4] && deco instanceof PointDecoration) {
      if (deco.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (to > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let len = to - from2;
    if (deco instanceof PointDecoration) {
      if (deco.block) {
        if (deco.startSide > 0 && !this.posCovered())
          this.getLine();
        this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, deco));
      } else {
        let view = WidgetView.create(deco.widget || new NullWidget("span"), len, len ? 0 : deco.startSide);
        let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from2 < to || deco.startSide > 0);
        let cursorAfter = !view.isEditable && (from2 < to || openStart > active.length || deco.startSide <= 0);
        let line2 = this.getLine();
        if (this.pendingBuffer == 2 && !cursorBefore && !view.isEditable)
          this.pendingBuffer = 0;
        this.flushBuffer(active);
        if (cursorBefore) {
          line2.append(wrapMarks(new WidgetBufferView(1), active), openStart);
          openStart = active.length + Math.max(0, openStart - active.length);
        }
        line2.append(wrapMarks(view, active), openStart);
        this.atCursorPos = cursorAfter;
        this.pendingBuffer = !cursorAfter ? 0 : from2 < to || openStart > active.length ? 1 : 2;
        if (this.pendingBuffer)
          this.bufferMarks = active.slice();
      }
    } else if (this.doc.lineAt(this.pos).from == this.pos) {
      this.getLine().addLineDeco(deco);
    }
    if (len) {
      if (this.textOff + len <= this.text.length) {
        this.textOff += len;
      } else {
        this.skip += len - (this.text.length - this.textOff);
        this.text = "";
        this.textOff = 0;
      }
      this.pos = to;
    }
    if (this.openStart < 0)
      this.openStart = openStart;
  }
  static build(text, from2, to, decorations2, dynamicDecorationMap) {
    let builder = new _ContentBuilder(text, from2, to, dynamicDecorationMap);
    builder.openEnd = RangeSet.spans(decorations2, from2, to, builder);
    if (builder.openStart < 0)
      builder.openStart = builder.openEnd;
    builder.finish(builder.openEnd);
    return builder;
  }
};
function wrapMarks(view, active) {
  for (let mark of active)
    view = new MarkView(mark, [view], view.length);
  return view;
}
var NullWidget = class extends WidgetType {
  constructor(tag) {
    super();
    this.tag = tag;
  }
  eq(other) {
    return other.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(elt) {
    return elt.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return true;
  }
};
var Direction = function(Direction2) {
  Direction2[Direction2["LTR"] = 0] = "LTR";
  Direction2[Direction2["RTL"] = 1] = "RTL";
  return Direction2;
}(Direction || (Direction = {}));
var LTR = Direction.LTR;
var RTL = Direction.RTL;
function dec(str) {
  let result = [];
  for (let i2 = 0; i2 < str.length; i2++)
    result.push(1 << +str[i2]);
  return result;
}
var LowTypes = dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
var ArabicTypes = dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
var Brackets = /* @__PURE__ */ Object.create(null);
var BracketStack = [];
for (let p of ["()", "[]", "{}"]) {
  let l = p.charCodeAt(0), r2 = p.charCodeAt(1);
  Brackets[l] = r2;
  Brackets[r2] = -l;
}
function charType(ch) {
  return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8204 ? 256 : 64336 <= ch && ch <= 65023 ? 4 : 1;
}
var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
var BidiSpan = class {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? RTL : LTR;
  }
  /**
  @internal
  */
  constructor(from2, to, level) {
    this.from = from2;
    this.to = to;
    this.level = level;
  }
  /**
  @internal
  */
  side(end2, dir) {
    return this.dir == dir == end2 ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(forward, dir) {
    return forward == (this.dir == dir);
  }
  /**
  @internal
  */
  static find(order2, index4, level, assoc) {
    let maybe = -1;
    for (let i2 = 0; i2 < order2.length; i2++) {
      let span = order2[i2];
      if (span.from <= index4 && span.to >= index4) {
        if (span.level == level)
          return i2;
        if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index4 : span.to > index4 : order2[maybe].level > span.level))
          maybe = i2;
      }
    }
    if (maybe < 0)
      throw new RangeError("Index out of range");
    return maybe;
  }
};
function isolatesEq(a3, b2) {
  if (a3.length != b2.length)
    return false;
  for (let i2 = 0; i2 < a3.length; i2++) {
    let iA = a3[i2], iB = b2[i2];
    if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))
      return false;
  }
  return true;
}
var types = [];
function computeCharTypes(line2, rFrom, rTo, isolates, outerType) {
  for (let iI = 0; iI <= isolates.length; iI++) {
    let from2 = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    let prevType = iI ? 256 : outerType;
    for (let i2 = from2, prev2 = prevType, prevStrong = prevType; i2 < to; i2++) {
      let type = charType(line2.charCodeAt(i2));
      if (type == 512)
        type = prev2;
      else if (type == 8 && prevStrong == 4)
        type = 16;
      types[i2] = type == 4 ? 2 : type;
      if (type & 7)
        prevStrong = type;
      prev2 = type;
    }
    for (let i2 = from2, prev2 = prevType, prevStrong = prevType; i2 < to; i2++) {
      let type = types[i2];
      if (type == 128) {
        if (i2 < to - 1 && prev2 == types[i2 + 1] && prev2 & 24)
          type = types[i2] = prev2;
        else
          types[i2] = 256;
      } else if (type == 64) {
        let end2 = i2 + 1;
        while (end2 < to && types[end2] == 64)
          end2++;
        let replace2 = i2 && prev2 == 8 || end2 < rTo && types[end2] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
        for (let j = i2; j < end2; j++)
          types[j] = replace2;
        i2 = end2 - 1;
      } else if (type == 8 && prevStrong == 1) {
        types[i2] = 1;
      }
      prev2 = type;
      if (type & 7)
        prevStrong = type;
    }
  }
}
function processBracketPairs(line2, rFrom, rTo, isolates, outerType) {
  let oppositeType = outerType == 1 ? 2 : 1;
  for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
    let from2 = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i2 = from2, ch, br, type; i2 < to; i2++) {
      if (br = Brackets[ch = line2.charCodeAt(i2)]) {
        if (br < 0) {
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            if (BracketStack[sJ + 1] == -br) {
              let flags = BracketStack[sJ + 2];
              let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
              if (type2)
                types[i2] = types[BracketStack[sJ]] = type2;
              sI = sJ;
              break;
            }
          }
        } else if (BracketStack.length == 189) {
          break;
        } else {
          BracketStack[sI++] = i2;
          BracketStack[sI++] = ch;
          BracketStack[sI++] = context;
        }
      } else if ((type = types[i2]) == 2 || type == 1) {
        let embed = type == outerType;
        context = embed ? 0 : 1;
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          let cur2 = BracketStack[sJ + 2];
          if (cur2 & 2)
            break;
          if (embed) {
            BracketStack[sJ + 2] |= 2;
          } else {
            if (cur2 & 4)
              break;
            BracketStack[sJ + 2] |= 4;
          }
        }
      }
    }
  }
}
function processNeutrals(rFrom, rTo, isolates, outerType) {
  for (let iI = 0, prev2 = outerType; iI <= isolates.length; iI++) {
    let from2 = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i2 = from2; i2 < to; ) {
      let type = types[i2];
      if (type == 256) {
        let end2 = i2 + 1;
        for (; ; ) {
          if (end2 == to) {
            if (iI == isolates.length)
              break;
            end2 = isolates[iI++].to;
            to = iI < isolates.length ? isolates[iI].from : rTo;
          } else if (types[end2] == 256) {
            end2++;
          } else {
            break;
          }
        }
        let beforeL = prev2 == 1;
        let afterL = (end2 < rTo ? types[end2] : outerType) == 1;
        let replace2 = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
        for (let j = end2, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i2; ) {
          if (j == fromJ) {
            j = isolates[--jI].from;
            fromJ = jI ? isolates[jI - 1].to : rFrom;
          }
          types[--j] = replace2;
        }
        i2 = end2;
      } else {
        prev2 = type;
        i2++;
      }
    }
  }
}
function emitSpans(line2, from2, to, level, baseLevel, isolates, order2) {
  let ourType = level % 2 ? 2 : 1;
  if (level % 2 == baseLevel % 2) {
    for (let iCh = from2, iI = 0; iCh < to; ) {
      let sameDir = true, isNum = false;
      if (iI == isolates.length || iCh < isolates[iI].from) {
        let next2 = types[iCh];
        if (next2 != ourType) {
          sameDir = false;
          isNum = next2 == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level : level + 1;
      let iScan = iCh;
      run:
        for (; ; ) {
          if (iI < isolates.length && iScan == isolates[iI].from) {
            if (isNum)
              break run;
            let iso = isolates[iI];
            if (!sameDir)
              for (let upto = iso.to, jI = iI + 1; ; ) {
                if (upto == to)
                  break run;
                if (jI < isolates.length && isolates[jI].from == upto)
                  upto = isolates[jI++].to;
                else if (types[upto] == ourType)
                  break run;
                else
                  break;
              }
            iI++;
            if (recurse) {
              recurse.push(iso);
            } else {
              if (iso.from > iCh)
                order2.push(new BidiSpan(iCh, iso.from, localLevel));
              let dirSwap = iso.direction == LTR != !(localLevel % 2);
              computeSectionOrder(line2, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order2);
              iCh = iso.to;
            }
            iScan = iso.to;
          } else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
            break;
          } else {
            iScan++;
          }
        }
      if (recurse)
        emitSpans(line2, iCh, iScan, level + 1, baseLevel, recurse, order2);
      else if (iCh < iScan)
        order2.push(new BidiSpan(iCh, iScan, localLevel));
      iCh = iScan;
    }
  } else {
    for (let iCh = to, iI = isolates.length; iCh > from2; ) {
      let sameDir = true, isNum = false;
      if (!iI || iCh > isolates[iI - 1].to) {
        let next2 = types[iCh - 1];
        if (next2 != ourType) {
          sameDir = false;
          isNum = next2 == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level : level + 1;
      let iScan = iCh;
      run:
        for (; ; ) {
          if (iI && iScan == isolates[iI - 1].to) {
            if (isNum)
              break run;
            let iso = isolates[--iI];
            if (!sameDir)
              for (let upto = iso.from, jI = iI; ; ) {
                if (upto == from2)
                  break run;
                if (jI && isolates[jI - 1].to == upto)
                  upto = isolates[--jI].from;
                else if (types[upto - 1] == ourType)
                  break run;
                else
                  break;
              }
            if (recurse) {
              recurse.push(iso);
            } else {
              if (iso.to < iCh)
                order2.push(new BidiSpan(iso.to, iCh, localLevel));
              let dirSwap = iso.direction == LTR != !(localLevel % 2);
              computeSectionOrder(line2, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order2);
              iCh = iso.from;
            }
            iScan = iso.from;
          } else if (iScan == from2 || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
            break;
          } else {
            iScan--;
          }
        }
      if (recurse)
        emitSpans(line2, iScan, iCh, level + 1, baseLevel, recurse, order2);
      else if (iScan < iCh)
        order2.push(new BidiSpan(iScan, iCh, localLevel));
      iCh = iScan;
    }
  }
}
function computeSectionOrder(line2, level, baseLevel, isolates, from2, to, order2) {
  let outerType = level % 2 ? 2 : 1;
  computeCharTypes(line2, from2, to, isolates, outerType);
  processBracketPairs(line2, from2, to, isolates, outerType);
  processNeutrals(from2, to, isolates, outerType);
  emitSpans(line2, from2, to, level, baseLevel, isolates, order2);
}
function computeOrder(line2, direction, isolates) {
  if (!line2)
    return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
  if (direction == LTR && !isolates.length && !BidiRE.test(line2))
    return trivialOrder(line2.length);
  if (isolates.length)
    while (line2.length > types.length)
      types[types.length] = 256;
  let order2 = [], level = direction == LTR ? 0 : 1;
  computeSectionOrder(line2, level, level, isolates, 0, line2.length, order2);
  return order2;
}
function trivialOrder(length2) {
  return [new BidiSpan(0, length2, 0)];
}
var movedOver = "";
function moveVisually(line2, order2, dir, start2, forward) {
  var _a2;
  let startIndex = start2.head - line2.from;
  let spanI = BidiSpan.find(order2, startIndex, (_a2 = start2.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start2.assoc);
  let span = order2[spanI], spanEnd = span.side(forward, dir);
  if (startIndex == spanEnd) {
    let nextI = spanI += forward ? 1 : -1;
    if (nextI < 0 || nextI >= order2.length)
      return null;
    span = order2[spanI = nextI];
    startIndex = span.side(!forward, dir);
    spanEnd = span.side(forward, dir);
  }
  let nextIndex = findClusterBreak(line2.text, startIndex, span.forward(forward, dir));
  if (nextIndex < span.from || nextIndex > span.to)
    nextIndex = spanEnd;
  movedOver = line2.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
  let nextSpan = spanI == (forward ? order2.length - 1 : 0) ? null : order2[spanI + (forward ? 1 : -1)];
  if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level)
    return EditorSelection.cursor(nextSpan.side(!forward, dir) + line2.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);
  return EditorSelection.cursor(nextIndex + line2.from, span.forward(forward, dir) ? -1 : 1, span.level);
}
function autoDirection(text, from2, to) {
  for (let i2 = from2; i2 < to; i2++) {
    let type = charType(text.charCodeAt(i2));
    if (type == 1)
      return LTR;
    if (type == 2 || type == 4)
      return RTL;
  }
  return LTR;
}
var clickAddsSelectionRange = Facet.define();
var dragMovesSelection$1 = Facet.define();
var mouseSelectionStyle = Facet.define();
var exceptionSink = Facet.define();
var updateListener = Facet.define();
var inputHandler = Facet.define();
var focusChangeEffect = Facet.define();
var perLineTextDirection = Facet.define({
  combine: (values) => values.some((x2) => x2)
});
var nativeSelectionHidden = Facet.define({
  combine: (values) => values.some((x2) => x2)
});
var ScrollTarget = class _ScrollTarget {
  constructor(range, y3 = "nearest", x2 = "nearest", yMargin = 5, xMargin = 5, isSnapshot = false) {
    this.range = range;
    this.y = y3;
    this.x = x2;
    this.yMargin = yMargin;
    this.xMargin = xMargin;
    this.isSnapshot = isSnapshot;
  }
  map(changes) {
    return changes.empty ? this : new _ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(state) {
    return this.range.to <= state.doc.length ? this : new _ScrollTarget(EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
};
var scrollIntoView2 = StateEffect.define({ map: (t4, ch) => t4.map(ch) });
function logException(state, exception, context) {
  let handler = state.facet(exceptionSink);
  if (handler.length)
    handler[0](exception);
  else if (window.onerror)
    window.onerror(String(exception), context, void 0, void 0, exception);
  else if (context)
    console.error(context + ":", exception);
  else
    console.error(exception);
}
var editable = Facet.define({ combine: (values) => values.length ? values[0] : true });
var nextPluginID = 0;
var viewPlugin = Facet.define();
var ViewPlugin = class _ViewPlugin {
  constructor(id, create2, domEventHandlers, domEventObservers, buildExtensions) {
    this.id = id;
    this.create = create2;
    this.domEventHandlers = domEventHandlers;
    this.domEventObservers = domEventObservers;
    this.extension = buildExtensions(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(create2, spec) {
    const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};
    return new _ViewPlugin(nextPluginID++, create2, eventHandlers, eventObservers, (plugin2) => {
      let ext = [viewPlugin.of(plugin2)];
      if (deco)
        ext.push(decorations.of((view) => {
          let pluginInst = view.plugin(plugin2);
          return pluginInst ? deco(pluginInst) : Decoration.none;
        }));
      if (provide)
        ext.push(provide(plugin2));
      return ext;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(cls, spec) {
    return _ViewPlugin.define((view) => new cls(view), spec);
  }
};
var PluginInstance = class {
  constructor(spec) {
    this.spec = spec;
    this.mustUpdate = null;
    this.value = null;
  }
  update(view) {
    if (!this.value) {
      if (this.spec) {
        try {
          this.value = this.spec.create(view);
        } catch (e4) {
          logException(view.state, e4, "CodeMirror plugin crashed");
          this.deactivate();
        }
      }
    } else if (this.mustUpdate) {
      let update = this.mustUpdate;
      this.mustUpdate = null;
      if (this.value.update) {
        try {
          this.value.update(update);
        } catch (e4) {
          logException(update.state, e4, "CodeMirror plugin crashed");
          if (this.value.destroy)
            try {
              this.value.destroy();
            } catch (_) {
            }
          this.deactivate();
        }
      }
    }
    return this;
  }
  destroy(view) {
    var _a2;
    if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
      try {
        this.value.destroy();
      } catch (e4) {
        logException(view.state, e4, "CodeMirror plugin crashed");
      }
    }
  }
  deactivate() {
    this.spec = this.value = null;
  }
};
var editorAttributes = Facet.define();
var contentAttributes = Facet.define();
var decorations = Facet.define();
var outerDecorations = Facet.define();
var atomicRanges = Facet.define();
var bidiIsolatedRanges = Facet.define();
function getIsolatedRanges(view, line2) {
  let isolates = view.state.facet(bidiIsolatedRanges);
  if (!isolates.length)
    return isolates;
  let sets = isolates.map((i2) => i2 instanceof Function ? i2(view) : i2);
  let result = [];
  RangeSet.spans(sets, line2.from, line2.to, {
    point() {
    },
    span(fromDoc, toDoc, active, open) {
      let from2 = fromDoc - line2.from, to = toDoc - line2.from;
      let level = result;
      for (let i2 = active.length - 1; i2 >= 0; i2--, open--) {
        let direction = active[i2].spec.bidiIsolate, update;
        if (direction == null)
          direction = autoDirection(line2.text, from2, to);
        if (open > 0 && level.length && (update = level[level.length - 1]).to == from2 && update.direction == direction) {
          update.to = to;
          level = update.inner;
        } else {
          let add3 = { from: from2, to, direction, inner: [] };
          level.push(add3);
          level = add3.inner;
        }
      }
    }
  });
  return result;
}
var scrollMargins = Facet.define();
function getScrollMargins(view) {
  let left2 = 0, right2 = 0, top3 = 0, bottom2 = 0;
  for (let source of view.state.facet(scrollMargins)) {
    let m3 = source(view);
    if (m3) {
      if (m3.left != null)
        left2 = Math.max(left2, m3.left);
      if (m3.right != null)
        right2 = Math.max(right2, m3.right);
      if (m3.top != null)
        top3 = Math.max(top3, m3.top);
      if (m3.bottom != null)
        bottom2 = Math.max(bottom2, m3.bottom);
    }
  }
  return { left: left2, right: right2, top: top3, bottom: bottom2 };
}
var styleModule = Facet.define();
var ChangedRange = class _ChangedRange {
  constructor(fromA, toA, fromB, toB) {
    this.fromA = fromA;
    this.toA = toA;
    this.fromB = fromB;
    this.toB = toB;
  }
  join(other) {
    return new _ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
  }
  addToSet(set2) {
    let i2 = set2.length, me2 = this;
    for (; i2 > 0; i2--) {
      let range = set2[i2 - 1];
      if (range.fromA > me2.toA)
        continue;
      if (range.toA < me2.fromA)
        break;
      me2 = me2.join(range);
      set2.splice(i2 - 1, 1);
    }
    set2.splice(i2, 0, me2);
    return set2;
  }
  static extendWithRanges(diff, ranges) {
    if (ranges.length == 0)
      return diff;
    let result = [];
    for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
      let next2 = dI == diff.length ? null : diff[dI], off2 = posA - posB;
      let end2 = next2 ? next2.fromB : 1e9;
      while (rI < ranges.length && ranges[rI] < end2) {
        let from2 = ranges[rI], to = ranges[rI + 1];
        let fromB = Math.max(posB, from2), toB = Math.min(end2, to);
        if (fromB <= toB)
          new _ChangedRange(fromB + off2, toB + off2, fromB, toB).addToSet(result);
        if (to > end2)
          break;
        else
          rI += 2;
      }
      if (!next2)
        return result;
      new _ChangedRange(next2.fromA, next2.toA, next2.fromB, next2.toB).addToSet(result);
      posA = next2.toA;
      posB = next2.toB;
    }
  }
};
var ViewUpdate = class _ViewUpdate {
  constructor(view, state, transactions) {
    this.view = view;
    this.state = state;
    this.transactions = transactions;
    this.flags = 0;
    this.startState = view.state;
    this.changes = ChangeSet.empty(this.startState.doc.length);
    for (let tr2 of transactions)
      this.changes = this.changes.compose(tr2.changes);
    let changedRanges = [];
    this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
    this.changedRanges = changedRanges;
  }
  /**
  @internal
  */
  static create(view, state, transactions) {
    return new _ViewUpdate(view, state, transactions);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & (8 | 2)) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((tr2) => tr2.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
};
var DocView = class extends ContentView {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(view) {
    super();
    this.view = view;
    this.decorations = [];
    this.dynamicDecorationMap = [];
    this.domChanged = null;
    this.hasComposition = null;
    this.markedForComposition = /* @__PURE__ */ new Set();
    this.minWidth = 0;
    this.minWidthFrom = 0;
    this.minWidthTo = 0;
    this.impreciseAnchor = null;
    this.impreciseHead = null;
    this.forceSelection = false;
    this.lastUpdate = Date.now();
    this.setDOM(view.contentDOM);
    this.children = [new LineView()];
    this.children[0].setParent(this);
    this.updateDeco();
    this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(update) {
    var _a2;
    let changedRanges = update.changedRanges;
    if (this.minWidth > 0 && changedRanges.length) {
      if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
        this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
      } else {
        this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
        this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
      }
    }
    let readCompositionAt = -1;
    if (this.view.inputState.composing >= 0) {
      if ((_a2 = this.domChanged) === null || _a2 === void 0 ? void 0 : _a2.newSel)
        readCompositionAt = this.domChanged.newSel.head;
      else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet)
        readCompositionAt = update.state.selection.main.head;
    }
    let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;
    this.domChanged = null;
    if (this.hasComposition) {
      this.markedForComposition.clear();
      let { from: from2, to } = this.hasComposition;
      changedRanges = new ChangedRange(from2, to, update.changes.mapPos(from2, -1), update.changes.mapPos(to, 1)).addToSet(changedRanges.slice());
    }
    this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;
    if ((browser2.ie || browser2.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines)
      this.forceSelection = true;
    let prevDeco = this.decorations, deco = this.updateDeco();
    let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
    changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
    if (!(this.flags & 7) && changedRanges.length == 0) {
      return false;
    } else {
      this.updateInner(changedRanges, update.startState.doc.length, composition);
      if (update.transactions.length)
        this.lastUpdate = Date.now();
      return true;
    }
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(changes, oldLength, composition) {
    this.view.viewState.mustMeasureContent = true;
    this.updateChildren(changes, oldLength, composition);
    let { observer } = this.view;
    observer.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
      this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let track = browser2.chrome || browser2.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
      this.sync(this.view, track);
      this.flags &= ~7;
      if (track && (track.written || observer.selectionRange.focusNode != track.node))
        this.forceSelection = true;
      this.dom.style.height = "";
    });
    this.markedForComposition.forEach(
      (cView) => cView.flags &= ~8
      /* ViewFlag.Composition */
    );
    let gaps = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
      for (let child of this.children)
        if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
          gaps.push(child.dom);
    }
    observer.updateGaps(gaps);
  }
  updateChildren(changes, oldLength, composition) {
    let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
    let cursor2 = this.childCursor(oldLength);
    for (let i2 = ranges.length - 1; ; i2--) {
      let next2 = i2 >= 0 ? ranges[i2] : null;
      if (!next2)
        break;
      let { fromA, toA, fromB, toB } = next2, content2, breakAtStart, openStart, openEnd;
      if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
        let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
        let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
        breakAtStart = before.breakAtStart;
        openStart = before.openStart;
        openEnd = after.openEnd;
        let compLine = this.compositionView(composition);
        if (after.breakAtStart) {
          compLine.breakAfter = 1;
        } else if (after.content.length && compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {
          compLine.breakAfter = after.content[0].breakAfter;
          after.content.shift();
        }
        if (before.content.length && compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {
          before.content.pop();
        }
        content2 = before.content.concat(compLine).concat(after.content);
      } else {
        ({ content: content2, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));
      }
      let { i: toI, off: toOff } = cursor2.findPos(toA, 1);
      let { i: fromI, off: fromOff } = cursor2.findPos(fromA, -1);
      replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
    }
    if (composition)
      this.fixCompositionDOM(composition);
  }
  compositionView(composition) {
    let cur2 = new TextView(composition.text.nodeValue);
    cur2.flags |= 8;
    for (let { deco } of composition.marks)
      cur2 = new MarkView(deco, [cur2], cur2.length);
    let line2 = new LineView();
    line2.append(cur2, 0);
    return line2;
  }
  fixCompositionDOM(composition) {
    let fix = (dom, cView2) => {
      cView2.flags |= 8 | (cView2.children.some(
        (c2) => c2.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0);
      this.markedForComposition.add(cView2);
      let prev2 = ContentView.get(dom);
      if (prev2 && prev2 != cView2)
        prev2.dom = null;
      cView2.setDOM(dom);
    };
    let pos = this.childPos(composition.range.fromB, 1);
    let cView = this.children[pos.i];
    fix(composition.line, cView);
    for (let i2 = composition.marks.length - 1; i2 >= -1; i2--) {
      pos = cView.childPos(pos.off, 1);
      cView = cView.children[pos.i];
      fix(i2 >= 0 ? composition.marks[i2].node : composition.text, cView);
    }
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(mustRead = false, fromPointer = false) {
    if (mustRead || !this.view.observer.selectionRange.focusNode)
      this.view.observer.readSelectionRange();
    let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;
    let selectionNotFocus = !focused && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
    if (!(focused || fromPointer || selectionNotFocus))
      return;
    let force = this.forceSelection;
    this.forceSelection = false;
    let main2 = this.view.state.selection.main;
    let anchor = this.moveToLine(this.domAtPos(main2.anchor));
    let head = main2.empty ? anchor : this.moveToLine(this.domAtPos(main2.head));
    if (browser2.gecko && main2.empty && !this.hasComposition && betweenUneditable(anchor)) {
      let dummy = document.createTextNode("");
      this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
      anchor = head = new DOMPos(dummy, 0);
      force = true;
    }
    let domSel = this.view.observer.selectionRange;
    if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main2)) {
      this.view.observer.ignore(() => {
        if (browser2.android && browser2.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
          this.dom.blur();
          this.dom.focus({ preventScroll: true });
        }
        let rawSel = getSelection(this.view.root);
        if (!rawSel)
          ;
        else if (main2.empty) {
          if (browser2.gecko) {
            let nextTo = nextToUneditable(anchor.node, anchor.offset);
            if (nextTo && nextTo != (1 | 2)) {
              let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 ? 1 : -1);
              if (text)
                anchor = new DOMPos(text.node, text.offset);
            }
          }
          rawSel.collapse(anchor.node, anchor.offset);
          if (main2.bidiLevel != null && rawSel.caretBidiLevel !== void 0)
            rawSel.caretBidiLevel = main2.bidiLevel;
        } else if (rawSel.extend) {
          rawSel.collapse(anchor.node, anchor.offset);
          try {
            rawSel.extend(head.node, head.offset);
          } catch (_) {
          }
        } else {
          let range = document.createRange();
          if (main2.anchor > main2.head)
            [anchor, head] = [head, anchor];
          range.setEnd(head.node, head.offset);
          range.setStart(anchor.node, anchor.offset);
          rawSel.removeAllRanges();
          rawSel.addRange(range);
        }
        if (selectionNotFocus && this.view.root.activeElement == this.dom) {
          this.dom.blur();
          if (activeElt)
            activeElt.focus();
        }
      });
      this.view.observer.setSelectionRange(anchor, head);
    }
    this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
    this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(sel, cursor2) {
    return this.hasComposition && cursor2.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor2.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view } = this, cursor2 = view.state.selection.main;
    let sel = getSelection(view.root);
    let { anchorNode, anchorOffset } = view.observer.selectionRange;
    if (!sel || !cursor2.empty || !cursor2.assoc || !sel.modify)
      return;
    let line2 = LineView.find(this, cursor2.head);
    if (!line2)
      return;
    let lineStart = line2.posAtStart;
    if (cursor2.head == lineStart || cursor2.head == lineStart + line2.length)
      return;
    let before = this.coordsAt(cursor2.head, -1), after = this.coordsAt(cursor2.head, 1);
    if (!before || !after || before.bottom > after.top)
      return;
    let dom = this.domAtPos(cursor2.head + cursor2.assoc);
    sel.collapse(dom.node, dom.offset);
    sel.modify("move", cursor2.assoc < 0 ? "forward" : "backward", "lineboundary");
    view.observer.readSelectionRange();
    let newRange = view.observer.selectionRange;
    if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor2.from)
      sel.collapse(anchorNode, anchorOffset);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(pos) {
    let dom = this.dom, newPos;
    if (pos.node != dom)
      return pos;
    for (let i2 = pos.offset; !newPos && i2 < dom.childNodes.length; i2++) {
      let view = ContentView.get(dom.childNodes[i2]);
      if (view instanceof LineView)
        newPos = view.domAtPos(0);
    }
    for (let i2 = pos.offset - 1; !newPos && i2 >= 0; i2--) {
      let view = ContentView.get(dom.childNodes[i2]);
      if (view instanceof LineView)
        newPos = view.domAtPos(view.length);
    }
    return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;
  }
  nearest(dom) {
    for (let cur2 = dom; cur2; ) {
      let domView = ContentView.get(cur2);
      if (domView && domView.rootView == this)
        return domView;
      cur2 = cur2.parentNode;
    }
    return null;
  }
  posFromDOM(node3, offset3) {
    let view = this.nearest(node3);
    if (!view)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return view.localPosFromDOM(node3, offset3) + view.posAtStart;
  }
  domAtPos(pos) {
    let { i: i2, off: off2 } = this.childCursor().findPos(pos, -1);
    for (; i2 < this.children.length - 1; ) {
      let child = this.children[i2];
      if (off2 < child.length || child instanceof LineView)
        break;
      i2++;
      off2 = 0;
    }
    return this.children[i2].domAtPos(off2);
  }
  coordsAt(pos, side) {
    let best = null, bestPos = 0;
    for (let off2 = this.length, i2 = this.children.length - 1; i2 >= 0; i2--) {
      let child = this.children[i2], end2 = off2 - child.breakAfter, start2 = end2 - child.length;
      if (end2 < pos)
        break;
      if (start2 <= pos && (start2 < pos || child.covers(-1)) && (end2 > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {
        best = child;
        bestPos = start2;
      }
      off2 = start2;
    }
    return best ? best.coordsAt(pos - bestPos, side) : null;
  }
  coordsForChar(pos) {
    let { i: i2, off: off2 } = this.childPos(pos, 1), child = this.children[i2];
    if (!(child instanceof LineView))
      return null;
    while (child.children.length) {
      let { i: i3, off: childOff } = child.childPos(off2, 1);
      for (; ; i3++) {
        if (i3 == child.children.length)
          return null;
        if ((child = child.children[i3]).length)
          break;
      }
      off2 = childOff;
    }
    if (!(child instanceof TextView))
      return null;
    let end2 = findClusterBreak(child.text, off2);
    if (end2 == off2)
      return null;
    let rects = textRange(child.dom, off2, end2).getClientRects();
    for (let i3 = 0; i3 < rects.length; i3++) {
      let rect = rects[i3];
      if (i3 == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right)
        return rect;
    }
    return null;
  }
  measureVisibleLineHeights(viewport2) {
    let result = [], { from: from2, to } = viewport2;
    let contentWidth = this.view.contentDOM.clientWidth;
    let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
    let widest = -1, ltr = this.view.textDirection == Direction.LTR;
    for (let pos = 0, i2 = 0; i2 < this.children.length; i2++) {
      let child = this.children[i2], end2 = pos + child.length;
      if (end2 > to)
        break;
      if (pos >= from2) {
        let childRect = child.dom.getBoundingClientRect();
        result.push(childRect.height);
        if (isWider) {
          let last = child.dom.lastChild;
          let rects = last ? clientRectsFor(last) : [];
          if (rects.length) {
            let rect = rects[rects.length - 1];
            let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
            if (width > widest) {
              widest = width;
              this.minWidth = contentWidth;
              this.minWidthFrom = pos;
              this.minWidthTo = end2;
            }
          }
        }
      }
      pos = end2 + child.breakAfter;
    }
    return result;
  }
  textDirectionAt(pos) {
    let { i: i2 } = this.childPos(pos, 1);
    return getComputedStyle(this.children[i2].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
  }
  measureTextSize() {
    for (let child of this.children) {
      if (child instanceof LineView) {
        let measure = child.measureTextSize();
        if (measure)
          return measure;
      }
    }
    let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
    dummy.className = "cm-line";
    dummy.style.width = "99999px";
    dummy.style.position = "absolute";
    dummy.textContent = "abc def ghi jkl mno pqr stu";
    this.view.observer.ignore(() => {
      this.dom.appendChild(dummy);
      let rect = clientRectsFor(dummy.firstChild)[0];
      lineHeight = dummy.getBoundingClientRect().height;
      charWidth = rect ? rect.width / 27 : 7;
      textHeight = rect ? rect.height : lineHeight;
      dummy.remove();
    });
    return { lineHeight, charWidth, textHeight };
  }
  childCursor(pos = this.length) {
    let i2 = this.children.length;
    if (i2)
      pos -= this.children[--i2].length;
    return new ChildCursor(this.children, pos, i2);
  }
  computeBlockGapDeco() {
    let deco = [], vs2 = this.view.viewState;
    for (let pos = 0, i2 = 0; ; i2++) {
      let next2 = i2 == vs2.viewports.length ? null : vs2.viewports[i2];
      let end2 = next2 ? next2.from - 1 : this.length;
      if (end2 > pos) {
        let height = (vs2.lineBlockAt(end2).bottom - vs2.lineBlockAt(pos).top) / this.view.scaleY;
        deco.push(Decoration.replace({
          widget: new BlockGapWidget(height),
          block: true,
          inclusive: true,
          isBlockGap: true
        }).range(pos, end2));
      }
      if (!next2)
        break;
      pos = next2.to + 1;
    }
    return Decoration.set(deco);
  }
  updateDeco() {
    let allDeco = this.view.state.facet(decorations).map((d3, i2) => {
      let dynamic = this.dynamicDecorationMap[i2] = typeof d3 == "function";
      return dynamic ? d3(this.view) : d3;
    });
    let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d3, i2) => {
      let dynamic = typeof d3 == "function";
      if (dynamic)
        dynamicOuter = true;
      return dynamic ? d3(this.view) : d3;
    });
    if (outerDeco.length) {
      this.dynamicDecorationMap[allDeco.length] = dynamicOuter;
      allDeco.push(RangeSet.join(outerDeco));
    }
    for (let i2 = allDeco.length; i2 < allDeco.length + 3; i2++)
      this.dynamicDecorationMap[i2] = false;
    return this.decorations = [
      ...allDeco,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(target) {
    if (target.isSnapshot) {
      let ref = this.view.viewState.lineBlockAt(target.range.head);
      this.view.scrollDOM.scrollTop = ref.top - target.yMargin;
      this.view.scrollDOM.scrollLeft = target.xMargin;
      return;
    }
    let { range } = target;
    let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
    if (!rect)
      return;
    if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
      rect = {
        left: Math.min(rect.left, other.left),
        top: Math.min(rect.top, other.top),
        right: Math.max(rect.right, other.right),
        bottom: Math.max(rect.bottom, other.bottom)
      };
    let margins = getScrollMargins(this.view);
    let targetRect = {
      left: rect.left - margins.left,
      top: rect.top - margins.top,
      right: rect.right + margins.right,
      bottom: rect.bottom + margins.bottom
    };
    let { offsetWidth, offsetHeight } = this.view.scrollDOM;
    scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);
  }
};
function betweenUneditable(pos) {
  return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
var BlockGapWidget = class extends WidgetType {
  constructor(height) {
    super();
    this.height = height;
  }
  toDOM() {
    let elt = document.createElement("div");
    elt.className = "cm-gap";
    this.updateDOM(elt);
    return elt;
  }
  eq(other) {
    return other.height == this.height;
  }
  updateDOM(elt) {
    elt.style.height = this.height + "px";
    return true;
  }
  get editable() {
    return true;
  }
  get estimatedHeight() {
    return this.height;
  }
};
function findCompositionNode(view, headPos) {
  let sel = view.observer.selectionRange;
  let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
  if (!textNode)
    return null;
  let from2 = headPos - textNode.offset;
  return { from: from2, to: from2 + textNode.node.nodeValue.length, node: textNode.node };
}
function findCompositionRange(view, changes, headPos) {
  let found = findCompositionNode(view, headPos);
  if (!found)
    return null;
  let { node: textNode, from: from2, to } = found, text = textNode.nodeValue;
  if (/[\n\r]/.test(text))
    return null;
  if (view.state.doc.sliceString(found.from, found.to) != text)
    return null;
  let inv = changes.invertedDesc;
  let range = new ChangedRange(inv.mapPos(from2), inv.mapPos(to), from2, to);
  let marks2 = [];
  for (let parent = textNode.parentNode; ; parent = parent.parentNode) {
    let parentView = ContentView.get(parent);
    if (parentView instanceof MarkView)
      marks2.push({ node: parent, deco: parentView.mark });
    else if (parentView instanceof LineView || parent.nodeName == "DIV" && parent.parentNode == view.contentDOM)
      return { range, text: textNode, marks: marks2, line: parent };
    else if (parent != view.contentDOM)
      marks2.push({ node: parent, deco: new MarkDecoration({
        inclusive: true,
        attributes: getAttrs(parent),
        tagName: parent.tagName.toLowerCase()
      }) });
    else
      return null;
  }
}
function nearbyTextNode(startNode, startOffset, side) {
  if (side <= 0)
    for (let node3 = startNode, offset3 = startOffset; ; ) {
      if (node3.nodeType == 3)
        return { node: node3, offset: offset3 };
      if (node3.nodeType == 1 && offset3 > 0) {
        node3 = node3.childNodes[offset3 - 1];
        offset3 = maxOffset(node3);
      } else {
        break;
      }
    }
  if (side >= 0)
    for (let node3 = startNode, offset3 = startOffset; ; ) {
      if (node3.nodeType == 3)
        return { node: node3, offset: offset3 };
      if (node3.nodeType == 1 && offset3 < node3.childNodes.length && side >= 0) {
        node3 = node3.childNodes[offset3];
        offset3 = 0;
      } else {
        break;
      }
    }
  return null;
}
function nextToUneditable(node3, offset3) {
  if (node3.nodeType != 1)
    return 0;
  return (offset3 && node3.childNodes[offset3 - 1].contentEditable == "false" ? 1 : 0) | (offset3 < node3.childNodes.length && node3.childNodes[offset3].contentEditable == "false" ? 2 : 0);
}
var DecorationComparator$1 = class DecorationComparator {
  constructor() {
    this.changes = [];
  }
  compareRange(from2, to) {
    addRange(from2, to, this.changes);
  }
  comparePoint(from2, to) {
    addRange(from2, to, this.changes);
  }
};
function findChangedDeco(a3, b2, diff) {
  let comp = new DecorationComparator$1();
  RangeSet.compare(a3, b2, diff, comp);
  return comp.changes;
}
function inUneditable(node3, inside2) {
  for (let cur2 = node3; cur2 && cur2 != inside2; cur2 = cur2.assignedSlot || cur2.parentNode) {
    if (cur2.nodeType == 1 && cur2.contentEditable == "false") {
      return true;
    }
  }
  return false;
}
function touchesComposition(changes, composition) {
  let touched = false;
  if (composition)
    changes.iterChangedRanges((from2, to) => {
      if (from2 < composition.to && to > composition.from)
        touched = true;
    });
  return touched;
}
function groupAt(state, pos, bias = 1) {
  let categorize = state.charCategorizer(pos);
  let line2 = state.doc.lineAt(pos), linePos = pos - line2.from;
  if (line2.length == 0)
    return EditorSelection.cursor(pos);
  if (linePos == 0)
    bias = 1;
  else if (linePos == line2.length)
    bias = -1;
  let from2 = linePos, to = linePos;
  if (bias < 0)
    from2 = findClusterBreak(line2.text, linePos, false);
  else
    to = findClusterBreak(line2.text, linePos);
  let cat = categorize(line2.text.slice(from2, to));
  while (from2 > 0) {
    let prev2 = findClusterBreak(line2.text, from2, false);
    if (categorize(line2.text.slice(prev2, from2)) != cat)
      break;
    from2 = prev2;
  }
  while (to < line2.length) {
    let next2 = findClusterBreak(line2.text, to);
    if (categorize(line2.text.slice(to, next2)) != cat)
      break;
    to = next2;
  }
  return EditorSelection.range(from2 + line2.from, to + line2.from);
}
function getdx(x2, rect) {
  return rect.left > x2 ? rect.left - x2 : Math.max(0, x2 - rect.right);
}
function getdy(y3, rect) {
  return rect.top > y3 ? rect.top - y3 : Math.max(0, y3 - rect.bottom);
}
function yOverlap(a3, b2) {
  return a3.top < b2.bottom - 1 && a3.bottom > b2.top + 1;
}
function upTop(rect, top3) {
  return top3 < rect.top ? { top: top3, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
}
function upBot(rect, bottom2) {
  return bottom2 > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom: bottom2 } : rect;
}
function domPosAtCoords(parent, x2, y3) {
  let closest, closestRect, closestX, closestY, closestOverlap = false;
  let above, below, aboveRect, belowRect;
  for (let child = parent.firstChild; child; child = child.nextSibling) {
    let rects = clientRectsFor(child);
    for (let i2 = 0; i2 < rects.length; i2++) {
      let rect = rects[i2];
      if (closestRect && yOverlap(closestRect, rect))
        rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
      let dx = getdx(x2, rect), dy = getdy(y3, rect);
      if (dx == 0 && dy == 0)
        return child.nodeType == 3 ? domPosInText(child, x2, y3) : domPosAtCoords(child, x2, y3);
      if (!closest || closestY > dy || closestY == dy && closestX > dx) {
        closest = child;
        closestRect = rect;
        closestX = dx;
        closestY = dy;
        let side = dy ? y3 < rect.top ? -1 : 1 : dx ? x2 < rect.left ? -1 : 1 : 0;
        closestOverlap = !side || (side > 0 ? i2 < rects.length - 1 : i2 > 0);
      }
      if (dx == 0) {
        if (y3 > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
          above = child;
          aboveRect = rect;
        } else if (y3 < rect.top && (!belowRect || belowRect.top > rect.top)) {
          below = child;
          belowRect = rect;
        }
      } else if (aboveRect && yOverlap(aboveRect, rect)) {
        aboveRect = upBot(aboveRect, rect.bottom);
      } else if (belowRect && yOverlap(belowRect, rect)) {
        belowRect = upTop(belowRect, rect.top);
      }
    }
  }
  if (aboveRect && aboveRect.bottom >= y3) {
    closest = above;
    closestRect = aboveRect;
  } else if (belowRect && belowRect.top <= y3) {
    closest = below;
    closestRect = belowRect;
  }
  if (!closest)
    return { node: parent, offset: 0 };
  let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x2));
  if (closest.nodeType == 3)
    return domPosInText(closest, clipX, y3);
  if (closestOverlap && closest.contentEditable != "false")
    return domPosAtCoords(closest, clipX, y3);
  let offset3 = Array.prototype.indexOf.call(parent.childNodes, closest) + (x2 >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
  return { node: parent, offset: offset3 };
}
function domPosInText(node3, x2, y3) {
  let len = node3.nodeValue.length;
  let closestOffset = -1, closestDY = 1e9, generalSide = 0;
  for (let i2 = 0; i2 < len; i2++) {
    let rects = textRange(node3, i2, i2 + 1).getClientRects();
    for (let j = 0; j < rects.length; j++) {
      let rect = rects[j];
      if (rect.top == rect.bottom)
        continue;
      if (!generalSide)
        generalSide = x2 - rect.left;
      let dy = (rect.top > y3 ? rect.top - y3 : y3 - rect.bottom) - 1;
      if (rect.left - 1 <= x2 && rect.right + 1 >= x2 && dy < closestDY) {
        let right2 = x2 >= (rect.left + rect.right) / 2, after = right2;
        if (browser2.chrome || browser2.gecko) {
          let rectBefore = textRange(node3, i2).getBoundingClientRect();
          if (rectBefore.left == rect.right)
            after = !right2;
        }
        if (dy <= 0)
          return { node: node3, offset: i2 + (after ? 1 : 0) };
        closestOffset = i2 + (after ? 1 : 0);
        closestDY = dy;
      }
    }
  }
  return { node: node3, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node3.nodeValue.length : 0 };
}
function posAtCoords(view, coords, precise, bias = -1) {
  var _a2, _b;
  let content2 = view.contentDOM.getBoundingClientRect(), docTop = content2.top + view.viewState.paddingTop;
  let block, { docHeight } = view.viewState;
  let { x: x2, y: y3 } = coords, yOffset = y3 - docTop;
  if (yOffset < 0)
    return 0;
  if (yOffset > docHeight)
    return view.state.doc.length;
  for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false; ; ) {
    block = view.elementAtHeight(yOffset);
    if (block.type == BlockType.Text)
      break;
    for (; ; ) {
      yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
      if (yOffset >= 0 && yOffset <= docHeight)
        break;
      if (bounced)
        return precise ? null : 0;
      bounced = true;
      bias = -bias;
    }
  }
  y3 = docTop + yOffset;
  let lineStart = block.from;
  if (lineStart < view.viewport.from)
    return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content2, block, x2, y3);
  if (lineStart > view.viewport.to)
    return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content2, block, x2, y3);
  let doc2 = view.dom.ownerDocument;
  let root = view.root.elementFromPoint ? view.root : doc2;
  let element = root.elementFromPoint(x2, y3);
  if (element && !view.contentDOM.contains(element))
    element = null;
  if (!element) {
    x2 = Math.max(content2.left + 1, Math.min(content2.right - 1, x2));
    element = root.elementFromPoint(x2, y3);
    if (element && !view.contentDOM.contains(element))
      element = null;
  }
  let node3, offset3 = -1;
  if (element && ((_a2 = view.docView.nearest(element)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) != false) {
    if (doc2.caretPositionFromPoint) {
      let pos = doc2.caretPositionFromPoint(x2, y3);
      if (pos)
        ({ offsetNode: node3, offset: offset3 } = pos);
    } else if (doc2.caretRangeFromPoint) {
      let range = doc2.caretRangeFromPoint(x2, y3);
      if (range) {
        ({ startContainer: node3, startOffset: offset3 } = range);
        if (!view.contentDOM.contains(node3) || browser2.safari && isSuspiciousSafariCaretResult(node3, offset3, x2) || browser2.chrome && isSuspiciousChromeCaretResult(node3, offset3, x2))
          node3 = void 0;
      }
    }
  }
  if (!node3 || !view.docView.dom.contains(node3)) {
    let line2 = LineView.find(view.docView, lineStart);
    if (!line2)
      return yOffset > block.top + block.height / 2 ? block.to : block.from;
    ({ node: node3, offset: offset3 } = domPosAtCoords(line2.dom, x2, y3));
  }
  let nearest = view.docView.nearest(node3);
  if (!nearest)
    return null;
  if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
    let rect = nearest.dom.getBoundingClientRect();
    return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;
  } else {
    return nearest.localPosFromDOM(node3, offset3) + nearest.posAtStart;
  }
}
function posAtCoordsImprecise(view, contentRect, block, x2, y3) {
  let into = Math.round((x2 - contentRect.left) * view.defaultCharacterWidth);
  if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
    let textHeight = view.viewState.heightOracle.textHeight;
    let line2 = Math.floor((y3 - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
    into += line2 * view.viewState.heightOracle.lineLength;
  }
  let content2 = view.state.sliceDoc(block.from, block.to);
  return block.from + findColumn(content2, into, view.state.tabSize);
}
function isSuspiciousSafariCaretResult(node3, offset3, x2) {
  let len;
  if (node3.nodeType != 3 || offset3 != (len = node3.nodeValue.length))
    return false;
  for (let next2 = node3.nextSibling; next2; next2 = next2.nextSibling)
    if (next2.nodeType != 1 || next2.nodeName != "BR")
      return false;
  return textRange(node3, len - 1, len).getBoundingClientRect().left > x2;
}
function isSuspiciousChromeCaretResult(node3, offset3, x2) {
  if (offset3 != 0)
    return false;
  for (let cur2 = node3; ; ) {
    let parent = cur2.parentNode;
    if (!parent || parent.nodeType != 1 || parent.firstChild != cur2)
      return false;
    if (parent.classList.contains("cm-line"))
      break;
    cur2 = parent;
  }
  let rect = node3.nodeType == 1 ? node3.getBoundingClientRect() : textRange(node3, 0, Math.max(node3.nodeValue.length, 1)).getBoundingClientRect();
  return x2 - rect.left > 5;
}
function blockAt(view, pos) {
  let line2 = view.lineBlockAt(pos);
  if (Array.isArray(line2.type))
    for (let l of line2.type) {
      if (l.to > pos || l.to == pos && (l.to == line2.to || l.type == BlockType.Text))
        return l;
    }
  return line2;
}
function moveToLineBoundary(view, start2, forward, includeWrap) {
  let line2 = blockAt(view, start2.head);
  let coords = !includeWrap || line2.type != BlockType.Text || !(view.lineWrapping || line2.widgetLineBreaks) ? null : view.coordsAtPos(start2.assoc < 0 && start2.head > line2.from ? start2.head - 1 : start2.head);
  if (coords) {
    let editorRect = view.dom.getBoundingClientRect();
    let direction = view.textDirectionAt(line2.from);
    let pos = view.posAtCoords({
      x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
      y: (coords.top + coords.bottom) / 2
    });
    if (pos != null)
      return EditorSelection.cursor(pos, forward ? -1 : 1);
  }
  return EditorSelection.cursor(forward ? line2.to : line2.from, forward ? -1 : 1);
}
function moveByChar(view, start2, forward, by) {
  let line2 = view.state.doc.lineAt(start2.head), spans = view.bidiSpans(line2);
  let direction = view.textDirectionAt(line2.from);
  for (let cur2 = start2, check = null; ; ) {
    let next2 = moveVisually(line2, spans, direction, cur2, forward), char2 = movedOver;
    if (!next2) {
      if (line2.number == (forward ? view.state.doc.lines : 1))
        return cur2;
      char2 = "\n";
      line2 = view.state.doc.line(line2.number + (forward ? 1 : -1));
      spans = view.bidiSpans(line2);
      next2 = view.visualLineSide(line2, !forward);
    }
    if (!check) {
      if (!by)
        return next2;
      check = by(char2);
    } else if (!check(char2)) {
      return cur2;
    }
    cur2 = next2;
  }
}
function byGroup(view, pos, start2) {
  let categorize = view.state.charCategorizer(pos);
  let cat = categorize(start2);
  return (next2) => {
    let nextCat = categorize(next2);
    if (cat == CharCategory.Space)
      cat = nextCat;
    return cat == nextCat;
  };
}
function moveVertically(view, start2, forward, distance) {
  let startPos = start2.head, dir = forward ? 1 : -1;
  if (startPos == (forward ? view.state.doc.length : 0))
    return EditorSelection.cursor(startPos, start2.assoc);
  let goal = start2.goalColumn, startY;
  let rect = view.contentDOM.getBoundingClientRect();
  let startCoords = view.coordsAtPos(startPos, start2.assoc || -1), docTop = view.documentTop;
  if (startCoords) {
    if (goal == null)
      goal = startCoords.left - rect.left;
    startY = dir < 0 ? startCoords.top : startCoords.bottom;
  } else {
    let line2 = view.viewState.lineBlockAt(startPos);
    if (goal == null)
      goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line2.from));
    startY = (dir < 0 ? line2.top : line2.bottom) + docTop;
  }
  let resolvedGoal = rect.left + goal;
  let dist2 = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;
  for (let extra = 0; ; extra += 10) {
    let curY = startY + (dist2 + extra) * dir;
    let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
    if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {
      let charRect = view.docView.coordsForChar(pos);
      let assoc = !charRect || curY < charRect.top ? -1 : 1;
      return EditorSelection.cursor(pos, assoc, void 0, goal);
    }
  }
}
function skipAtomicRanges(atoms, pos, bias) {
  for (; ; ) {
    let moved = 0;
    for (let set2 of atoms) {
      set2.between(pos - 1, pos + 1, (from2, to, value) => {
        if (pos > from2 && pos < to) {
          let side = moved || bias || (pos - from2 < to - pos ? -1 : 1);
          pos = side < 0 ? from2 : to;
          moved = side;
        }
      });
    }
    if (!moved)
      return pos;
  }
}
function skipAtoms(view, oldPos, pos) {
  let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map((f) => f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
  return newPos == pos.from ? pos : EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
}
var InputState = class {
  setSelectionOrigin(origin) {
    this.lastSelectionOrigin = origin;
    this.lastSelectionTime = Date.now();
  }
  constructor(view) {
    this.view = view;
    this.lastKeyCode = 0;
    this.lastKeyTime = 0;
    this.lastTouchTime = 0;
    this.lastFocusTime = 0;
    this.lastScrollTop = 0;
    this.lastScrollLeft = 0;
    this.pendingIOSKey = void 0;
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastEscPress = 0;
    this.lastContextMenu = 0;
    this.scrollHandlers = [];
    this.handlers = /* @__PURE__ */ Object.create(null);
    this.composing = -1;
    this.compositionFirstChange = null;
    this.compositionEndedAt = 0;
    this.compositionPendingKey = false;
    this.compositionPendingChange = false;
    this.mouseSelection = null;
    this.draggedContent = null;
    this.handleEvent = this.handleEvent.bind(this);
    this.notifiedFocused = view.hasFocus;
    if (browser2.safari)
      view.contentDOM.addEventListener("input", () => null);
    if (browser2.gecko)
      firefoxCopyCutHack(view.contentDOM.ownerDocument);
  }
  handleEvent(event) {
    if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event))
      return;
    if (event.type == "keydown" && this.keydown(event))
      return;
    this.runHandlers(event.type, event);
  }
  runHandlers(type, event) {
    let handlers2 = this.handlers[type];
    if (handlers2) {
      for (let observer of handlers2.observers)
        observer(this.view, event);
      for (let handler of handlers2.handlers) {
        if (event.defaultPrevented)
          break;
        if (handler(this.view, event)) {
          event.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(plugins) {
    let handlers2 = computeHandlers(plugins), prev2 = this.handlers, dom = this.view.contentDOM;
    for (let type in handlers2)
      if (type != "scroll") {
        let passive2 = !handlers2[type].handlers.length;
        let exists = prev2[type];
        if (exists && passive2 != !exists.handlers.length) {
          dom.removeEventListener(type, this.handleEvent);
          exists = null;
        }
        if (!exists)
          dom.addEventListener(type, this.handleEvent, { passive: passive2 });
      }
    for (let type in prev2)
      if (type != "scroll" && !handlers2[type])
        dom.removeEventListener(type, this.handleEvent);
    this.handlers = handlers2;
  }
  keydown(event) {
    this.lastKeyCode = event.keyCode;
    this.lastKeyTime = Date.now();
    if (event.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return true;
    if (event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0)
      this.view.inputState.lastEscPress = 0;
    if (browser2.android && browser2.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
      this.view.observer.delayAndroidKey(event.key, event.keyCode);
      return true;
    }
    let pending;
    if (browser2.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key) => key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
      this.pendingIOSKey = pending || event;
      setTimeout(() => this.flushIOSKey(), 250);
      return true;
    }
    if (event.keyCode != 229)
      this.view.observer.forceFlush();
    return false;
  }
  flushIOSKey() {
    let key = this.pendingIOSKey;
    if (!key)
      return false;
    this.pendingIOSKey = void 0;
    return dispatchKey(this.view.contentDOM, key.key, key.keyCode);
  }
  ignoreDuringComposition(event) {
    if (!/^key/.test(event.type))
      return false;
    if (this.composing > 0)
      return true;
    if (browser2.safari && !browser2.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
      this.compositionPendingKey = false;
      return true;
    }
    return false;
  }
  startMouseSelection(mouseSelection) {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
    this.mouseSelection = mouseSelection;
  }
  update(update) {
    if (this.mouseSelection)
      this.mouseSelection.update(update);
    if (this.draggedContent && update.docChanged)
      this.draggedContent = this.draggedContent.map(update.changes);
    if (update.transactions.length)
      this.lastKeyCode = this.lastSelectionTime = 0;
  }
  destroy() {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
  }
};
function bindHandler(plugin2, handler) {
  return (view, event) => {
    try {
      return handler.call(plugin2, event, view);
    } catch (e4) {
      logException(view.state, e4);
    }
  };
}
function computeHandlers(plugins) {
  let result = /* @__PURE__ */ Object.create(null);
  function record(type) {
    return result[type] || (result[type] = { observers: [], handlers: [] });
  }
  for (let plugin2 of plugins) {
    let spec = plugin2.spec;
    if (spec && spec.domEventHandlers)
      for (let type in spec.domEventHandlers) {
        let f = spec.domEventHandlers[type];
        if (f)
          record(type).handlers.push(bindHandler(plugin2.value, f));
      }
    if (spec && spec.domEventObservers)
      for (let type in spec.domEventObservers) {
        let f = spec.domEventObservers[type];
        if (f)
          record(type).observers.push(bindHandler(plugin2.value, f));
      }
  }
  for (let type in handlers)
    record(type).handlers.push(handlers[type]);
  for (let type in observers)
    record(type).observers.push(observers[type]);
  return result;
}
var PendingKeys = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
];
var EmacsyPendingKeys = "dthko";
var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
var dragScrollMargin = 6;
function dragScrollSpeed(dist2) {
  return Math.max(0, dist2) * 0.7 + 8;
}
function dist(a3, b2) {
  return Math.max(Math.abs(a3.clientX - b2.clientX), Math.abs(a3.clientY - b2.clientY));
}
var MouseSelection = class {
  constructor(view, startEvent, style, mustSelect) {
    this.view = view;
    this.startEvent = startEvent;
    this.style = style;
    this.mustSelect = mustSelect;
    this.scrollSpeed = { x: 0, y: 0 };
    this.scrolling = -1;
    this.lastEvent = startEvent;
    this.scrollParent = scrollableParent(view.contentDOM);
    this.atoms = view.state.facet(atomicRanges).map((f) => f(view));
    let doc2 = view.contentDOM.ownerDocument;
    doc2.addEventListener("mousemove", this.move = this.move.bind(this));
    doc2.addEventListener("mouseup", this.up = this.up.bind(this));
    this.extend = startEvent.shiftKey;
    this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
    this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
  }
  start(event) {
    if (this.dragging === false)
      this.select(event);
  }
  move(event) {
    var _a2;
    if (event.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10)
      return;
    this.select(this.lastEvent = event);
    let sx = 0, sy = 0;
    let rect = ((_a2 = this.scrollParent) === null || _a2 === void 0 ? void 0 : _a2.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight };
    let margins = getScrollMargins(this.view);
    if (event.clientX - margins.left <= rect.left + dragScrollMargin)
      sx = -dragScrollSpeed(rect.left - event.clientX);
    else if (event.clientX + margins.right >= rect.right - dragScrollMargin)
      sx = dragScrollSpeed(event.clientX - rect.right);
    if (event.clientY - margins.top <= rect.top + dragScrollMargin)
      sy = -dragScrollSpeed(rect.top - event.clientY);
    else if (event.clientY + margins.bottom >= rect.bottom - dragScrollMargin)
      sy = dragScrollSpeed(event.clientY - rect.bottom);
    this.setScrollSpeed(sx, sy);
  }
  up(event) {
    if (this.dragging == null)
      this.select(this.lastEvent);
    if (!this.dragging)
      event.preventDefault();
    this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let doc2 = this.view.contentDOM.ownerDocument;
    doc2.removeEventListener("mousemove", this.move);
    doc2.removeEventListener("mouseup", this.up);
    this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(sx, sy) {
    this.scrollSpeed = { x: sx, y: sy };
    if (sx || sy) {
      if (this.scrolling < 0)
        this.scrolling = setInterval(() => this.scroll(), 50);
    } else if (this.scrolling > -1) {
      clearInterval(this.scrolling);
      this.scrolling = -1;
    }
  }
  scroll() {
    if (this.scrollParent) {
      this.scrollParent.scrollLeft += this.scrollSpeed.x;
      this.scrollParent.scrollTop += this.scrollSpeed.y;
    } else {
      this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y);
    }
    if (this.dragging === false)
      this.select(this.lastEvent);
  }
  skipAtoms(sel) {
    let ranges = null;
    for (let i2 = 0; i2 < sel.ranges.length; i2++) {
      let range = sel.ranges[i2], updated = null;
      if (range.empty) {
        let pos = skipAtomicRanges(this.atoms, range.from, 0);
        if (pos != range.from)
          updated = EditorSelection.cursor(pos, -1);
      } else {
        let from2 = skipAtomicRanges(this.atoms, range.from, -1);
        let to = skipAtomicRanges(this.atoms, range.to, 1);
        if (from2 != range.from || to != range.to)
          updated = EditorSelection.range(range.from == range.anchor ? from2 : to, range.from == range.head ? from2 : to);
      }
      if (updated) {
        if (!ranges)
          ranges = sel.ranges.slice();
        ranges[i2] = updated;
      }
    }
    return ranges ? EditorSelection.create(ranges, sel.mainIndex) : sel;
  }
  select(event) {
    let { view } = this, selection = this.skipAtoms(this.style.get(event, this.extend, this.multiple));
    if (this.mustSelect || !selection.eq(view.state.selection, this.dragging === false))
      this.view.dispatch({
        selection,
        userEvent: "select.pointer"
      });
    this.mustSelect = false;
  }
  update(update) {
    if (this.style.update(update))
      setTimeout(() => this.select(this.lastEvent), 20);
  }
};
function addsSelectionRange(view, event) {
  let facet = view.state.facet(clickAddsSelectionRange);
  return facet.length ? facet[0](event) : browser2.mac ? event.metaKey : event.ctrlKey;
}
function dragMovesSelection(view, event) {
  let facet = view.state.facet(dragMovesSelection$1);
  return facet.length ? facet[0](event) : browser2.mac ? !event.altKey : !event.ctrlKey;
}
function isInPrimarySelection(view, event) {
  let { main: main2 } = view.state.selection;
  if (main2.empty)
    return false;
  let sel = getSelection(view.root);
  if (!sel || sel.rangeCount == 0)
    return true;
  let rects = sel.getRangeAt(0).getClientRects();
  for (let i2 = 0; i2 < rects.length; i2++) {
    let rect = rects[i2];
    if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY)
      return true;
  }
  return false;
}
function eventBelongsToEditor(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node3 = event.target, cView; node3 != view.contentDOM; node3 = node3.parentNode)
    if (!node3 || node3.nodeType == 11 || (cView = ContentView.get(node3)) && cView.ignoreEvent(event))
      return false;
  return true;
}
var handlers = /* @__PURE__ */ Object.create(null);
var observers = /* @__PURE__ */ Object.create(null);
var brokenClipboardAPI = browser2.ie && browser2.ie_version < 15 || browser2.ios && browser2.webkit_version < 604;
function capturePaste(view) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(() => {
    view.focus();
    target.remove();
    doPaste(view, target.value);
  }, 50);
}
function doPaste(view, input) {
  let { state } = view, changes, i2 = 1, text = state.toText(input);
  let byLine = text.lines == state.selection.ranges.length;
  let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r2) => r2.empty) && lastLinewiseCopy == text.toString();
  if (linewise) {
    let lastLine = -1;
    changes = state.changeByRange((range) => {
      let line2 = state.doc.lineAt(range.from);
      if (line2.from == lastLine)
        return { range };
      lastLine = line2.from;
      let insert2 = state.toText((byLine ? text.line(i2++).text : input) + state.lineBreak);
      return {
        changes: { from: line2.from, insert: insert2 },
        range: EditorSelection.cursor(range.from + insert2.length)
      };
    });
  } else if (byLine) {
    changes = state.changeByRange((range) => {
      let line2 = text.line(i2++);
      return {
        changes: { from: range.from, to: range.to, insert: line2.text },
        range: EditorSelection.cursor(range.from + line2.length)
      };
    });
  } else {
    changes = state.replaceSelection(text);
  }
  view.dispatch(changes, {
    userEvent: "input.paste",
    scrollIntoView: true
  });
}
observers.scroll = (view) => {
  view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
  view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
};
handlers.keydown = (view, event) => {
  view.inputState.setSelectionOrigin("select");
  if (event.keyCode == 27)
    view.inputState.lastEscPress = Date.now();
  return false;
};
observers.touchstart = (view, e4) => {
  view.inputState.lastTouchTime = Date.now();
  view.inputState.setSelectionOrigin("select.pointer");
};
observers.touchmove = (view) => {
  view.inputState.setSelectionOrigin("select.pointer");
};
handlers.mousedown = (view, event) => {
  view.observer.flush();
  if (view.inputState.lastTouchTime > Date.now() - 2e3)
    return false;
  let style = null;
  for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
    style = makeStyle(view, event);
    if (style)
      break;
  }
  if (!style && event.button == 0)
    style = basicMouseSelection(view, event);
  if (style) {
    let mustFocus = !view.hasFocus;
    view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
    if (mustFocus)
      view.observer.ignore(() => focusPreventScroll(view.contentDOM));
    let mouseSel = view.inputState.mouseSelection;
    if (mouseSel) {
      mouseSel.start(event);
      return mouseSel.dragging === false;
    }
  }
  return false;
};
function rangeForClick(view, pos, bias, type) {
  if (type == 1) {
    return EditorSelection.cursor(pos, bias);
  } else if (type == 2) {
    return groupAt(view.state, pos, bias);
  } else {
    let visual = LineView.find(view.docView, pos), line2 = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
    let from2 = visual ? visual.posAtStart : line2.from, to = visual ? visual.posAtEnd : line2.to;
    if (to < view.state.doc.length && to == line2.to)
      to++;
    return EditorSelection.range(from2, to);
  }
}
var insideY = (y3, rect) => y3 >= rect.top && y3 <= rect.bottom;
var inside = (x2, y3, rect) => insideY(y3, rect) && x2 >= rect.left && x2 <= rect.right;
function findPositionSide(view, pos, x2, y3) {
  let line2 = LineView.find(view.docView, pos);
  if (!line2)
    return 1;
  let off2 = pos - line2.posAtStart;
  if (off2 == 0)
    return 1;
  if (off2 == line2.length)
    return -1;
  let before = line2.coordsAt(off2, -1);
  if (before && inside(x2, y3, before))
    return -1;
  let after = line2.coordsAt(off2, 1);
  if (after && inside(x2, y3, after))
    return 1;
  return before && insideY(y3, before) ? -1 : 1;
}
function queryPos(view, event) {
  let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };
}
var BadMouseDetail = browser2.ie && browser2.ie_version <= 11;
var lastMouseDown = null;
var lastMouseDownCount = 0;
var lastMouseDownTime = 0;
function getClickType(event) {
  if (!BadMouseDetail)
    return event.detail;
  let last = lastMouseDown, lastTime = lastMouseDownTime;
  lastMouseDown = event;
  lastMouseDownTime = Date.now();
  return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event) {
  let start2 = queryPos(view, event), type = getClickType(event);
  let startSel = view.state.selection;
  return {
    update(update) {
      if (update.docChanged) {
        start2.pos = update.changes.mapPos(start2.pos);
        startSel = startSel.map(update.changes);
      }
    },
    get(event2, extend2, multiple) {
      let cur2 = queryPos(view, event2), removed;
      let range = rangeForClick(view, cur2.pos, cur2.bias, type);
      if (start2.pos != cur2.pos && !extend2) {
        let startRange = rangeForClick(view, start2.pos, start2.bias, type);
        let from2 = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
        range = from2 < range.from ? EditorSelection.range(from2, to) : EditorSelection.range(to, from2);
      }
      if (extend2)
        return startSel.replaceRange(startSel.main.extend(range.from, range.to));
      else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur2.pos)))
        return removed;
      else if (multiple)
        return startSel.addRange(range);
      else
        return EditorSelection.create([range]);
    }
  };
}
function removeRangeAround(sel, pos) {
  for (let i2 = 0; i2 < sel.ranges.length; i2++) {
    let { from: from2, to } = sel.ranges[i2];
    if (from2 <= pos && to >= pos)
      return EditorSelection.create(sel.ranges.slice(0, i2).concat(sel.ranges.slice(i2 + 1)), sel.mainIndex == i2 ? 0 : sel.mainIndex - (sel.mainIndex > i2 ? 1 : 0));
  }
  return null;
}
handlers.dragstart = (view, event) => {
  let { selection: { main: range } } = view.state;
  if (event.target.draggable) {
    let cView = view.docView.nearest(event.target);
    if (cView && cView.isWidget) {
      let from2 = cView.posAtStart, to = from2 + cView.length;
      if (from2 >= range.to || to <= range.from)
        range = EditorSelection.range(from2, to);
    }
  }
  let { inputState } = view;
  if (inputState.mouseSelection)
    inputState.mouseSelection.dragging = true;
  inputState.draggedContent = range;
  if (event.dataTransfer) {
    event.dataTransfer.setData("Text", view.state.sliceDoc(range.from, range.to));
    event.dataTransfer.effectAllowed = "copyMove";
  }
  return false;
};
handlers.dragend = (view) => {
  view.inputState.draggedContent = null;
  return false;
};
function dropText(view, event, text, direct) {
  if (!text)
    return;
  let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  let { draggedContent } = view.inputState;
  let del = direct && draggedContent && dragMovesSelection(view, event) ? { from: draggedContent.from, to: draggedContent.to } : null;
  let ins = { from: dropPos, insert: text };
  let changes = view.state.changes(del ? [del, ins] : ins);
  view.focus();
  view.dispatch({
    changes,
    selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
    userEvent: del ? "move.drop" : "input.drop"
  });
  view.inputState.draggedContent = null;
}
handlers.drop = (view, event) => {
  if (!event.dataTransfer)
    return false;
  if (view.state.readOnly)
    return true;
  let files = event.dataTransfer.files;
  if (files && files.length) {
    let text = Array(files.length), read2 = 0;
    let finishFile = () => {
      if (++read2 == files.length)
        dropText(view, event, text.filter((s3) => s3 != null).join(view.state.lineBreak), false);
    };
    for (let i2 = 0; i2 < files.length; i2++) {
      let reader = new FileReader();
      reader.onerror = finishFile;
      reader.onload = () => {
        if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
          text[i2] = reader.result;
        finishFile();
      };
      reader.readAsText(files[i2]);
    }
    return true;
  } else {
    let text = event.dataTransfer.getData("Text");
    if (text) {
      dropText(view, event, text, true);
      return true;
    }
  }
  return false;
};
handlers.paste = (view, event) => {
  if (view.state.readOnly)
    return true;
  view.observer.flush();
  let data = brokenClipboardAPI ? null : event.clipboardData;
  if (data) {
    doPaste(view, data.getData("text/plain") || data.getData("text/uri-text"));
    return true;
  } else {
    capturePaste(view);
    return false;
  }
};
function captureCopy(view, text) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.value = text;
  target.focus();
  target.selectionEnd = text.length;
  target.selectionStart = 0;
  setTimeout(() => {
    target.remove();
    view.focus();
  }, 50);
}
function copiedRange(state) {
  let content2 = [], ranges = [], linewise = false;
  for (let range of state.selection.ranges)
    if (!range.empty) {
      content2.push(state.sliceDoc(range.from, range.to));
      ranges.push(range);
    }
  if (!content2.length) {
    let upto = -1;
    for (let { from: from2 } of state.selection.ranges) {
      let line2 = state.doc.lineAt(from2);
      if (line2.number > upto) {
        content2.push(line2.text);
        ranges.push({ from: line2.from, to: Math.min(state.doc.length, line2.to + 1) });
      }
      upto = line2.number;
    }
    linewise = true;
  }
  return { text: content2.join(state.lineBreak), ranges, linewise };
}
var lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event) => {
  let { text, ranges, linewise } = copiedRange(view.state);
  if (!text && !linewise)
    return false;
  lastLinewiseCopy = linewise ? text : null;
  if (event.type == "cut" && !view.state.readOnly)
    view.dispatch({
      changes: ranges,
      scrollIntoView: true,
      userEvent: "delete.cut"
    });
  let data = brokenClipboardAPI ? null : event.clipboardData;
  if (data) {
    data.clearData();
    data.setData("text/plain", text);
    return true;
  } else {
    captureCopy(view, text);
    return false;
  }
};
var isFocusChange = Annotation.define();
function focusChangeTransaction(state, focus) {
  let effects = [];
  for (let getEffect of state.facet(focusChangeEffect)) {
    let effect4 = getEffect(state, focus);
    if (effect4)
      effects.push(effect4);
  }
  return effects ? state.update({ effects, annotations: isFocusChange.of(true) }) : null;
}
function updateForFocusChange(view) {
  setTimeout(() => {
    let focus = view.hasFocus;
    if (focus != view.inputState.notifiedFocused) {
      let tr2 = focusChangeTransaction(view.state, focus);
      if (tr2)
        view.dispatch(tr2);
      else
        view.update([]);
    }
  }, 10);
}
observers.focus = (view) => {
  view.inputState.lastFocusTime = Date.now();
  if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
    view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
    view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
  }
  updateForFocusChange(view);
};
observers.blur = (view) => {
  view.observer.clearSelectionRange();
  updateForFocusChange(view);
};
observers.compositionstart = observers.compositionupdate = (view) => {
  if (view.inputState.compositionFirstChange == null)
    view.inputState.compositionFirstChange = true;
  if (view.inputState.composing < 0) {
    view.inputState.composing = 0;
  }
};
observers.compositionend = (view) => {
  view.inputState.composing = -1;
  view.inputState.compositionEndedAt = Date.now();
  view.inputState.compositionPendingKey = true;
  view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
  view.inputState.compositionFirstChange = null;
  if (browser2.chrome && browser2.android) {
    view.observer.flushSoon();
  } else if (view.inputState.compositionPendingChange) {
    Promise.resolve().then(() => view.observer.flush());
  } else {
    setTimeout(() => {
      if (view.inputState.composing < 0 && view.docView.hasComposition)
        view.update([]);
    }, 50);
  }
};
observers.contextmenu = (view) => {
  view.inputState.lastContextMenu = Date.now();
};
handlers.beforeinput = (view, event) => {
  var _a2;
  let pending;
  if (browser2.chrome && browser2.android && (pending = PendingKeys.find((key) => key.inputType == event.inputType))) {
    view.observer.delayAndroidKey(pending.key, pending.keyCode);
    if (pending.key == "Backspace" || pending.key == "Delete") {
      let startViewHeight = ((_a2 = window.visualViewport) === null || _a2 === void 0 ? void 0 : _a2.height) || 0;
      setTimeout(() => {
        var _a3;
        if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view.hasFocus) {
          view.contentDOM.blur();
          view.focus();
        }
      }, 100);
    }
  }
  return false;
};
var appliedFirefoxHack = /* @__PURE__ */ new Set();
function firefoxCopyCutHack(doc2) {
  if (!appliedFirefoxHack.has(doc2)) {
    appliedFirefoxHack.add(doc2);
    doc2.addEventListener("copy", () => {
    });
    doc2.addEventListener("cut", () => {
    });
  }
}
var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
var HeightOracle = class {
  constructor(lineWrapping) {
    this.lineWrapping = lineWrapping;
    this.doc = Text.empty;
    this.heightSamples = {};
    this.lineHeight = 14;
    this.charWidth = 7;
    this.textHeight = 14;
    this.lineLength = 30;
    this.heightChanged = false;
  }
  heightForGap(from2, to) {
    let lines = this.doc.lineAt(to).number - this.doc.lineAt(from2).number + 1;
    if (this.lineWrapping)
      lines += Math.max(0, Math.ceil((to - from2 - lines * this.lineLength * 0.5) / this.lineLength));
    return this.lineHeight * lines;
  }
  heightForLine(length2) {
    if (!this.lineWrapping)
      return this.lineHeight;
    let lines = 1 + Math.max(0, Math.ceil((length2 - this.lineLength) / (this.lineLength - 5)));
    return lines * this.lineHeight;
  }
  setDoc(doc2) {
    this.doc = doc2;
    return this;
  }
  mustRefreshForWrapping(whiteSpace) {
    return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(lineHeights) {
    let newHeight = false;
    for (let i2 = 0; i2 < lineHeights.length; i2++) {
      let h3 = lineHeights[i2];
      if (h3 < 0) {
        i2++;
      } else if (!this.heightSamples[Math.floor(h3 * 10)]) {
        newHeight = true;
        this.heightSamples[Math.floor(h3 * 10)] = true;
      }
    }
    return newHeight;
  }
  refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
    let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
    let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
    this.lineWrapping = lineWrapping;
    this.lineHeight = lineHeight;
    this.charWidth = charWidth;
    this.textHeight = textHeight;
    this.lineLength = lineLength;
    if (changed) {
      this.heightSamples = {};
      for (let i2 = 0; i2 < knownHeights.length; i2++) {
        let h3 = knownHeights[i2];
        if (h3 < 0)
          i2++;
        else
          this.heightSamples[Math.floor(h3 * 10)] = true;
      }
    }
    return changed;
  }
};
var MeasuredHeights = class {
  constructor(from2, heights) {
    this.from = from2;
    this.heights = heights;
    this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
};
var BlockInfo = class _BlockInfo {
  /**
  @internal
  */
  constructor(from2, length2, top3, height, _content) {
    this.from = from2;
    this.length = length2;
    this.top = top3;
    this.height = height;
    this._content = _content;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof PointDecoration ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(other) {
    let content2 = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(other._content) ? other._content : [other]);
    return new _BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content2);
  }
};
var QueryType = function(QueryType3) {
  QueryType3[QueryType3["ByPos"] = 0] = "ByPos";
  QueryType3[QueryType3["ByHeight"] = 1] = "ByHeight";
  QueryType3[QueryType3["ByPosNoHeight"] = 2] = "ByPosNoHeight";
  return QueryType3;
}(QueryType || (QueryType = {}));
var Epsilon = 1e-3;
var HeightMap = class _HeightMap {
  constructor(length2, height, flags = 2) {
    this.length = length2;
    this.height = height;
    this.flags = flags;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(value) {
    this.flags = (value ? 2 : 0) | this.flags & ~2;
  }
  setHeight(oracle, height) {
    if (this.height != height) {
      if (Math.abs(this.height - height) > Epsilon)
        oracle.heightChanged = true;
      this.height = height;
    }
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(_from, _to, nodes) {
    return _HeightMap.of(nodes);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(_to, result) {
    result.push(this);
  }
  decomposeRight(_from, result) {
    result.push(this);
  }
  applyChanges(decorations2, oldDoc, oracle, changes) {
    let me2 = this, doc2 = oracle.doc;
    for (let i2 = changes.length - 1; i2 >= 0; i2--) {
      let { fromA, toA, fromB, toB } = changes[i2];
      let start2 = me2.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
      let end2 = start2.to >= toA ? start2 : me2.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
      toB += end2.to - toA;
      toA = end2.to;
      while (i2 > 0 && start2.from <= changes[i2 - 1].toA) {
        fromA = changes[i2 - 1].fromA;
        fromB = changes[i2 - 1].fromB;
        i2--;
        if (fromA < start2.from)
          start2 = me2.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
      }
      fromB += start2.from - fromA;
      fromA = start2.from;
      let nodes = NodeBuilder.build(oracle.setDoc(doc2), decorations2, fromB, toB);
      me2 = me2.replace(fromA, toA, nodes);
    }
    return me2.updateHeight(oracle, 0);
  }
  static empty() {
    return new HeightMapText(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(nodes) {
    if (nodes.length == 1)
      return nodes[0];
    let i2 = 0, j = nodes.length, before = 0, after = 0;
    for (; ; ) {
      if (i2 == j) {
        if (before > after * 2) {
          let split = nodes[i2 - 1];
          if (split.break)
            nodes.splice(--i2, 1, split.left, null, split.right);
          else
            nodes.splice(--i2, 1, split.left, split.right);
          j += 1 + split.break;
          before -= split.size;
        } else if (after > before * 2) {
          let split = nodes[j];
          if (split.break)
            nodes.splice(j, 1, split.left, null, split.right);
          else
            nodes.splice(j, 1, split.left, split.right);
          j += 2 + split.break;
          after -= split.size;
        } else {
          break;
        }
      } else if (before < after) {
        let next2 = nodes[i2++];
        if (next2)
          before += next2.size;
      } else {
        let next2 = nodes[--j];
        if (next2)
          after += next2.size;
      }
    }
    let brk = 0;
    if (nodes[i2 - 1] == null) {
      brk = 1;
      i2--;
    } else if (nodes[i2] == null) {
      brk = 1;
      j++;
    }
    return new HeightMapBranch(_HeightMap.of(nodes.slice(0, i2)), brk, _HeightMap.of(nodes.slice(j)));
  }
};
HeightMap.prototype.size = 1;
var HeightMapBlock = class extends HeightMap {
  constructor(length2, height, deco) {
    super(length2, height);
    this.deco = deco;
  }
  blockAt(_height, _oracle, top3, offset3) {
    return new BlockInfo(offset3, this.length, top3, this.height, this.deco || 0);
  }
  lineAt(_value, _type, oracle, top3, offset3) {
    return this.blockAt(0, oracle, top3, offset3);
  }
  forEachLine(from2, to, oracle, top3, offset3, f) {
    if (from2 <= offset3 + this.length && to >= offset3)
      f(this.blockAt(0, oracle, top3, offset3));
  }
  updateHeight(oracle, offset3 = 0, _force = false, measured) {
    if (measured && measured.from <= offset3 && measured.more)
      this.setHeight(oracle, measured.heights[measured.index++]);
    this.outdated = false;
    return this;
  }
  toString() {
    return `block(${this.length})`;
  }
};
var HeightMapText = class _HeightMapText extends HeightMapBlock {
  constructor(length2, height) {
    super(length2, height, null);
    this.collapsed = 0;
    this.widgetHeight = 0;
    this.breaks = 0;
  }
  blockAt(_height, _oracle, top3, offset3) {
    return new BlockInfo(offset3, this.length, top3, this.height, this.breaks);
  }
  replace(_from, _to, nodes) {
    let node3 = nodes[0];
    if (nodes.length == 1 && (node3 instanceof _HeightMapText || node3 instanceof HeightMapGap && node3.flags & 4) && Math.abs(this.length - node3.length) < 10) {
      if (node3 instanceof HeightMapGap)
        node3 = new _HeightMapText(node3.length, this.height);
      else
        node3.height = this.height;
      if (!this.outdated)
        node3.outdated = false;
      return node3;
    } else {
      return HeightMap.of(nodes);
    }
  }
  updateHeight(oracle, offset3 = 0, force = false, measured) {
    if (measured && measured.from <= offset3 && measured.more)
      this.setHeight(oracle, measured.heights[measured.index++]);
    else if (force || this.outdated)
      this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);
    this.outdated = false;
    return this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
};
var HeightMapGap = class _HeightMapGap extends HeightMap {
  constructor(length2) {
    super(length2, 0);
  }
  heightMetrics(oracle, offset3) {
    let firstLine = oracle.doc.lineAt(offset3).number, lastLine = oracle.doc.lineAt(offset3 + this.length).number;
    let lines = lastLine - firstLine + 1;
    let perLine, perChar = 0;
    if (oracle.lineWrapping) {
      let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
      perLine = totalPerLine / lines;
      if (this.length > lines + 1)
        perChar = (this.height - totalPerLine) / (this.length - lines - 1);
    } else {
      perLine = this.height / lines;
    }
    return { firstLine, lastLine, perLine, perChar };
  }
  blockAt(height, oracle, top3, offset3) {
    let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset3);
    if (oracle.lineWrapping) {
      let guess = offset3 + Math.round(Math.max(0, Math.min(1, (height - top3) / this.height)) * this.length);
      let line2 = oracle.doc.lineAt(guess), lineHeight = perLine + line2.length * perChar;
      let lineTop = Math.max(top3, height - lineHeight / 2);
      return new BlockInfo(line2.from, line2.length, lineTop, lineHeight, 0);
    } else {
      let line2 = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top3) / perLine)));
      let { from: from2, length: length2 } = oracle.doc.line(firstLine + line2);
      return new BlockInfo(from2, length2, top3 + perLine * line2, perLine, 0);
    }
  }
  lineAt(value, type, oracle, top3, offset3) {
    if (type == QueryType.ByHeight)
      return this.blockAt(value, oracle, top3, offset3);
    if (type == QueryType.ByPosNoHeight) {
      let { from: from2, to } = oracle.doc.lineAt(value);
      return new BlockInfo(from2, to - from2, 0, 0, 0);
    }
    let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset3);
    let line2 = oracle.doc.lineAt(value), lineHeight = perLine + line2.length * perChar;
    let linesAbove = line2.number - firstLine;
    let lineTop = top3 + perLine * linesAbove + perChar * (line2.from - offset3 - linesAbove);
    return new BlockInfo(line2.from, line2.length, Math.max(top3, Math.min(lineTop, top3 + this.height - lineHeight)), lineHeight, 0);
  }
  forEachLine(from2, to, oracle, top3, offset3, f) {
    from2 = Math.max(from2, offset3);
    to = Math.min(to, offset3 + this.length);
    let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset3);
    for (let pos = from2, lineTop = top3; pos <= to; ) {
      let line2 = oracle.doc.lineAt(pos);
      if (pos == from2) {
        let linesAbove = line2.number - firstLine;
        lineTop += perLine * linesAbove + perChar * (from2 - offset3 - linesAbove);
      }
      let lineHeight = perLine + perChar * line2.length;
      f(new BlockInfo(line2.from, line2.length, lineTop, lineHeight, 0));
      lineTop += lineHeight;
      pos = line2.to + 1;
    }
  }
  replace(from2, to, nodes) {
    let after = this.length - to;
    if (after > 0) {
      let last = nodes[nodes.length - 1];
      if (last instanceof _HeightMapGap)
        nodes[nodes.length - 1] = new _HeightMapGap(last.length + after);
      else
        nodes.push(null, new _HeightMapGap(after - 1));
    }
    if (from2 > 0) {
      let first = nodes[0];
      if (first instanceof _HeightMapGap)
        nodes[0] = new _HeightMapGap(from2 + first.length);
      else
        nodes.unshift(new _HeightMapGap(from2 - 1), null);
    }
    return HeightMap.of(nodes);
  }
  decomposeLeft(to, result) {
    result.push(new _HeightMapGap(to - 1), null);
  }
  decomposeRight(from2, result) {
    result.push(null, new _HeightMapGap(this.length - from2 - 1));
  }
  updateHeight(oracle, offset3 = 0, force = false, measured) {
    let end2 = offset3 + this.length;
    if (measured && measured.from <= offset3 + this.length && measured.more) {
      let nodes = [], pos = Math.max(offset3, measured.from), singleHeight = -1;
      if (measured.from > offset3)
        nodes.push(new _HeightMapGap(measured.from - offset3 - 1).updateHeight(oracle, offset3));
      while (pos <= end2 && measured.more) {
        let len = oracle.doc.lineAt(pos).length;
        if (nodes.length)
          nodes.push(null);
        let height = measured.heights[measured.index++];
        if (singleHeight == -1)
          singleHeight = height;
        else if (Math.abs(height - singleHeight) >= Epsilon)
          singleHeight = -2;
        let line2 = new HeightMapText(len, height);
        line2.outdated = false;
        nodes.push(line2);
        pos += len + 1;
      }
      if (pos <= end2)
        nodes.push(null, new _HeightMapGap(end2 - pos).updateHeight(oracle, pos));
      let result = HeightMap.of(nodes);
      if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset3).perLine) >= Epsilon)
        oracle.heightChanged = true;
      return result;
    } else if (force || this.outdated) {
      this.setHeight(oracle, oracle.heightForGap(offset3, offset3 + this.length));
      this.outdated = false;
    }
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
};
var HeightMapBranch = class extends HeightMap {
  constructor(left2, brk, right2) {
    super(left2.length + brk + right2.length, left2.height + right2.height, brk | (left2.outdated || right2.outdated ? 2 : 0));
    this.left = left2;
    this.right = right2;
    this.size = left2.size + right2.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(height, oracle, top3, offset3) {
    let mid = top3 + this.left.height;
    return height < mid ? this.left.blockAt(height, oracle, top3, offset3) : this.right.blockAt(height, oracle, mid, offset3 + this.left.length + this.break);
  }
  lineAt(value, type, oracle, top3, offset3) {
    let rightTop = top3 + this.left.height, rightOffset = offset3 + this.left.length + this.break;
    let left2 = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
    let base2 = left2 ? this.left.lineAt(value, type, oracle, top3, offset3) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);
    if (this.break || (left2 ? base2.to < rightOffset : base2.from > rightOffset))
      return base2;
    let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
    if (left2)
      return base2.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
    else
      return this.left.lineAt(rightOffset, subQuery, oracle, top3, offset3).join(base2);
  }
  forEachLine(from2, to, oracle, top3, offset3, f) {
    let rightTop = top3 + this.left.height, rightOffset = offset3 + this.left.length + this.break;
    if (this.break) {
      if (from2 < rightOffset)
        this.left.forEachLine(from2, to, oracle, top3, offset3, f);
      if (to >= rightOffset)
        this.right.forEachLine(from2, to, oracle, rightTop, rightOffset, f);
    } else {
      let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top3, offset3);
      if (from2 < mid.from)
        this.left.forEachLine(from2, mid.from - 1, oracle, top3, offset3, f);
      if (mid.to >= from2 && mid.from <= to)
        f(mid);
      if (to > mid.to)
        this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);
    }
  }
  replace(from2, to, nodes) {
    let rightStart = this.left.length + this.break;
    if (to < rightStart)
      return this.balanced(this.left.replace(from2, to, nodes), this.right);
    if (from2 > this.left.length)
      return this.balanced(this.left, this.right.replace(from2 - rightStart, to - rightStart, nodes));
    let result = [];
    if (from2 > 0)
      this.decomposeLeft(from2, result);
    let left2 = result.length;
    for (let node3 of nodes)
      result.push(node3);
    if (from2 > 0)
      mergeGaps(result, left2 - 1);
    if (to < this.length) {
      let right2 = result.length;
      this.decomposeRight(to, result);
      mergeGaps(result, right2);
    }
    return HeightMap.of(result);
  }
  decomposeLeft(to, result) {
    let left2 = this.left.length;
    if (to <= left2)
      return this.left.decomposeLeft(to, result);
    result.push(this.left);
    if (this.break) {
      left2++;
      if (to >= left2)
        result.push(null);
    }
    if (to > left2)
      this.right.decomposeLeft(to - left2, result);
  }
  decomposeRight(from2, result) {
    let left2 = this.left.length, right2 = left2 + this.break;
    if (from2 >= right2)
      return this.right.decomposeRight(from2 - right2, result);
    if (from2 < left2)
      this.left.decomposeRight(from2, result);
    if (this.break && from2 < right2)
      result.push(null);
    result.push(this.right);
  }
  balanced(left2, right2) {
    if (left2.size > 2 * right2.size || right2.size > 2 * left2.size)
      return HeightMap.of(this.break ? [left2, null, right2] : [left2, right2]);
    this.left = left2;
    this.right = right2;
    this.height = left2.height + right2.height;
    this.outdated = left2.outdated || right2.outdated;
    this.size = left2.size + right2.size;
    this.length = left2.length + this.break + right2.length;
    return this;
  }
  updateHeight(oracle, offset3 = 0, force = false, measured) {
    let { left: left2, right: right2 } = this, rightStart = offset3 + left2.length + this.break, rebalance = null;
    if (measured && measured.from <= offset3 + left2.length && measured.more)
      rebalance = left2 = left2.updateHeight(oracle, offset3, force, measured);
    else
      left2.updateHeight(oracle, offset3, force);
    if (measured && measured.from <= rightStart + right2.length && measured.more)
      rebalance = right2 = right2.updateHeight(oracle, rightStart, force, measured);
    else
      right2.updateHeight(oracle, rightStart, force);
    if (rebalance)
      return this.balanced(left2, right2);
    this.height = this.left.height + this.right.height;
    this.outdated = false;
    return this;
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
};
function mergeGaps(nodes, around) {
  let before, after;
  if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
    nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}
var relevantWidgetHeight = 5;
var NodeBuilder = class _NodeBuilder {
  constructor(pos, oracle) {
    this.pos = pos;
    this.oracle = oracle;
    this.nodes = [];
    this.lineStart = -1;
    this.lineEnd = -1;
    this.covering = null;
    this.writtenTo = pos;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(_from, to) {
    if (this.lineStart > -1) {
      let end2 = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
      if (last instanceof HeightMapText)
        last.length += end2 - this.pos;
      else if (end2 > this.pos || !this.isCovered)
        this.nodes.push(new HeightMapText(end2 - this.pos, -1));
      this.writtenTo = end2;
      if (to > end2) {
        this.nodes.push(null);
        this.writtenTo++;
        this.lineStart = -1;
      }
    }
    this.pos = to;
  }
  point(from2, to, deco) {
    if (from2 < to || deco.heightRelevant) {
      let height = deco.widget ? deco.widget.estimatedHeight : 0;
      let breaks = deco.widget ? deco.widget.lineBreaks : 0;
      if (height < 0)
        height = this.oracle.lineHeight;
      let len = to - from2;
      if (deco.block) {
        this.addBlock(new HeightMapBlock(len, height, deco));
      } else if (len || breaks || height >= relevantWidgetHeight) {
        this.addLineDeco(height, breaks, len);
      }
    } else if (to > from2) {
      this.span(from2, to);
    }
    if (this.lineEnd > -1 && this.lineEnd < this.pos)
      this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: from2, to } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = from2;
    this.lineEnd = to;
    if (this.writtenTo < from2) {
      if (this.writtenTo < from2 - 1 || this.nodes[this.nodes.length - 1] == null)
        this.nodes.push(this.blankContent(this.writtenTo, from2 - 1));
      this.nodes.push(null);
    }
    if (this.pos > from2)
      this.nodes.push(new HeightMapText(this.pos - from2, -1));
    this.writtenTo = this.pos;
  }
  blankContent(from2, to) {
    let gap = new HeightMapGap(to - from2);
    if (this.oracle.doc.lineAt(from2).to == to)
      gap.flags |= 4;
    return gap;
  }
  ensureLine() {
    this.enterLine();
    let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (last instanceof HeightMapText)
      return last;
    let line2 = new HeightMapText(0, -1);
    this.nodes.push(line2);
    return line2;
  }
  addBlock(block) {
    this.enterLine();
    let deco = block.deco;
    if (deco && deco.startSide > 0 && !this.isCovered)
      this.ensureLine();
    this.nodes.push(block);
    this.writtenTo = this.pos = this.pos + block.length;
    if (deco && deco.endSide > 0)
      this.covering = block;
  }
  addLineDeco(height, breaks, length2) {
    let line2 = this.ensureLine();
    line2.length += length2;
    line2.collapsed += length2;
    line2.widgetHeight = Math.max(line2.widgetHeight, height);
    line2.breaks += breaks;
    this.writtenTo = this.pos = this.pos + length2;
  }
  finish(from2) {
    let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
      this.nodes.push(new HeightMapText(0, -1));
    else if (this.writtenTo < this.pos || last == null)
      this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let pos = from2;
    for (let node3 of this.nodes) {
      if (node3 instanceof HeightMapText)
        node3.updateHeight(this.oracle, pos);
      pos += node3 ? node3.length : 1;
    }
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(oracle, decorations2, from2, to) {
    let builder = new _NodeBuilder(from2, oracle);
    RangeSet.spans(decorations2, from2, to, builder, 0);
    return builder.finish(from2);
  }
};
function heightRelevantDecoChanges(a3, b2, diff) {
  let comp = new DecorationComparator2();
  RangeSet.compare(a3, b2, diff, comp, 0);
  return comp.changes;
}
var DecorationComparator2 = class {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(from2, to, a3, b2) {
    if (from2 < to || a3 && a3.heightRelevant || b2 && b2.heightRelevant)
      addRange(from2, to, this.changes, 5);
  }
};
function visiblePixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  let left2 = Math.max(0, rect.left), right2 = Math.min(win.innerWidth, rect.right);
  let top3 = Math.max(0, rect.top), bottom2 = Math.min(win.innerHeight, rect.bottom);
  for (let parent = dom.parentNode; parent && parent != doc2.body; ) {
    if (parent.nodeType == 1) {
      let elt = parent;
      let style = window.getComputedStyle(elt);
      if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != "visible") {
        let parentRect = elt.getBoundingClientRect();
        left2 = Math.max(left2, parentRect.left);
        right2 = Math.min(right2, parentRect.right);
        top3 = Math.max(top3, parentRect.top);
        bottom2 = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom2, parentRect.bottom);
      }
      parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
    } else if (parent.nodeType == 11) {
      parent = parent.host;
    } else {
      break;
    }
  }
  return {
    left: left2 - rect.left,
    right: Math.max(left2, right2) - rect.left,
    top: top3 - (rect.top + paddingTop),
    bottom: Math.max(top3, bottom2) - (rect.top + paddingTop)
  };
}
function fullPixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  return {
    left: 0,
    right: rect.right - rect.left,
    top: paddingTop,
    bottom: rect.bottom - (rect.top + paddingTop)
  };
}
var LineGap = class {
  constructor(from2, to, size3) {
    this.from = from2;
    this.to = to;
    this.size = size3;
  }
  static same(a3, b2) {
    if (a3.length != b2.length)
      return false;
    for (let i2 = 0; i2 < a3.length; i2++) {
      let gA = a3[i2], gB = b2[i2];
      if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
        return false;
    }
    return true;
  }
  draw(viewState, wrapping) {
    return Decoration.replace({
      widget: new LineGapWidget(this.size * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
    }).range(this.from, this.to);
  }
};
var LineGapWidget = class extends WidgetType {
  constructor(size3, vertical) {
    super();
    this.size = size3;
    this.vertical = vertical;
  }
  eq(other) {
    return other.size == this.size && other.vertical == this.vertical;
  }
  toDOM() {
    let elt = document.createElement("div");
    if (this.vertical) {
      elt.style.height = this.size + "px";
    } else {
      elt.style.width = this.size + "px";
      elt.style.height = "2px";
      elt.style.display = "inline-block";
    }
    return elt;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
};
var ViewState = class {
  constructor(state) {
    this.state = state;
    this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
    this.inView = true;
    this.paddingTop = 0;
    this.paddingBottom = 0;
    this.contentDOMWidth = 0;
    this.contentDOMHeight = 0;
    this.editorHeight = 0;
    this.editorWidth = 0;
    this.scrollTop = 0;
    this.scrolledToBottom = true;
    this.scaleX = 1;
    this.scaleY = 1;
    this.scrollAnchorPos = 0;
    this.scrollAnchorHeight = -1;
    this.scaler = IdScaler;
    this.scrollTarget = null;
    this.printing = false;
    this.mustMeasureContent = true;
    this.defaultTextDirection = Direction.LTR;
    this.visibleRanges = [];
    this.mustEnforceCursorAssoc = false;
    let guessWrapping = state.facet(contentAttributes).some((v) => typeof v != "function" && v.class == "cm-lineWrapping");
    this.heightOracle = new HeightOracle(guessWrapping);
    this.stateDeco = state.facet(decorations).filter((d3) => typeof d3 != "function");
    this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
    this.viewport = this.getViewport(0, null);
    this.updateViewportLines();
    this.updateForViewport();
    this.lineGaps = this.ensureLineGaps([]);
    this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(this, false)));
    this.computeVisibleRanges();
  }
  updateForViewport() {
    let viewports = [this.viewport], { main: main2 } = this.state.selection;
    for (let i2 = 0; i2 <= 1; i2++) {
      let pos = i2 ? main2.head : main2.anchor;
      if (!viewports.some(({ from: from2, to }) => pos >= from2 && pos <= to)) {
        let { from: from2, to } = this.lineBlockAt(pos);
        viewports.push(new Viewport(from2, to));
      }
    }
    this.viewports = viewports.sort((a3, b2) => a3.from - b2.from);
    this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [];
    this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block) => {
      this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));
    });
  }
  update(update, scrollTarget = null) {
    this.state = update.state;
    let prevDeco = this.stateDeco;
    this.stateDeco = this.state.facet(decorations).filter((d3) => typeof d3 != "function");
    let contentChanges = update.changedRanges;
    let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
    let prevHeight = this.heightMap.height;
    let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
    if (this.heightMap.height != prevHeight)
      update.flags |= 2;
    if (scrollAnchor) {
      this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);
      this.scrollAnchorHeight = scrollAnchor.top;
    } else {
      this.scrollAnchorPos = -1;
      this.scrollAnchorHeight = this.heightMap.height;
    }
    let viewport2 = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
    if (scrollTarget && (scrollTarget.range.head < viewport2.from || scrollTarget.range.head > viewport2.to) || !this.viewportIsAppropriate(viewport2))
      viewport2 = this.getViewport(0, scrollTarget);
    let updateLines = !update.changes.empty || update.flags & 2 || viewport2.from != this.viewport.from || viewport2.to != this.viewport.to;
    this.viewport = viewport2;
    this.updateForViewport();
    if (updateLines)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
    update.flags |= this.computeVisibleRanges();
    if (scrollTarget)
      this.scrollTarget = scrollTarget;
    if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden))
      this.mustEnforceCursorAssoc = true;
  }
  measure(view) {
    let dom = view.contentDOM, style = window.getComputedStyle(dom);
    let oracle = this.heightOracle;
    let whiteSpace = style.whiteSpace;
    this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
    let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
    let domRect = dom.getBoundingClientRect();
    let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
    this.contentDOMHeight = domRect.height;
    this.mustMeasureContent = false;
    let result = 0, bias = 0;
    if (domRect.width && domRect.height) {
      let { scaleX, scaleY } = getScale2(dom, domRect);
      if (this.scaleX != scaleX || this.scaleY != scaleY) {
        this.scaleX = scaleX;
        this.scaleY = scaleY;
        result |= 8;
        refresh = measureContent = true;
      }
    }
    let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
    let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
    if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
      this.paddingTop = paddingTop;
      this.paddingBottom = paddingBottom;
      result |= 8 | 2;
    }
    if (this.editorWidth != view.scrollDOM.clientWidth) {
      if (oracle.lineWrapping)
        measureContent = true;
      this.editorWidth = view.scrollDOM.clientWidth;
      result |= 8;
    }
    let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
    if (this.scrollTop != scrollTop) {
      this.scrollAnchorHeight = -1;
      this.scrollTop = scrollTop;
    }
    this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
    let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
    let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
    this.pixelViewport = pixelViewport;
    let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (inView != this.inView) {
      this.inView = inView;
      if (inView)
        measureContent = true;
    }
    if (!this.inView && !this.scrollTarget)
      return 0;
    let contentWidth = domRect.width;
    if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
      this.contentDOMWidth = domRect.width;
      this.editorHeight = view.scrollDOM.clientHeight;
      result |= 8;
    }
    if (measureContent) {
      let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
      if (oracle.mustRefreshForHeights(lineHeights))
        refresh = true;
      if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
        let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();
        refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);
        if (refresh) {
          view.docView.minWidth = 0;
          result |= 8;
        }
      }
      if (dTop > 0 && dBottom > 0)
        bias = Math.max(dTop, dBottom);
      else if (dTop < 0 && dBottom < 0)
        bias = Math.min(dTop, dBottom);
      oracle.heightChanged = false;
      for (let vp of this.viewports) {
        let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
        this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
      }
      if (oracle.heightChanged)
        result |= 2;
    }
    let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    if (viewportChange)
      this.viewport = this.getViewport(bias, this.scrollTarget);
    this.updateForViewport();
    if (result & 2 || viewportChange)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
    result |= this.computeVisibleRanges();
    if (this.mustEnforceCursorAssoc) {
      this.mustEnforceCursorAssoc = false;
      view.docView.enforceCursorAssoc();
    }
    return result;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(bias, scrollTarget) {
    let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
    let map = this.heightMap, oracle = this.heightOracle;
    let { visibleTop, visibleBottom } = this;
    let viewport2 = new Viewport(map.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, oracle, 0, 0).to);
    if (scrollTarget) {
      let { head } = scrollTarget.range;
      if (head < viewport2.from || head > viewport2.to) {
        let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
        let block = map.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;
        if (scrollTarget.y == "center")
          topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
        else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport2.from)
          topPos = block.top;
        else
          topPos = block.bottom - viewHeight;
        viewport2 = new Viewport(map.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).to);
      }
    }
    return viewport2;
  }
  mapViewport(viewport2, changes) {
    let from2 = changes.mapPos(viewport2.from, -1), to = changes.mapPos(viewport2.to, 1);
    return new Viewport(this.heightMap.lineAt(from2, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: from2, to }, bias = 0) {
    if (!this.inView)
      return true;
    let { top: top3 } = this.heightMap.lineAt(from2, QueryType.ByPos, this.heightOracle, 0, 0);
    let { bottom: bottom2 } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);
    let { visibleTop, visibleBottom } = this;
    return (from2 == 0 || top3 <= visibleTop - Math.max(10, Math.min(
      -bias,
      250
      /* VP.MaxCoverMargin */
    ))) && (to == this.state.doc.length || bottom2 >= visibleBottom + Math.max(10, Math.min(
      bias,
      250
      /* VP.MaxCoverMargin */
    ))) && (top3 > visibleTop - 2 * 1e3 && bottom2 < visibleBottom + 2 * 1e3);
  }
  mapLineGaps(gaps, changes) {
    if (!gaps.length || changes.empty)
      return gaps;
    let mapped = [];
    for (let gap of gaps)
      if (!changes.touchesRange(gap.from, gap.to))
        mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
    return mapped;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(current, mayMeasure) {
    let wrapping = this.heightOracle.lineWrapping;
    let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
    if (this.defaultTextDirection != Direction.LTR && !wrapping)
      return [];
    let gaps = [];
    let addGap = (from2, to, line2, structure) => {
      if (to - from2 < halfMargin)
        return;
      let sel = this.state.selection.main, avoid = [sel.from];
      if (!sel.empty)
        avoid.push(sel.to);
      for (let pos of avoid) {
        if (pos > from2 && pos < to) {
          addGap(from2, pos - 10, line2, structure);
          addGap(pos + 10, to, line2, structure);
          return;
        }
      }
      let gap = find(current, (gap2) => gap2.from >= line2.from && gap2.to <= line2.to && Math.abs(gap2.from - from2) < halfMargin && Math.abs(gap2.to - to) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
      if (!gap) {
        if (to < line2.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r2) => r2.from <= to && r2.to >= to)) {
          let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to), false, true).head;
          if (lineStart > from2)
            to = lineStart;
        }
        gap = new LineGap(from2, to, this.gapSize(line2, from2, to, structure));
      }
      gaps.push(gap);
    };
    for (let line2 of this.viewportLines) {
      if (line2.length < doubleMargin)
        continue;
      let structure = lineStructure(line2.from, line2.to, this.stateDeco);
      if (structure.total < doubleMargin)
        continue;
      let target = this.scrollTarget ? this.scrollTarget.range.head : null;
      let viewFrom, viewTo;
      if (wrapping) {
        let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
        let top3, bot;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line2.height;
          top3 = targetFrac - spaceFrac;
          bot = targetFrac + spaceFrac;
        } else {
          top3 = (this.visibleTop - line2.top - marginHeight) / line2.height;
          bot = (this.visibleBottom - line2.top + marginHeight) / line2.height;
        }
        viewFrom = findPosition(structure, top3);
        viewTo = findPosition(structure, bot);
      } else {
        let totalWidth = structure.total * this.heightOracle.charWidth;
        let marginWidth = margin * this.heightOracle.charWidth;
        let left2, right2;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;
          left2 = targetFrac - spaceFrac;
          right2 = targetFrac + spaceFrac;
        } else {
          left2 = (this.pixelViewport.left - marginWidth) / totalWidth;
          right2 = (this.pixelViewport.right + marginWidth) / totalWidth;
        }
        viewFrom = findPosition(structure, left2);
        viewTo = findPosition(structure, right2);
      }
      if (viewFrom > line2.from)
        addGap(line2.from, viewFrom, line2, structure);
      if (viewTo < line2.to)
        addGap(viewTo, line2.to, line2, structure);
    }
    return gaps;
  }
  gapSize(line2, from2, to, structure) {
    let fraction = findFraction(structure, to) - findFraction(structure, from2);
    if (this.heightOracle.lineWrapping) {
      return line2.height * fraction;
    } else {
      return structure.total * this.heightOracle.charWidth * fraction;
    }
  }
  updateLineGaps(gaps) {
    if (!LineGap.same(gaps, this.lineGaps)) {
      this.lineGaps = gaps;
      this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this, this.heightOracle.lineWrapping)));
    }
  }
  computeVisibleRanges() {
    let deco = this.stateDeco;
    if (this.lineGaps.length)
      deco = deco.concat(this.lineGapDeco);
    let ranges = [];
    RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
      span(from2, to) {
        ranges.push({ from: from2, to });
      },
      point() {
      }
    }, 20);
    let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r2, i2) => r2.from != ranges[i2].from || r2.to != ranges[i2].to);
    this.visibleRanges = ranges;
    return changed ? 4 : 0;
  }
  lineBlockAt(pos) {
    return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b2) => b2.from <= pos && b2.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(height) {
    return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(scrollTop) {
    let block = this.lineBlockAtHeight(scrollTop + 8);
    return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
  }
  elementAtHeight(height) {
    return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
};
var Viewport = class {
  constructor(from2, to) {
    this.from = from2;
    this.to = to;
  }
};
function lineStructure(from2, to, stateDeco) {
  let ranges = [], pos = from2, total = 0;
  RangeSet.spans(stateDeco, from2, to, {
    span() {
    },
    point(from3, to2) {
      if (from3 > pos) {
        ranges.push({ from: pos, to: from3 });
        total += from3 - pos;
      }
      pos = to2;
    }
  }, 20);
  if (pos < to) {
    ranges.push({ from: pos, to });
    total += to - pos;
  }
  return { total, ranges };
}
function findPosition({ total, ranges }, ratio) {
  if (ratio <= 0)
    return ranges[0].from;
  if (ratio >= 1)
    return ranges[ranges.length - 1].to;
  let dist2 = Math.floor(total * ratio);
  for (let i2 = 0; ; i2++) {
    let { from: from2, to } = ranges[i2], size3 = to - from2;
    if (dist2 <= size3)
      return from2 + dist2;
    dist2 -= size3;
  }
}
function findFraction(structure, pos) {
  let counted = 0;
  for (let { from: from2, to } of structure.ranges) {
    if (pos <= to) {
      counted += pos - from2;
      break;
    }
    counted += to - from2;
  }
  return counted / structure.total;
}
function find(array, f) {
  for (let val of array)
    if (f(val))
      return val;
  return void 0;
}
var IdScaler = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1
};
var BigScaler = class {
  constructor(oracle, heightMap, viewports) {
    let vpHeight = 0, base2 = 0, domBase = 0;
    this.viewports = viewports.map(({ from: from2, to }) => {
      let top3 = heightMap.lineAt(from2, QueryType.ByPos, oracle, 0, 0).top;
      let bottom2 = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;
      vpHeight += bottom2 - top3;
      return { from: from2, to, top: top3, bottom: bottom2, domTop: 0, domBottom: 0 };
    });
    this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
    for (let obj of this.viewports) {
      obj.domTop = domBase + (obj.top - base2) * this.scale;
      domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
      base2 = obj.bottom;
    }
  }
  toDOM(n) {
    for (let i2 = 0, base2 = 0, domBase = 0; ; i2++) {
      let vp = i2 < this.viewports.length ? this.viewports[i2] : null;
      if (!vp || n < vp.top)
        return domBase + (n - base2) * this.scale;
      if (n <= vp.bottom)
        return vp.domTop + (n - vp.top);
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
  fromDOM(n) {
    for (let i2 = 0, base2 = 0, domBase = 0; ; i2++) {
      let vp = i2 < this.viewports.length ? this.viewports[i2] : null;
      if (!vp || n < vp.domTop)
        return base2 + (n - domBase) / this.scale;
      if (n <= vp.domBottom)
        return vp.top + (n - vp.domTop);
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
};
function scaleBlock(block, scaler) {
  if (scaler.scale == 1)
    return block;
  let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
  return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map((b2) => scaleBlock(b2, scaler)) : block._content);
}
var theme = Facet.define({ combine: (strs) => strs.join(" ") });
var darkTheme = Facet.define({ combine: (values) => values.indexOf(true) > -1 });
var baseThemeID = StyleModule.newName();
var baseLightID = StyleModule.newName();
var baseDarkID = StyleModule.newName();
var lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
function buildTheme(main2, spec, scopes) {
  return new StyleModule(spec, {
    finish(sel) {
      return /&/.test(sel) ? sel.replace(/&\w*/, (m3) => {
        if (m3 == "&")
          return main2;
        if (!scopes || !scopes[m3])
          throw new RangeError(`Unsupported selector: ${m3}`);
        return scopes[m3];
      }) : main2 + " " + sel;
    }
  });
}
var baseTheme$1 = buildTheme("." + baseThemeID, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, lightDarkIDs);
var LineBreakPlaceholder = "";
var DOMReader = class {
  constructor(points, state) {
    this.points = points;
    this.text = "";
    this.lineSeparator = state.facet(EditorState.lineSeparator);
  }
  append(text) {
    this.text += text;
  }
  lineBreak() {
    this.text += LineBreakPlaceholder;
  }
  readRange(start2, end2) {
    if (!start2)
      return this;
    let parent = start2.parentNode;
    for (let cur2 = start2; ; ) {
      this.findPointBefore(parent, cur2);
      let oldLen = this.text.length;
      this.readNode(cur2);
      let next2 = cur2.nextSibling;
      if (next2 == end2)
        break;
      let view = ContentView.get(cur2), nextView = ContentView.get(next2);
      if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur2)) || isBlockElement(next2) && (cur2.nodeName != "BR" || cur2.cmIgnore) && this.text.length > oldLen)
        this.lineBreak();
      cur2 = next2;
    }
    this.findPointBefore(parent, end2);
    return this;
  }
  readTextNode(node3) {
    let text = node3.nodeValue;
    for (let point of this.points)
      if (point.node == node3)
        point.pos = this.text.length + Math.min(point.offset, text.length);
    for (let off2 = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let nextBreak = -1, breakSize = 1, m3;
      if (this.lineSeparator) {
        nextBreak = text.indexOf(this.lineSeparator, off2);
        breakSize = this.lineSeparator.length;
      } else if (m3 = re.exec(text)) {
        nextBreak = m3.index;
        breakSize = m3[0].length;
      }
      this.append(text.slice(off2, nextBreak < 0 ? text.length : nextBreak));
      if (nextBreak < 0)
        break;
      this.lineBreak();
      if (breakSize > 1) {
        for (let point of this.points)
          if (point.node == node3 && point.pos > this.text.length)
            point.pos -= breakSize - 1;
      }
      off2 = nextBreak + breakSize;
    }
  }
  readNode(node3) {
    if (node3.cmIgnore)
      return;
    let view = ContentView.get(node3);
    let fromView = view && view.overrideDOMText;
    if (fromView != null) {
      this.findPointInside(node3, fromView.length);
      for (let i2 = fromView.iter(); !i2.next().done; ) {
        if (i2.lineBreak)
          this.lineBreak();
        else
          this.append(i2.value);
      }
    } else if (node3.nodeType == 3) {
      this.readTextNode(node3);
    } else if (node3.nodeName == "BR") {
      if (node3.nextSibling)
        this.lineBreak();
    } else if (node3.nodeType == 1) {
      this.readRange(node3.firstChild, null);
    }
  }
  findPointBefore(node3, next2) {
    for (let point of this.points)
      if (point.node == node3 && node3.childNodes[point.offset] == next2)
        point.pos = this.text.length;
  }
  findPointInside(node3, length2) {
    for (let point of this.points)
      if (node3.nodeType == 3 ? point.node == node3 : node3.contains(point.node))
        point.pos = this.text.length + (isAtEnd(node3, point.node, point.offset) ? length2 : 0);
  }
};
function isAtEnd(parent, node3, offset3) {
  for (; ; ) {
    if (!node3 || offset3 < maxOffset(node3))
      return false;
    if (node3 == parent)
      return true;
    offset3 = domIndex(node3) + 1;
    node3 = node3.parentNode;
  }
}
function isBlockElement(node3) {
  return node3.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node3.nodeName);
}
var DOMPoint = class {
  constructor(node3, offset3) {
    this.node = node3;
    this.offset = offset3;
    this.pos = -1;
  }
};
var DOMChange = class {
  constructor(view, start2, end2, typeOver) {
    this.typeOver = typeOver;
    this.bounds = null;
    this.text = "";
    let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
    if (view.state.readOnly && start2 > -1) {
      this.newSel = null;
    } else if (start2 > -1 && (this.bounds = view.docView.domBoundsAround(start2, end2, 0))) {
      let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
      let reader = new DOMReader(selPoints, view.state);
      reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
      this.text = reader.text;
      this.newSel = selectionFromPoints(selPoints, this.bounds.from);
    } else {
      let domSel = view.observer.selectionRange;
      let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains4(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
      let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains4(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
      let vp = view.viewport;
      if (browser2.ios && view.state.selection.main.empty && head != anchor && (vp.from > 0 || vp.to < view.state.doc.length)) {
        let offFrom = vp.from - Math.min(head, anchor), offTo = vp.to - Math.max(head, anchor);
        if ((offFrom == 0 || offFrom == 1) && (offTo == 0 || offTo == -1)) {
          head = 0;
          anchor = view.state.doc.length;
        }
      }
      this.newSel = EditorSelection.single(anchor, head);
    }
  }
};
function applyDOMChange(view, domChange) {
  let change;
  let { newSel } = domChange, sel = view.state.selection.main;
  let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
  if (domChange.bounds) {
    let { from: from2, to } = domChange.bounds;
    let preferredPos = sel.from, preferredSide = null;
    if (lastKey === 8 || browser2.android && domChange.text.length < to - from2) {
      preferredPos = sel.to;
      preferredSide = "end";
    }
    let diff = findDiff(view.state.doc.sliceString(from2, to, LineBreakPlaceholder), domChange.text, preferredPos - from2, preferredSide);
    if (diff) {
      if (browser2.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
        diff.toB--;
      change = {
        from: from2 + diff.from,
        to: from2 + diff.toA,
        insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
      };
    }
  } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
    newSel = null;
  }
  if (!change && !newSel)
    return false;
  if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
    change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
  } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
    change = {
      from: sel.from,
      to: sel.to,
      insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
    };
  } else if ((browser2.mac || browser2.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
    if (newSel && change.insert.length == 2)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
  } else if (browser2.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
    if (newSel)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
  }
  if (change) {
    if (browser2.ios && view.inputState.flushIOSKey())
      return true;
    if (browser2.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
      return true;
    let text = change.insert.toString();
    if (view.inputState.composing >= 0)
      view.inputState.composing++;
    let defaultTr;
    let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
    if (!view.state.facet(inputHandler).some((h3) => h3(view, change.from, change.to, text, defaultInsert)))
      view.dispatch(defaultInsert());
    return true;
  } else if (newSel && !newSel.main.eq(sel)) {
    let scrollIntoView4 = false, userEvent = "select";
    if (view.inputState.lastSelectionTime > Date.now() - 50) {
      if (view.inputState.lastSelectionOrigin == "select")
        scrollIntoView4 = true;
      userEvent = view.inputState.lastSelectionOrigin;
    }
    view.dispatch({ selection: newSel, scrollIntoView: scrollIntoView4, userEvent });
    return true;
  } else {
    return false;
  }
}
function applyDefaultInsert(view, change, newSel) {
  let tr2, startState = view.state, sel = startState.selection.main;
  if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
    let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
    let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
    tr2 = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
  } else {
    let changes = startState.changes(change);
    let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : void 0;
    if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
      let replaced = view.state.sliceDoc(change.from, change.to);
      let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);
      if (composition) {
        let dLen = change.insert.length - (change.to - change.from);
        compositionRange = { from: composition.from, to: composition.to - dLen };
      } else {
        compositionRange = view.state.doc.lineAt(sel.head);
      }
      let offset3 = sel.to - change.to, size3 = sel.to - sel.from;
      tr2 = startState.changeByRange((range) => {
        if (range.from == sel.from && range.to == sel.to)
          return { changes, range: mainSel || range.map(changes) };
        let to = range.to - offset3, from2 = to - replaced.length;
        if (range.to - range.from != size3 || view.state.sliceDoc(from2, to) != replaced || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        range.to >= compositionRange.from && range.from <= compositionRange.to)
          return { range };
        let rangeChanges = startState.changes({ from: from2, to, insert: change.insert }), selOff = range.to - sel.to;
        return {
          changes: rangeChanges,
          range: !mainSel ? range.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
        };
      });
    } else {
      tr2 = {
        changes,
        selection: mainSel && startState.selection.replaceRange(mainSel)
      };
    }
  }
  let userEvent = "input.type";
  if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
    view.inputState.compositionPendingChange = false;
    userEvent += ".compose";
    if (view.inputState.compositionFirstChange) {
      userEvent += ".start";
      view.inputState.compositionFirstChange = false;
    }
  }
  return startState.update(tr2, { userEvent, scrollIntoView: true });
}
function findDiff(a3, b2, preferredPos, preferredSide) {
  let minLen = Math.min(a3.length, b2.length);
  let from2 = 0;
  while (from2 < minLen && a3.charCodeAt(from2) == b2.charCodeAt(from2))
    from2++;
  if (from2 == minLen && a3.length == b2.length)
    return null;
  let toA = a3.length, toB = b2.length;
  while (toA > 0 && toB > 0 && a3.charCodeAt(toA - 1) == b2.charCodeAt(toB - 1)) {
    toA--;
    toB--;
  }
  if (preferredSide == "end") {
    let adjust = Math.max(0, from2 - Math.min(toA, toB));
    preferredPos -= toA + adjust - from2;
  }
  if (toA < from2 && a3.length < b2.length) {
    let move = preferredPos <= from2 && preferredPos >= toA ? from2 - preferredPos : 0;
    from2 -= move;
    toB = from2 + (toB - toA);
    toA = from2;
  } else if (toB < from2) {
    let move = preferredPos <= from2 && preferredPos >= toB ? from2 - preferredPos : 0;
    from2 -= move;
    toA = from2 + (toA - toB);
    toB = from2;
  }
  return { from: from2, toA, toB };
}
function selectionPoints(view) {
  let result = [];
  if (view.root.activeElement != view.contentDOM)
    return result;
  let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
  if (anchorNode) {
    result.push(new DOMPoint(anchorNode, anchorOffset));
    if (focusNode != anchorNode || focusOffset != anchorOffset)
      result.push(new DOMPoint(focusNode, focusOffset));
  }
  return result;
}
function selectionFromPoints(points, base2) {
  if (points.length == 0)
    return null;
  let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
  return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
}
var observeOptions = {
  childList: true,
  characterData: true,
  subtree: true,
  attributes: true,
  characterDataOldValue: true
};
var useCharData = browser2.ie && browser2.ie_version <= 11;
var DOMObserver = class {
  constructor(view) {
    this.view = view;
    this.active = false;
    this.selectionRange = new DOMSelectionState();
    this.selectionChanged = false;
    this.delayedFlush = -1;
    this.resizeTimeout = -1;
    this.queue = [];
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
    this.lastChange = 0;
    this.scrollTargets = [];
    this.intersection = null;
    this.resizeScroll = null;
    this.intersecting = false;
    this.gapIntersection = null;
    this.gaps = [];
    this.parentCheck = -1;
    this.dom = view.contentDOM;
    this.observer = new MutationObserver((mutations) => {
      for (let mut of mutations)
        this.queue.push(mut);
      if ((browser2.ie && browser2.ie_version <= 11 || browser2.ios && view.composing) && mutations.some((m3) => m3.type == "childList" && m3.removedNodes.length || m3.type == "characterData" && m3.oldValue.length > m3.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData)
      this.onCharData = (event) => {
        this.queue.push({
          target: event.target,
          type: "characterData",
          oldValue: event.prevValue
        });
        this.flushSoon();
      };
    this.onSelectionChange = this.onSelectionChange.bind(this);
    this.onResize = this.onResize.bind(this);
    this.onPrint = this.onPrint.bind(this);
    this.onScroll = this.onScroll.bind(this);
    if (typeof ResizeObserver == "function") {
      this.resizeScroll = new ResizeObserver(() => {
        var _a2;
        if (((_a2 = this.view.docView) === null || _a2 === void 0 ? void 0 : _a2.lastUpdate) < Date.now() - 75)
          this.onResize();
      });
      this.resizeScroll.observe(view.scrollDOM);
    }
    this.addWindowListeners(this.win = view.win);
    this.start();
    if (typeof IntersectionObserver == "function") {
      this.intersection = new IntersectionObserver((entries) => {
        if (this.parentCheck < 0)
          this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
          this.intersecting = !this.intersecting;
          if (this.intersecting != this.view.inView)
            this.onScrollChanged(document.createEvent("Event"));
        }
      }, { threshold: [0, 1e-3] });
      this.intersection.observe(this.dom);
      this.gapIntersection = new IntersectionObserver((entries) => {
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
          this.onScrollChanged(document.createEvent("Event"));
      }, {});
    }
    this.listenForScroll();
    this.readSelectionRange();
  }
  onScrollChanged(e4) {
    this.view.inputState.runHandlers("scroll", e4);
    if (this.intersecting)
      this.view.measure();
  }
  onScroll(e4) {
    if (this.intersecting)
      this.flush(false);
    this.onScrollChanged(e4);
  }
  onResize() {
    if (this.resizeTimeout < 0)
      this.resizeTimeout = setTimeout(() => {
        this.resizeTimeout = -1;
        this.view.requestMeasure();
      }, 50);
  }
  onPrint() {
    this.view.viewState.printing = true;
    this.view.measure();
    setTimeout(() => {
      this.view.viewState.printing = false;
      this.view.requestMeasure();
    }, 500);
  }
  updateGaps(gaps) {
    if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i2) => g != gaps[i2]))) {
      this.gapIntersection.disconnect();
      for (let gap of gaps)
        this.gapIntersection.observe(gap);
      this.gaps = gaps;
    }
  }
  onSelectionChange(event) {
    let wasChanged = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view } = this, sel = this.selectionRange;
    if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))
      return;
    let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
    if (context && context.ignoreEvent(event)) {
      if (!wasChanged)
        this.selectionChanged = false;
      return;
    }
    if ((browser2.ie && browser2.ie_version <= 11 || browser2.android && browser2.chrome) && !view.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
      this.flushSoon();
    else
      this.flush(false);
  }
  readSelectionRange() {
    let { view } = this;
    let range = browser2.safari && view.root.nodeType == 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariSelectionRangeHack(this.view) || getSelection(view.root);
    if (!range || this.selectionRange.eq(range))
      return false;
    let local = hasSelection(this.dom, range);
    if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {
      this.view.inputState.lastFocusTime = 0;
      view.docView.updateSelection();
      return false;
    }
    this.selectionRange.setRange(range);
    if (local)
      this.selectionChanged = true;
    return true;
  }
  setSelectionRange(anchor, head) {
    this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
    this.selectionChanged = false;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let i2 = 0, changed = null;
    for (let dom = this.dom; dom; ) {
      if (dom.nodeType == 1) {
        if (!changed && i2 < this.scrollTargets.length && this.scrollTargets[i2] == dom)
          i2++;
        else if (!changed)
          changed = this.scrollTargets.slice(0, i2);
        if (changed)
          changed.push(dom);
        dom = dom.assignedSlot || dom.parentNode;
      } else if (dom.nodeType == 11) {
        dom = dom.host;
      } else {
        break;
      }
    }
    if (i2 < this.scrollTargets.length && !changed)
      changed = this.scrollTargets.slice(0, i2);
    if (changed) {
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      for (let dom of this.scrollTargets = changed)
        dom.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(f) {
    if (!this.active)
      return f();
    try {
      this.stop();
      return f();
    } finally {
      this.start();
      this.clear();
    }
  }
  start() {
    if (this.active)
      return;
    this.observer.observe(this.dom, observeOptions);
    if (useCharData)
      this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.active = true;
  }
  stop() {
    if (!this.active)
      return;
    this.active = false;
    this.observer.disconnect();
    if (useCharData)
      this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }
  // Throw away any pending changes
  clear() {
    this.processRecords();
    this.queue.length = 0;
    this.selectionChanged = false;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(key, keyCode) {
    var _a2;
    if (!this.delayedAndroidKey) {
      let flush = () => {
        let key2 = this.delayedAndroidKey;
        if (key2) {
          this.clearDelayedAndroidKey();
          this.view.inputState.lastKeyCode = key2.keyCode;
          this.view.inputState.lastKeyTime = Date.now();
          let flushed = this.flush();
          if (!flushed && key2.force)
            dispatchKey(this.dom, key2.key, key2.keyCode);
        }
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
    }
    if (!this.delayedAndroidKey || key == "Enter")
      this.delayedAndroidKey = {
        key,
        keyCode,
        // Only run the key handler when no changes are detected if
        // this isn't coming right after another change, in which case
        // it is probably part of a weird chain of updates, and should
        // be ignored if it returns the DOM to its previous state.
        force: this.lastChange < Date.now() - 50 || !!((_a2 = this.delayedAndroidKey) === null || _a2 === void 0 ? void 0 : _a2.force)
      };
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
  }
  flushSoon() {
    if (this.delayedFlush < 0)
      this.delayedFlush = this.view.win.requestAnimationFrame(() => {
        this.delayedFlush = -1;
        this.flush();
      });
  }
  forceFlush() {
    if (this.delayedFlush >= 0) {
      this.view.win.cancelAnimationFrame(this.delayedFlush);
      this.delayedFlush = -1;
    }
    this.flush();
  }
  pendingRecords() {
    for (let mut of this.observer.takeRecords())
      this.queue.push(mut);
    return this.queue;
  }
  processRecords() {
    let records = this.pendingRecords();
    if (records.length)
      this.queue = [];
    let from2 = -1, to = -1, typeOver = false;
    for (let record of records) {
      let range = this.readMutation(record);
      if (!range)
        continue;
      if (range.typeOver)
        typeOver = true;
      if (from2 == -1) {
        ({ from: from2, to } = range);
      } else {
        from2 = Math.min(range.from, from2);
        to = Math.max(range.to, to);
      }
    }
    return { from: from2, to, typeOver };
  }
  readChange() {
    let { from: from2, to, typeOver } = this.processRecords();
    let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
    if (from2 < 0 && !newSel)
      return null;
    if (from2 > -1)
      this.lastChange = Date.now();
    this.view.inputState.lastFocusTime = 0;
    this.selectionChanged = false;
    let change = new DOMChange(this.view, from2, to, typeOver);
    this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };
    return change;
  }
  // Apply pending changes, if any
  flush(readSelection = true) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return false;
    if (readSelection)
      this.readSelectionRange();
    let domChange = this.readChange();
    if (!domChange) {
      this.view.requestMeasure();
      return false;
    }
    let startState = this.view.state;
    let handled = applyDOMChange(this.view, domChange);
    if (this.view.state == startState)
      this.view.update([]);
    return handled;
  }
  readMutation(rec) {
    let cView = this.view.docView.nearest(rec.target);
    if (!cView || cView.ignoreMutation(rec))
      return null;
    cView.markDirty(rec.type == "attributes");
    if (rec.type == "attributes")
      cView.flags |= 4;
    if (rec.type == "childList") {
      let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
      let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
      return {
        from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
        to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
        typeOver: false
      };
    } else if (rec.type == "characterData") {
      return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
    } else {
      return null;
    }
  }
  setWindow(win) {
    if (win != this.win) {
      this.removeWindowListeners(this.win);
      this.win = win;
      this.addWindowListeners(this.win);
    }
  }
  addWindowListeners(win) {
    win.addEventListener("resize", this.onResize);
    win.addEventListener("beforeprint", this.onPrint);
    win.addEventListener("scroll", this.onScroll);
    win.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(win) {
    win.removeEventListener("scroll", this.onScroll);
    win.removeEventListener("resize", this.onResize);
    win.removeEventListener("beforeprint", this.onPrint);
    win.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var _a2, _b, _c;
    this.stop();
    (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
    (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
    for (let dom of this.scrollTargets)
      dom.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win);
    clearTimeout(this.parentCheck);
    clearTimeout(this.resizeTimeout);
    this.win.cancelAnimationFrame(this.delayedFlush);
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
};
function findChild(cView, dom, dir) {
  while (dom) {
    let curView = ContentView.get(dom);
    if (curView && curView.parent == cView)
      return curView;
    let parent = dom.parentNode;
    dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
  }
  return null;
}
function safariSelectionRangeHack(view) {
  let found = null;
  function read2(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found = event.getTargetRanges()[0];
  }
  view.contentDOM.addEventListener("beforeinput", read2, true);
  view.dom.ownerDocument.execCommand("indent");
  view.contentDOM.removeEventListener("beforeinput", read2, true);
  if (!found)
    return null;
  let anchorNode = found.startContainer, anchorOffset = found.startOffset;
  let focusNode = found.endContainer, focusOffset = found.endOffset;
  let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
  if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
var EditorView = class _EditorView {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(config2 = {}) {
    this.plugins = [];
    this.pluginMap = /* @__PURE__ */ new Map();
    this.editorAttrs = {};
    this.contentAttrs = {};
    this.bidiCache = [];
    this.destroyed = false;
    this.updateState = 2;
    this.measureScheduled = -1;
    this.measureRequests = [];
    this.contentDOM = document.createElement("div");
    this.scrollDOM = document.createElement("div");
    this.scrollDOM.tabIndex = -1;
    this.scrollDOM.className = "cm-scroller";
    this.scrollDOM.appendChild(this.contentDOM);
    this.announceDOM = document.createElement("div");
    this.announceDOM.className = "cm-announced";
    this.announceDOM.setAttribute("aria-live", "polite");
    this.dom = document.createElement("div");
    this.dom.appendChild(this.announceDOM);
    this.dom.appendChild(this.scrollDOM);
    if (config2.parent)
      config2.parent.appendChild(this.dom);
    let { dispatch } = config2;
    this.dispatchTransactions = config2.dispatchTransactions || dispatch && ((trs) => trs.forEach((tr2) => dispatch(tr2, this))) || ((trs) => this.update(trs));
    this.dispatch = this.dispatch.bind(this);
    this._root = config2.root || getRoot(config2.parent) || document;
    this.viewState = new ViewState(config2.state || EditorState.create(config2));
    if (config2.scrollTo && config2.scrollTo.is(scrollIntoView2))
      this.viewState.scrollTarget = config2.scrollTo.value.clip(this.viewState.state);
    this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
    for (let plugin2 of this.plugins)
      plugin2.update(this);
    this.observer = new DOMObserver(this);
    this.inputState = new InputState(this);
    this.inputState.ensureHandlers(this.plugins);
    this.docView = new DocView(this);
    this.mountStyles();
    this.updateAttrs();
    this.updateState = 0;
    this.requestMeasure();
  }
  dispatch(...input) {
    let trs = input.length == 1 && input[0] instanceof Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [this.state.update(...input)];
    this.dispatchTransactions(trs, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(transactions) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let redrawn = false, attrsChanged = false, update;
    let state = this.state;
    for (let tr2 of transactions) {
      if (tr2.startState != state)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      state = tr2.state;
    }
    if (this.destroyed) {
      this.viewState.state = state;
      return;
    }
    let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
    if (transactions.some((tr2) => tr2.annotation(isFocusChange))) {
      this.inputState.notifiedFocused = focus;
      focusFlag = 1;
    } else if (focus != this.inputState.notifiedFocused) {
      this.inputState.notifiedFocused = focus;
      dispatchFocus = focusChangeTransaction(state, focus);
      if (!dispatchFocus)
        focusFlag = 1;
    }
    let pendingKey = this.observer.delayedAndroidKey, domChange = null;
    if (pendingKey) {
      this.observer.clearDelayedAndroidKey();
      domChange = this.observer.readChange();
      if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
        domChange = null;
    } else {
      this.observer.clear();
    }
    if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
      return this.setState(state);
    update = ViewUpdate.create(this, state, transactions);
    update.flags |= focusFlag;
    let scrollTarget = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let tr2 of transactions) {
        if (scrollTarget)
          scrollTarget = scrollTarget.map(tr2.changes);
        if (tr2.scrollIntoView) {
          let { main: main2 } = tr2.state.selection;
          scrollTarget = new ScrollTarget(main2.empty ? main2 : EditorSelection.cursor(main2.head, main2.head > main2.anchor ? -1 : 1));
        }
        for (let e4 of tr2.effects)
          if (e4.is(scrollIntoView2))
            scrollTarget = e4.value.clip(this.state);
      }
      this.viewState.update(update, scrollTarget);
      this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
      if (!update.empty) {
        this.updatePlugins(update);
        this.inputState.update(update);
      }
      redrawn = this.docView.update(update);
      if (this.state.facet(styleModule) != this.styleModules)
        this.mountStyles();
      attrsChanged = this.updateAttrs();
      this.showAnnouncements(transactions);
      this.docView.updateSelection(redrawn, transactions.some((tr2) => tr2.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (update.startState.facet(theme) != update.state.facet(theme))
      this.viewState.mustMeasureContent = true;
    if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
      this.requestMeasure();
    if (!update.empty)
      for (let listener of this.state.facet(updateListener)) {
        try {
          listener(update);
        } catch (e4) {
          logException(this.state, e4, "update listener");
        }
      }
    if (dispatchFocus || domChange)
      Promise.resolve().then(() => {
        if (dispatchFocus && this.state == dispatchFocus.startState)
          this.dispatch(dispatchFocus);
        if (domChange) {
          if (!applyDOMChange(this, domChange) && pendingKey.force)
            dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
        }
      });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(newState) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = newState;
      return;
    }
    this.updateState = 2;
    let hadFocus = this.hasFocus;
    try {
      for (let plugin2 of this.plugins)
        plugin2.destroy(this);
      this.viewState = new ViewState(newState);
      this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      this.pluginMap.clear();
      for (let plugin2 of this.plugins)
        plugin2.update(this);
      this.docView.destroy();
      this.docView = new DocView(this);
      this.inputState.ensureHandlers(this.plugins);
      this.mountStyles();
      this.updateAttrs();
      this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    if (hadFocus)
      this.focus();
    this.requestMeasure();
  }
  updatePlugins(update) {
    let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
    if (prevSpecs != specs) {
      let newPlugins = [];
      for (let spec of specs) {
        let found = prevSpecs.indexOf(spec);
        if (found < 0) {
          newPlugins.push(new PluginInstance(spec));
        } else {
          let plugin2 = this.plugins[found];
          plugin2.mustUpdate = update;
          newPlugins.push(plugin2);
        }
      }
      for (let plugin2 of this.plugins)
        if (plugin2.mustUpdate != update)
          plugin2.destroy(this);
      this.plugins = newPlugins;
      this.pluginMap.clear();
    } else {
      for (let p of this.plugins)
        p.mustUpdate = update;
    }
    for (let i2 = 0; i2 < this.plugins.length; i2++)
      this.plugins[i2].update(this);
    if (prevSpecs != specs)
      this.inputState.ensureHandlers(this.plugins);
  }
  /**
  @internal
  */
  measure(flush = true) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1)
      this.win.cancelAnimationFrame(this.measureScheduled);
    if (this.observer.delayedAndroidKey) {
      this.measureScheduled = -1;
      this.requestMeasure();
      return;
    }
    this.measureScheduled = 0;
    if (flush)
      this.observer.forceFlush();
    let updated = null;
    let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
    let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
    if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)
      scrollAnchorHeight = -1;
    this.viewState.scrollAnchorHeight = -1;
    try {
      for (let i2 = 0; ; i2++) {
        if (scrollAnchorHeight < 0) {
          if (isScrolledToBottom(sDOM)) {
            scrollAnchorPos = -1;
            scrollAnchorHeight = this.viewState.heightMap.height;
          } else {
            let block = this.viewState.scrollAnchorAt(scrollTop);
            scrollAnchorPos = block.from;
            scrollAnchorHeight = block.top;
          }
        }
        this.updateState = 1;
        let changed = this.viewState.measure(this);
        if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (i2 > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let measuring = [];
        if (!(changed & 4))
          [this.measureRequests, measuring] = [measuring, this.measureRequests];
        let measured = measuring.map((m3) => {
          try {
            return m3.read(this);
          } catch (e4) {
            logException(this.state, e4);
            return BadMeasure;
          }
        });
        let update = ViewUpdate.create(this, this.state, []), redrawn = false;
        update.flags |= changed;
        if (!updated)
          updated = update;
        else
          updated.flags |= changed;
        this.updateState = 2;
        if (!update.empty) {
          this.updatePlugins(update);
          this.inputState.update(update);
          this.updateAttrs();
          redrawn = this.docView.update(update);
        }
        for (let i3 = 0; i3 < measuring.length; i3++)
          if (measured[i3] != BadMeasure) {
            try {
              let m3 = measuring[i3];
              if (m3.write)
                m3.write(measured[i3], this);
            } catch (e4) {
              logException(this.state, e4);
            }
          }
        if (redrawn)
          this.docView.updateSelection(true);
        if (!update.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight) {
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget);
              this.viewState.scrollTarget = null;
              scrollAnchorHeight = -1;
              continue;
            } else {
              let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;
              let diff = newAnchorHeight - scrollAnchorHeight;
              if (diff > 1 || diff < -1) {
                scrollTop = scrollTop + diff;
                sDOM.scrollTop = scrollTop / this.scaleY;
                scrollAnchorHeight = -1;
                continue;
              }
            }
          }
          break;
        }
      }
    } finally {
      this.updateState = 0;
      this.measureScheduled = -1;
    }
    if (updated && !updated.empty)
      for (let listener of this.state.facet(updateListener))
        listener(updated);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
  }
  updateAttrs() {
    let editorAttrs = attrsFromFacet(this, editorAttributes, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    });
    let contentAttrs = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: !this.state.facet(editable) ? "false" : "true",
      class: "cm-content",
      style: `${browser2.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    if (this.state.readOnly)
      contentAttrs["aria-readonly"] = "true";
    attrsFromFacet(this, contentAttributes, contentAttrs);
    let changed = this.observer.ignore(() => {
      let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
      let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
      return changedContent || changedEditor;
    });
    this.editorAttrs = editorAttrs;
    this.contentAttrs = contentAttrs;
    return changed;
  }
  showAnnouncements(trs) {
    let first = true;
    for (let tr2 of trs)
      for (let effect4 of tr2.effects)
        if (effect4.is(_EditorView.announce)) {
          if (first)
            this.announceDOM.textContent = "";
          first = false;
          let div = this.announceDOM.appendChild(document.createElement("div"));
          div.textContent = effect4.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(styleModule);
    let nonce = this.state.facet(_EditorView.cspNonce);
    StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? { nonce } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    if (this.updateState == 0 && this.measureScheduled > -1)
      this.measure(false);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(request) {
    if (this.measureScheduled < 0)
      this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
    if (request) {
      if (this.measureRequests.indexOf(request) > -1)
        return;
      if (request.key != null)
        for (let i2 = 0; i2 < this.measureRequests.length; i2++) {
          if (this.measureRequests[i2].key === request.key) {
            this.measureRequests[i2] = request;
            return;
          }
        }
      this.measureRequests.push(request);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(plugin2) {
    let known = this.pluginMap.get(plugin2);
    if (known === void 0 || known && known.spec != plugin2)
      this.pluginMap.set(plugin2, known = this.plugins.find((p) => p.spec == plugin2) || null);
    return known && known.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(height) {
    this.readMeasured();
    return this.viewState.elementAtHeight(height);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(height) {
    this.readMeasured();
    return this.viewState.lineBlockAtHeight(height);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(pos) {
    return this.viewState.lineBlockAt(pos);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(start2, forward, by) {
    return skipAtoms(this, start2, moveByChar(this, start2, forward, by));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(start2, forward) {
    return skipAtoms(this, start2, moveByChar(this, start2, forward, (initial) => byGroup(this, start2.head, initial)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(line2, end2) {
    let order2 = this.bidiSpans(line2), dir = this.textDirectionAt(line2.from);
    let span = order2[end2 ? order2.length - 1 : 0];
    return EditorSelection.cursor(span.side(end2, dir) + line2.from, span.forward(!end2, dir) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(start2, forward, includeWrap = true) {
    return moveToLineBoundary(this, start2, forward, includeWrap);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(start2, forward, distance) {
    return skipAtoms(this, start2, moveVertically(this, start2, forward, distance));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(pos) {
    return this.docView.domAtPos(pos);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(node3, offset3 = 0) {
    return this.docView.posFromDOM(node3, offset3);
  }
  posAtCoords(coords, precise = true) {
    this.readMeasured();
    return posAtCoords(this, coords, precise);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(pos, side = 1) {
    this.readMeasured();
    let rect = this.docView.coordsAt(pos, side);
    if (!rect || rect.left == rect.right)
      return rect;
    let line2 = this.state.doc.lineAt(pos), order2 = this.bidiSpans(line2);
    let span = order2[BidiSpan.find(order2, pos - line2.from, -1, side)];
    return flattenRect(rect, span.dir == Direction.LTR == side > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(pos) {
    this.readMeasured();
    return this.docView.coordsForChar(pos);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(pos) {
    let perLine = this.state.facet(perLineTextDirection);
    if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
      return this.textDirection;
    this.readMeasured();
    return this.docView.textDirectionAt(pos);
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(line2) {
    if (line2.length > MaxBidiLine)
      return trivialOrder(line2.length);
    let dir = this.textDirectionAt(line2.from), isolates;
    for (let entry of this.bidiCache) {
      if (entry.from == line2.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line2))))
        return entry.order;
    }
    if (!isolates)
      isolates = getIsolatedRanges(this, line2);
    let order2 = computeOrder(line2.text, dir, isolates);
    this.bidiCache.push(new CachedOrder(line2.from, line2.to, dir, isolates, true, order2));
    return order2;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var _a2;
    return (this.dom.ownerDocument.hasFocus() || browser2.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      focusPreventScroll(this.contentDOM);
      this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(root) {
    if (this._root != root) {
      this._root = root;
      this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
      this.mountStyles();
    }
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let plugin2 of this.plugins)
      plugin2.destroy(this);
    this.plugins = [];
    this.inputState.destroy();
    this.docView.destroy();
    this.dom.remove();
    this.observer.destroy();
    if (this.measureScheduled > -1)
      this.win.cancelAnimationFrame(this.measureScheduled);
    this.destroyed = true;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(pos, options2 = {}) {
    return scrollIntoView2.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options2.y, options2.x, options2.yMargin, options2.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop, scrollLeft } = this.scrollDOM;
    let ref = this.viewState.scrollAnchorAt(scrollTop);
    return scrollIntoView2.of(new ScrollTarget(EditorSelection.cursor(ref.from), "start", "start", ref.top - scrollTop, scrollLeft, true));
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(handlers2) {
    return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(observers2) {
    return ViewPlugin.define(() => ({}), { eventObservers: observers2 });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be
  addedneed to be explicitly differentiated by adding an `&` to
  the selector for that elementfor example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(spec, options2) {
    let prefix3 = StyleModule.newName();
    let result = [theme.of(prefix3), styleModule.of(buildTheme(`.${prefix3}`, spec))];
    if (options2 && options2.dark)
      result.push(darkTheme.of(true));
    return result;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(spec) {
    return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(dom) {
    var _a2;
    let content2 = dom.querySelector(".cm-content");
    let cView = content2 && ContentView.get(content2) || ContentView.get(dom);
    return ((_a2 = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a2 === void 0 ? void 0 : _a2.view) || null;
  }
};
EditorView.styleModule = styleModule;
EditorView.inputHandler = inputHandler;
EditorView.focusChangeEffect = focusChangeEffect;
EditorView.perLineTextDirection = perLineTextDirection;
EditorView.exceptionSink = exceptionSink;
EditorView.updateListener = updateListener;
EditorView.editable = editable;
EditorView.mouseSelectionStyle = mouseSelectionStyle;
EditorView.dragMovesSelection = dragMovesSelection$1;
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
EditorView.decorations = decorations;
EditorView.outerDecorations = outerDecorations;
EditorView.atomicRanges = atomicRanges;
EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
EditorView.scrollMargins = scrollMargins;
EditorView.darkTheme = darkTheme;
EditorView.cspNonce = Facet.define({ combine: (values) => values.length ? values[0] : "" });
EditorView.contentAttributes = contentAttributes;
EditorView.editorAttributes = editorAttributes;
EditorView.lineWrapping = EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
EditorView.announce = StateEffect.define();
var MaxBidiLine = 4096;
var BadMeasure = {};
var CachedOrder = class _CachedOrder {
  constructor(from2, to, dir, isolates, fresh, order2) {
    this.from = from2;
    this.to = to;
    this.dir = dir;
    this.isolates = isolates;
    this.fresh = fresh;
    this.order = order2;
  }
  static update(cache, changes) {
    if (changes.empty && !cache.some((c2) => c2.fresh))
      return cache;
    let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
    for (let i2 = Math.max(0, cache.length - 10); i2 < cache.length; i2++) {
      let entry = cache[i2];
      if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
        result.push(new _CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
    }
    return result;
  }
};
function attrsFromFacet(view, facet, base2) {
  for (let sources = view.state.facet(facet), i2 = sources.length - 1; i2 >= 0; i2--) {
    let source = sources[i2], value = typeof source == "function" ? source(view) : source;
    if (value)
      combineAttrs(value, base2);
  }
  return base2;
}
var currentPlatform = browser2.mac ? "mac" : browser2.windows ? "win" : browser2.linux ? "linux" : "key";
function normalizeKeyName(name2, platform2) {
  const parts = name2.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift4, meta2;
  for (let i2 = 0; i2 < parts.length - 1; ++i2) {
    const mod = parts[i2];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta2 = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift4 = true;
    else if (/^mod$/i.test(mod)) {
      if (platform2 == "mac")
        meta2 = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta2)
    result = "Meta-" + result;
  if (shift4)
    result = "Shift-" + result;
  return result;
}
function modifiers(name2, event, shift4) {
  if (event.altKey)
    name2 = "Alt-" + name2;
  if (event.ctrlKey)
    name2 = "Ctrl-" + name2;
  if (event.metaKey)
    name2 = "Meta-" + name2;
  if (shift4 !== false && event.shiftKey)
    name2 = "Shift-" + name2;
  return name2;
}
var handleKeyEvents = Prec.default(EditorView.domEventHandlers({
  keydown(event, view) {
    return runHandlers(getKeymap(view.state), event, view, "editor");
  }
}));
var keymap = Facet.define({ enables: handleKeyEvents });
var Keymaps = /* @__PURE__ */ new WeakMap();
function getKeymap(state) {
  let bindings = state.facet(keymap);
  let map = Keymaps.get(bindings);
  if (!map)
    Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a3, b2) => a3.concat(b2), [])));
  return map;
}
function runScopeHandlers(view, event, scope) {
  return runHandlers(getKeymap(view.state), event, view, scope);
}
var storedPrefix = null;
var PrefixTimeout = 4e3;
function buildKeymap(bindings, platform2 = currentPlatform) {
  let bound = /* @__PURE__ */ Object.create(null);
  let isPrefix = /* @__PURE__ */ Object.create(null);
  let checkPrefix = (name2, is) => {
    let current = isPrefix[name2];
    if (current == null)
      isPrefix[name2] = is;
    else if (current != is)
      throw new Error("Key binding " + name2 + " is used both as a regular binding and as a multi-stroke prefix");
  };
  let add3 = (scope, key, command2, preventDefault, stopPropagation) => {
    var _a2, _b;
    let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
    let parts = key.split(/ (?!$)/).map((k2) => normalizeKeyName(k2, platform2));
    for (let i2 = 1; i2 < parts.length; i2++) {
      let prefix3 = parts.slice(0, i2).join(" ");
      checkPrefix(prefix3, true);
      if (!scopeObj[prefix3])
        scopeObj[prefix3] = {
          preventDefault: true,
          stopPropagation: false,
          run: [(view) => {
            let ourObj = storedPrefix = { view, prefix: prefix3, scope };
            setTimeout(() => {
              if (storedPrefix == ourObj)
                storedPrefix = null;
            }, PrefixTimeout);
            return true;
          }]
        };
    }
    let full = parts.join(" ");
    checkPrefix(full, false);
    let binding = scopeObj[full] || (scopeObj[full] = {
      preventDefault: false,
      stopPropagation: false,
      run: ((_b = (_a2 = scopeObj._any) === null || _a2 === void 0 ? void 0 : _a2.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
    });
    if (command2)
      binding.run.push(command2);
    if (preventDefault)
      binding.preventDefault = true;
    if (stopPropagation)
      binding.stopPropagation = true;
  };
  for (let b2 of bindings) {
    let scopes = b2.scope ? b2.scope.split(" ") : ["editor"];
    if (b2.any)
      for (let scope of scopes) {
        let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
        if (!scopeObj._any)
          scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] };
        for (let key in scopeObj)
          scopeObj[key].run.push(b2.any);
      }
    let name2 = b2[platform2] || b2.key;
    if (!name2)
      continue;
    for (let scope of scopes) {
      add3(scope, name2, b2.run, b2.preventDefault, b2.stopPropagation);
      if (b2.shift)
        add3(scope, "Shift-" + name2, b2.shift, b2.preventDefault, b2.stopPropagation);
    }
  }
  return bound;
}
function runHandlers(map, event, view, scope) {
  let name2 = keyName(event);
  let charCode = codePointAt(name2, 0), isChar = codePointSize(charCode) == name2.length && name2 != " ";
  let prefix3 = "", handled = false, prevented = false, stopPropagation = false;
  if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
    prefix3 = storedPrefix.prefix + " ";
    if (modifierCodes.indexOf(event.keyCode) < 0) {
      prevented = true;
      storedPrefix = null;
    }
  }
  let ran = /* @__PURE__ */ new Set();
  let runFor = (binding) => {
    if (binding) {
      for (let cmd2 of binding.run)
        if (!ran.has(cmd2)) {
          ran.add(cmd2);
          if (cmd2(view, event)) {
            if (binding.stopPropagation)
              stopPropagation = true;
            return true;
          }
        }
      if (binding.preventDefault) {
        if (binding.stopPropagation)
          stopPropagation = true;
        prevented = true;
      }
    }
    return false;
  };
  let scopeObj = map[scope], baseName, shiftName;
  if (scopeObj) {
    if (runFor(scopeObj[prefix3 + modifiers(name2, event, !isChar)])) {
      handled = true;
    } else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
    !(browser2.windows && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name2) {
      if (runFor(scopeObj[prefix3 + modifiers(baseName, event, true)])) {
        handled = true;
      } else if (event.shiftKey && (shiftName = shift3[event.keyCode]) != name2 && shiftName != baseName && runFor(scopeObj[prefix3 + modifiers(shiftName, event, false)])) {
        handled = true;
      }
    } else if (isChar && event.shiftKey && runFor(scopeObj[prefix3 + modifiers(name2, event, true)])) {
      handled = true;
    }
    if (!handled && runFor(scopeObj._any))
      handled = true;
  }
  if (prevented)
    handled = true;
  if (handled && stopPropagation)
    event.stopPropagation();
  return handled;
}
var RectangleMarker = class _RectangleMarker {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(className, left2, top3, width, height) {
    this.className = className;
    this.left = left2;
    this.top = top3;
    this.width = width;
    this.height = height;
  }
  draw() {
    let elt = document.createElement("div");
    elt.className = this.className;
    this.adjust(elt);
    return elt;
  }
  update(elt, prev2) {
    if (prev2.className != this.className)
      return false;
    this.adjust(elt);
    return true;
  }
  adjust(elt) {
    elt.style.left = this.left + "px";
    elt.style.top = this.top + "px";
    if (this.width != null)
      elt.style.width = this.width + "px";
    elt.style.height = this.height + "px";
  }
  eq(p) {
    return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(view, className, range) {
    if (range.empty) {
      let pos = view.coordsAtPos(range.head, range.assoc || 1);
      if (!pos)
        return [];
      let base2 = getBase(view);
      return [new _RectangleMarker(className, pos.left - base2.left, pos.top - base2.top, null, pos.bottom - pos.top)];
    } else {
      return rectanglesForRange(view, className, range);
    }
  }
};
function getBase(view) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let left2 = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;
  return { left: left2 - view.scrollDOM.scrollLeft * view.scaleX, top: rect.top - view.scrollDOM.scrollTop * view.scaleY };
}
function wrappedLine(view, pos, inside2) {
  let range = EditorSelection.cursor(pos);
  return {
    from: Math.max(inside2.from, view.moveToLineBoundary(range, false, true).from),
    to: Math.min(inside2.to, view.moveToLineBoundary(range, true, true).from),
    type: BlockType.Text
  };
}
function rectanglesForRange(view, className, range) {
  if (range.to <= view.viewport.from || range.from >= view.viewport.to)
    return [];
  let from2 = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);
  let ltr = view.textDirection == Direction.LTR;
  let content2 = view.contentDOM, contentRect = content2.getBoundingClientRect(), base2 = getBase(view);
  let lineElt = content2.querySelector(".cm-line"), lineStyle = lineElt && window.getComputedStyle(lineElt);
  let leftSide = contentRect.left + (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);
  let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);
  let startBlock = blockAt(view, from2), endBlock = blockAt(view, to);
  let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
  let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
  if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks))
    visualStart = wrappedLine(view, from2, visualStart);
  if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks))
    visualEnd = wrappedLine(view, to, visualEnd);
  if (visualStart && visualEnd && visualStart.from == visualEnd.from) {
    return pieces(drawForLine(range.from, range.to, visualStart));
  } else {
    let top3 = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
    let bottom2 = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
    let between = [];
    if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) || startBlock.widgetLineBreaks > 1 && top3.bottom + view.defaultLineHeight / 2 < bottom2.top)
      between.push(piece(leftSide, top3.bottom, rightSide, bottom2.top));
    else if (top3.bottom < bottom2.top && view.elementAtHeight((top3.bottom + bottom2.top) / 2).type == BlockType.Text)
      top3.bottom = bottom2.top = (top3.bottom + bottom2.top) / 2;
    return pieces(top3).concat(between).concat(pieces(bottom2));
  }
  function piece(left2, top3, right2, bottom2) {
    return new RectangleMarker(
      className,
      left2 - base2.left,
      top3 - base2.top - 0.01,
      right2 - left2,
      bottom2 - top3 + 0.01
      /* C.Epsilon */
    );
  }
  function pieces({ top: top3, bottom: bottom2, horizontal }) {
    let pieces2 = [];
    for (let i2 = 0; i2 < horizontal.length; i2 += 2)
      pieces2.push(piece(horizontal[i2], top3, horizontal[i2 + 1], bottom2));
    return pieces2;
  }
  function drawForLine(from3, to2, line2) {
    let top3 = 1e9, bottom2 = -1e9, horizontal = [];
    function addSpan(from4, fromOpen, to3, toOpen, dir) {
      let fromCoords = view.coordsAtPos(from4, from4 == line2.to ? -2 : 2);
      let toCoords = view.coordsAtPos(to3, to3 == line2.from ? 2 : -2);
      if (!fromCoords || !toCoords)
        return;
      top3 = Math.min(fromCoords.top, toCoords.top, top3);
      bottom2 = Math.max(fromCoords.bottom, toCoords.bottom, bottom2);
      if (dir == Direction.LTR)
        horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
      else
        horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
    }
    let start2 = from3 !== null && from3 !== void 0 ? from3 : line2.from, end2 = to2 !== null && to2 !== void 0 ? to2 : line2.to;
    for (let r2 of view.visibleRanges)
      if (r2.to > start2 && r2.from < end2) {
        for (let pos = Math.max(r2.from, start2), endPos = Math.min(r2.to, end2); ; ) {
          let docLine = view.state.doc.lineAt(pos);
          for (let span of view.bidiSpans(docLine)) {
            let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
            if (spanFrom >= endPos)
              break;
            if (spanTo > pos)
              addSpan(Math.max(spanFrom, pos), from3 == null && spanFrom <= start2, Math.min(spanTo, endPos), to2 == null && spanTo >= end2, span.dir);
          }
          pos = docLine.to + 1;
          if (pos >= endPos)
            break;
        }
      }
    if (horizontal.length == 0)
      addSpan(start2, from3 == null, end2, to2 == null, view.textDirection);
    return { top: top3, bottom: bottom2, horizontal };
  }
  function drawForWidget(block, top3) {
    let y3 = contentRect.top + (top3 ? block.top : block.bottom);
    return { top: y3, bottom: y3, horizontal: [] };
  }
}
function sameMarker(a3, b2) {
  return a3.constructor == b2.constructor && a3.eq(b2);
}
var LayerView = class {
  constructor(view, layer2) {
    this.view = view;
    this.layer = layer2;
    this.drawn = [];
    this.scaleX = 1;
    this.scaleY = 1;
    this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) };
    this.dom = view.scrollDOM.appendChild(document.createElement("div"));
    this.dom.classList.add("cm-layer");
    if (layer2.above)
      this.dom.classList.add("cm-layer-above");
    if (layer2.class)
      this.dom.classList.add(layer2.class);
    this.scale();
    this.dom.setAttribute("aria-hidden", "true");
    this.setOrder(view.state);
    view.requestMeasure(this.measureReq);
    if (layer2.mount)
      layer2.mount(this.dom, view);
  }
  update(update) {
    if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))
      this.setOrder(update.state);
    if (this.layer.update(update, this.dom) || update.geometryChanged) {
      this.scale();
      update.view.requestMeasure(this.measureReq);
    }
  }
  setOrder(state) {
    let pos = 0, order2 = state.facet(layerOrder);
    while (pos < order2.length && order2[pos] != this.layer)
      pos++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX, scaleY } = this.view;
    if (scaleX != this.scaleX || scaleY != this.scaleY) {
      this.scaleX = scaleX;
      this.scaleY = scaleY;
      this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;
    }
  }
  draw(markers) {
    if (markers.length != this.drawn.length || markers.some((p, i2) => !sameMarker(p, this.drawn[i2]))) {
      let old = this.dom.firstChild, oldI = 0;
      for (let marker of markers) {
        if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {
          old = old.nextSibling;
          oldI++;
        } else {
          this.dom.insertBefore(marker.draw(), old);
        }
      }
      while (old) {
        let next2 = old.nextSibling;
        old.remove();
        old = next2;
      }
      this.drawn = markers;
    }
  }
  destroy() {
    if (this.layer.destroy)
      this.layer.destroy(this.dom, this.view);
    this.dom.remove();
  }
};
var layerOrder = Facet.define();
function layer(config2) {
  return [
    ViewPlugin.define((v) => new LayerView(v, config2)),
    layerOrder.of(config2)
  ];
}
var CanHidePrimary = !browser2.ios;
var selectionConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      cursorBlinkRate: 1200,
      drawRangeCursor: true
    }, {
      cursorBlinkRate: (a3, b2) => Math.min(a3, b2),
      drawRangeCursor: (a3, b2) => a3 || b2
    });
  }
});
function drawSelection(config2 = {}) {
  return [
    selectionConfig.of(config2),
    cursorLayer,
    selectionLayer,
    hideNativeSelection,
    nativeSelectionHidden.of(true)
  ];
}
function configChanged(update) {
  return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
}
var cursorLayer = layer({
  above: true,
  markers(view) {
    let { state } = view, conf = state.facet(selectionConfig);
    let cursors = [];
    for (let r2 of state.selection.ranges) {
      let prim = r2 == state.selection.main;
      if (r2.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
        let className = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
        let cursor2 = r2.empty ? r2 : EditorSelection.cursor(r2.head, r2.head > r2.anchor ? -1 : 1);
        for (let piece of RectangleMarker.forRange(view, className, cursor2))
          cursors.push(piece);
      }
    }
    return cursors;
  },
  update(update, dom) {
    if (update.transactions.some((tr2) => tr2.selection))
      dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
    let confChange = configChanged(update);
    if (confChange)
      setBlinkRate(update.state, dom);
    return update.docChanged || update.selectionSet || confChange;
  },
  mount(dom, view) {
    setBlinkRate(view.state, dom);
  },
  class: "cm-cursorLayer"
});
function setBlinkRate(state, dom) {
  dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + "ms";
}
var selectionLayer = layer({
  above: false,
  markers(view) {
    return view.state.selection.ranges.map((r2) => r2.empty ? [] : RectangleMarker.forRange(view, "cm-selectionBackground", r2)).reduce((a3, b2) => a3.concat(b2));
  },
  update(update, dom) {
    return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);
  },
  class: "cm-selectionLayer"
});
var themeSpec = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
if (CanHidePrimary) {
  themeSpec[".cm-line"].caretColor = "transparent !important";
  themeSpec[".cm-content"] = { caretColor: "transparent !important" };
}
var hideNativeSelection = Prec.highest(EditorView.theme(themeSpec));
var setDropCursorPos = StateEffect.define({
  map(pos, mapping) {
    return pos == null ? null : mapping.mapPos(pos);
  }
});
var dropCursorPos = StateField.define({
  create() {
    return null;
  },
  update(pos, tr2) {
    if (pos != null)
      pos = tr2.changes.mapPos(pos);
    return tr2.effects.reduce((pos2, e4) => e4.is(setDropCursorPos) ? e4.value : pos2, pos);
  }
});
var drawDropCursor = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.cursor = null;
    this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(update) {
    var _a2;
    let cursorPos = update.state.field(dropCursorPos);
    if (cursorPos == null) {
      if (this.cursor != null) {
        (_a2 = this.cursor) === null || _a2 === void 0 ? void 0 : _a2.remove();
        this.cursor = null;
      }
    } else {
      if (!this.cursor) {
        this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
        this.cursor.className = "cm-dropCursor";
      }
      if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)
        this.view.requestMeasure(this.measureReq);
    }
  }
  readPos() {
    let { view } = this;
    let pos = view.state.field(dropCursorPos);
    let rect = pos != null && view.coordsAtPos(pos);
    if (!rect)
      return null;
    let outer = view.scrollDOM.getBoundingClientRect();
    return {
      left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,
      top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,
      height: rect.bottom - rect.top
    };
  }
  drawCursor(pos) {
    if (this.cursor) {
      let { scaleX, scaleY } = this.view;
      if (pos) {
        this.cursor.style.left = pos.left / scaleX + "px";
        this.cursor.style.top = pos.top / scaleY + "px";
        this.cursor.style.height = pos.height / scaleY + "px";
      } else {
        this.cursor.style.left = "-100000px";
      }
    }
  }
  destroy() {
    if (this.cursor)
      this.cursor.remove();
  }
  setDropPos(pos) {
    if (this.view.state.field(dropCursorPos) != pos)
      this.view.dispatch({ effects: setDropCursorPos.of(pos) });
  }
}, {
  eventObservers: {
    dragover(event) {
      this.setDropPos(this.view.posAtCoords({ x: event.clientX, y: event.clientY }));
    },
    dragleave(event) {
      if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))
        this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function iterMatches(doc2, re, from2, to, f) {
  re.lastIndex = 0;
  for (let cursor2 = doc2.iterRange(from2, to), pos = from2, m3; !cursor2.next().done; pos += cursor2.value.length) {
    if (!cursor2.lineBreak)
      while (m3 = re.exec(cursor2.value))
        f(pos + m3.index, m3);
  }
}
function matchRanges(view, maxLength) {
  let visible = view.visibleRanges;
  if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to)
    return visible;
  let result = [];
  for (let { from: from2, to } of visible) {
    from2 = Math.max(view.state.doc.lineAt(from2).from, from2 - maxLength);
    to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
    if (result.length && result[result.length - 1].to >= from2)
      result[result.length - 1].to = to;
    else
      result.push({ from: from2, to });
  }
  return result;
}
var MatchDecorator = class {
  /**
  Create a decorator.
  */
  constructor(config2) {
    const { regexp, decoration, decorate, boundary, maxLength = 1e3 } = config2;
    if (!regexp.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    this.regexp = regexp;
    if (decorate) {
      this.addMatch = (match3, view, from2, add3) => decorate(add3, from2, from2 + match3[0].length, match3, view);
    } else if (typeof decoration == "function") {
      this.addMatch = (match3, view, from2, add3) => {
        let deco = decoration(match3, view, from2);
        if (deco)
          add3(from2, from2 + match3[0].length, deco);
      };
    } else if (decoration) {
      this.addMatch = (match3, _view, from2, add3) => add3(from2, from2 + match3[0].length, decoration);
    } else {
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    }
    this.boundary = boundary;
    this.maxLength = maxLength;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(view) {
    let build = new RangeSetBuilder(), add3 = build.add.bind(build);
    for (let { from: from2, to } of matchRanges(view, this.maxLength))
      iterMatches(view.state.doc, this.regexp, from2, to, (from3, m3) => this.addMatch(m3, view, from3, add3));
    return build.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(update, deco) {
    let changeFrom = 1e9, changeTo = -1;
    if (update.docChanged)
      update.changes.iterChanges((_f, _t2, from2, to) => {
        if (to > update.view.viewport.from && from2 < update.view.viewport.to) {
          changeFrom = Math.min(from2, changeFrom);
          changeTo = Math.max(to, changeTo);
        }
      });
    if (update.viewportChanged || changeTo - changeFrom > 1e3)
      return this.createDeco(update.view);
    if (changeTo > -1)
      return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
    return deco;
  }
  updateRange(view, deco, updateFrom, updateTo) {
    for (let r2 of view.visibleRanges) {
      let from2 = Math.max(r2.from, updateFrom), to = Math.min(r2.to, updateTo);
      if (to > from2) {
        let fromLine = view.state.doc.lineAt(from2), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
        let start2 = Math.max(r2.from, fromLine.from), end2 = Math.min(r2.to, toLine.to);
        if (this.boundary) {
          for (; from2 > fromLine.from; from2--)
            if (this.boundary.test(fromLine.text[from2 - 1 - fromLine.from])) {
              start2 = from2;
              break;
            }
          for (; to < toLine.to; to++)
            if (this.boundary.test(toLine.text[to - toLine.from])) {
              end2 = to;
              break;
            }
        }
        let ranges = [], m3;
        let add3 = (from3, to2, deco2) => ranges.push(deco2.range(from3, to2));
        if (fromLine == toLine) {
          this.regexp.lastIndex = start2 - fromLine.from;
          while ((m3 = this.regexp.exec(fromLine.text)) && m3.index < end2 - fromLine.from)
            this.addMatch(m3, view, m3.index + fromLine.from, add3);
        } else {
          iterMatches(view.state.doc, this.regexp, start2, end2, (from3, m4) => this.addMatch(m4, view, from3, add3));
        }
        deco = deco.update({ filterFrom: start2, filterTo: end2, filter: (from3, to2) => from3 < start2 || to2 > end2, add: ranges });
      }
    }
    return deco;
  }
};
var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
var Specials = new RegExp("[\0-\b\n--\u2028\u2029\uFEFF-]", UnicodeRegexpSupport);
var _supportsTabSize = null;
function supportsTabSize() {
  var _a2;
  if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
    let styles2 = document.body.style;
    _supportsTabSize = ((_a2 = styles2.tabSize) !== null && _a2 !== void 0 ? _a2 : styles2.MozTabSize) != null;
  }
  return _supportsTabSize || false;
}
var specialCharConfig = Facet.define({
  combine(configs) {
    let config2 = combineConfig(configs, {
      render: null,
      specialChars: Specials,
      addSpecialChars: null
    });
    if (config2.replaceTabs = !supportsTabSize())
      config2.specialChars = new RegExp("	|" + config2.specialChars.source, UnicodeRegexpSupport);
    if (config2.addSpecialChars)
      config2.specialChars = new RegExp(config2.specialChars.source + "|" + config2.addSpecialChars.source, UnicodeRegexpSupport);
    return config2;
  }
});
var plugin = ViewPlugin.fromClass(class {
  constructor() {
    this.height = 1e3;
    this.attrs = { style: "padding-bottom: 1000px" };
  }
  update(update) {
    let { view } = update;
    let height = view.viewState.editorHeight * view.scaleY - view.defaultLineHeight - view.documentPadding.top - 0.5;
    if (height >= 0 && height != this.height) {
      this.height = height;
      this.attrs = { style: `padding-bottom: ${height}px` };
    }
  }
});
var lineDeco = Decoration.line({ class: "cm-activeLine" });
var activeLineHighlighter = ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update) {
    if (update.docChanged || update.selectionSet)
      this.decorations = this.getDeco(update.view);
  }
  getDeco(view) {
    let lastLineStart = -1, deco = [];
    for (let r2 of view.state.selection.ranges) {
      let line2 = view.lineBlockAt(r2.head);
      if (line2.from > lastLineStart) {
        deco.push(lineDeco.range(line2.from));
        lastLineStart = line2.from;
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: (v) => v.decorations
});
var Placeholder3 = class extends WidgetType {
  constructor(content2) {
    super();
    this.content = content2;
  }
  toDOM() {
    let wrap = document.createElement("span");
    wrap.className = "cm-placeholder";
    wrap.style.pointerEvents = "none";
    wrap.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : this.content);
    if (typeof this.content == "string")
      wrap.setAttribute("aria-label", "placeholder " + this.content);
    else
      wrap.setAttribute("aria-hidden", "true");
    return wrap;
  }
  coordsAt(dom) {
    let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];
    if (!rects.length)
      return null;
    let style = window.getComputedStyle(dom.parentNode);
    let rect = flattenRect(rects[0], style.direction != "rtl");
    let lineHeight = parseInt(style.lineHeight);
    if (rect.bottom - rect.top > lineHeight * 1.5)
      return { left: rect.left, right: rect.right, top: rect.top, bottom: rect.top + lineHeight };
    return rect;
  }
  ignoreEvent() {
    return false;
  }
};
function placeholder(content2) {
  return ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.placeholder = content2 ? Decoration.set([Decoration.widget({ widget: new Placeholder3(content2), side: 1 }).range(0)]) : Decoration.none;
    }
    get decorations() {
      return this.view.state.doc.length ? Decoration.none : this.placeholder;
    }
  }, { decorations: (v) => v.decorations });
}
var MaxOff = 2e3;
function rectangleFor(state, a3, b2) {
  let startLine = Math.min(a3.line, b2.line), endLine = Math.max(a3.line, b2.line);
  let ranges = [];
  if (a3.off > MaxOff || b2.off > MaxOff || a3.col < 0 || b2.col < 0) {
    let startOff = Math.min(a3.off, b2.off), endOff = Math.max(a3.off, b2.off);
    for (let i2 = startLine; i2 <= endLine; i2++) {
      let line2 = state.doc.line(i2);
      if (line2.length <= endOff)
        ranges.push(EditorSelection.range(line2.from + startOff, line2.to + endOff));
    }
  } else {
    let startCol = Math.min(a3.col, b2.col), endCol = Math.max(a3.col, b2.col);
    for (let i2 = startLine; i2 <= endLine; i2++) {
      let line2 = state.doc.line(i2);
      let start2 = findColumn(line2.text, startCol, state.tabSize, true);
      if (start2 < 0) {
        ranges.push(EditorSelection.cursor(line2.to));
      } else {
        let end2 = findColumn(line2.text, endCol, state.tabSize);
        ranges.push(EditorSelection.range(line2.from + start2, line2.from + end2));
      }
    }
  }
  return ranges;
}
function absoluteColumn(view, x2) {
  let ref = view.coordsAtPos(view.viewport.from);
  return ref ? Math.round(Math.abs((ref.left - x2) / view.defaultCharacterWidth)) : -1;
}
function getPos(view, event) {
  let offset3 = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  let line2 = view.state.doc.lineAt(offset3), off2 = offset3 - line2.from;
  let col = off2 > MaxOff ? -1 : off2 == line2.length ? absoluteColumn(view, event.clientX) : countColumn(line2.text, view.state.tabSize, offset3 - line2.from);
  return { line: line2.number, col, off: off2 };
}
function rectangleSelectionStyle(view, event) {
  let start2 = getPos(view, event), startSel = view.state.selection;
  if (!start2)
    return null;
  return {
    update(update) {
      if (update.docChanged) {
        let newStart = update.changes.mapPos(update.startState.doc.line(start2.line).from);
        let newLine = update.state.doc.lineAt(newStart);
        start2 = { line: newLine.number, col: start2.col, off: Math.min(start2.off, newLine.length) };
        startSel = startSel.map(update.changes);
      }
    },
    get(event2, _extend, multiple) {
      let cur2 = getPos(view, event2);
      if (!cur2)
        return startSel;
      let ranges = rectangleFor(view.state, start2, cur2);
      if (!ranges.length)
        return startSel;
      if (multiple)
        return EditorSelection.create(ranges.concat(startSel.ranges));
      else
        return EditorSelection.create(ranges);
    }
  };
}
function rectangularSelection(options2) {
  let filter = (options2 === null || options2 === void 0 ? void 0 : options2.eventFilter) || ((e4) => e4.altKey && e4.button == 0);
  return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
}
var keys = {
  Alt: [18, (e4) => !!e4.altKey],
  Control: [17, (e4) => !!e4.ctrlKey],
  Shift: [16, (e4) => !!e4.shiftKey],
  Meta: [91, (e4) => !!e4.metaKey]
};
var showCrosshair = { style: "cursor: crosshair" };
function crosshairCursor(options2 = {}) {
  let [code, getter] = keys[options2.key || "Alt"];
  let plugin2 = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.isDown = false;
    }
    set(isDown) {
      if (this.isDown != isDown) {
        this.isDown = isDown;
        this.view.update([]);
      }
    }
  }, {
    eventObservers: {
      keydown(e4) {
        this.set(e4.keyCode == code || getter(e4));
      },
      keyup(e4) {
        if (e4.keyCode == code || !getter(e4))
          this.set(false);
      },
      mousemove(e4) {
        this.set(getter(e4));
      }
    }
  });
  return [
    plugin2,
    EditorView.contentAttributes.of((view) => {
      var _a2;
      return ((_a2 = view.plugin(plugin2)) === null || _a2 === void 0 ? void 0 : _a2.isDown) ? showCrosshair : null;
    })
  ];
}
var Outside = "-10000px";
var TooltipViewManager = class {
  constructor(view, facet, createTooltipView) {
    this.facet = facet;
    this.createTooltipView = createTooltipView;
    this.input = view.state.facet(facet);
    this.tooltips = this.input.filter((t4) => t4);
    this.tooltipViews = this.tooltips.map(createTooltipView);
  }
  update(update, above) {
    var _a2;
    let input = update.state.facet(this.facet);
    let tooltips2 = input.filter((x2) => x2);
    if (input === this.input) {
      for (let t4 of this.tooltipViews)
        if (t4.update)
          t4.update(update);
      return false;
    }
    let tooltipViews = [], newAbove = above ? [] : null;
    for (let i2 = 0; i2 < tooltips2.length; i2++) {
      let tip = tooltips2[i2], known = -1;
      if (!tip)
        continue;
      for (let i3 = 0; i3 < this.tooltips.length; i3++) {
        let other = this.tooltips[i3];
        if (other && other.create == tip.create)
          known = i3;
      }
      if (known < 0) {
        tooltipViews[i2] = this.createTooltipView(tip);
        if (newAbove)
          newAbove[i2] = !!tip.above;
      } else {
        let tooltipView = tooltipViews[i2] = this.tooltipViews[known];
        if (newAbove)
          newAbove[i2] = above[known];
        if (tooltipView.update)
          tooltipView.update(update);
      }
    }
    for (let t4 of this.tooltipViews)
      if (tooltipViews.indexOf(t4) < 0) {
        t4.dom.remove();
        (_a2 = t4.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t4);
      }
    if (above) {
      newAbove.forEach((val, i2) => above[i2] = val);
      above.length = newAbove.length;
    }
    this.input = input;
    this.tooltips = tooltips2;
    this.tooltipViews = tooltipViews;
    return true;
  }
};
function tooltips(config2 = {}) {
  return tooltipConfig.of(config2);
}
function windowSpace(view) {
  let { win } = view;
  return { top: 0, left: 0, bottom: win.innerHeight, right: win.innerWidth };
}
var tooltipConfig = Facet.define({
  combine: (values) => {
    var _a2, _b, _c;
    return {
      position: browser2.ios ? "absolute" : ((_a2 = values.find((conf) => conf.position)) === null || _a2 === void 0 ? void 0 : _a2.position) || "fixed",
      parent: ((_b = values.find((conf) => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
      tooltipSpace: ((_c = values.find((conf) => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace
    };
  }
});
var knownHeight = /* @__PURE__ */ new WeakMap();
var tooltipPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.above = [];
    this.inView = true;
    this.madeAbsolute = false;
    this.lastTransaction = 0;
    this.measureTimeout = -1;
    let config2 = view.state.facet(tooltipConfig);
    this.position = config2.position;
    this.parent = config2.parent;
    this.classes = view.themeClasses;
    this.createContainer();
    this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
    this.manager = new TooltipViewManager(view, showTooltip, (t4) => this.createTooltip(t4));
    this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries) => {
      if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
        this.measureSoon();
    }, { threshold: [1] }) : null;
    this.observeIntersection();
    view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
    this.maybeMeasure();
  }
  createContainer() {
    if (this.parent) {
      this.container = document.createElement("div");
      this.container.style.position = "relative";
      this.container.className = this.view.themeClasses;
      this.parent.appendChild(this.container);
    } else {
      this.container = this.view.dom;
    }
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let tooltip of this.manager.tooltipViews)
        this.intersectionObserver.observe(tooltip.dom);
    }
  }
  measureSoon() {
    if (this.measureTimeout < 0)
      this.measureTimeout = setTimeout(() => {
        this.measureTimeout = -1;
        this.maybeMeasure();
      }, 50);
  }
  update(update) {
    if (update.transactions.length)
      this.lastTransaction = Date.now();
    let updated = this.manager.update(update, this.above);
    if (updated)
      this.observeIntersection();
    let shouldMeasure = updated || update.geometryChanged;
    let newConfig = update.state.facet(tooltipConfig);
    if (newConfig.position != this.position && !this.madeAbsolute) {
      this.position = newConfig.position;
      for (let t4 of this.manager.tooltipViews)
        t4.dom.style.position = this.position;
      shouldMeasure = true;
    }
    if (newConfig.parent != this.parent) {
      if (this.parent)
        this.container.remove();
      this.parent = newConfig.parent;
      this.createContainer();
      for (let t4 of this.manager.tooltipViews)
        this.container.appendChild(t4.dom);
      shouldMeasure = true;
    } else if (this.parent && this.view.themeClasses != this.classes) {
      this.classes = this.container.className = this.view.themeClasses;
    }
    if (shouldMeasure)
      this.maybeMeasure();
  }
  createTooltip(tooltip) {
    let tooltipView = tooltip.create(this.view);
    tooltipView.dom.classList.add("cm-tooltip");
    if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let arrow5 = document.createElement("div");
      arrow5.className = "cm-tooltip-arrow";
      tooltipView.dom.appendChild(arrow5);
    }
    tooltipView.dom.style.position = this.position;
    tooltipView.dom.style.top = Outside;
    tooltipView.dom.style.left = "0px";
    this.container.appendChild(tooltipView.dom);
    if (tooltipView.mount)
      tooltipView.mount(this.view);
    return tooltipView;
  }
  destroy() {
    var _a2, _b;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let tooltipView of this.manager.tooltipViews) {
      tooltipView.dom.remove();
      (_a2 = tooltipView.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(tooltipView);
    }
    if (this.parent)
      this.container.remove();
    (_b = this.intersectionObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
    clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let editor = this.view.dom.getBoundingClientRect();
    let scaleX = 1, scaleY = 1, makeAbsolute = false;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom } = this.manager.tooltipViews[0];
      if (browser2.gecko) {
        makeAbsolute = dom.offsetParent != this.container.ownerDocument.body;
      } else if (dom.style.top == Outside && dom.style.left == "0px") {
        let rect = dom.getBoundingClientRect();
        makeAbsolute = Math.abs(rect.top + 1e4) > 1 || Math.abs(rect.left) > 1;
      }
    }
    if (makeAbsolute || this.position == "absolute") {
      if (this.parent) {
        let rect = this.parent.getBoundingClientRect();
        if (rect.width && rect.height) {
          scaleX = rect.width / this.parent.offsetWidth;
          scaleY = rect.height / this.parent.offsetHeight;
        }
      } else {
        ({ scaleX, scaleY } = this.view.viewState);
      }
    }
    return {
      editor,
      parent: this.parent ? this.container.getBoundingClientRect() : editor,
      pos: this.manager.tooltips.map((t4, i2) => {
        let tv = this.manager.tooltipViews[i2];
        return tv.getCoords ? tv.getCoords(t4.pos) : this.view.coordsAtPos(t4.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
      space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
      scaleX,
      scaleY,
      makeAbsolute
    };
  }
  writeMeasure(measured) {
    var _a2;
    if (measured.makeAbsolute) {
      this.madeAbsolute = true;
      this.position = "absolute";
      for (let t4 of this.manager.tooltipViews)
        t4.dom.style.position = "absolute";
    }
    let { editor, space, scaleX, scaleY } = measured;
    let others = [];
    for (let i2 = 0; i2 < this.manager.tooltips.length; i2++) {
      let tooltip = this.manager.tooltips[i2], tView = this.manager.tooltipViews[i2], { dom } = tView;
      let pos = measured.pos[i2], size3 = measured.size[i2];
      if (!pos || pos.bottom <= Math.max(editor.top, space.top) || pos.top >= Math.min(editor.bottom, space.bottom) || pos.right < Math.max(editor.left, space.left) - 0.1 || pos.left > Math.min(editor.right, space.right) + 0.1) {
        dom.style.top = Outside;
        continue;
      }
      let arrow5 = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
      let arrowHeight = arrow5 ? 7 : 0;
      let width = size3.right - size3.left, height = (_a2 = knownHeight.get(tView)) !== null && _a2 !== void 0 ? _a2 : size3.bottom - size3.top;
      let offset3 = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
      let left2 = size3.width > space.right - space.left ? ltr ? space.left : space.right - size3.width : ltr ? Math.min(pos.left - (arrow5 ? 14 : 0) + offset3.x, space.right - width) : Math.max(space.left, pos.left - width + (arrow5 ? 14 : 0) - offset3.x);
      let above = this.above[i2];
      if (!tooltip.strictSide && (above ? pos.top - (size3.bottom - size3.top) - offset3.y < space.top : pos.bottom + (size3.bottom - size3.top) + offset3.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top)
        above = this.above[i2] = !above;
      let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;
      if (spaceVert < height && tView.resize !== false) {
        if (spaceVert < this.view.defaultLineHeight) {
          dom.style.top = Outside;
          continue;
        }
        knownHeight.set(tView, height);
        dom.style.height = (height = spaceVert) / scaleY + "px";
      } else if (dom.style.height) {
        dom.style.height = "";
      }
      let top3 = above ? pos.top - height - arrowHeight - offset3.y : pos.bottom + arrowHeight + offset3.y;
      let right2 = left2 + width;
      if (tView.overlap !== true) {
        for (let r2 of others)
          if (r2.left < right2 && r2.right > left2 && r2.top < top3 + height && r2.bottom > top3)
            top3 = above ? r2.top - height - 2 - arrowHeight : r2.bottom + arrowHeight + 2;
      }
      if (this.position == "absolute") {
        dom.style.top = (top3 - measured.parent.top) / scaleY + "px";
        dom.style.left = (left2 - measured.parent.left) / scaleX + "px";
      } else {
        dom.style.top = top3 / scaleY + "px";
        dom.style.left = left2 / scaleX + "px";
      }
      if (arrow5) {
        let arrowLeft = pos.left + (ltr ? offset3.x : -offset3.x) - (left2 + 14 - 7);
        arrow5.style.left = arrowLeft / scaleX + "px";
      }
      if (tView.overlap !== true)
        others.push({ left: left2, top: top3, right: right2, bottom: top3 + height });
      dom.classList.toggle("cm-tooltip-above", above);
      dom.classList.toggle("cm-tooltip-below", !above);
      if (tView.positioned)
        tView.positioned(measured.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length) {
      if (this.view.inView)
        this.view.requestMeasure(this.measureReq);
      if (this.inView != this.view.inView) {
        this.inView = this.view.inView;
        if (!this.inView)
          for (let tv of this.manager.tooltipViews)
            tv.dom.style.top = Outside;
      }
    }
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
var baseTheme = EditorView.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: `${7}px`,
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: `${7}px solid transparent`,
      borderRight: `${7}px solid transparent`
    },
    ".cm-tooltip-above &": {
      bottom: `-${7}px`,
      "&:before": {
        borderTop: `${7}px solid #bbb`
      },
      "&:after": {
        borderTop: `${7}px solid #f5f5f5`,
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: `-${7}px`,
      "&:before": {
        borderBottom: `${7}px solid #bbb`
      },
      "&:after": {
        borderBottom: `${7}px solid #f5f5f5`,
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
});
var noOffset = { x: 0, y: 0 };
var showTooltip = Facet.define({
  enables: [tooltipPlugin, baseTheme]
});
var showHoverTooltip = Facet.define();
var HoverTooltipHost = class _HoverTooltipHost {
  // Needs to be static so that host tooltip instances always match
  static create(view) {
    return new _HoverTooltipHost(view);
  }
  constructor(view) {
    this.view = view;
    this.mounted = false;
    this.dom = document.createElement("div");
    this.dom.classList.add("cm-tooltip-hover");
    this.manager = new TooltipViewManager(view, showHoverTooltip, (t4) => this.createHostedView(t4));
  }
  createHostedView(tooltip) {
    let hostedView = tooltip.create(this.view);
    hostedView.dom.classList.add("cm-tooltip-section");
    this.dom.appendChild(hostedView.dom);
    if (this.mounted && hostedView.mount)
      hostedView.mount(this.view);
    return hostedView;
  }
  mount(view) {
    for (let hostedView of this.manager.tooltipViews) {
      if (hostedView.mount)
        hostedView.mount(view);
    }
    this.mounted = true;
  }
  positioned(space) {
    for (let hostedView of this.manager.tooltipViews) {
      if (hostedView.positioned)
        hostedView.positioned(space);
    }
  }
  update(update) {
    this.manager.update(update);
  }
  destroy() {
    var _a2;
    for (let t4 of this.manager.tooltipViews)
      (_a2 = t4.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t4);
  }
  passProp(name2) {
    let value = void 0;
    for (let view of this.manager.tooltipViews) {
      let given = view[name2];
      if (given !== void 0) {
        if (value === void 0)
          value = given;
        else if (value !== given)
          return void 0;
      }
    }
    return value;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
};
var showHoverTooltipHost = showTooltip.compute([showHoverTooltip], (state) => {
  let tooltips2 = state.facet(showHoverTooltip).filter((t4) => t4);
  if (tooltips2.length === 0)
    return null;
  return {
    pos: Math.min(...tooltips2.map((t4) => t4.pos)),
    end: Math.max(...tooltips2.map((t4) => {
      var _a2;
      return (_a2 = t4.end) !== null && _a2 !== void 0 ? _a2 : t4.pos;
    })),
    create: HoverTooltipHost.create,
    above: tooltips2[0].above,
    arrow: tooltips2.some((t4) => t4.arrow)
  };
});
var HoverPlugin = class {
  constructor(view, source, field, setHover, hoverTime) {
    this.view = view;
    this.source = source;
    this.field = field;
    this.setHover = setHover;
    this.hoverTime = hoverTime;
    this.hoverTimeout = -1;
    this.restartTimeout = -1;
    this.pending = null;
    this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };
    this.checkHover = this.checkHover.bind(this);
    view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
    view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    if (this.pending) {
      this.pending = null;
      clearTimeout(this.restartTimeout);
      this.restartTimeout = setTimeout(() => this.startHover(), 20);
    }
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    this.hoverTimeout = -1;
    if (this.active)
      return;
    let hovered = Date.now() - this.lastMove.time;
    if (hovered < this.hoverTime)
      this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
    else
      this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view, lastMove } = this;
    let desc = view.docView.nearest(lastMove.target);
    if (!desc)
      return;
    let pos, side = 1;
    if (desc instanceof WidgetView) {
      pos = desc.posAtStart;
    } else {
      pos = view.posAtCoords(lastMove);
      if (pos == null)
        return;
      let posCoords = view.coordsAtPos(pos);
      if (!posCoords || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - view.defaultCharacterWidth || lastMove.x > posCoords.right + view.defaultCharacterWidth)
        return;
      let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find((s3) => s3.from <= pos && s3.to >= pos);
      let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
      side = lastMove.x < posCoords.left ? -rtl : rtl;
    }
    let open = this.source(view, pos, side);
    if (open === null || open === void 0 ? void 0 : open.then) {
      let pending = this.pending = { pos };
      open.then((result) => {
        if (this.pending == pending) {
          this.pending = null;
          if (result)
            view.dispatch({ effects: this.setHover.of(result) });
        }
      }, (e4) => logException(view.state, e4, "hover tooltip"));
    } else if (open) {
      view.dispatch({ effects: this.setHover.of(open) });
    }
  }
  get tooltip() {
    let plugin2 = this.view.plugin(tooltipPlugin);
    let index4 = plugin2 ? plugin2.manager.tooltips.findIndex((t4) => t4.create == HoverTooltipHost.create) : -1;
    return index4 > -1 ? plugin2.manager.tooltipViews[index4] : null;
  }
  mousemove(event) {
    var _a2;
    this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };
    if (this.hoverTimeout < 0)
      this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
    let { active, tooltip } = this;
    if (active && tooltip && !isInTooltip(tooltip.dom, event) || this.pending) {
      let { pos } = active || this.pending, end2 = (_a2 = active === null || active === void 0 ? void 0 : active.end) !== null && _a2 !== void 0 ? _a2 : pos;
      if (pos == end2 ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end2, event.clientX, event.clientY)) {
        this.view.dispatch({ effects: this.setHover.of(null) });
        this.pending = null;
      }
    }
  }
  mouseleave(event) {
    clearTimeout(this.hoverTimeout);
    this.hoverTimeout = -1;
    let { active } = this;
    if (active) {
      let { tooltip } = this;
      let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget);
      if (!inTooltip)
        this.view.dispatch({ effects: this.setHover.of(null) });
      else
        this.watchTooltipLeave(tooltip.dom);
    }
  }
  watchTooltipLeave(tooltip) {
    let watch = (event) => {
      tooltip.removeEventListener("mouseleave", watch);
      if (this.active && !this.view.dom.contains(event.relatedTarget))
        this.view.dispatch({ effects: this.setHover.of(null) });
    };
    tooltip.addEventListener("mouseleave", watch);
  }
  destroy() {
    clearTimeout(this.hoverTimeout);
    this.view.dom.removeEventListener("mouseleave", this.mouseleave);
    this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
};
var tooltipMargin = 4;
function isInTooltip(tooltip, event) {
  let rect = tooltip.getBoundingClientRect();
  return event.clientX >= rect.left - tooltipMargin && event.clientX <= rect.right + tooltipMargin && event.clientY >= rect.top - tooltipMargin && event.clientY <= rect.bottom + tooltipMargin;
}
function isOverRange(view, from2, to, x2, y3, margin) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;
  if (rect.left > x2 || rect.right < x2 || rect.top > y3 || Math.min(rect.bottom, docBottom) < y3)
    return false;
  let pos = view.posAtCoords({ x: x2, y: y3 }, false);
  return pos >= from2 && pos <= to;
}
function hoverTooltip(source, options2 = {}) {
  let setHover = StateEffect.define();
  let hoverState = StateField.define({
    create() {
      return null;
    },
    update(value, tr2) {
      if (value && (options2.hideOnChange && (tr2.docChanged || tr2.selection) || options2.hideOn && options2.hideOn(tr2, value)))
        return null;
      if (value && tr2.docChanged) {
        let newPos = tr2.changes.mapPos(value.pos, -1, MapMode.TrackDel);
        if (newPos == null)
          return null;
        let copy2 = Object.assign(/* @__PURE__ */ Object.create(null), value);
        copy2.pos = newPos;
        if (value.end != null)
          copy2.end = tr2.changes.mapPos(value.end);
        value = copy2;
      }
      for (let effect4 of tr2.effects) {
        if (effect4.is(setHover))
          value = effect4.value;
        if (effect4.is(closeHoverTooltipEffect))
          value = null;
      }
      return value;
    },
    provide: (f) => showHoverTooltip.from(f)
  });
  return [
    hoverState,
    ViewPlugin.define((view) => new HoverPlugin(
      view,
      source,
      hoverState,
      setHover,
      options2.hoverTime || 300
      /* Hover.Time */
    )),
    showHoverTooltipHost
  ];
}
function getTooltip(view, tooltip) {
  let plugin2 = view.plugin(tooltipPlugin);
  if (!plugin2)
    return null;
  let found = plugin2.manager.tooltips.indexOf(tooltip);
  return found < 0 ? null : plugin2.manager.tooltipViews[found];
}
var closeHoverTooltipEffect = StateEffect.define();
var closeHoverTooltips = closeHoverTooltipEffect.of(null);
var panelConfig = Facet.define({
  combine(configs) {
    let topContainer, bottomContainer;
    for (let c2 of configs) {
      topContainer = topContainer || c2.topContainer;
      bottomContainer = bottomContainer || c2.bottomContainer;
    }
    return { topContainer, bottomContainer };
  }
});
function getPanel(view, panel) {
  let plugin2 = view.plugin(panelPlugin);
  let index4 = plugin2 ? plugin2.specs.indexOf(panel) : -1;
  return index4 > -1 ? plugin2.panels[index4] : null;
}
var panelPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.input = view.state.facet(showPanel);
    this.specs = this.input.filter((s3) => s3);
    this.panels = this.specs.map((spec) => spec(view));
    let conf = view.state.facet(panelConfig);
    this.top = new PanelGroup(view, true, conf.topContainer);
    this.bottom = new PanelGroup(view, false, conf.bottomContainer);
    this.top.sync(this.panels.filter((p) => p.top));
    this.bottom.sync(this.panels.filter((p) => !p.top));
    for (let p of this.panels) {
      p.dom.classList.add("cm-panel");
      if (p.mount)
        p.mount();
    }
  }
  update(update) {
    let conf = update.state.facet(panelConfig);
    if (this.top.container != conf.topContainer) {
      this.top.sync([]);
      this.top = new PanelGroup(update.view, true, conf.topContainer);
    }
    if (this.bottom.container != conf.bottomContainer) {
      this.bottom.sync([]);
      this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
    }
    this.top.syncClasses();
    this.bottom.syncClasses();
    let input = update.state.facet(showPanel);
    if (input != this.input) {
      let specs = input.filter((x2) => x2);
      let panels = [], top3 = [], bottom2 = [], mount = [];
      for (let spec of specs) {
        let known = this.specs.indexOf(spec), panel;
        if (known < 0) {
          panel = spec(update.view);
          mount.push(panel);
        } else {
          panel = this.panels[known];
          if (panel.update)
            panel.update(update);
        }
        panels.push(panel);
        (panel.top ? top3 : bottom2).push(panel);
      }
      this.specs = specs;
      this.panels = panels;
      this.top.sync(top3);
      this.bottom.sync(bottom2);
      for (let p of mount) {
        p.dom.classList.add("cm-panel");
        if (p.mount)
          p.mount();
      }
    } else {
      for (let p of this.panels)
        if (p.update)
          p.update(update);
    }
  }
  destroy() {
    this.top.sync([]);
    this.bottom.sync([]);
  }
}, {
  provide: (plugin2) => EditorView.scrollMargins.of((view) => {
    let value = view.plugin(plugin2);
    return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
  })
});
var PanelGroup = class {
  constructor(view, top3, container) {
    this.view = view;
    this.top = top3;
    this.container = container;
    this.dom = void 0;
    this.classes = "";
    this.panels = [];
    this.syncClasses();
  }
  sync(panels) {
    for (let p of this.panels)
      if (p.destroy && panels.indexOf(p) < 0)
        p.destroy();
    this.panels = panels;
    this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      if (this.dom) {
        this.dom.remove();
        this.dom = void 0;
      }
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div");
      this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
      this.dom.style[this.top ? "top" : "bottom"] = "0";
      let parent = this.container || this.view.dom;
      parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
    }
    let curDOM = this.dom.firstChild;
    for (let panel of this.panels) {
      if (panel.dom.parentNode == this.dom) {
        while (curDOM != panel.dom)
          curDOM = rm(curDOM);
        curDOM = curDOM.nextSibling;
      } else {
        this.dom.insertBefore(panel.dom, curDOM);
      }
    }
    while (curDOM)
      curDOM = rm(curDOM);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!this.container || this.classes == this.view.themeClasses)
      return;
    for (let cls of this.classes.split(" "))
      if (cls)
        this.container.classList.remove(cls);
    for (let cls of (this.classes = this.view.themeClasses).split(" "))
      if (cls)
        this.container.classList.add(cls);
  }
};
function rm(node3) {
  let next2 = node3.nextSibling;
  node3.remove();
  return next2;
}
var showPanel = Facet.define({
  enables: panelPlugin
});
var GutterMarker = class extends RangeValue {
  /**
  @internal
  */
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(other) {
    return false;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(dom) {
  }
};
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = void 0;
GutterMarker.prototype.mapMode = MapMode.TrackBefore;
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
GutterMarker.prototype.point = true;
var gutterLineClass = Facet.define();
var defaults = {
  class: "",
  renderEmptyElements: false,
  elementStyle: "",
  markers: () => RangeSet.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
};
var activeGutters = Facet.define();
function gutter(config2) {
  return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config2))];
}
var unfixGutters = Facet.define({
  combine: (values) => values.some((x2) => x2)
});
function gutters(config2) {
  let result = [
    gutterView
  ];
  if (config2 && config2.fixed === false)
    result.push(unfixGutters.of(true));
  return result;
}
var gutterView = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.prevViewport = view.viewport;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutters";
    this.dom.setAttribute("aria-hidden", "true");
    this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
    this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
    for (let gutter2 of this.gutters)
      this.dom.appendChild(gutter2.dom);
    this.fixed = !view.state.facet(unfixGutters);
    if (this.fixed) {
      this.dom.style.position = "sticky";
    }
    this.syncGutters(false);
    view.scrollDOM.insertBefore(this.dom, view.contentDOM);
  }
  update(update) {
    if (this.updateGutters(update)) {
      let vpA = this.prevViewport, vpB = update.view.viewport;
      let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
      this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
    }
    if (update.geometryChanged)
      this.dom.style.minHeight = this.view.contentHeight + "px";
    if (this.view.state.facet(unfixGutters) != !this.fixed) {
      this.fixed = !this.fixed;
      this.dom.style.position = this.fixed ? "sticky" : "";
    }
    this.prevViewport = update.view.viewport;
  }
  syncGutters(detach) {
    let after = this.dom.nextSibling;
    if (detach)
      this.dom.remove();
    let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
    let classSet = [];
    let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
    for (let line2 of this.view.viewportLineBlocks) {
      if (classSet.length)
        classSet = [];
      if (Array.isArray(line2.type)) {
        let first = true;
        for (let b2 of line2.type) {
          if (b2.type == BlockType.Text && first) {
            advanceCursor(lineClasses, classSet, b2.from);
            for (let cx of contexts)
              cx.line(this.view, b2, classSet);
            first = false;
          } else if (b2.widget) {
            for (let cx of contexts)
              cx.widget(this.view, b2);
          }
        }
      } else if (line2.type == BlockType.Text) {
        advanceCursor(lineClasses, classSet, line2.from);
        for (let cx of contexts)
          cx.line(this.view, line2, classSet);
      } else if (line2.widget) {
        for (let cx of contexts)
          cx.widget(this.view, line2);
      }
    }
    for (let cx of contexts)
      cx.finish();
    if (detach)
      this.view.scrollDOM.insertBefore(this.dom, after);
  }
  updateGutters(update) {
    let prev2 = update.startState.facet(activeGutters), cur2 = update.state.facet(activeGutters);
    let change = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
    if (prev2 == cur2) {
      for (let gutter2 of this.gutters)
        if (gutter2.update(update))
          change = true;
    } else {
      change = true;
      let gutters2 = [];
      for (let conf of cur2) {
        let known = prev2.indexOf(conf);
        if (known < 0) {
          gutters2.push(new SingleGutterView(this.view, conf));
        } else {
          this.gutters[known].update(update);
          gutters2.push(this.gutters[known]);
        }
      }
      for (let g of this.gutters) {
        g.dom.remove();
        if (gutters2.indexOf(g) < 0)
          g.destroy();
      }
      for (let g of gutters2)
        this.dom.appendChild(g.dom);
      this.gutters = gutters2;
    }
    return change;
  }
  destroy() {
    for (let view of this.gutters)
      view.destroy();
    this.dom.remove();
  }
}, {
  provide: (plugin2) => EditorView.scrollMargins.of((view) => {
    let value = view.plugin(plugin2);
    if (!value || value.gutters.length == 0 || !value.fixed)
      return null;
    return view.textDirection == Direction.LTR ? { left: value.dom.offsetWidth * view.scaleX } : { right: value.dom.offsetWidth * view.scaleX };
  })
});
function asArray3(val) {
  return Array.isArray(val) ? val : [val];
}
function advanceCursor(cursor2, collect, pos) {
  while (cursor2.value && cursor2.from <= pos) {
    if (cursor2.from == pos)
      collect.push(cursor2.value);
    cursor2.next();
  }
}
var UpdateContext = class {
  constructor(gutter2, viewport2, height) {
    this.gutter = gutter2;
    this.height = height;
    this.i = 0;
    this.cursor = RangeSet.iter(gutter2.markers, viewport2.from);
  }
  addElement(view, block, markers) {
    let { gutter: gutter2 } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;
    if (this.i == gutter2.elements.length) {
      let newElt = new GutterElement(view, height, above, markers);
      gutter2.elements.push(newElt);
      gutter2.dom.appendChild(newElt.dom);
    } else {
      gutter2.elements[this.i].update(view, height, above, markers);
    }
    this.height = block.bottom;
    this.i++;
  }
  line(view, line2, extraMarkers) {
    let localMarkers = [];
    advanceCursor(this.cursor, localMarkers, line2.from);
    if (extraMarkers.length)
      localMarkers = localMarkers.concat(extraMarkers);
    let forLine = this.gutter.config.lineMarker(view, line2, localMarkers);
    if (forLine)
      localMarkers.unshift(forLine);
    let gutter2 = this.gutter;
    if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
      return;
    this.addElement(view, line2, localMarkers);
  }
  widget(view, block) {
    let marker = this.gutter.config.widgetMarker(view, block.widget, block);
    if (marker)
      this.addElement(view, block, [marker]);
  }
  finish() {
    let gutter2 = this.gutter;
    while (gutter2.elements.length > this.i) {
      let last = gutter2.elements.pop();
      gutter2.dom.removeChild(last.dom);
      last.destroy();
    }
  }
};
var SingleGutterView = class {
  constructor(view, config2) {
    this.view = view;
    this.config = config2;
    this.elements = [];
    this.spacer = null;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let prop in config2.domEventHandlers) {
      this.dom.addEventListener(prop, (event) => {
        let target = event.target, y3;
        if (target != this.dom && this.dom.contains(target)) {
          while (target.parentNode != this.dom)
            target = target.parentNode;
          let rect = target.getBoundingClientRect();
          y3 = (rect.top + rect.bottom) / 2;
        } else {
          y3 = event.clientY;
        }
        let line2 = view.lineBlockAtHeight(y3 - view.documentTop);
        if (config2.domEventHandlers[prop](view, line2, event))
          event.preventDefault();
      });
    }
    this.markers = asArray3(config2.markers(view));
    if (config2.initialSpacer) {
      this.spacer = new GutterElement(view, 0, 0, [config2.initialSpacer(view)]);
      this.dom.appendChild(this.spacer.dom);
      this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
    }
  }
  update(update) {
    let prevMarkers = this.markers;
    this.markers = asArray3(this.config.markers(update.view));
    if (this.spacer && this.config.updateSpacer) {
      let updated = this.config.updateSpacer(this.spacer.markers[0], update);
      if (updated != this.spacer.markers[0])
        this.spacer.update(update.view, 0, 0, [updated]);
    }
    let vp = update.view.viewport;
    return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
  }
  destroy() {
    for (let elt of this.elements)
      elt.destroy();
  }
};
var GutterElement = class {
  constructor(view, height, above, markers) {
    this.height = -1;
    this.above = 0;
    this.markers = [];
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutterElement";
    this.update(view, height, above, markers);
  }
  update(view, height, above, markers) {
    if (this.height != height) {
      this.height = height;
      this.dom.style.height = height + "px";
    }
    if (this.above != above)
      this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
    if (!sameMarkers(this.markers, markers))
      this.setMarkers(view, markers);
  }
  setMarkers(view, markers) {
    let cls = "cm-gutterElement", domPos = this.dom.firstChild;
    for (let iNew = 0, iOld = 0; ; ) {
      let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
      if (marker) {
        let c2 = marker.elementClass;
        if (c2)
          cls += " " + c2;
        for (let i2 = iOld; i2 < this.markers.length; i2++)
          if (this.markers[i2].compare(marker)) {
            skipTo = i2;
            matched = true;
            break;
          }
      } else {
        skipTo = this.markers.length;
      }
      while (iOld < skipTo) {
        let next2 = this.markers[iOld++];
        if (next2.toDOM) {
          next2.destroy(domPos);
          let after = domPos.nextSibling;
          domPos.remove();
          domPos = after;
        }
      }
      if (!marker)
        break;
      if (marker.toDOM) {
        if (matched)
          domPos = domPos.nextSibling;
        else
          this.dom.insertBefore(marker.toDOM(view), domPos);
      }
      if (matched)
        iOld++;
    }
    this.dom.className = cls;
    this.markers = markers;
  }
  destroy() {
    this.setMarkers(null, []);
  }
};
function sameMarkers(a3, b2) {
  if (a3.length != b2.length)
    return false;
  for (let i2 = 0; i2 < a3.length; i2++)
    if (!a3[i2].compare(b2[i2]))
      return false;
  return true;
}
var lineNumberMarkers = Facet.define();
var lineNumberConfig = Facet.define({
  combine(values) {
    return combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(a3, b2) {
        let result = Object.assign({}, a3);
        for (let event in b2) {
          let exists = result[event], add3 = b2[event];
          result[event] = exists ? (view, line2, event2) => exists(view, line2, event2) || add3(view, line2, event2) : add3;
        }
        return result;
      }
    });
  }
});
var NumberMarker = class extends GutterMarker {
  constructor(number2) {
    super();
    this.number = number2;
  }
  eq(other) {
    return this.number == other.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
};
function formatNumber(view, number2) {
  return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
}
var lineNumberGutter = activeGutters.compute([lineNumberConfig], (state) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: false,
  markers(view) {
    return view.state.facet(lineNumberMarkers);
  },
  lineMarker(view, line2, others) {
    if (others.some((m3) => m3.toDOM))
      return null;
    return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line2.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (update) => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
  initialSpacer(view) {
    return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
  },
  updateSpacer(spacer, update) {
    let max4 = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
    return max4 == spacer.number ? spacer : new NumberMarker(max4);
  },
  domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
}));
function lineNumbers(config2 = {}) {
  return [
    lineNumberConfig.of(config2),
    gutters(),
    lineNumberGutter
  ];
}
function maxLineNumber(lines) {
  let last = 9;
  while (last < lines)
    last = last * 10 + 9;
  return last;
}
var activeLineGutterMarker = new class extends GutterMarker {
  constructor() {
    super(...arguments);
    this.elementClass = "cm-activeLineGutter";
  }
}();
var activeLineGutterHighlighter = gutterLineClass.compute(["selection"], (state) => {
  let marks2 = [], last = -1;
  for (let range of state.selection.ranges) {
    let linePos = state.doc.lineAt(range.head).from;
    if (linePos > last) {
      last = linePos;
      marks2.push(activeLineGutterMarker.range(linePos));
    }
  }
  return RangeSet.of(marks2);
});
var WhitespaceDeco = /* @__PURE__ */ new Map();
function getWhitespaceDeco(space) {
  let deco = WhitespaceDeco.get(space);
  if (!deco)
    WhitespaceDeco.set(space, deco = Decoration.mark({
      attributes: space === "	" ? {
        class: "cm-highlightTab"
      } : {
        class: "cm-highlightSpace",
        "data-display": space.replace(/ /g, "")
      }
    }));
  return deco;
}
function matcher(decorator) {
  return ViewPlugin.define((view) => ({
    decorations: decorator.createDeco(view),
    update(u2) {
      this.decorations = decorator.updateDeco(u2, this.decorations);
    }
  }), {
    decorations: (v) => v.decorations
  });
}
var whitespaceHighlighter = matcher(new MatchDecorator({
  regexp: /\t| +/g,
  decoration: (match3) => getWhitespaceDeco(match3[0]),
  boundary: /\S/
}));
var trailingHighlighter = matcher(new MatchDecorator({
  regexp: /\s+$/g,
  decoration: Decoration.mark({ class: "cm-trailingSpace" }),
  boundary: /\S/
}));

// node_modules/@lezer/common/dist/index.js
var DefaultBufferLength = 1024;
var nextPropID = 0;
var Range2 = class {
  constructor(from2, to) {
    this.from = from2;
    this.to = to;
  }
};
var NodeProp = class {
  /**
  Create a new node prop type.
  */
  constructor(config2 = {}) {
    this.id = nextPropID++;
    this.perNode = !!config2.perNode;
    this.deserialize = config2.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(match3) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    if (typeof match3 != "function")
      match3 = NodeType.match(match3);
    return (type) => {
      let result = match3(type);
      return result === void 0 ? null : [this, result];
    };
  }
};
NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.isolate = new NodeProp({ deserialize: (value) => {
  if (value && value != "rtl" && value != "ltr" && value != "auto")
    throw new RangeError("Invalid value for isolate: " + value);
  return value || "auto";
} });
NodeProp.contextHash = new NodeProp({ perNode: true });
NodeProp.lookAhead = new NodeProp({ perNode: true });
NodeProp.mounted = new NodeProp({ perNode: true });
var MountedTree = class {
  constructor(tree, overlay, parser) {
    this.tree = tree;
    this.overlay = overlay;
    this.parser = parser;
  }
  /**
  @internal
  */
  static get(tree) {
    return tree && tree.props && tree.props[NodeProp.mounted.id];
  }
};
var noProps = /* @__PURE__ */ Object.create(null);
var NodeType = class _NodeType {
  /**
  @internal
  */
  constructor(name2, props, id, flags = 0) {
    this.name = name2;
    this.props = props;
    this.id = id;
    this.flags = flags;
  }
  /**
  Define a node type.
  */
  static define(spec) {
    let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
    let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
    let type = new _NodeType(spec.name || "", props, spec.id, flags);
    if (spec.props)
      for (let src of spec.props) {
        if (!Array.isArray(src))
          src = src(type);
        if (src) {
          if (src[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          props[src[0].id] = src[1];
        }
      }
    return type;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(prop) {
    return this.props[prop.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(name2) {
    if (typeof name2 == "string") {
      if (this.name == name2)
        return true;
      let group = this.prop(NodeProp.group);
      return group ? group.indexOf(name2) > -1 : false;
    }
    return this.id == name2;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(map) {
    let direct = /* @__PURE__ */ Object.create(null);
    for (let prop in map)
      for (let name2 of prop.split(" "))
        direct[name2] = map[prop];
    return (node3) => {
      for (let groups = node3.prop(NodeProp.group), i2 = -1; i2 < (groups ? groups.length : 0); i2++) {
        let found = direct[i2 < 0 ? node3.name : groups[i2]];
        if (found)
          return found;
      }
    };
  }
};
NodeType.none = new NodeType(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
var NodeSet = class _NodeSet {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(types2) {
    this.types = types2;
    for (let i2 = 0; i2 < types2.length; i2++)
      if (types2[i2].id != i2)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...props) {
    let newTypes = [];
    for (let type of this.types) {
      let newProps = null;
      for (let source of props) {
        let add3 = source(type);
        if (add3) {
          if (!newProps)
            newProps = Object.assign({}, type.props);
          newProps[add3[0].id] = add3[1];
        }
      }
      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
    }
    return new _NodeSet(newTypes);
  }
};
var CachedNode = /* @__PURE__ */ new WeakMap();
var CachedInnerNode = /* @__PURE__ */ new WeakMap();
var IterMode;
(function(IterMode2) {
  IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
  IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
  IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
  IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(IterMode || (IterMode = {}));
var Tree = class _Tree {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(type, children, positions, length2, props) {
    this.type = type;
    this.children = children;
    this.positions = positions;
    this.length = length2;
    this.props = null;
    if (props && props.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [prop, value] of props)
        this.props[typeof prop == "number" ? prop : prop.id] = value;
    }
  }
  /**
  @internal
  */
  toString() {
    let mounted = MountedTree.get(this);
    if (mounted && !mounted.overlay)
      return mounted.tree.toString();
    let children = "";
    for (let ch of this.children) {
      let str = ch.toString();
      if (str) {
        if (children)
          children += ",";
        children += str;
      }
    }
    return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(mode = 0) {
    return new TreeCursor(this.topNode, mode);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(pos, side = 0, mode = 0) {
    let scope = CachedNode.get(this) || this.topNode;
    let cursor2 = new TreeCursor(scope);
    cursor2.moveTo(pos, side);
    CachedNode.set(this, cursor2._tree);
    return cursor2;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new TreeNode(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(pos, side = 0) {
    let node3 = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
    CachedNode.set(this, node3);
    return node3;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(pos, side = 0) {
    let node3 = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
    CachedInnerNode.set(this, node3);
    return node3;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(pos, side = 0) {
    return stackIterator(this, pos, side);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(spec) {
    let { enter, leave, from: from2 = 0, to = this.length } = spec;
    let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
    for (let c2 = this.cursor(mode | IterMode.IncludeAnonymous); ; ) {
      let entered = false;
      if (c2.from <= to && c2.to >= from2 && (!anon && c2.type.isAnonymous || enter(c2) !== false)) {
        if (c2.firstChild())
          continue;
        entered = true;
      }
      for (; ; ) {
        if (entered && leave && (anon || !c2.type.isAnonymous))
          leave(c2);
        if (c2.nextSibling())
          break;
        if (!c2.parent())
          return;
        entered = true;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(prop) {
    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let result = [];
    if (this.props)
      for (let id in this.props)
        result.push([+id, this.props[id]]);
    return result;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(config2 = {}) {
    return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length2) => new _Tree(this.type, children, positions, length2, this.propValues), config2.makeTree || ((children, positions, length2) => new _Tree(NodeType.none, children, positions, length2)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(data) {
    return buildTree(data);
  }
};
Tree.empty = new Tree(NodeType.none, [], [], 0);
var FlatBufferCursor = class _FlatBufferCursor {
  constructor(buffer, index4) {
    this.buffer = buffer;
    this.index = index4;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new _FlatBufferCursor(this.buffer, this.index);
  }
};
var TreeBuffer = class _TreeBuffer {
  /**
  Create a tree buffer.
  */
  constructor(buffer, length2, set2) {
    this.buffer = buffer;
    this.length = length2;
    this.set = set2;
  }
  /**
  @internal
  */
  get type() {
    return NodeType.none;
  }
  /**
  @internal
  */
  toString() {
    let result = [];
    for (let index4 = 0; index4 < this.buffer.length; ) {
      result.push(this.childString(index4));
      index4 = this.buffer[index4 + 3];
    }
    return result.join(",");
  }
  /**
  @internal
  */
  childString(index4) {
    let id = this.buffer[index4], endIndex = this.buffer[index4 + 3];
    let type = this.set.types[id], result = type.name;
    if (/\W/.test(result) && !type.isError)
      result = JSON.stringify(result);
    index4 += 4;
    if (endIndex == index4)
      return result;
    let children = [];
    while (index4 < endIndex) {
      children.push(this.childString(index4));
      index4 = this.buffer[index4 + 3];
    }
    return result + "(" + children.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(startIndex, endIndex, dir, pos, side) {
    let { buffer } = this, pick = -1;
    for (let i2 = startIndex; i2 != endIndex; i2 = buffer[i2 + 3]) {
      if (checkSide(side, pos, buffer[i2 + 1], buffer[i2 + 2])) {
        pick = i2;
        if (dir > 0)
          break;
      }
    }
    return pick;
  }
  /**
  @internal
  */
  slice(startI, endI, from2) {
    let b2 = this.buffer;
    let copy2 = new Uint16Array(endI - startI), len = 0;
    for (let i2 = startI, j = 0; i2 < endI; ) {
      copy2[j++] = b2[i2++];
      copy2[j++] = b2[i2++] - from2;
      let to = copy2[j++] = b2[i2++] - from2;
      copy2[j++] = b2[i2++] - startI;
      len = Math.max(len, to);
    }
    return new _TreeBuffer(copy2, len, this.set);
  }
};
function checkSide(side, pos, from2, to) {
  switch (side) {
    case -2:
      return from2 < pos;
    case -1:
      return to >= pos && from2 < pos;
    case 0:
      return from2 < pos && to > pos;
    case 1:
      return from2 <= pos && to > pos;
    case 2:
      return to > pos;
    case 4:
      return true;
  }
}
function resolveNode(node3, pos, side, overlays) {
  var _a2;
  while (node3.from == node3.to || (side < 1 ? node3.from >= pos : node3.from > pos) || (side > -1 ? node3.to <= pos : node3.to < pos)) {
    let parent = !overlays && node3 instanceof TreeNode && node3.index < 0 ? null : node3.parent;
    if (!parent)
      return node3;
    node3 = parent;
  }
  let mode = overlays ? 0 : IterMode.IgnoreOverlays;
  if (overlays)
    for (let scan = node3, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
      if (scan instanceof TreeNode && scan.index < 0 && ((_a2 = parent.enter(pos, side, mode)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan.from)
        node3 = parent;
    }
  for (; ; ) {
    let inner = node3.enter(pos, side, mode);
    if (!inner)
      return node3;
    node3 = inner;
  }
}
var BaseNode = class {
  cursor(mode = 0) {
    return new TreeCursor(this, mode);
  }
  getChild(type, before = null, after = null) {
    let r2 = getChildren2(this, type, before, after);
    return r2.length ? r2[0] : null;
  }
  getChildren(type, before = null, after = null) {
    return getChildren2(this, type, before, after);
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  matchContext(context) {
    return matchNodeContext(this, context);
  }
  enterUnfinishedNodesBefore(pos) {
    let scan = this.childBefore(pos), node3 = this;
    while (scan) {
      let last = scan.lastChild;
      if (!last || last.to != scan.to)
        break;
      if (last.type.isError && last.from == last.to) {
        node3 = scan;
        scan = last.prevSibling;
      } else {
        scan = last;
      }
    }
    return node3;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
};
var TreeNode = class _TreeNode extends BaseNode {
  constructor(_tree, from2, index4, _parent) {
    super();
    this._tree = _tree;
    this.from = from2;
    this.index = index4;
    this._parent = _parent;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(i2, dir, pos, side, mode = 0) {
    for (let parent = this; ; ) {
      for (let { children, positions } = parent._tree, e4 = dir > 0 ? children.length : -1; i2 != e4; i2 += dir) {
        let next2 = children[i2], start2 = positions[i2] + parent.from;
        if (!checkSide(side, pos, start2, start2 + next2.length))
          continue;
        if (next2 instanceof TreeBuffer) {
          if (mode & IterMode.ExcludeBuffers)
            continue;
          let index4 = next2.findChild(0, next2.buffer.length, dir, pos - start2, side);
          if (index4 > -1)
            return new BufferNode(new BufferContext(parent, next2, i2, start2), null, index4);
        } else if (mode & IterMode.IncludeAnonymous || (!next2.type.isAnonymous || hasChild(next2))) {
          let mounted;
          if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next2)) && !mounted.overlay)
            return new _TreeNode(mounted.tree, start2, i2, parent);
          let inner = new _TreeNode(next2, start2, i2, parent);
          return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next2.children.length - 1 : 0, dir, pos, side);
        }
      }
      if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
        return null;
      if (parent.index >= 0)
        i2 = parent.index + dir;
      else
        i2 = dir < 0 ? -1 : parent._parent._tree.children.length;
      parent = parent._parent;
      if (!parent)
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.nextChild(
      0,
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  enter(pos, side, mode = 0) {
    let mounted;
    if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
      let rPos = pos - this.from;
      for (let { from: from2, to } of mounted.overlay) {
        if ((side > 0 ? from2 <= rPos : from2 < rPos) && (side < 0 ? to >= rPos : to > rPos))
          return new _TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
      }
    }
    return this.nextChild(0, 1, pos, side, mode);
  }
  nextSignificantParent() {
    let val = this;
    while (val.type.isAnonymous && val._parent)
      val = val._parent;
    return val;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
};
function getChildren2(node3, type, before, after) {
  let cur2 = node3.cursor(), result = [];
  if (!cur2.firstChild())
    return result;
  if (before != null) {
    while (!cur2.type.is(before))
      if (!cur2.nextSibling())
        return result;
  }
  for (; ; ) {
    if (after != null && cur2.type.is(after))
      return result;
    if (cur2.type.is(type))
      result.push(cur2.node);
    if (!cur2.nextSibling())
      return after == null ? result : [];
  }
}
function matchNodeContext(node3, context, i2 = context.length - 1) {
  for (let p = node3.parent; i2 >= 0; p = p.parent) {
    if (!p)
      return false;
    if (!p.type.isAnonymous) {
      if (context[i2] && context[i2] != p.name)
        return false;
      i2--;
    }
  }
  return true;
}
var BufferContext = class {
  constructor(parent, buffer, index4, start2) {
    this.parent = parent;
    this.buffer = buffer;
    this.index = index4;
    this.start = start2;
  }
};
var BufferNode = class _BufferNode extends BaseNode {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(context, _parent, index4) {
    super();
    this.context = context;
    this._parent = _parent;
    this.index = index4;
    this.type = context.buffer.set.types[context.buffer.buffer[index4]];
  }
  child(dir, pos, side) {
    let { buffer } = this.context;
    let index4 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
    return index4 < 0 ? null : new _BufferNode(this.context, this, index4);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.child(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.child(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  enter(pos, side, mode = 0) {
    if (mode & IterMode.ExcludeBuffers)
      return null;
    let { buffer } = this.context;
    let index4 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
    return index4 < 0 ? null : new _BufferNode(this.context, this, index4);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(dir) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + dir,
      dir,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer } = this.context;
    let after = buffer.buffer[this.index + 3];
    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
      return new _BufferNode(this.context, this._parent, after);
    return this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer } = this.context;
    let parentStart = this._parent ? this._parent.index + 4 : 0;
    if (this.index == parentStart)
      return this.externalSibling(-1);
    return new _BufferNode(this.context, this._parent, buffer.findChild(
      parentStart,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let children = [], positions = [];
    let { buffer } = this.context;
    let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
    if (endI > startI) {
      let from2 = buffer.buffer[this.index + 1];
      children.push(buffer.slice(startI, endI, from2));
      positions.push(0);
    }
    return new Tree(this.type, children, positions, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
};
function iterStack(heads) {
  if (!heads.length)
    return null;
  let pick = 0, picked = heads[0];
  for (let i2 = 1; i2 < heads.length; i2++) {
    let node3 = heads[i2];
    if (node3.from > picked.from || node3.to < picked.to) {
      picked = node3;
      pick = i2;
    }
  }
  let next2 = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
  let newHeads = heads.slice();
  if (next2)
    newHeads[pick] = next2;
  else
    newHeads.splice(pick, 1);
  return new StackIterator(newHeads, picked);
}
var StackIterator = class {
  constructor(heads, node3) {
    this.heads = heads;
    this.node = node3;
  }
  get next() {
    return iterStack(this.heads);
  }
};
function stackIterator(tree, pos, side) {
  let inner = tree.resolveInner(pos, side), layers = null;
  for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
    if (scan.index < 0) {
      let parent = scan.parent;
      (layers || (layers = [inner])).push(parent.resolve(pos, side));
      scan = parent;
    } else {
      let mount = MountedTree.get(scan.tree);
      if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
        let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
        (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));
      }
    }
  }
  return layers ? iterStack(layers) : inner;
}
var TreeCursor = class {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(node3, mode = 0) {
    this.mode = mode;
    this.buffer = null;
    this.stack = [];
    this.index = 0;
    this.bufferNode = null;
    if (node3 instanceof TreeNode) {
      this.yieldNode(node3);
    } else {
      this._tree = node3.context.parent;
      this.buffer = node3.context;
      for (let n = node3._parent; n; n = n._parent)
        this.stack.unshift(n.index);
      this.bufferNode = node3;
      this.yieldBuf(node3.index);
    }
  }
  yieldNode(node3) {
    if (!node3)
      return false;
    this._tree = node3;
    this.type = node3.type;
    this.from = node3.from;
    this.to = node3.to;
    return true;
  }
  yieldBuf(index4, type) {
    this.index = index4;
    let { start: start2, buffer } = this.buffer;
    this.type = type || buffer.set.types[buffer.buffer[index4]];
    this.from = start2 + buffer.buffer[index4 + 1];
    this.to = start2 + buffer.buffer[index4 + 2];
    return true;
  }
  /**
  @internal
  */
  yield(node3) {
    if (!node3)
      return false;
    if (node3 instanceof TreeNode) {
      this.buffer = null;
      return this.yieldNode(node3);
    }
    this.buffer = node3.context;
    return this.yieldBuf(node3.index, node3.type);
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(dir, pos, side) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
    let { buffer } = this.buffer;
    let index4 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
    if (index4 < 0)
      return false;
    this.stack.push(this.index);
    return this.yieldBuf(index4);
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(pos) {
    return this.enterChild(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(pos) {
    return this.enterChild(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(pos, side, mode = this.mode) {
    if (!this.buffer)
      return this.yield(this._tree.enter(pos, side, mode));
    return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    this.buffer = null;
    return this.yieldNode(parent);
  }
  /**
  @internal
  */
  sibling(dir) {
    if (!this.buffer)
      return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
    let { buffer } = this.buffer, d3 = this.stack.length - 1;
    if (dir < 0) {
      let parentStart = d3 < 0 ? 0 : this.stack[d3] + 4;
      if (this.index != parentStart)
        return this.yieldBuf(buffer.findChild(
          parentStart,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let after = buffer.buffer[this.index + 3];
      if (after < (d3 < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d3] + 3]))
        return this.yieldBuf(after);
    }
    return d3 < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(dir) {
    let index4, parent, { buffer } = this;
    if (buffer) {
      if (dir > 0) {
        if (this.index < buffer.buffer.buffer.length)
          return false;
      } else {
        for (let i2 = 0; i2 < this.index; i2++)
          if (buffer.buffer.buffer[i2 + 3] < this.index)
            return false;
      }
      ({ index: index4, parent } = buffer);
    } else {
      ({ index: index4, _parent: parent } = this._tree);
    }
    for (; parent; { index: index4, _parent: parent } = parent) {
      if (index4 > -1)
        for (let i2 = index4 + dir, e4 = dir < 0 ? -1 : parent._tree.children.length; i2 != e4; i2 += dir) {
          let child = parent._tree.children[i2];
          if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
            return false;
        }
    }
    return true;
  }
  move(dir, enter) {
    if (enter && this.enterChild(
      dir,
      0,
      4
      /* Side.DontCare */
    ))
      return true;
    for (; ; ) {
      if (this.sibling(dir))
        return true;
      if (this.atLastNode(dir) || !this.parent())
        return false;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(enter = true) {
    return this.move(1, enter);
  }
  /**
  Move to the next node in a last-to-first pre-order traveral. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(enter = true) {
    return this.move(-1, enter);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(pos, side = 0) {
    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
      if (!this.parent())
        break;
    while (this.enterChild(1, pos, side)) {
    }
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let cache = this.bufferNode, result = null, depth2 = 0;
    if (cache && cache.context == this.buffer) {
      scan:
        for (let index4 = this.index, d3 = this.stack.length; d3 >= 0; ) {
          for (let c2 = cache; c2; c2 = c2._parent)
            if (c2.index == index4) {
              if (index4 == this.index)
                return c2;
              result = c2;
              depth2 = d3 + 1;
              break scan;
            }
          index4 = this.stack[--d3];
        }
    }
    for (let i2 = depth2; i2 < this.stack.length; i2++)
      result = new BufferNode(this.buffer, result, this.stack[i2]);
    return this.bufferNode = new BufferNode(this.buffer, result, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(enter, leave) {
    for (let depth2 = 0; ; ) {
      let mustLeave = false;
      if (this.type.isAnonymous || enter(this) !== false) {
        if (this.firstChild()) {
          depth2++;
          continue;
        }
        if (!this.type.isAnonymous)
          mustLeave = true;
      }
      for (; ; ) {
        if (mustLeave && leave)
          leave(this);
        mustLeave = this.type.isAnonymous;
        if (this.nextSibling())
          break;
        if (!depth2)
          return;
        this.parent();
        depth2--;
        mustLeave = true;
      }
    }
  }
  /**
  Test whether the current node matches a given contexta sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(context) {
    if (!this.buffer)
      return matchNodeContext(this.node, context);
    let { buffer } = this.buffer, { types: types2 } = buffer.set;
    for (let i2 = context.length - 1, d3 = this.stack.length - 1; i2 >= 0; d3--) {
      if (d3 < 0)
        return matchNodeContext(this.node, context, i2);
      let type = types2[buffer.buffer[this.stack[d3]]];
      if (!type.isAnonymous) {
        if (context[i2] && context[i2] != type.name)
          return false;
        i2--;
      }
    }
    return true;
  }
};
function hasChild(tree) {
  return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
  var _a2;
  let { buffer, nodeSet: nodeSet2, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet2.types.length } = data;
  let cursor2 = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
  let types2 = nodeSet2.types;
  let contextHash = 0, lookAhead = 0;
  function takeNode(parentStart, minPos, children2, positions2, inRepeat, depth2) {
    let { id, start: start2, end: end2, size: size3 } = cursor2;
    let lookAheadAtStart = lookAhead;
    while (size3 < 0) {
      cursor2.next();
      if (size3 == -1) {
        let node4 = reused[id];
        children2.push(node4);
        positions2.push(start2 - parentStart);
        return;
      } else if (size3 == -3) {
        contextHash = id;
        return;
      } else if (size3 == -4) {
        lookAhead = id;
        return;
      } else {
        throw new RangeError(`Unrecognized record size: ${size3}`);
      }
    }
    let type = types2[id], node3, buffer2;
    let startPos = start2 - parentStart;
    if (end2 - start2 <= maxBufferLength && (buffer2 = findBufferSize(cursor2.pos - minPos, inRepeat))) {
      let data2 = new Uint16Array(buffer2.size - buffer2.skip);
      let endPos = cursor2.pos - buffer2.size, index4 = data2.length;
      while (cursor2.pos > endPos)
        index4 = copyToBuffer(buffer2.start, data2, index4);
      node3 = new TreeBuffer(data2, end2 - buffer2.start, nodeSet2);
      startPos = buffer2.start - parentStart;
    } else {
      let endPos = cursor2.pos - size3;
      cursor2.next();
      let localChildren = [], localPositions = [];
      let localInRepeat = id >= minRepeatType ? id : -1;
      let lastGroup = 0, lastEnd = end2;
      while (cursor2.pos > endPos) {
        if (localInRepeat >= 0 && cursor2.id == localInRepeat && cursor2.size >= 0) {
          if (cursor2.end <= lastEnd - maxBufferLength) {
            makeRepeatLeaf(localChildren, localPositions, start2, lastGroup, cursor2.end, lastEnd, localInRepeat, lookAheadAtStart);
            lastGroup = localChildren.length;
            lastEnd = cursor2.end;
          }
          cursor2.next();
        } else if (depth2 > 2500) {
          takeFlatNode(start2, endPos, localChildren, localPositions);
        } else {
          takeNode(start2, endPos, localChildren, localPositions, localInRepeat, depth2 + 1);
        }
      }
      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
        makeRepeatLeaf(localChildren, localPositions, start2, lastGroup, start2, lastEnd, localInRepeat, lookAheadAtStart);
      localChildren.reverse();
      localPositions.reverse();
      if (localInRepeat > -1 && lastGroup > 0) {
        let make = makeBalanced(type);
        node3 = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end2 - start2, make, make);
      } else {
        node3 = makeTree(type, localChildren, localPositions, end2 - start2, lookAheadAtStart - end2);
      }
    }
    children2.push(node3);
    positions2.push(startPos);
  }
  function takeFlatNode(parentStart, minPos, children2, positions2) {
    let nodes = [];
    let nodeCount = 0, stopAt = -1;
    while (cursor2.pos > minPos) {
      let { id, start: start2, end: end2, size: size3 } = cursor2;
      if (size3 > 4) {
        cursor2.next();
      } else if (stopAt > -1 && start2 < stopAt) {
        break;
      } else {
        if (stopAt < 0)
          stopAt = end2 - maxBufferLength;
        nodes.push(id, start2, end2);
        nodeCount++;
        cursor2.next();
      }
    }
    if (nodeCount) {
      let buffer2 = new Uint16Array(nodeCount * 4);
      let start2 = nodes[nodes.length - 2];
      for (let i2 = nodes.length - 3, j = 0; i2 >= 0; i2 -= 3) {
        buffer2[j++] = nodes[i2];
        buffer2[j++] = nodes[i2 + 1] - start2;
        buffer2[j++] = nodes[i2 + 2] - start2;
        buffer2[j++] = j;
      }
      children2.push(new TreeBuffer(buffer2, nodes[2] - start2, nodeSet2));
      positions2.push(start2 - parentStart);
    }
  }
  function makeBalanced(type) {
    return (children2, positions2, length3) => {
      let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
      if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
        if (!lastI && last.type == type && last.length == length3)
          return last;
        if (lookAheadProp = last.prop(NodeProp.lookAhead))
          lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
      }
      return makeTree(type, children2, positions2, length3, lookAhead2);
    };
  }
  function makeRepeatLeaf(children2, positions2, base2, i2, from2, to, type, lookAhead2) {
    let localChildren = [], localPositions = [];
    while (children2.length > i2) {
      localChildren.push(children2.pop());
      localPositions.push(positions2.pop() + base2 - from2);
    }
    children2.push(makeTree(nodeSet2.types[type], localChildren, localPositions, to - from2, lookAhead2 - to));
    positions2.push(from2 - base2);
  }
  function makeTree(type, children2, positions2, length3, lookAhead2 = 0, props) {
    if (contextHash) {
      let pair = [NodeProp.contextHash, contextHash];
      props = props ? [pair].concat(props) : [pair];
    }
    if (lookAhead2 > 25) {
      let pair = [NodeProp.lookAhead, lookAhead2];
      props = props ? [pair].concat(props) : [pair];
    }
    return new Tree(type, children2, positions2, length3, props);
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork = cursor2.fork();
    let size3 = 0, start2 = 0, skip = 0, minStart = fork.end - maxBufferLength;
    let result = { size: 0, start: 0, skip: 0 };
    scan:
      for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
        let nodeSize2 = fork.size;
        if (fork.id == inRepeat && nodeSize2 >= 0) {
          result.size = size3;
          result.start = start2;
          result.skip = skip;
          skip += 4;
          size3 += 4;
          fork.next();
          continue;
        }
        let startPos = fork.pos - nodeSize2;
        if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
          break;
        let localSkipped = fork.id >= minRepeatType ? 4 : 0;
        let nodeStart2 = fork.start;
        fork.next();
        while (fork.pos > startPos) {
          if (fork.size < 0) {
            if (fork.size == -3)
              localSkipped += 4;
            else
              break scan;
          } else if (fork.id >= minRepeatType) {
            localSkipped += 4;
          }
          fork.next();
        }
        start2 = nodeStart2;
        size3 += nodeSize2;
        skip += localSkipped;
      }
    if (inRepeat < 0 || size3 == maxSize) {
      result.size = size3;
      result.start = start2;
      result.skip = skip;
    }
    return result.size > 4 ? result : void 0;
  }
  function copyToBuffer(bufferStart, buffer2, index4) {
    let { id, start: start2, end: end2, size: size3 } = cursor2;
    cursor2.next();
    if (size3 >= 0 && id < minRepeatType) {
      let startIndex = index4;
      if (size3 > 4) {
        let endPos = cursor2.pos - (size3 - 4);
        while (cursor2.pos > endPos)
          index4 = copyToBuffer(bufferStart, buffer2, index4);
      }
      buffer2[--index4] = startIndex;
      buffer2[--index4] = end2 - bufferStart;
      buffer2[--index4] = start2 - bufferStart;
      buffer2[--index4] = id;
    } else if (size3 == -3) {
      contextHash = id;
    } else if (size3 == -4) {
      lookAhead = id;
    }
    return index4;
  }
  let children = [], positions = [];
  while (cursor2.pos > 0)
    takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);
  let length2 = (_a2 = data.length) !== null && _a2 !== void 0 ? _a2 : children.length ? positions[0] + children[0].length : 0;
  return new Tree(types2[data.topID], children.reverse(), positions.reverse(), length2);
}
var nodeSizeCache = /* @__PURE__ */ new WeakMap();
function nodeSize(balanceType, node3) {
  if (!balanceType.isAnonymous || node3 instanceof TreeBuffer || node3.type != balanceType)
    return 1;
  let size3 = nodeSizeCache.get(node3);
  if (size3 == null) {
    size3 = 1;
    for (let child of node3.children) {
      if (child.type != balanceType || !(child instanceof Tree)) {
        size3 = 1;
        break;
      }
      size3 += nodeSize(balanceType, child);
    }
    nodeSizeCache.set(node3, size3);
  }
  return size3;
}
function balanceRange(balanceType, children, positions, from2, to, start2, length2, mkTop, mkTree) {
  let total = 0;
  for (let i2 = from2; i2 < to; i2++)
    total += nodeSize(balanceType, children[i2]);
  let maxChild = Math.ceil(
    total * 1.5 / 8
    /* Balance.BranchFactor */
  );
  let localChildren = [], localPositions = [];
  function divide(children2, positions2, from3, to2, offset3) {
    for (let i2 = from3; i2 < to2; ) {
      let groupFrom = i2, groupStart = positions2[i2], groupSize = nodeSize(balanceType, children2[i2]);
      i2++;
      for (; i2 < to2; i2++) {
        let nextSize = nodeSize(balanceType, children2[i2]);
        if (groupSize + nextSize >= maxChild)
          break;
        groupSize += nextSize;
      }
      if (i2 == groupFrom + 1) {
        if (groupSize > maxChild) {
          let only = children2[groupFrom];
          divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset3);
          continue;
        }
        localChildren.push(children2[groupFrom]);
      } else {
        let length3 = positions2[i2 - 1] + children2[i2 - 1].length - groupStart;
        localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i2, groupStart, length3, null, mkTree));
      }
      localPositions.push(groupStart + offset3 - start2);
    }
  }
  divide(children, positions, from2, to, 0);
  return (mkTop || mkTree)(localChildren, localPositions, length2);
}
var TreeFragment = class _TreeFragment {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(from2, to, tree, offset3, openStart = false, openEnd = false) {
    this.from = from2;
    this.to = to;
    this.tree = tree;
    this.offset = offset3;
    this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(tree, fragments = [], partial = false) {
    let result = [new _TreeFragment(0, tree.length, tree, 0, false, partial)];
    for (let f of fragments)
      if (f.to > tree.length)
        result.push(f);
    return result;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(fragments, changes, minGap = 128) {
    if (!changes.length)
      return fragments;
    let result = [];
    let fI = 1, nextF = fragments.length ? fragments[0] : null;
    for (let cI = 0, pos = 0, off2 = 0; ; cI++) {
      let nextC = cI < changes.length ? changes[cI] : null;
      let nextPos = nextC ? nextC.fromA : 1e9;
      if (nextPos - pos >= minGap)
        while (nextF && nextF.from < nextPos) {
          let cut = nextF;
          if (pos >= cut.from || nextPos <= cut.to || off2) {
            let fFrom = Math.max(cut.from, pos) - off2, fTo = Math.min(cut.to, nextPos) - off2;
            cut = fFrom >= fTo ? null : new _TreeFragment(fFrom, fTo, cut.tree, cut.offset + off2, cI > 0, !!nextC);
          }
          if (cut)
            result.push(cut);
          if (nextF.to > nextPos)
            break;
          nextF = fI < fragments.length ? fragments[fI++] : null;
        }
      if (!nextC)
        break;
      pos = nextC.toA;
      off2 = nextC.toA - nextC.toB;
    }
    return result;
  }
};
var Parser2 = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(input, fragments, ranges) {
    if (typeof input == "string")
      input = new StringInput(input);
    ranges = !ranges ? [new Range2(0, input.length)] : ranges.length ? ranges.map((r2) => new Range2(r2.from, r2.to)) : [new Range2(0, 0)];
    return this.createParse(input, fragments || [], ranges);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(input, fragments, ranges) {
    let parse5 = this.startParse(input, fragments, ranges);
    for (; ; ) {
      let done = parse5.advance();
      if (done)
        return done;
    }
  }
};
var StringInput = class {
  constructor(string3) {
    this.string = string3;
  }
  get length() {
    return this.string.length;
  }
  chunk(from2) {
    return this.string.slice(from2);
  }
  get lineChunks() {
    return false;
  }
  read(from2, to) {
    return this.string.slice(from2, to);
  }
};
var stoppedInner = new NodeProp({ perNode: true });

// node_modules/@lezer/highlight/dist/index.js
var nextTagID = 0;
var Tag3 = class _Tag {
  /**
  @internal
  */
  constructor(set2, base2, modified) {
    this.set = set2;
    this.base = base2;
    this.modified = modified;
    this.id = nextTagID++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and
  [highlighters](#highlight.tagHighlighter) that don't mention
  this tag will try to fall back to the parent tag (or grandparent
  tag, etc).
  */
  static define(parent) {
    if (parent === null || parent === void 0 ? void 0 : parent.base)
      throw new Error("Can not derive from a modified tag");
    let tag = new _Tag([], null, []);
    tag.set.push(tag);
    if (parent)
      for (let t4 of parent.set)
        tag.set.push(t4);
    return tag;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier() {
    let mod = new Modifier();
    return (tag) => {
      if (tag.modified.indexOf(mod) > -1)
        return tag;
      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a3, b2) => a3.id - b2.id));
    };
  }
};
var nextModifierID = 0;
var Modifier = class _Modifier {
  constructor() {
    this.instances = [];
    this.id = nextModifierID++;
  }
  static get(base2, mods) {
    if (!mods.length)
      return base2;
    let exists = mods[0].instances.find((t4) => t4.base == base2 && sameArray2(mods, t4.modified));
    if (exists)
      return exists;
    let set2 = [], tag = new Tag3(set2, base2, mods);
    for (let m3 of mods)
      m3.instances.push(tag);
    let configs = powerSet(mods);
    for (let parent of base2.set)
      if (!parent.modified.length)
        for (let config2 of configs)
          set2.push(_Modifier.get(parent, config2));
    return tag;
  }
};
function sameArray2(a3, b2) {
  return a3.length == b2.length && a3.every((x2, i2) => x2 == b2[i2]);
}
function powerSet(array) {
  let sets = [[]];
  for (let i2 = 0; i2 < array.length; i2++) {
    for (let j = 0, e4 = sets.length; j < e4; j++) {
      sets.push(sets[j].concat(array[i2]));
    }
  }
  return sets.sort((a3, b2) => b2.length - a3.length);
}
function styleTags(spec) {
  let byName = /* @__PURE__ */ Object.create(null);
  for (let prop in spec) {
    let tags2 = spec[prop];
    if (!Array.isArray(tags2))
      tags2 = [tags2];
    for (let part of prop.split(" "))
      if (part) {
        let pieces = [], mode = 2, rest = part;
        for (let pos = 0; ; ) {
          if (rest == "..." && pos > 0 && pos + 3 == part.length) {
            mode = 1;
            break;
          }
          let m3 = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
          if (!m3)
            throw new RangeError("Invalid path: " + part);
          pieces.push(m3[0] == "*" ? "" : m3[0][0] == '"' ? JSON.parse(m3[0]) : m3[0]);
          pos += m3[0].length;
          if (pos == part.length)
            break;
          let next2 = part[pos++];
          if (pos == part.length && next2 == "!") {
            mode = 0;
            break;
          }
          if (next2 != "/")
            throw new RangeError("Invalid path: " + part);
          rest = part.slice(pos);
        }
        let last = pieces.length - 1, inner = pieces[last];
        if (!inner)
          throw new RangeError("Invalid path: " + part);
        let rule = new Rule(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
        byName[inner] = rule.sort(byName[inner]);
      }
  }
  return ruleNodeProp.add(byName);
}
var ruleNodeProp = new NodeProp();
var Rule = class {
  constructor(tags2, mode, context, next2) {
    this.tags = tags2;
    this.mode = mode;
    this.context = context;
    this.next = next2;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(other) {
    if (!other || other.depth < this.depth) {
      this.next = other;
      return this;
    }
    other.next = this.sort(other.next);
    return other;
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
};
Rule.empty = new Rule([], 2, null);
function tagHighlighter(tags2, options2) {
  let map = /* @__PURE__ */ Object.create(null);
  for (let style of tags2) {
    if (!Array.isArray(style.tag))
      map[style.tag.id] = style.class;
    else
      for (let tag of style.tag)
        map[tag.id] = style.class;
  }
  let { scope, all = null } = options2 || {};
  return {
    style: (tags3) => {
      let cls = all;
      for (let tag of tags3) {
        for (let sub2 of tag.set) {
          let tagClass = map[sub2.id];
          if (tagClass) {
            cls = cls ? cls + " " + tagClass : tagClass;
            break;
          }
        }
      }
      return cls;
    },
    scope
  };
}
function highlightTags(highlighters, tags2) {
  let result = null;
  for (let highlighter3 of highlighters) {
    let value = highlighter3.style(tags2);
    if (value)
      result = result ? result + " " + value : value;
  }
  return result;
}
function highlightTree(tree, highlighter3, putStyle, from2 = 0, to = tree.length) {
  let builder = new HighlightBuilder(from2, Array.isArray(highlighter3) ? highlighter3 : [highlighter3], putStyle);
  builder.highlightRange(tree.cursor(), from2, to, "", builder.highlighters);
  builder.flush(to);
}
var HighlightBuilder = class {
  constructor(at2, highlighters, span) {
    this.at = at2;
    this.highlighters = highlighters;
    this.span = span;
    this.class = "";
  }
  startSpan(at2, cls) {
    if (cls != this.class) {
      this.flush(at2);
      if (at2 > this.at)
        this.at = at2;
      this.class = cls;
    }
  }
  flush(to) {
    if (to > this.at && this.class)
      this.span(this.at, to, this.class);
  }
  highlightRange(cursor2, from2, to, inheritedClass, highlighters) {
    let { type, from: start2, to: end2 } = cursor2;
    if (start2 >= to || end2 <= from2)
      return;
    if (type.isTop)
      highlighters = this.highlighters.filter((h3) => !h3.scope || h3.scope(type));
    let cls = inheritedClass;
    let rule = getStyleTags(cursor2) || Rule.empty;
    let tagCls = highlightTags(highlighters, rule.tags);
    if (tagCls) {
      if (cls)
        cls += " ";
      cls += tagCls;
      if (rule.mode == 1)
        inheritedClass += (inheritedClass ? " " : "") + tagCls;
    }
    this.startSpan(Math.max(from2, start2), cls);
    if (rule.opaque)
      return;
    let mounted = cursor2.tree && cursor2.tree.prop(NodeProp.mounted);
    if (mounted && mounted.overlay) {
      let inner = cursor2.node.enter(mounted.overlay[0].from + start2, 1);
      let innerHighlighters = this.highlighters.filter((h3) => !h3.scope || h3.scope(mounted.tree.type));
      let hasChild2 = cursor2.firstChild();
      for (let i2 = 0, pos = start2; ; i2++) {
        let next2 = i2 < mounted.overlay.length ? mounted.overlay[i2] : null;
        let nextPos = next2 ? next2.from + start2 : end2;
        let rangeFrom = Math.max(from2, pos), rangeTo = Math.min(to, nextPos);
        if (rangeFrom < rangeTo && hasChild2) {
          while (cursor2.from < rangeTo) {
            this.highlightRange(cursor2, rangeFrom, rangeTo, inheritedClass, highlighters);
            this.startSpan(Math.min(rangeTo, cursor2.to), cls);
            if (cursor2.to >= nextPos || !cursor2.nextSibling())
              break;
          }
        }
        if (!next2 || nextPos > to)
          break;
        pos = next2.to + start2;
        if (pos > from2) {
          this.highlightRange(inner.cursor(), Math.max(from2, next2.from + start2), Math.min(to, pos), "", innerHighlighters);
          this.startSpan(Math.min(to, pos), cls);
        }
      }
      if (hasChild2)
        cursor2.parent();
    } else if (cursor2.firstChild()) {
      if (mounted)
        inheritedClass = "";
      do {
        if (cursor2.to <= from2)
          continue;
        if (cursor2.from >= to)
          break;
        this.highlightRange(cursor2, from2, to, inheritedClass, highlighters);
        this.startSpan(Math.min(to, cursor2.to), cls);
      } while (cursor2.nextSibling());
      cursor2.parent();
    }
  }
};
function getStyleTags(node3) {
  let rule = node3.type.prop(ruleNodeProp);
  while (rule && rule.context && !node3.matchContext(rule.context))
    rule = rule.next;
  return rule || null;
}
var t3 = Tag3.define;
var comment2 = t3();
var name = t3();
var typeName = t3(name);
var propertyName = t3(name);
var literal = t3();
var string2 = t3(literal);
var number = t3(literal);
var content = t3();
var heading = t3(content);
var keyword = t3();
var operator = t3();
var punctuation = t3();
var bracket = t3(punctuation);
var meta = t3();
var tags = {
  /**
  A comment.
  */
  comment: comment2,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: t3(comment2),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: t3(comment2),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: t3(comment2),
  /**
  Any kind of identifier.
  */
  name,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: t3(name),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: t3(typeName),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: t3(propertyName),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: t3(name),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: t3(name),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: t3(name),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: t3(name),
  /**
  A literal value.
  */
  literal,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: string2,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: t3(string2),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: t3(string2),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: t3(string2),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: t3(number),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: t3(number),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: t3(literal),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: t3(literal),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: t3(literal),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: t3(literal),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: t3(literal),
  /**
  A language keyword.
  */
  keyword,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: t3(keyword),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: t3(keyword),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: t3(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: t3(keyword),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: t3(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: t3(keyword),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: t3(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: t3(keyword),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: t3(keyword),
  /**
  An operator.
  */
  operator,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: t3(operator),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: t3(operator),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: t3(operator),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: t3(operator),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: t3(operator),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: t3(operator),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: t3(operator),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: t3(operator),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: t3(operator),
  /**
  Program or markup punctuation.
  */
  punctuation,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: t3(punctuation),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: t3(bracket),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: t3(bracket),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: t3(bracket),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: t3(bracket),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: t3(heading),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: t3(heading),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: t3(heading),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: t3(heading),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: t3(heading),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: t3(heading),
  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: t3(content),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: t3(content),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: t3(content),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: t3(content),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: t3(content),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: t3(content),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: t3(content),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: t3(content),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: t3(),
  /**
  Deleted text.
  */
  deleted: t3(),
  /**
  Changed text.
  */
  changed: t3(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: t3(),
  /**
  Metadata or meta-instruction.
  */
  meta,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: t3(meta),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: t3(meta),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: t3(meta),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Tag3.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Tag3.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Tag3.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Tag3.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Tag3.defineModifier(),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Tag3.defineModifier()
};
var classHighlighter = tagHighlighter([
  { tag: tags.link, class: "tok-link" },
  { tag: tags.heading, class: "tok-heading" },
  { tag: tags.emphasis, class: "tok-emphasis" },
  { tag: tags.strong, class: "tok-strong" },
  { tag: tags.keyword, class: "tok-keyword" },
  { tag: tags.atom, class: "tok-atom" },
  { tag: tags.bool, class: "tok-bool" },
  { tag: tags.url, class: "tok-url" },
  { tag: tags.labelName, class: "tok-labelName" },
  { tag: tags.inserted, class: "tok-inserted" },
  { tag: tags.deleted, class: "tok-deleted" },
  { tag: tags.literal, class: "tok-literal" },
  { tag: tags.string, class: "tok-string" },
  { tag: tags.number, class: "tok-number" },
  { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
  { tag: tags.variableName, class: "tok-variableName" },
  { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
  { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
  { tag: tags.special(tags.variableName), class: "tok-variableName2" },
  { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
  { tag: tags.typeName, class: "tok-typeName" },
  { tag: tags.namespace, class: "tok-namespace" },
  { tag: tags.className, class: "tok-className" },
  { tag: tags.macroName, class: "tok-macroName" },
  { tag: tags.propertyName, class: "tok-propertyName" },
  { tag: tags.operator, class: "tok-operator" },
  { tag: tags.comment, class: "tok-comment" },
  { tag: tags.meta, class: "tok-meta" },
  { tag: tags.invalid, class: "tok-invalid" },
  { tag: tags.punctuation, class: "tok-punctuation" }
]);

// node_modules/@codemirror/language/dist/index.js
var _a;
var languageDataProp = new NodeProp();
function defineLanguageFacet(baseData) {
  return Facet.define({
    combine: baseData ? (values) => values.concat(baseData) : void 0
  });
}
var sublanguageProp = new NodeProp();
var Language = class {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(data, parser, extraExtensions = [], name2 = "") {
    this.data = data;
    this.name = name2;
    if (!EditorState.prototype.hasOwnProperty("tree"))
      Object.defineProperty(EditorState.prototype, "tree", { get() {
        return syntaxTree(this);
      } });
    this.parser = parser;
    this.extension = [
      language.of(this),
      EditorState.languageData.of((state, pos, side) => {
        let top3 = topNodeAt(state, pos, side), data2 = top3.type.prop(languageDataProp);
        if (!data2)
          return [];
        let base2 = state.facet(data2), sub2 = top3.type.prop(sublanguageProp);
        if (sub2) {
          let innerNode = top3.resolve(pos - top3.from, side);
          for (let sublang of sub2)
            if (sublang.test(innerNode, state)) {
              let data3 = state.facet(sublang.facet);
              return sublang.type == "replace" ? data3 : data3.concat(base2);
            }
        }
        return base2;
      })
    ].concat(extraExtensions);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(state, pos, side = -1) {
    return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(state) {
    let lang = state.facet(language);
    if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
      return [{ from: 0, to: state.doc.length }];
    if (!lang || !lang.allowsNesting)
      return [];
    let result = [];
    let explore = (tree, from2) => {
      if (tree.prop(languageDataProp) == this.data) {
        result.push({ from: from2, to: from2 + tree.length });
        return;
      }
      let mount = tree.prop(NodeProp.mounted);
      if (mount) {
        if (mount.tree.prop(languageDataProp) == this.data) {
          if (mount.overlay)
            for (let r2 of mount.overlay)
              result.push({ from: r2.from + from2, to: r2.to + from2 });
          else
            result.push({ from: from2, to: from2 + tree.length });
          return;
        } else if (mount.overlay) {
          let size3 = result.length;
          explore(mount.tree, mount.overlay[0].from + from2);
          if (result.length > size3)
            return;
        }
      }
      for (let i2 = 0; i2 < tree.children.length; i2++) {
        let ch = tree.children[i2];
        if (ch instanceof Tree)
          explore(ch, tree.positions[i2] + from2);
      }
    };
    explore(syntaxTree(state), 0);
    return result;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return true;
  }
};
Language.setState = StateEffect.define();
function topNodeAt(state, pos, side) {
  let topLang = state.facet(language), tree = syntaxTree(state).topNode;
  if (!topLang || topLang.allowsNesting) {
    for (let node3 = tree; node3; node3 = node3.enter(pos, side, IterMode.ExcludeBuffers))
      if (node3.type.isTop)
        tree = node3;
  }
  return tree;
}
function syntaxTree(state) {
  let field = state.field(Language.state, false);
  return field ? field.tree : Tree.empty;
}
var DocInput = class {
  /**
  Create an input object for the given document.
  */
  constructor(doc2) {
    this.doc = doc2;
    this.cursorPos = 0;
    this.string = "";
    this.cursor = doc2.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(pos) {
    this.string = this.cursor.next(pos - this.cursorPos).value;
    this.cursorPos = pos + this.string.length;
    return this.cursorPos - this.string.length;
  }
  chunk(pos) {
    this.syncTo(pos);
    return this.string;
  }
  get lineChunks() {
    return true;
  }
  read(from2, to) {
    let stringStart = this.cursorPos - this.string.length;
    if (from2 < stringStart || to >= this.cursorPos)
      return this.doc.sliceString(from2, to);
    else
      return this.string.slice(from2 - stringStart, to - stringStart);
  }
};
var currentContext = null;
var ParseContext = class _ParseContext {
  constructor(parser, state, fragments = [], tree, treeLen, viewport2, skipped, scheduleOn) {
    this.parser = parser;
    this.state = state;
    this.fragments = fragments;
    this.tree = tree;
    this.treeLen = treeLen;
    this.viewport = viewport2;
    this.skipped = skipped;
    this.scheduleOn = scheduleOn;
    this.parse = null;
    this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(parser, state, viewport2) {
    return new _ParseContext(parser, state, [], Tree.empty, 0, viewport2, [], null);
  }
  startParse() {
    return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(until, upto) {
    if (upto != null && upto >= this.state.doc.length)
      upto = void 0;
    if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
      this.takeTree();
      return true;
    }
    return this.withContext(() => {
      var _a2;
      if (typeof until == "number") {
        let endTime = Date.now() + until;
        until = () => Date.now() > endTime;
      }
      if (!this.parse)
        this.parse = this.startParse();
      if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
        this.parse.stopAt(upto);
      for (; ; ) {
        let done = this.parse.advance();
        if (done) {
          this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
          this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
          this.tree = done;
          this.parse = null;
          if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
            this.parse = this.startParse();
          else
            return true;
        }
        if (until())
          return false;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let pos, tree;
    if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
      if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
        this.parse.stopAt(pos);
      this.withContext(() => {
        while (!(tree = this.parse.advance())) {
        }
      });
      this.treeLen = pos;
      this.tree = tree;
      this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
      this.parse = null;
    }
  }
  withContext(f) {
    let prev2 = currentContext;
    currentContext = this;
    try {
      return f();
    } finally {
      currentContext = prev2;
    }
  }
  withoutTempSkipped(fragments) {
    for (let r2; r2 = this.tempSkipped.pop(); )
      fragments = cutFragments(fragments, r2.from, r2.to);
    return fragments;
  }
  /**
  @internal
  */
  changes(changes, newState) {
    let { fragments, tree, treeLen, viewport: viewport2, skipped } = this;
    this.takeTree();
    if (!changes.empty) {
      let ranges = [];
      changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
      fragments = TreeFragment.applyChanges(fragments, ranges);
      tree = Tree.empty;
      treeLen = 0;
      viewport2 = { from: changes.mapPos(viewport2.from, -1), to: changes.mapPos(viewport2.to, 1) };
      if (this.skipped.length) {
        skipped = [];
        for (let r2 of this.skipped) {
          let from2 = changes.mapPos(r2.from, 1), to = changes.mapPos(r2.to, -1);
          if (from2 < to)
            skipped.push({ from: from2, to });
        }
      }
    }
    return new _ParseContext(this.parser, newState, fragments, tree, treeLen, viewport2, skipped, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(viewport2) {
    if (this.viewport.from == viewport2.from && this.viewport.to == viewport2.to)
      return false;
    this.viewport = viewport2;
    let startLen = this.skipped.length;
    for (let i2 = 0; i2 < this.skipped.length; i2++) {
      let { from: from2, to } = this.skipped[i2];
      if (from2 < viewport2.to && to > viewport2.from) {
        this.fragments = cutFragments(this.fragments, from2, to);
        this.skipped.splice(i2--, 1);
      }
    }
    if (this.skipped.length >= startLen)
      return false;
    this.reset();
    return true;
  }
  /**
  @internal
  */
  reset() {
    if (this.parse) {
      this.takeTree();
      this.parse = null;
    }
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(from2, to) {
    this.skipped.push({ from: from2, to });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(until) {
    return new class extends Parser2 {
      createParse(input, fragments, ranges) {
        let from2 = ranges[0].from, to = ranges[ranges.length - 1].to;
        let parser = {
          parsedPos: from2,
          advance() {
            let cx = currentContext;
            if (cx) {
              for (let r2 of ranges)
                cx.tempSkipped.push(r2);
              if (until)
                cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
            }
            this.parsedPos = to;
            return new Tree(NodeType.none, [], [], to - from2);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
        return parser;
      }
    }();
  }
  /**
  @internal
  */
  isDone(upto) {
    upto = Math.min(upto, this.state.doc.length);
    let frags = this.fragments;
    return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return currentContext;
  }
};
function cutFragments(fragments, from2, to) {
  return TreeFragment.applyChanges(fragments, [{ fromA: from2, toA: to, fromB: from2, toB: to }]);
}
var LanguageState = class _LanguageState {
  constructor(context) {
    this.context = context;
    this.tree = context.tree;
  }
  apply(tr2) {
    if (!tr2.docChanged && this.tree == this.context.tree)
      return this;
    let newCx = this.context.changes(tr2.changes, tr2.state);
    let upto = this.context.treeLen == tr2.startState.doc.length ? void 0 : Math.max(tr2.changes.mapPos(this.context.treeLen), newCx.viewport.to);
    if (!newCx.work(20, upto))
      newCx.takeTree();
    return new _LanguageState(newCx);
  }
  static init(state) {
    let vpTo = Math.min(3e3, state.doc.length);
    let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
    if (!parseState.work(20, vpTo))
      parseState.takeTree();
    return new _LanguageState(parseState);
  }
};
Language.state = StateField.define({
  create: LanguageState.init,
  update(value, tr2) {
    for (let e4 of tr2.effects)
      if (e4.is(Language.setState))
        return e4.value;
    if (tr2.startState.facet(language) != tr2.state.facet(language))
      return LanguageState.init(tr2.state);
    return value.apply(tr2);
  }
});
var requestIdle = (callback) => {
  let timeout = setTimeout(
    () => callback(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(timeout);
};
if (typeof requestIdleCallback != "undefined")
  requestIdle = (callback) => {
    let idle = -1, timeout = setTimeout(
      () => {
        idle = requestIdleCallback(callback, {
          timeout: 500 - 100
          /* Work.MinPause */
        });
      },
      100
      /* Work.MinPause */
    );
    return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
  };
var isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
var parseWorker = ViewPlugin.fromClass(class ParseWorker {
  constructor(view) {
    this.view = view;
    this.working = null;
    this.workScheduled = 0;
    this.chunkEnd = -1;
    this.chunkBudget = -1;
    this.work = this.work.bind(this);
    this.scheduleWork();
  }
  update(update) {
    let cx = this.view.state.field(Language.state).context;
    if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
      this.scheduleWork();
    if (update.docChanged || update.selectionSet) {
      if (this.view.hasFocus)
        this.chunkBudget += 50;
      this.scheduleWork();
    }
    this.checkAsyncSchedule(cx);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state } = this.view, field = state.field(Language.state);
    if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
      this.working = requestIdle(this.work);
  }
  work(deadline) {
    this.working = null;
    let now = Date.now();
    if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
      this.chunkEnd = now + 3e4;
      this.chunkBudget = 3e3;
    }
    if (this.chunkBudget <= 0)
      return;
    let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
    if (field.tree == field.context.tree && field.context.isDone(
      vpTo + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
    let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
    let done = field.context.work(() => {
      return isInputPending && isInputPending() || Date.now() > endTime;
    }, vpTo + (viewportFirst ? 0 : 1e5));
    this.chunkBudget -= Date.now() - now;
    if (done || this.chunkBudget <= 0) {
      field.context.takeTree();
      this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
    }
    if (this.chunkBudget > 0 && !(done && !viewportFirst))
      this.scheduleWork();
    this.checkAsyncSchedule(field.context);
  }
  checkAsyncSchedule(cx) {
    if (cx.scheduleOn) {
      this.workScheduled++;
      cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
      cx.scheduleOn = null;
    }
  }
  destroy() {
    if (this.working)
      this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
});
var language = Facet.define({
  combine(languages) {
    return languages.length ? languages[0] : null;
  },
  enables: (language2) => [
    Language.state,
    parseWorker,
    EditorView.contentAttributes.compute([language2], (state) => {
      let lang = state.facet(language2);
      return lang && lang.name ? { "data-language": lang.name } : {};
    })
  ]
});
var indentService = Facet.define();
var indentUnit = Facet.define({
  combine: (values) => {
    if (!values.length)
      return "  ";
    let unit = values[0];
    if (!unit || /\S/.test(unit) || Array.from(unit).some((e4) => e4 != unit[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
    return unit;
  }
});
function getIndentUnit(state) {
  let unit = state.facet(indentUnit);
  return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
}
function indentString(state, cols) {
  let result = "", ts = state.tabSize, ch = state.facet(indentUnit)[0];
  if (ch == "	") {
    while (cols >= ts) {
      result += "	";
      cols -= ts;
    }
    ch = " ";
  }
  for (let i2 = 0; i2 < cols; i2++)
    result += ch;
  return result;
}
function getIndentation(context, pos) {
  if (context instanceof EditorState)
    context = new IndentContext(context);
  for (let service of context.state.facet(indentService)) {
    let result = service(context, pos);
    if (result !== void 0)
      return result;
  }
  let tree = syntaxTree(context.state);
  return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;
}
var IndentContext = class {
  /**
  Create an indent context.
  */
  constructor(state, options2 = {}) {
    this.state = state;
    this.options = options2;
    this.unit = getIndentUnit(state);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(pos, bias = 1) {
    let line2 = this.state.doc.lineAt(pos);
    let { simulateBreak, simulateDoubleBreak } = this.options;
    if (simulateBreak != null && simulateBreak >= line2.from && simulateBreak <= line2.to) {
      if (simulateDoubleBreak && simulateBreak == pos)
        return { text: "", from: pos };
      else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
        return { text: line2.text.slice(simulateBreak - line2.from), from: simulateBreak };
      else
        return { text: line2.text.slice(0, simulateBreak - line2.from), from: line2.from };
    }
    return line2;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(pos, bias = 1) {
    if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
      return "";
    let { text, from: from2 } = this.lineAt(pos, bias);
    return text.slice(pos - from2, Math.min(text.length, pos + 100 - from2));
  }
  /**
  Find the column for the given position.
  */
  column(pos, bias = 1) {
    let { text, from: from2 } = this.lineAt(pos, bias);
    let result = this.countColumn(text, pos - from2);
    let override = this.options.overrideIndentation ? this.options.overrideIndentation(from2) : -1;
    if (override > -1)
      result += override - this.countColumn(text, text.search(/\S|$/));
    return result;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(line2, pos = line2.length) {
    return countColumn(line2, this.state.tabSize, pos);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(pos, bias = 1) {
    let { text, from: from2 } = this.lineAt(pos, bias);
    let override = this.options.overrideIndentation;
    if (override) {
      let overriden = override(from2);
      if (overriden > -1)
        return overriden;
    }
    return this.countColumn(text, text.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
};
var indentNodeProp = new NodeProp();
function syntaxIndentation(cx, ast, pos) {
  let stack = ast.resolveStack(pos);
  let inner = stack.node.enterUnfinishedNodesBefore(pos);
  if (inner != stack.node) {
    let add3 = [];
    for (let cur2 = inner; cur2 != stack.node; cur2 = cur2.parent)
      add3.push(cur2);
    for (let i2 = add3.length - 1; i2 >= 0; i2--)
      stack = { node: add3[i2], next: stack };
  }
  return indentFor(stack, cx, pos);
}
function indentFor(stack, cx, pos) {
  for (let cur2 = stack; cur2; cur2 = cur2.next) {
    let strategy = indentStrategy(cur2.node);
    if (strategy)
      return strategy(TreeIndentContext.create(cx, pos, cur2));
  }
  return 0;
}
function ignoreClosed(cx) {
  return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
}
function indentStrategy(tree) {
  let strategy = tree.type.prop(indentNodeProp);
  if (strategy)
    return strategy;
  let first = tree.firstChild, close;
  if (first && (close = first.type.prop(NodeProp.closedBy))) {
    let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
    return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last.from : void 0);
  }
  return tree.parent == null ? topIndent : null;
}
function topIndent() {
  return 0;
}
var TreeIndentContext = class _TreeIndentContext extends IndentContext {
  constructor(base2, pos, context) {
    super(base2.state, base2.options);
    this.base = base2;
    this.pos = pos;
    this.context = context;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(base2, pos, context) {
    return new _TreeIndentContext(base2, pos, context);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(node3) {
    let line2 = this.state.doc.lineAt(node3.from);
    for (; ; ) {
      let atBreak = node3.resolve(line2.from);
      while (atBreak.parent && atBreak.parent.from == atBreak.from)
        atBreak = atBreak.parent;
      if (isParent(atBreak, node3))
        break;
      line2 = this.state.doc.lineAt(atBreak.from);
    }
    return this.lineIndent(line2.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return indentFor(this.context.next, this.base, this.pos);
  }
};
function isParent(parent, of) {
  for (let cur2 = of; cur2; cur2 = cur2.parent)
    if (parent == cur2)
      return true;
  return false;
}
function bracketedAligned(context) {
  let tree = context.node;
  let openToken = tree.childAfter(tree.from), last = tree.lastChild;
  if (!openToken)
    return null;
  let sim = context.options.simulateBreak;
  let openLine = context.state.doc.lineAt(openToken.from);
  let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
  for (let pos = openToken.to; ; ) {
    let next2 = tree.childAfter(pos);
    if (!next2 || next2 == last)
      return null;
    if (!next2.type.isSkipped)
      return next2.from < lineEnd ? openToken : null;
    pos = next2.to;
  }
}
function delimitedStrategy(context, align, units, closing2, closedAt) {
  let after = context.textAfter, space = after.match(/^\s*/)[0].length;
  let closed = closing2 && after.slice(space, space + closing2.length) == closing2 || closedAt == context.pos + space;
  let aligned = align ? bracketedAligned(context) : null;
  if (aligned)
    return closed ? context.column(aligned.from) : context.column(aligned.to);
  return context.baseIndent + (closed ? 0 : context.unit * units);
}
var DontIndentBeyond = 200;
function indentOnInput() {
  return EditorState.transactionFilter.of((tr2) => {
    if (!tr2.docChanged || !tr2.isUserEvent("input.type") && !tr2.isUserEvent("input.complete"))
      return tr2;
    let rules = tr2.startState.languageDataAt("indentOnInput", tr2.startState.selection.main.head);
    if (!rules.length)
      return tr2;
    let doc2 = tr2.newDoc, { head } = tr2.newSelection.main, line2 = doc2.lineAt(head);
    if (head > line2.from + DontIndentBeyond)
      return tr2;
    let lineStart = doc2.sliceString(line2.from, head);
    if (!rules.some((r2) => r2.test(lineStart)))
      return tr2;
    let { state } = tr2, last = -1, changes = [];
    for (let { head: head2 } of state.selection.ranges) {
      let line3 = state.doc.lineAt(head2);
      if (line3.from == last)
        continue;
      last = line3.from;
      let indent = getIndentation(state, line3.from);
      if (indent == null)
        continue;
      let cur2 = /^\s*/.exec(line3.text)[0];
      let norm2 = indentString(state, indent);
      if (cur2 != norm2)
        changes.push({ from: line3.from, to: line3.from + cur2.length, insert: norm2 });
    }
    return changes.length ? [tr2, { changes, sequential: true }] : tr2;
  });
}
var foldService = Facet.define();
var foldNodeProp = new NodeProp();
function syntaxFolding(state, start2, end2) {
  let tree = syntaxTree(state);
  if (tree.length < end2)
    return null;
  let stack = tree.resolveStack(end2, 1);
  let found = null;
  for (let iter = stack; iter; iter = iter.next) {
    let cur2 = iter.node;
    if (cur2.to <= end2 || cur2.from > end2)
      continue;
    if (found && cur2.from < start2)
      break;
    let prop = cur2.type.prop(foldNodeProp);
    if (prop && (cur2.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur2))) {
      let value = prop(cur2, state);
      if (value && value.from <= end2 && value.from >= start2 && value.to > end2)
        found = value;
    }
  }
  return found;
}
function isUnfinished(node3) {
  let ch = node3.lastChild;
  return ch && ch.to == node3.to && ch.type.isError;
}
function foldable(state, lineStart, lineEnd) {
  for (let service of state.facet(foldService)) {
    let result = service(state, lineStart, lineEnd);
    if (result)
      return result;
  }
  return syntaxFolding(state, lineStart, lineEnd);
}
function mapRange(range, mapping) {
  let from2 = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);
  return from2 >= to ? void 0 : { from: from2, to };
}
var foldEffect = StateEffect.define({ map: mapRange });
var unfoldEffect = StateEffect.define({ map: mapRange });
function selectedLines(view) {
  let lines = [];
  for (let { head } of view.state.selection.ranges) {
    if (lines.some((l) => l.from <= head && l.to >= head))
      continue;
    lines.push(view.lineBlockAt(head));
  }
  return lines;
}
var foldState = StateField.define({
  create() {
    return Decoration.none;
  },
  update(folded, tr2) {
    folded = folded.map(tr2.changes);
    for (let e4 of tr2.effects) {
      if (e4.is(foldEffect) && !foldExists(folded, e4.value.from, e4.value.to)) {
        let { preparePlaceholder } = tr2.state.facet(foldConfig);
        let widget = !preparePlaceholder ? foldWidget : Decoration.replace({ widget: new PreparedFoldWidget(preparePlaceholder(tr2.state, e4.value)) });
        folded = folded.update({ add: [widget.range(e4.value.from, e4.value.to)] });
      } else if (e4.is(unfoldEffect)) {
        folded = folded.update({
          filter: (from2, to) => e4.value.from != from2 || e4.value.to != to,
          filterFrom: e4.value.from,
          filterTo: e4.value.to
        });
      }
    }
    if (tr2.selection) {
      let onSelection = false, { head } = tr2.selection.main;
      folded.between(head, head, (a3, b2) => {
        if (a3 < head && b2 > head)
          onSelection = true;
      });
      if (onSelection)
        folded = folded.update({
          filterFrom: head,
          filterTo: head,
          filter: (a3, b2) => b2 <= head || a3 >= head
        });
    }
    return folded;
  },
  provide: (f) => EditorView.decorations.from(f),
  toJSON(folded, state) {
    let ranges = [];
    folded.between(0, state.doc.length, (from2, to) => {
      ranges.push(from2, to);
    });
    return ranges;
  },
  fromJSON(value) {
    if (!Array.isArray(value) || value.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let ranges = [];
    for (let i2 = 0; i2 < value.length; ) {
      let from2 = value[i2++], to = value[i2++];
      if (typeof from2 != "number" || typeof to != "number")
        throw new RangeError("Invalid JSON for fold state");
      ranges.push(foldWidget.range(from2, to));
    }
    return Decoration.set(ranges, true);
  }
});
function findFold(state, from2, to) {
  var _a2;
  let found = null;
  (_a2 = state.field(foldState, false)) === null || _a2 === void 0 ? void 0 : _a2.between(from2, to, (from3, to2) => {
    if (!found || found.from > from3)
      found = { from: from3, to: to2 };
  });
  return found;
}
function foldExists(folded, from2, to) {
  let found = false;
  folded.between(from2, from2, (a3, b2) => {
    if (a3 == from2 && b2 == to)
      found = true;
  });
  return found;
}
function maybeEnable(state, other) {
  return state.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));
}
var foldCode = (view) => {
  for (let line2 of selectedLines(view)) {
    let range = foldable(view.state, line2.from, line2.to);
    if (range) {
      view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)]) });
      return true;
    }
  }
  return false;
};
var unfoldCode = (view) => {
  if (!view.state.field(foldState, false))
    return false;
  let effects = [];
  for (let line2 of selectedLines(view)) {
    let folded = findFold(view.state, line2.from, line2.to);
    if (folded)
      effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
  }
  if (effects.length)
    view.dispatch({ effects });
  return effects.length > 0;
};
function announceFold(view, range, fold = true) {
  let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;
  return EditorView.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
}
var foldAll = (view) => {
  let { state } = view, effects = [];
  for (let pos = 0; pos < state.doc.length; ) {
    let line2 = view.lineBlockAt(pos), range = foldable(state, line2.from, line2.to);
    if (range)
      effects.push(foldEffect.of(range));
    pos = (range ? view.lineBlockAt(range.to) : line2).to + 1;
  }
  if (effects.length)
    view.dispatch({ effects: maybeEnable(view.state, effects) });
  return !!effects.length;
};
var unfoldAll = (view) => {
  let field = view.state.field(foldState, false);
  if (!field || !field.size)
    return false;
  let effects = [];
  field.between(0, view.state.doc.length, (from2, to) => {
    effects.push(unfoldEffect.of({ from: from2, to }));
  });
  view.dispatch({ effects });
  return true;
};
var foldKeymap = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode },
  { key: "Ctrl-Alt-[", run: foldAll },
  { key: "Ctrl-Alt-]", run: unfoldAll }
];
var defaultConfig = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: ""
};
var foldConfig = Facet.define({
  combine(values) {
    return combineConfig(values, defaultConfig);
  }
});
function codeFolding(config2) {
  let result = [foldState, baseTheme$12];
  if (config2)
    result.push(foldConfig.of(config2));
  return result;
}
function widgetToDOM(view, prepared) {
  let { state } = view, conf = state.facet(foldConfig);
  let onclick = (event) => {
    let line2 = view.lineBlockAt(view.posAtDOM(event.target));
    let folded = findFold(view.state, line2.from, line2.to);
    if (folded)
      view.dispatch({ effects: unfoldEffect.of(folded) });
    event.preventDefault();
  };
  if (conf.placeholderDOM)
    return conf.placeholderDOM(view, onclick, prepared);
  let element = document.createElement("span");
  element.textContent = conf.placeholderText;
  element.setAttribute("aria-label", state.phrase("folded code"));
  element.title = state.phrase("unfold");
  element.className = "cm-foldPlaceholder";
  element.onclick = onclick;
  return element;
}
var foldWidget = Decoration.replace({ widget: new class extends WidgetType {
  toDOM(view) {
    return widgetToDOM(view, null);
  }
}() });
var PreparedFoldWidget = class extends WidgetType {
  constructor(value) {
    super();
    this.value = value;
  }
  eq(other) {
    return this.value == other.value;
  }
  toDOM(view) {
    return widgetToDOM(view, this.value);
  }
};
var baseTheme$12 = EditorView.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
var HighlightStyle = class _HighlightStyle {
  constructor(specs, options2) {
    this.specs = specs;
    let modSpec;
    function def(spec) {
      let cls = StyleModule.newName();
      (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec;
      return cls;
    }
    const all = typeof options2.all == "string" ? options2.all : options2.all ? def(options2.all) : void 0;
    const scopeOpt = options2.scope;
    this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type) => type == scopeOpt : void 0;
    this.style = tagHighlighter(specs.map((style) => ({
      tag: style.tag,
      class: style.class || def(Object.assign({}, style, { tag: null }))
    })), {
      all
    }).style;
    this.module = modSpec ? new StyleModule(modSpec) : null;
    this.themeType = options2.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(specs, options2) {
    return new _HighlightStyle(specs, options2 || {});
  }
};
var highlighterFacet = Facet.define();
var fallbackHighlighter = Facet.define({
  combine(values) {
    return values.length ? [values[0]] : null;
  }
});
function getHighlighters(state) {
  let main2 = state.facet(highlighterFacet);
  return main2.length ? main2 : state.facet(fallbackHighlighter);
}
function syntaxHighlighting(highlighter3, options2) {
  let ext = [treeHighlighter], themeType;
  if (highlighter3 instanceof HighlightStyle) {
    if (highlighter3.module)
      ext.push(EditorView.styleModule.of(highlighter3.module));
    themeType = highlighter3.themeType;
  }
  if (options2 === null || options2 === void 0 ? void 0 : options2.fallback)
    ext.push(fallbackHighlighter.of(highlighter3));
  else if (themeType)
    ext.push(highlighterFacet.computeN([EditorView.darkTheme], (state) => {
      return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter3] : [];
    }));
  else
    ext.push(highlighterFacet.of(highlighter3));
  return ext;
}
var TreeHighlighter = class {
  constructor(view) {
    this.markCache = /* @__PURE__ */ Object.create(null);
    this.tree = syntaxTree(view.state);
    this.decorations = this.buildDeco(view, getHighlighters(view.state));
  }
  update(update) {
    let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
    let styleChange = highlighters != getHighlighters(update.startState);
    if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {
      this.decorations = this.decorations.map(update.changes);
    } else if (tree != this.tree || update.viewportChanged || styleChange) {
      this.tree = tree;
      this.decorations = this.buildDeco(update.view, highlighters);
    }
  }
  buildDeco(view, highlighters) {
    if (!highlighters || !this.tree.length)
      return Decoration.none;
    let builder = new RangeSetBuilder();
    for (let { from: from2, to } of view.visibleRanges) {
      highlightTree(this.tree, highlighters, (from3, to2, style) => {
        builder.add(from3, to2, this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style })));
      }, from2, to);
    }
    return builder.finish();
  }
};
var treeHighlighter = Prec.high(ViewPlugin.fromClass(TreeHighlighter, {
  decorations: (v) => v.decorations
}));
var defaultHighlightStyle = HighlightStyle.define([
  {
    tag: tags.meta,
    color: "#404740"
  },
  {
    tag: tags.link,
    textDecoration: "underline"
  },
  {
    tag: tags.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: tags.emphasis,
    fontStyle: "italic"
  },
  {
    tag: tags.strong,
    fontWeight: "bold"
  },
  {
    tag: tags.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: tags.keyword,
    color: "#708"
  },
  {
    tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
    color: "#219"
  },
  {
    tag: [tags.literal, tags.inserted],
    color: "#164"
  },
  {
    tag: [tags.string, tags.deleted],
    color: "#a11"
  },
  {
    tag: [tags.regexp, tags.escape, tags.special(tags.string)],
    color: "#e40"
  },
  {
    tag: tags.definition(tags.variableName),
    color: "#00f"
  },
  {
    tag: tags.local(tags.variableName),
    color: "#30a"
  },
  {
    tag: [tags.typeName, tags.namespace],
    color: "#085"
  },
  {
    tag: tags.className,
    color: "#167"
  },
  {
    tag: [tags.special(tags.variableName), tags.macroName],
    color: "#256"
  },
  {
    tag: tags.definition(tags.propertyName),
    color: "#00c"
  },
  {
    tag: tags.comment,
    color: "#940"
  },
  {
    tag: tags.invalid,
    color: "#f00"
  }
]);
var baseTheme2 = EditorView.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
});
var DefaultScanDist = 1e4;
var DefaultBrackets = "()[]{}";
var bracketMatchingConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      afterCursor: true,
      brackets: DefaultBrackets,
      maxScanDistance: DefaultScanDist,
      renderMatch: defaultRenderMatch
    });
  }
});
var matchingMark = Decoration.mark({ class: "cm-matchingBracket" });
var nonmatchingMark = Decoration.mark({ class: "cm-nonmatchingBracket" });
function defaultRenderMatch(match3) {
  let decorations2 = [];
  let mark = match3.matched ? matchingMark : nonmatchingMark;
  decorations2.push(mark.range(match3.start.from, match3.start.to));
  if (match3.end)
    decorations2.push(mark.range(match3.end.from, match3.end.to));
  return decorations2;
}
var bracketMatchingState = StateField.define({
  create() {
    return Decoration.none;
  },
  update(deco, tr2) {
    if (!tr2.docChanged && !tr2.selection)
      return deco;
    let decorations2 = [];
    let config2 = tr2.state.facet(bracketMatchingConfig);
    for (let range of tr2.state.selection.ranges) {
      if (!range.empty)
        continue;
      let match3 = matchBrackets(tr2.state, range.head, -1, config2) || range.head > 0 && matchBrackets(tr2.state, range.head - 1, 1, config2) || config2.afterCursor && (matchBrackets(tr2.state, range.head, 1, config2) || range.head < tr2.state.doc.length && matchBrackets(tr2.state, range.head + 1, -1, config2));
      if (match3)
        decorations2 = decorations2.concat(config2.renderMatch(match3, tr2.state));
    }
    return Decoration.set(decorations2, true);
  },
  provide: (f) => EditorView.decorations.from(f)
});
var bracketMatchingUnique = [
  bracketMatchingState,
  baseTheme2
];
function bracketMatching(config2 = {}) {
  return [bracketMatchingConfig.of(config2), bracketMatchingUnique];
}
var bracketMatchingHandle = new NodeProp();
function matchingNodes(node3, dir, brackets) {
  let byProp = node3.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
  if (byProp)
    return byProp;
  if (node3.name.length == 1) {
    let index4 = brackets.indexOf(node3.name);
    if (index4 > -1 && index4 % 2 == (dir < 0 ? 1 : 0))
      return [brackets[index4 + dir]];
  }
  return null;
}
function findHandle(node3) {
  let hasHandle = node3.type.prop(bracketMatchingHandle);
  return hasHandle ? hasHandle(node3.node) : node3;
}
function matchBrackets(state, pos, dir, config2 = {}) {
  let maxScanDistance = config2.maxScanDistance || DefaultScanDist, brackets = config2.brackets || DefaultBrackets;
  let tree = syntaxTree(state), node3 = tree.resolveInner(pos, dir);
  for (let cur2 = node3; cur2; cur2 = cur2.parent) {
    let matches2 = matchingNodes(cur2.type, dir, brackets);
    if (matches2 && cur2.from < cur2.to) {
      let handle = findHandle(cur2);
      if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to))
        return matchMarkedBrackets(state, pos, dir, cur2, handle, matches2, brackets);
    }
  }
  return matchPlainBrackets(state, pos, dir, tree, node3.type, maxScanDistance, brackets);
}
function matchMarkedBrackets(_state, _pos, dir, token2, handle, matching, brackets) {
  let parent = token2.parent, firstToken = { from: handle.from, to: handle.to };
  let depth2 = 0, cursor2 = parent === null || parent === void 0 ? void 0 : parent.cursor();
  if (cursor2 && (dir < 0 ? cursor2.childBefore(token2.from) : cursor2.childAfter(token2.to)))
    do {
      if (dir < 0 ? cursor2.to <= token2.from : cursor2.from >= token2.to) {
        if (depth2 == 0 && matching.indexOf(cursor2.type.name) > -1 && cursor2.from < cursor2.to) {
          let endHandle = findHandle(cursor2);
          return { start: firstToken, end: endHandle ? { from: endHandle.from, to: endHandle.to } : void 0, matched: true };
        } else if (matchingNodes(cursor2.type, dir, brackets)) {
          depth2++;
        } else if (matchingNodes(cursor2.type, -dir, brackets)) {
          if (depth2 == 0) {
            let endHandle = findHandle(cursor2);
            return {
              start: firstToken,
              end: endHandle && endHandle.from < endHandle.to ? { from: endHandle.from, to: endHandle.to } : void 0,
              matched: false
            };
          }
          depth2--;
        }
      }
    } while (dir < 0 ? cursor2.prevSibling() : cursor2.nextSibling());
  return { start: firstToken, matched: false };
}
function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
  let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
  let bracket2 = brackets.indexOf(startCh);
  if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0)
    return null;
  let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
  let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth2 = 0;
  for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
    let text = iter.value;
    if (dir < 0)
      distance += text.length;
    let basePos = pos + distance * dir;
    for (let pos2 = dir > 0 ? 0 : text.length - 1, end2 = dir > 0 ? text.length : -1; pos2 != end2; pos2 += dir) {
      let found = brackets.indexOf(text[pos2]);
      if (found < 0 || tree.resolveInner(basePos + pos2, 1).type != tokenType)
        continue;
      if (found % 2 == 0 == dir > 0) {
        depth2++;
      } else if (depth2 == 1) {
        return { start: startToken, end: { from: basePos + pos2, to: basePos + pos2 + 1 }, matched: found >> 1 == bracket2 >> 1 };
      } else {
        depth2--;
      }
    }
    if (dir > 0)
      distance += text.length;
  }
  return iter.done ? { start: startToken, matched: false } : null;
}
function countCol(string3, end2, tabSize, startIndex = 0, startValue = 0) {
  if (end2 == null) {
    end2 = string3.search(/[^\s\u00a0]/);
    if (end2 == -1)
      end2 = string3.length;
  }
  let n = startValue;
  for (let i2 = startIndex; i2 < end2; i2++) {
    if (string3.charCodeAt(i2) == 9)
      n += tabSize - n % tabSize;
    else
      n++;
  }
  return n;
}
var StringStream = class {
  /**
  Create a stream.
  */
  constructor(string3, tabSize, indentUnit2, overrideIndent) {
    this.string = string3;
    this.tabSize = tabSize;
    this.indentUnit = indentUnit2;
    this.overrideIndent = overrideIndent;
    this.pos = 0;
    this.start = 0;
    this.lastColumnPos = 0;
    this.lastColumnValue = 0;
  }
  /**
  True if we are at the end of the line.
  */
  eol() {
    return this.pos >= this.string.length;
  }
  /**
  True if we are at the start of the line.
  */
  sol() {
    return this.pos == 0;
  }
  /**
  Get the next code unit after the current position, or undefined
  if we're at the end of the line.
  */
  peek() {
    return this.string.charAt(this.pos) || void 0;
  }
  /**
  Read the next code unit and advance `this.pos`.
  */
  next() {
    if (this.pos < this.string.length)
      return this.string.charAt(this.pos++);
  }
  /**
  Match the next character against the given string, regular
  expression, or predicate. Consume and return it if it matches.
  */
  eat(match3) {
    let ch = this.string.charAt(this.pos);
    let ok;
    if (typeof match3 == "string")
      ok = ch == match3;
    else
      ok = ch && (match3 instanceof RegExp ? match3.test(ch) : match3(ch));
    if (ok) {
      ++this.pos;
      return ch;
    }
  }
  /**
  Continue matching characters that match the given string,
  regular expression, or predicate function. Return true if any
  characters were consumed.
  */
  eatWhile(match3) {
    let start2 = this.pos;
    while (this.eat(match3)) {
    }
    return this.pos > start2;
  }
  /**
  Consume whitespace ahead of `this.pos`. Return true if any was
  found.
  */
  eatSpace() {
    let start2 = this.pos;
    while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
      ++this.pos;
    return this.pos > start2;
  }
  /**
  Move to the end of the line.
  */
  skipToEnd() {
    this.pos = this.string.length;
  }
  /**
  Move to directly before the given character, if found on the
  current line.
  */
  skipTo(ch) {
    let found = this.string.indexOf(ch, this.pos);
    if (found > -1) {
      this.pos = found;
      return true;
    }
  }
  /**
  Move back `n` characters.
  */
  backUp(n) {
    this.pos -= n;
  }
  /**
  Get the column position at `this.pos`.
  */
  column() {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
      this.lastColumnPos = this.start;
    }
    return this.lastColumnValue;
  }
  /**
  Get the indentation column of the current line.
  */
  indentation() {
    var _a2;
    return (_a2 = this.overrideIndent) !== null && _a2 !== void 0 ? _a2 : countCol(this.string, null, this.tabSize);
  }
  /**
  Match the input against the given string or regular expression
  (which should start with a `^`). Return true or the regexp match
  if it matches.
  
  Unless `consume` is set to `false`, this will move `this.pos`
  past the matched text.
  
  When matching a string `caseInsensitive` can be set to true to
  make the match case-insensitive.
  */
  match(pattern, consume, caseInsensitive) {
    if (typeof pattern == "string") {
      let cased = (str) => caseInsensitive ? str.toLowerCase() : str;
      let substr2 = this.string.substr(this.pos, pattern.length);
      if (cased(substr2) == cased(pattern)) {
        if (consume !== false)
          this.pos += pattern.length;
        return true;
      } else
        return null;
    } else {
      let match3 = this.string.slice(this.pos).match(pattern);
      if (match3 && match3.index > 0)
        return null;
      if (match3 && consume !== false)
        this.pos += match3[0].length;
      return match3;
    }
  }
  /**
  Get the current token.
  */
  current() {
    return this.string.slice(this.start, this.pos);
  }
};
function fullParser(spec) {
  return {
    name: spec.name || "",
    token: spec.token,
    blankLine: spec.blankLine || (() => {
    }),
    startState: spec.startState || (() => true),
    copyState: spec.copyState || defaultCopyState,
    indent: spec.indent || (() => null),
    languageData: spec.languageData || {},
    tokenTable: spec.tokenTable || noTokens
  };
}
function defaultCopyState(state) {
  if (typeof state != "object")
    return state;
  let newState = {};
  for (let prop in state) {
    let val = state[prop];
    newState[prop] = val instanceof Array ? val.slice() : val;
  }
  return newState;
}
var IndentedFrom = /* @__PURE__ */ new WeakMap();
var StreamLanguage = class _StreamLanguage extends Language {
  constructor(parser) {
    let data = defineLanguageFacet(parser.languageData);
    let p = fullParser(parser), self2;
    let impl = new class extends Parser2 {
      createParse(input, fragments, ranges) {
        return new Parse(self2, input, fragments, ranges);
      }
    }();
    super(data, impl, [indentService.of((cx, pos) => this.getIndent(cx, pos))], parser.name);
    this.topNode = docID(data);
    self2 = this;
    this.streamParser = p;
    this.stateAfter = new NodeProp({ perNode: true });
    this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;
  }
  /**
  Define a stream language.
  */
  static define(spec) {
    return new _StreamLanguage(spec);
  }
  getIndent(cx, pos) {
    let tree = syntaxTree(cx.state), at2 = tree.resolve(pos);
    while (at2 && at2.type != this.topNode)
      at2 = at2.parent;
    if (!at2)
      return null;
    let from2 = void 0;
    let { overrideIndentation } = cx.options;
    if (overrideIndentation) {
      from2 = IndentedFrom.get(cx.state);
      if (from2 != null && from2 < pos - 1e4)
        from2 = void 0;
    }
    let start2 = findState(this, tree, 0, at2.from, from2 !== null && from2 !== void 0 ? from2 : pos), statePos, state;
    if (start2) {
      state = start2.state;
      statePos = start2.pos + 1;
    } else {
      state = this.streamParser.startState(cx.unit);
      statePos = 0;
    }
    if (pos - statePos > 1e4)
      return null;
    while (statePos < pos) {
      let line3 = cx.state.doc.lineAt(statePos), end2 = Math.min(pos, line3.to);
      if (line3.length) {
        let indentation = overrideIndentation ? overrideIndentation(line3.from) : -1;
        let stream = new StringStream(line3.text, cx.state.tabSize, cx.unit, indentation < 0 ? void 0 : indentation);
        while (stream.pos < end2 - line3.from)
          readToken(this.streamParser.token, stream, state);
      } else {
        this.streamParser.blankLine(state, cx.unit);
      }
      if (end2 == pos)
        break;
      statePos = line3.to + 1;
    }
    let line2 = cx.lineAt(pos);
    if (overrideIndentation && from2 == null)
      IndentedFrom.set(cx.state, line2.from);
    return this.streamParser.indent(state, /^\s*(.*)/.exec(line2.text)[1], cx);
  }
  get allowsNesting() {
    return false;
  }
};
function findState(lang, tree, off2, startPos, before) {
  let state = off2 >= startPos && off2 + tree.length <= before && tree.prop(lang.stateAfter);
  if (state)
    return { state: lang.streamParser.copyState(state), pos: off2 + tree.length };
  for (let i2 = tree.children.length - 1; i2 >= 0; i2--) {
    let child = tree.children[i2], pos = off2 + tree.positions[i2];
    let found = child instanceof Tree && pos < before && findState(lang, child, pos, startPos, before);
    if (found)
      return found;
  }
  return null;
}
function cutTree(lang, tree, from2, to, inside2) {
  if (inside2 && from2 <= 0 && to >= tree.length)
    return tree;
  if (!inside2 && tree.type == lang.topNode)
    inside2 = true;
  for (let i2 = tree.children.length - 1; i2 >= 0; i2--) {
    let pos = tree.positions[i2], child = tree.children[i2], inner;
    if (pos < to && child instanceof Tree) {
      if (!(inner = cutTree(lang, child, from2 - pos, to - pos, inside2)))
        break;
      return !inside2 ? inner : new Tree(tree.type, tree.children.slice(0, i2).concat(inner), tree.positions.slice(0, i2 + 1), pos + inner.length);
    }
  }
  return null;
}
function findStartInFragments(lang, fragments, startPos, editorState) {
  for (let f of fragments) {
    let from2 = f.from + (f.openStart ? 25 : 0), to = f.to - (f.openEnd ? 25 : 0);
    let found = from2 <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to), tree;
    if (found && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false)))
      return { state: found.state, tree };
  }
  return { state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4), tree: Tree.empty };
}
var Parse = class {
  constructor(lang, input, fragments, ranges) {
    this.lang = lang;
    this.input = input;
    this.fragments = fragments;
    this.ranges = ranges;
    this.stoppedAt = null;
    this.chunks = [];
    this.chunkPos = [];
    this.chunk = [];
    this.chunkReused = void 0;
    this.rangeIndex = 0;
    this.to = ranges[ranges.length - 1].to;
    let context = ParseContext.get(), from2 = ranges[0].from;
    let { state, tree } = findStartInFragments(lang, fragments, from2, context === null || context === void 0 ? void 0 : context.state);
    this.state = state;
    this.parsedPos = this.chunkStart = from2 + tree.length;
    for (let i2 = 0; i2 < tree.children.length; i2++) {
      this.chunks.push(tree.children[i2]);
      this.chunkPos.push(tree.positions[i2]);
    }
    if (context && this.parsedPos < context.viewport.from - 1e5) {
      this.state = this.lang.streamParser.startState(getIndentUnit(context.state));
      context.skipUntilInView(this.parsedPos, context.viewport.from);
      this.parsedPos = context.viewport.from;
    }
    this.moveRangeIndex();
  }
  advance() {
    let context = ParseContext.get();
    let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);
    let end2 = Math.min(
      parseEnd,
      this.chunkStart + 2048
      /* C.ChunkSize */
    );
    if (context)
      end2 = Math.min(end2, context.viewport.to);
    while (this.parsedPos < end2)
      this.parseLine(context);
    if (this.chunkStart < this.parsedPos)
      this.finishChunk();
    if (this.parsedPos >= parseEnd)
      return this.finish();
    if (context && this.parsedPos >= context.viewport.to) {
      context.skipUntilInView(this.parsedPos, parseEnd);
      return this.finish();
    }
    return null;
  }
  stopAt(pos) {
    this.stoppedAt = pos;
  }
  lineAfter(pos) {
    let chunk = this.input.chunk(pos);
    if (!this.input.lineChunks) {
      let eol = chunk.indexOf("\n");
      if (eol > -1)
        chunk = chunk.slice(0, eol);
    } else if (chunk == "\n") {
      chunk = "";
    }
    return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);
  }
  nextLine() {
    let from2 = this.parsedPos, line2 = this.lineAfter(from2), end2 = from2 + line2.length;
    for (let index4 = this.rangeIndex; ; ) {
      let rangeEnd2 = this.ranges[index4].to;
      if (rangeEnd2 >= end2)
        break;
      line2 = line2.slice(0, rangeEnd2 - (end2 - line2.length));
      index4++;
      if (index4 == this.ranges.length)
        break;
      let rangeStart = this.ranges[index4].from;
      let after = this.lineAfter(rangeStart);
      line2 += after;
      end2 = rangeStart + after.length;
    }
    return { line: line2, end: end2 };
  }
  skipGapsTo(pos, offset3, side) {
    for (; ; ) {
      let end2 = this.ranges[this.rangeIndex].to, offPos = pos + offset3;
      if (side > 0 ? end2 > offPos : end2 >= offPos)
        break;
      let start2 = this.ranges[++this.rangeIndex].from;
      offset3 += start2 - end2;
    }
    return offset3;
  }
  moveRangeIndex() {
    while (this.ranges[this.rangeIndex].to < this.parsedPos)
      this.rangeIndex++;
  }
  emitToken(id, from2, to, size3, offset3) {
    if (this.ranges.length > 1) {
      offset3 = this.skipGapsTo(from2, offset3, 1);
      from2 += offset3;
      let len0 = this.chunk.length;
      offset3 = this.skipGapsTo(to, offset3, -1);
      to += offset3;
      size3 += this.chunk.length - len0;
    }
    this.chunk.push(id, from2, to, size3);
    return offset3;
  }
  parseLine(context) {
    let { line: line2, end: end2 } = this.nextLine(), offset3 = 0, { streamParser } = this.lang;
    let stream = new StringStream(line2, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);
    if (stream.eol()) {
      streamParser.blankLine(this.state, stream.indentUnit);
    } else {
      while (!stream.eol()) {
        let token2 = readToken(streamParser.token, stream, this.state);
        if (token2)
          offset3 = this.emitToken(this.lang.tokenTable.resolve(token2), this.parsedPos + stream.start, this.parsedPos + stream.pos, 4, offset3);
        if (stream.start > 1e4)
          break;
      }
    }
    this.parsedPos = end2;
    this.moveRangeIndex();
    if (this.parsedPos < this.to)
      this.parsedPos++;
  }
  finishChunk() {
    let tree = Tree.build({
      buffer: this.chunk,
      start: this.chunkStart,
      length: this.parsedPos - this.chunkStart,
      nodeSet,
      topID: 0,
      maxBufferLength: 2048,
      reused: this.chunkReused
    });
    tree = new Tree(tree.type, tree.children, tree.positions, tree.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);
    this.chunks.push(tree);
    this.chunkPos.push(this.chunkStart - this.ranges[0].from);
    this.chunk = [];
    this.chunkReused = void 0;
    this.chunkStart = this.parsedPos;
  }
  finish() {
    return new Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
  }
};
function readToken(token2, stream, state) {
  stream.start = stream.pos;
  for (let i2 = 0; i2 < 10; i2++) {
    let result = token2(stream, state);
    if (stream.pos > stream.start)
      return result;
  }
  throw new Error("Stream parser failed to advance stream.");
}
var noTokens = /* @__PURE__ */ Object.create(null);
var typeArray = [NodeType.none];
var nodeSet = new NodeSet(typeArray);
var warned = [];
var byTag = /* @__PURE__ */ Object.create(null);
var defaultTable = /* @__PURE__ */ Object.create(null);
for (let [legacyName, name2] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  defaultTable[legacyName] = createTokenType(noTokens, name2);
var TokenTable = class {
  constructor(extra) {
    this.extra = extra;
    this.table = Object.assign(/* @__PURE__ */ Object.create(null), defaultTable);
  }
  resolve(tag) {
    return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));
  }
};
var defaultTokenTable = new TokenTable(noTokens);
function warnForPart(part, msg) {
  if (warned.indexOf(part) > -1)
    return;
  warned.push(part);
  console.warn(msg);
}
function createTokenType(extra, tagStr) {
  let tags$1 = [];
  for (let name3 of tagStr.split(" ")) {
    let found = [];
    for (let part of name3.split(".")) {
      let value = extra[part] || tags[part];
      if (!value) {
        warnForPart(part, `Unknown highlighting tag ${part}`);
      } else if (typeof value == "function") {
        if (!found.length)
          warnForPart(part, `Modifier ${part} used at start of tag`);
        else
          found = found.map(value);
      } else {
        if (found.length)
          warnForPart(part, `Tag ${part} used as modifier`);
        else
          found = Array.isArray(value) ? value : [value];
      }
    }
    for (let tag of found)
      tags$1.push(tag);
  }
  if (!tags$1.length)
    return 0;
  let name2 = tagStr.replace(/ /g, "_"), key = name2 + " " + tags$1.map((t4) => t4.id);
  let known = byTag[key];
  if (known)
    return known.id;
  let type = byTag[key] = NodeType.define({
    id: typeArray.length,
    name: name2,
    props: [styleTags({ [name2]: tags$1 })]
  });
  typeArray.push(type);
  return type.id;
}
function docID(data) {
  let type = NodeType.define({ id: typeArray.length, name: "Document", props: [languageDataProp.add(() => data)], top: true });
  typeArray.push(type);
  return type;
}
function buildForLine(line2) {
  return line2.length <= 4096 && /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/.test(line2);
}
function textHasRTL(text) {
  for (let i2 = text.iter(); !i2.next().done; )
    if (buildForLine(i2.value))
      return true;
  return false;
}
function changeAddsRTL(change) {
  let added = false;
  change.iterChanges((fA, tA, fB, tB, ins) => {
    if (!added && textHasRTL(ins))
      added = true;
  });
  return added;
}
var alwaysIsolate = Facet.define({ combine: (values) => values.some((x2) => x2) });
var isolateMarks = ViewPlugin.fromClass(class {
  constructor(view) {
    this.always = view.state.facet(alwaysIsolate) || view.textDirection != Direction.LTR || view.state.facet(EditorView.perLineTextDirection);
    this.hasRTL = !this.always && textHasRTL(view.state.doc);
    this.tree = syntaxTree(view.state);
    this.decorations = buildDeco(view, this.tree, this.always);
  }
  update(update) {
    let always = update.state.facet(alwaysIsolate) || update.view.textDirection != Direction.LTR || update.state.facet(EditorView.perLineTextDirection);
    if (!always && !this.hasRTL && changeAddsRTL(update.changes))
      this.hasRTL = true;
    if (!always && !this.hasRTL)
      return;
    let tree = syntaxTree(update.state);
    if (always != this.always || tree != this.tree || update.docChanged || update.viewportChanged) {
      this.tree = tree;
      this.always = always;
      this.decorations = buildDeco(update.view, tree, always);
    }
  }
}, {
  provide: (plugin2) => {
    function access(view) {
      var _a2, _b;
      return (_b = (_a2 = view.plugin(plugin2)) === null || _a2 === void 0 ? void 0 : _a2.decorations) !== null && _b !== void 0 ? _b : Decoration.none;
    }
    return [
      EditorView.outerDecorations.of(access),
      Prec.lowest(EditorView.bidiIsolatedRanges.of(access))
    ];
  }
});
function buildDeco(view, tree, always) {
  let deco = new RangeSetBuilder();
  let ranges = view.visibleRanges;
  if (!always)
    ranges = clipRTLLines(ranges, view.state.doc);
  for (let { from: from2, to } of ranges) {
    tree.iterate({
      enter: (node3) => {
        let iso = node3.type.prop(NodeProp.isolate);
        if (iso)
          deco.add(node3.from, node3.to, marks[iso]);
      },
      from: from2,
      to
    });
  }
  return deco.finish();
}
function clipRTLLines(ranges, doc2) {
  let cur2 = doc2.iter(), pos = 0, result = [], last = null;
  for (let { from: from2, to } of ranges) {
    if (from2 != pos) {
      if (pos < from2)
        cur2.next(from2 - pos);
      pos = from2;
    }
    for (; ; ) {
      let start2 = pos, end2 = pos + cur2.value.length;
      if (!cur2.lineBreak && buildForLine(cur2.value)) {
        if (last && last.to > start2 - 10)
          last.to = Math.min(to, end2);
        else
          result.push(last = { from: start2, to: Math.min(to, end2) });
      }
      if (pos >= to)
        break;
      pos = end2;
      cur2.next();
    }
  }
  return result;
}
var marks = {
  rtl: Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "rtl" }, bidiIsolate: Direction.RTL }),
  ltr: Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "ltr" }, bidiIsolate: Direction.LTR }),
  auto: Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "auto" }, bidiIsolate: null })
};

// node_modules/@codemirror/autocomplete/dist/index.js
var CompletionContext = class {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sourcesin the editor, the extension will create
  these for you.)
  */
  constructor(state, pos, explicit) {
    this.state = state;
    this.pos = pos;
    this.explicit = explicit;
    this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(types2) {
    let token2 = syntaxTree(this.state).resolveInner(this.pos, -1);
    while (token2 && types2.indexOf(token2.name) < 0)
      token2 = token2.parent;
    return token2 ? {
      from: token2.from,
      to: this.pos,
      text: this.state.sliceDoc(token2.from, this.pos),
      type: token2.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(expr) {
    let line2 = this.state.doc.lineAt(this.pos);
    let start2 = Math.max(line2.from, this.pos - 250);
    let str = line2.text.slice(start2 - line2.from, this.pos - line2.from);
    let found = str.search(ensureAnchor(expr, false));
    return found < 0 ? null : { from: start2 + found, to: this.pos, text: str.slice(found) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */
  addEventListener(type, listener) {
    if (type == "abort" && this.abortListeners)
      this.abortListeners.push(listener);
  }
};
function toSet(chars) {
  let flat = Object.keys(chars).join("");
  let words = /\w/.test(flat);
  if (words)
    flat = flat.replace(/\w/g, "");
  return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
}
function prefixMatch(options2) {
  let first = /* @__PURE__ */ Object.create(null), rest = /* @__PURE__ */ Object.create(null);
  for (let { label } of options2) {
    first[label[0]] = true;
    for (let i2 = 1; i2 < label.length; i2++)
      rest[label[i2]] = true;
  }
  let source = toSet(first) + toSet(rest) + "*$";
  return [new RegExp("^" + source), new RegExp(source)];
}
function completeFromList(list) {
  let options2 = list.map((o) => typeof o == "string" ? { label: o } : o);
  let [validFor, match3] = options2.every((o) => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options2);
  return (context) => {
    let token2 = context.matchBefore(match3);
    return token2 || context.explicit ? { from: token2 ? token2.from : context.pos, options: options2, validFor } : null;
  };
}
var Option3 = class {
  constructor(completion, source, match3, score2) {
    this.completion = completion;
    this.source = source;
    this.match = match3;
    this.score = score2;
  }
};
function cur(state) {
  return state.selection.main.from;
}
function ensureAnchor(expr, start2) {
  var _a2;
  let { source } = expr;
  let addStart = start2 && source[0] != "^", addEnd = source[source.length - 1] != "$";
  if (!addStart && !addEnd)
    return expr;
  return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a2 = expr.flags) !== null && _a2 !== void 0 ? _a2 : expr.ignoreCase ? "i" : "");
}
var pickedCompletion = Annotation.define();
function insertCompletionText(state, text, from2, to) {
  let { main: main2 } = state.selection, fromOff = from2 - main2.from, toOff = to - main2.from;
  return Object.assign(Object.assign({}, state.changeByRange((range) => {
    if (range != main2 && from2 != to && state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from2, to))
      return { range };
    return {
      changes: { from: range.from + fromOff, to: to == main2.from ? range.to : range.from + toOff, insert: text },
      range: EditorSelection.cursor(range.from + fromOff + text.length)
    };
  })), { scrollIntoView: true, userEvent: "input.complete" });
}
var SourceCache = /* @__PURE__ */ new WeakMap();
function asSource(source) {
  if (!Array.isArray(source))
    return source;
  let known = SourceCache.get(source);
  if (!known)
    SourceCache.set(source, known = completeFromList(source));
  return known;
}
var startCompletionEffect = StateEffect.define();
var closeCompletionEffect = StateEffect.define();
var FuzzyMatcher = class {
  constructor(pattern) {
    this.pattern = pattern;
    this.chars = [];
    this.folded = [];
    this.any = [];
    this.precise = [];
    this.byWord = [];
    this.score = 0;
    this.matched = [];
    for (let p = 0; p < pattern.length; ) {
      let char2 = codePointAt(pattern, p), size3 = codePointSize(char2);
      this.chars.push(char2);
      let part = pattern.slice(p, p + size3), upper = part.toUpperCase();
      this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));
      p += size3;
    }
    this.astral = pattern.length != this.chars.length;
  }
  ret(score2, matched) {
    this.score = score2;
    this.matched = matched;
    return true;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(word) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (word.length < this.pattern.length)
      return false;
    let { chars, folded, any: any2, precise, byWord } = this;
    if (chars.length == 1) {
      let first = codePointAt(word, 0), firstSize = codePointSize(first);
      let score2 = firstSize == word.length ? 0 : -100;
      if (first == chars[0])
        ;
      else if (first == folded[0])
        score2 += -200;
      else
        return false;
      return this.ret(score2, [0, firstSize]);
    }
    let direct = word.indexOf(this.pattern);
    if (direct == 0)
      return this.ret(word.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let len = chars.length, anyTo = 0;
    if (direct < 0) {
      for (let i2 = 0, e4 = Math.min(word.length, 200); i2 < e4 && anyTo < len; ) {
        let next2 = codePointAt(word, i2);
        if (next2 == chars[anyTo] || next2 == folded[anyTo])
          any2[anyTo++] = i2;
        i2 += codePointSize(next2);
      }
      if (anyTo < len)
        return false;
    }
    let preciseTo = 0;
    let byWordTo = 0, byWordFolded = false;
    let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
    let hasLower = /[a-z]/.test(word), wordAdjacent = true;
    for (let i2 = 0, e4 = Math.min(word.length, 200), prevType = 0; i2 < e4 && byWordTo < len; ) {
      let next2 = codePointAt(word, i2);
      if (direct < 0) {
        if (preciseTo < len && next2 == chars[preciseTo])
          precise[preciseTo++] = i2;
        if (adjacentTo < len) {
          if (next2 == chars[adjacentTo] || next2 == folded[adjacentTo]) {
            if (adjacentTo == 0)
              adjacentStart = i2;
            adjacentEnd = i2 + 1;
            adjacentTo++;
          } else {
            adjacentTo = 0;
          }
        }
      }
      let ch, type = next2 < 255 ? next2 >= 48 && next2 <= 57 || next2 >= 97 && next2 <= 122 ? 2 : next2 >= 65 && next2 <= 90 ? 1 : 0 : (ch = fromCodePoint(next2)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;
      if (!i2 || type == 1 && hasLower || prevType == 0 && type != 0) {
        if (chars[byWordTo] == next2 || folded[byWordTo] == next2 && (byWordFolded = true))
          byWord[byWordTo++] = i2;
        else if (byWord.length)
          wordAdjacent = false;
      }
      prevType = type;
      i2 += codePointSize(next2);
    }
    if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
      return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
    if (adjacentTo == len && adjacentStart == 0)
      return this.ret(-200 - word.length + (adjacentEnd == word.length ? 0 : -100), [0, adjacentEnd]);
    if (direct > -1)
      return this.ret(-700 - word.length, [direct, direct + this.pattern.length]);
    if (adjacentTo == len)
      return this.ret(-200 + -700 - word.length, [adjacentStart, adjacentEnd]);
    if (byWordTo == len)
      return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
    return chars.length == 2 ? false : this.result((any2[0] ? -700 : 0) + -200 + -1100, any2, word);
  }
  result(score2, positions, word) {
    let result = [], i2 = 0;
    for (let pos of positions) {
      let to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);
      if (i2 && result[i2 - 1] == pos)
        result[i2 - 1] = to;
      else {
        result[i2++] = pos;
        result[i2++] = to;
      }
    }
    return this.ret(score2 - word.length, result);
  }
};
var completionConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      activateOnTyping: true,
      activateOnTypingDelay: 100,
      selectOnOpen: true,
      override: null,
      closeOnBlur: true,
      maxRenderedOptions: 100,
      defaultKeymap: true,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: false,
      icons: true,
      addToOptions: [],
      positionInfo: defaultPositionInfo,
      compareCompletions: (a3, b2) => a3.label.localeCompare(b2.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (a3, b2) => a3 && b2,
      closeOnBlur: (a3, b2) => a3 && b2,
      icons: (a3, b2) => a3 && b2,
      tooltipClass: (a3, b2) => (c2) => joinClass(a3(c2), b2(c2)),
      optionClass: (a3, b2) => (c2) => joinClass(a3(c2), b2(c2)),
      addToOptions: (a3, b2) => a3.concat(b2)
    });
  }
});
function joinClass(a3, b2) {
  return a3 ? b2 ? a3 + " " + b2 : a3 : b2;
}
function defaultPositionInfo(view, list, option, info, space, tooltip) {
  let rtl = view.textDirection == Direction.RTL, left2 = rtl, narrow = false;
  let side = "top", offset3, maxWidth;
  let spaceLeft = list.left - space.left, spaceRight = space.right - list.right;
  let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;
  if (left2 && spaceLeft < Math.min(infoWidth, spaceRight))
    left2 = false;
  else if (!left2 && spaceRight < Math.min(infoWidth, spaceLeft))
    left2 = true;
  if (infoWidth <= (left2 ? spaceLeft : spaceRight)) {
    offset3 = Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) - list.top;
    maxWidth = Math.min(400, left2 ? spaceLeft : spaceRight);
  } else {
    narrow = true;
    maxWidth = Math.min(
      400,
      (rtl ? list.right : space.right - list.left) - 30
      /* Info.Margin */
    );
    let spaceBelow = space.bottom - list.bottom;
    if (spaceBelow >= infoHeight || spaceBelow > list.top) {
      offset3 = option.bottom - list.top;
    } else {
      side = "bottom";
      offset3 = list.bottom - option.top;
    }
  }
  let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;
  let scaleX = (list.right - list.left) / tooltip.offsetWidth;
  return {
    style: `${side}: ${offset3 / scaleY}px; max-width: ${maxWidth / scaleX}px`,
    class: "cm-completionInfo-" + (narrow ? rtl ? "left-narrow" : "right-narrow" : left2 ? "left" : "right")
  };
}
function optionContent(config2) {
  let content2 = config2.addToOptions.slice();
  if (config2.icons)
    content2.push({
      render(completion) {
        let icon = document.createElement("div");
        icon.classList.add("cm-completionIcon");
        if (completion.type)
          icon.classList.add(...completion.type.split(/\s+/g).map((cls) => "cm-completionIcon-" + cls));
        icon.setAttribute("aria-hidden", "true");
        return icon;
      },
      position: 20
    });
  content2.push({
    render(completion, _s, _v, match3) {
      let labelElt = document.createElement("span");
      labelElt.className = "cm-completionLabel";
      let label = completion.displayLabel || completion.label, off2 = 0;
      for (let j = 0; j < match3.length; ) {
        let from2 = match3[j++], to = match3[j++];
        if (from2 > off2)
          labelElt.appendChild(document.createTextNode(label.slice(off2, from2)));
        let span = labelElt.appendChild(document.createElement("span"));
        span.appendChild(document.createTextNode(label.slice(from2, to)));
        span.className = "cm-completionMatchedText";
        off2 = to;
      }
      if (off2 < label.length)
        labelElt.appendChild(document.createTextNode(label.slice(off2)));
      return labelElt;
    },
    position: 50
  }, {
    render(completion) {
      if (!completion.detail)
        return null;
      let detailElt = document.createElement("span");
      detailElt.className = "cm-completionDetail";
      detailElt.textContent = completion.detail;
      return detailElt;
    },
    position: 80
  });
  return content2.sort((a3, b2) => a3.position - b2.position).map((a3) => a3.render);
}
function rangeAroundSelected(total, selected, max4) {
  if (total <= max4)
    return { from: 0, to: total };
  if (selected < 0)
    selected = 0;
  if (selected <= total >> 1) {
    let off3 = Math.floor(selected / max4);
    return { from: off3 * max4, to: (off3 + 1) * max4 };
  }
  let off2 = Math.floor((total - selected) / max4);
  return { from: total - (off2 + 1) * max4, to: total - off2 * max4 };
}
var CompletionTooltip = class {
  constructor(view, stateField, applyCompletion2) {
    this.view = view;
    this.stateField = stateField;
    this.applyCompletion = applyCompletion2;
    this.info = null;
    this.infoDestroy = null;
    this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (pos) => this.placeInfo(pos),
      key: this
    };
    this.space = null;
    this.currentClass = "";
    let cState = view.state.field(stateField);
    let { options: options2, selected } = cState.open;
    let config2 = view.state.facet(completionConfig);
    this.optionContent = optionContent(config2);
    this.optionClass = config2.optionClass;
    this.tooltipClass = config2.tooltipClass;
    this.range = rangeAroundSelected(options2.length, selected, config2.maxRenderedOptions);
    this.dom = document.createElement("div");
    this.dom.className = "cm-tooltip-autocomplete";
    this.updateTooltipClass(view.state);
    this.dom.addEventListener("mousedown", (e4) => {
      let { options: options3 } = view.state.field(stateField).open;
      for (let dom = e4.target, match3; dom && dom != this.dom; dom = dom.parentNode) {
        if (dom.nodeName == "LI" && (match3 = /-(\d+)$/.exec(dom.id)) && +match3[1] < options3.length) {
          this.applyCompletion(view, options3[+match3[1]]);
          e4.preventDefault();
          return;
        }
      }
    });
    this.dom.addEventListener("focusout", (e4) => {
      let state = view.state.field(this.stateField, false);
      if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur && e4.relatedTarget != view.contentDOM)
        view.dispatch({ effects: closeCompletionEffect.of(null) });
    });
    this.showOptions(options2, cState.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(options2, id) {
    if (this.list)
      this.list.remove();
    this.list = this.dom.appendChild(this.createListBox(options2, id, this.range));
    this.list.addEventListener("scroll", () => {
      if (this.info)
        this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(update) {
    var _a2;
    let cState = update.state.field(this.stateField);
    let prevState = update.startState.field(this.stateField);
    this.updateTooltipClass(update.state);
    if (cState != prevState) {
      let { options: options2, selected, disabled } = cState.open;
      if (!prevState.open || prevState.open.options != options2) {
        this.range = rangeAroundSelected(options2.length, selected, update.state.facet(completionConfig).maxRenderedOptions);
        this.showOptions(options2, cState.id);
      }
      this.updateSel();
      if (disabled != ((_a2 = prevState.open) === null || _a2 === void 0 ? void 0 : _a2.disabled))
        this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!disabled);
    }
  }
  updateTooltipClass(state) {
    let cls = this.tooltipClass(state);
    if (cls != this.currentClass) {
      for (let c2 of this.currentClass.split(" "))
        if (c2)
          this.dom.classList.remove(c2);
      for (let c2 of cls.split(" "))
        if (c2)
          this.dom.classList.add(c2);
      this.currentClass = cls;
    }
  }
  positioned(space) {
    this.space = space;
    if (this.info)
      this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let cState = this.view.state.field(this.stateField), open = cState.open;
    if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
      this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
      this.showOptions(open.options, cState.id);
    }
    if (this.updateSelectedOption(open.selected)) {
      this.destroyInfo();
      let { completion } = open.options[open.selected];
      let { info } = completion;
      if (!info)
        return;
      let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
      if (!infoResult)
        return;
      if ("then" in infoResult) {
        infoResult.then((obj) => {
          if (obj && this.view.state.field(this.stateField, false) == cState)
            this.addInfoPane(obj, completion);
        }).catch((e4) => logException(this.view.state, e4, "completion info"));
      } else {
        this.addInfoPane(infoResult, completion);
      }
    }
  }
  addInfoPane(content2, completion) {
    this.destroyInfo();
    let wrap = this.info = document.createElement("div");
    wrap.className = "cm-tooltip cm-completionInfo";
    if (content2.nodeType != null) {
      wrap.appendChild(content2);
      this.infoDestroy = null;
    } else {
      let { dom, destroy } = content2;
      wrap.appendChild(dom);
      this.infoDestroy = destroy || null;
    }
    this.dom.appendChild(wrap);
    this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(selected) {
    let set2 = null;
    for (let opt = this.list.firstChild, i2 = this.range.from; opt; opt = opt.nextSibling, i2++) {
      if (opt.nodeName != "LI" || !opt.id) {
        i2--;
      } else if (i2 == selected) {
        if (!opt.hasAttribute("aria-selected")) {
          opt.setAttribute("aria-selected", "true");
          set2 = opt;
        }
      } else {
        if (opt.hasAttribute("aria-selected"))
          opt.removeAttribute("aria-selected");
      }
    }
    if (set2)
      scrollIntoView3(this.list, set2);
    return set2;
  }
  measureInfo() {
    let sel = this.dom.querySelector("[aria-selected]");
    if (!sel || !this.info)
      return null;
    let listRect = this.dom.getBoundingClientRect();
    let infoRect = this.info.getBoundingClientRect();
    let selRect = sel.getBoundingClientRect();
    let space = this.space;
    if (!space) {
      let win = this.dom.ownerDocument.defaultView || window;
      space = { left: 0, top: 0, right: win.innerWidth, bottom: win.innerHeight };
    }
    if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space.top, listRect.top) + 10)
      return null;
    return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space, this.dom);
  }
  placeInfo(pos) {
    if (this.info) {
      if (pos) {
        if (pos.style)
          this.info.style.cssText = pos.style;
        this.info.className = "cm-tooltip cm-completionInfo " + (pos.class || "");
      } else {
        this.info.style.cssText = "top: -1e6px";
      }
    }
  }
  createListBox(options2, id, range) {
    const ul = document.createElement("ul");
    ul.id = id;
    ul.setAttribute("role", "listbox");
    ul.setAttribute("aria-expanded", "true");
    ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let curSection = null;
    for (let i2 = range.from; i2 < range.to; i2++) {
      let { completion, match: match3 } = options2[i2], { section } = completion;
      if (section) {
        let name2 = typeof section == "string" ? section : section.name;
        if (name2 != curSection && (i2 > range.from || range.from == 0)) {
          curSection = name2;
          if (typeof section != "string" && section.header) {
            ul.appendChild(section.header(section));
          } else {
            let header = ul.appendChild(document.createElement("completion-section"));
            header.textContent = name2;
          }
        }
      }
      const li = ul.appendChild(document.createElement("li"));
      li.id = id + "-" + i2;
      li.setAttribute("role", "option");
      let cls = this.optionClass(completion);
      if (cls)
        li.className = cls;
      for (let source of this.optionContent) {
        let node3 = source(completion, this.view.state, this.view, match3);
        if (node3)
          li.appendChild(node3);
      }
    }
    if (range.from)
      ul.classList.add("cm-completionListIncompleteTop");
    if (range.to < options2.length)
      ul.classList.add("cm-completionListIncompleteBottom");
    return ul;
  }
  destroyInfo() {
    if (this.info) {
      if (this.infoDestroy)
        this.infoDestroy();
      this.info.remove();
      this.info = null;
    }
  }
  destroy() {
    this.destroyInfo();
  }
};
function completionTooltip(stateField, applyCompletion2) {
  return (view) => new CompletionTooltip(view, stateField, applyCompletion2);
}
function scrollIntoView3(container, element) {
  let parent = container.getBoundingClientRect();
  let self2 = element.getBoundingClientRect();
  let scaleY = parent.height / container.offsetHeight;
  if (self2.top < parent.top)
    container.scrollTop -= (parent.top - self2.top) / scaleY;
  else if (self2.bottom > parent.bottom)
    container.scrollTop += (self2.bottom - parent.bottom) / scaleY;
}
function score(option) {
  return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
}
function sortOptions(active, state) {
  let options2 = [];
  let sections = null;
  let addOption = (option) => {
    options2.push(option);
    let { section } = option.completion;
    if (section) {
      if (!sections)
        sections = [];
      let name2 = typeof section == "string" ? section : section.name;
      if (!sections.some((s3) => s3.name == name2))
        sections.push(typeof section == "string" ? { name: name2 } : section);
    }
  };
  for (let a3 of active)
    if (a3.hasResult()) {
      let getMatch2 = a3.result.getMatch;
      if (a3.result.filter === false) {
        for (let option of a3.result.options) {
          addOption(new Option3(option, a3.source, getMatch2 ? getMatch2(option) : [], 1e9 - options2.length));
        }
      } else {
        let matcher2 = new FuzzyMatcher(state.sliceDoc(a3.from, a3.to));
        for (let option of a3.result.options)
          if (matcher2.match(option.label)) {
            let matched = !option.displayLabel ? matcher2.matched : getMatch2 ? getMatch2(option, matcher2.matched) : [];
            addOption(new Option3(option, a3.source, matched, matcher2.score + (option.boost || 0)));
          }
      }
    }
  if (sections) {
    let sectionOrder = /* @__PURE__ */ Object.create(null), pos = 0;
    let cmp = (a3, b2) => {
      var _a2, _b;
      return ((_a2 = a3.rank) !== null && _a2 !== void 0 ? _a2 : 1e9) - ((_b = b2.rank) !== null && _b !== void 0 ? _b : 1e9) || (a3.name < b2.name ? -1 : 1);
    };
    for (let s3 of sections.sort(cmp)) {
      pos -= 1e5;
      sectionOrder[s3.name] = pos;
    }
    for (let option of options2) {
      let { section } = option.completion;
      if (section)
        option.score += sectionOrder[typeof section == "string" ? section : section.name];
    }
  }
  let result = [], prev2 = null;
  let compare2 = state.facet(completionConfig).compareCompletions;
  for (let opt of options2.sort((a3, b2) => b2.score - a3.score || compare2(a3.completion, b2.completion))) {
    let cur2 = opt.completion;
    if (!prev2 || prev2.label != cur2.label || prev2.detail != cur2.detail || prev2.type != null && cur2.type != null && prev2.type != cur2.type || prev2.apply != cur2.apply || prev2.boost != cur2.boost)
      result.push(opt);
    else if (score(opt.completion) > score(prev2))
      result[result.length - 1] = opt;
    prev2 = opt.completion;
  }
  return result;
}
var CompletionDialog = class _CompletionDialog {
  constructor(options2, attrs, tooltip, timestamp, selected, disabled) {
    this.options = options2;
    this.attrs = attrs;
    this.tooltip = tooltip;
    this.timestamp = timestamp;
    this.selected = selected;
    this.disabled = disabled;
  }
  setSelected(selected, id) {
    return selected == this.selected || selected >= this.options.length ? this : new _CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);
  }
  static build(active, state, id, prev2, conf) {
    let options2 = sortOptions(active, state);
    if (!options2.length) {
      return prev2 && active.some(
        (a3) => a3.state == 1
        /* State.Pending */
      ) ? new _CompletionDialog(prev2.options, prev2.attrs, prev2.tooltip, prev2.timestamp, prev2.selected, true) : null;
    }
    let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;
    if (prev2 && prev2.selected != selected && prev2.selected != -1) {
      let selectedValue = prev2.options[prev2.selected].completion;
      for (let i2 = 0; i2 < options2.length; i2++)
        if (options2[i2].completion == selectedValue) {
          selected = i2;
          break;
        }
    }
    return new _CompletionDialog(options2, makeAttrs(id, selected), {
      pos: active.reduce((a3, b2) => b2.hasResult() ? Math.min(a3, b2.from) : a3, 1e8),
      create: createTooltip,
      above: conf.aboveCursor
    }, prev2 ? prev2.timestamp : Date.now(), selected, false);
  }
  map(changes) {
    return new _CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
};
var CompletionState = class _CompletionState {
  constructor(active, id, open) {
    this.active = active;
    this.id = id;
    this.open = open;
  }
  static start() {
    return new _CompletionState(none2, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(tr2) {
    let { state } = tr2, conf = state.facet(completionConfig);
    let sources = conf.override || state.languageDataAt("autocomplete", cur(state)).map(asSource);
    let active = sources.map((source) => {
      let value = this.active.find((s3) => s3.source == source) || new ActiveSource(
        source,
        this.active.some(
          (a3) => a3.state != 0
          /* State.Inactive */
        ) ? 1 : 0
        /* State.Inactive */
      );
      return value.update(tr2, conf);
    });
    if (active.length == this.active.length && active.every((a3, i2) => a3 == this.active[i2]))
      active = this.active;
    let open = this.open;
    if (open && tr2.docChanged)
      open = open.map(tr2.changes);
    if (tr2.selection || active.some((a3) => a3.hasResult() && tr2.changes.touchesRange(a3.from, a3.to)) || !sameResults(active, this.active))
      open = CompletionDialog.build(active, state, this.id, open, conf);
    else if (open && open.disabled && !active.some(
      (a3) => a3.state == 1
      /* State.Pending */
    ))
      open = null;
    if (!open && active.every(
      (a3) => a3.state != 1
      /* State.Pending */
    ) && active.some((a3) => a3.hasResult()))
      active = active.map((a3) => a3.hasResult() ? new ActiveSource(
        a3.source,
        0
        /* State.Inactive */
      ) : a3);
    for (let effect4 of tr2.effects)
      if (effect4.is(setSelectedEffect))
        open = open && open.setSelected(effect4.value, this.id);
    return active == this.active && open == this.open ? this : new _CompletionState(active, this.id, open);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : baseAttrs;
  }
};
function sameResults(a3, b2) {
  if (a3 == b2)
    return true;
  for (let iA = 0, iB = 0; ; ) {
    while (iA < a3.length && !a3[iA].hasResult)
      iA++;
    while (iB < b2.length && !b2[iB].hasResult)
      iB++;
    let endA = iA == a3.length, endB = iB == b2.length;
    if (endA || endB)
      return endA == endB;
    if (a3[iA++].result != b2[iB++].result)
      return false;
  }
}
var baseAttrs = {
  "aria-autocomplete": "list"
};
function makeAttrs(id, selected) {
  let result = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": id
  };
  if (selected > -1)
    result["aria-activedescendant"] = id + "-" + selected;
  return result;
}
var none2 = [];
function getUserEvent(tr2) {
  return tr2.isUserEvent("input.type") ? "input" : tr2.isUserEvent("delete.backward") ? "delete" : null;
}
var ActiveSource = class _ActiveSource {
  constructor(source, state, explicitPos = -1) {
    this.source = source;
    this.state = state;
    this.explicitPos = explicitPos;
  }
  hasResult() {
    return false;
  }
  update(tr2, conf) {
    let event = getUserEvent(tr2), value = this;
    if (event)
      value = value.handleUserEvent(tr2, event, conf);
    else if (tr2.docChanged)
      value = value.handleChange(tr2);
    else if (tr2.selection && value.state != 0)
      value = new _ActiveSource(
        value.source,
        0
        /* State.Inactive */
      );
    for (let effect4 of tr2.effects) {
      if (effect4.is(startCompletionEffect))
        value = new _ActiveSource(value.source, 1, effect4.value ? cur(tr2.state) : -1);
      else if (effect4.is(closeCompletionEffect))
        value = new _ActiveSource(
          value.source,
          0
          /* State.Inactive */
        );
      else if (effect4.is(setActiveEffect)) {
        for (let active of effect4.value)
          if (active.source == value.source)
            value = active;
      }
    }
    return value;
  }
  handleUserEvent(tr2, type, conf) {
    return type == "delete" || !conf.activateOnTyping ? this.map(tr2.changes) : new _ActiveSource(
      this.source,
      1
      /* State.Pending */
    );
  }
  handleChange(tr2) {
    return tr2.changes.touchesRange(cur(tr2.startState)) ? new _ActiveSource(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(tr2.changes);
  }
  map(changes) {
    return changes.empty || this.explicitPos < 0 ? this : new _ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));
  }
};
var ActiveResult = class _ActiveResult extends ActiveSource {
  constructor(source, explicitPos, result, from2, to) {
    super(source, 2, explicitPos);
    this.result = result;
    this.from = from2;
    this.to = to;
  }
  hasResult() {
    return true;
  }
  handleUserEvent(tr2, type, conf) {
    var _a2;
    let from2 = tr2.changes.mapPos(this.from), to = tr2.changes.mapPos(this.to, 1);
    let pos = cur(tr2.state);
    if ((this.explicitPos < 0 ? pos <= from2 : pos < this.from) || pos > to || type == "delete" && cur(tr2.startState) == this.from)
      return new ActiveSource(
        this.source,
        type == "input" && conf.activateOnTyping ? 1 : 0
        /* State.Inactive */
      );
    let explicitPos = this.explicitPos < 0 ? -1 : tr2.changes.mapPos(this.explicitPos), updated;
    if (checkValid(this.result.validFor, tr2.state, from2, to))
      return new _ActiveResult(this.source, explicitPos, this.result, from2, to);
    if (this.result.update && (updated = this.result.update(this.result, from2, to, new CompletionContext(tr2.state, pos, explicitPos >= 0))))
      return new _ActiveResult(this.source, explicitPos, updated, updated.from, (_a2 = updated.to) !== null && _a2 !== void 0 ? _a2 : cur(tr2.state));
    return new ActiveSource(this.source, 1, explicitPos);
  }
  handleChange(tr2) {
    return tr2.changes.touchesRange(this.from, this.to) ? new ActiveSource(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(tr2.changes);
  }
  map(mapping) {
    return mapping.empty ? this : new _ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
  }
};
function checkValid(validFor, state, from2, to) {
  if (!validFor)
    return false;
  let text = state.sliceDoc(from2, to);
  return typeof validFor == "function" ? validFor(text, from2, to, state) : ensureAnchor(validFor, true).test(text);
}
var setActiveEffect = StateEffect.define({
  map(sources, mapping) {
    return sources.map((s3) => s3.map(mapping));
  }
});
var setSelectedEffect = StateEffect.define();
var completionState = StateField.define({
  create() {
    return CompletionState.start();
  },
  update(value, tr2) {
    return value.update(tr2);
  },
  provide: (f) => [
    showTooltip.from(f, (val) => val.tooltip),
    EditorView.contentAttributes.from(f, (state) => state.attrs)
  ]
});
function applyCompletion(view, option) {
  const apply = option.completion.apply || option.completion.label;
  let result = view.state.field(completionState).active.find((a3) => a3.source == option.source);
  if (!(result instanceof ActiveResult))
    return false;
  if (typeof apply == "string")
    view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), { annotations: pickedCompletion.of(option.completion) }));
  else
    apply(view, option.completion, result.from, result.to);
  return true;
}
var createTooltip = completionTooltip(completionState, applyCompletion);
function moveCompletionSelection(forward, by = "option") {
  return (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
      return false;
    let step = 1, tooltip;
    if (by == "page" && (tooltip = getTooltip(view, cState.open.tooltip)))
      step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
    let { length: length2 } = cState.open.options;
    let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length2 - 1;
    if (selected < 0)
      selected = by == "page" ? 0 : length2 - 1;
    else if (selected >= length2)
      selected = by == "page" ? length2 - 1 : 0;
    view.dispatch({ effects: setSelectedEffect.of(selected) });
    return true;
  };
}
var acceptCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
    return false;
  return applyCompletion(view, cState.open.options[cState.open.selected]);
};
var startCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState)
    return false;
  view.dispatch({ effects: startCompletionEffect.of(true) });
  return true;
};
var closeCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState || !cState.active.some(
    (a3) => a3.state != 0
    /* State.Inactive */
  ))
    return false;
  view.dispatch({ effects: closeCompletionEffect.of(null) });
  return true;
};
var RunningQuery = class {
  constructor(active, context) {
    this.active = active;
    this.context = context;
    this.time = Date.now();
    this.updates = [];
    this.done = void 0;
  }
};
var MaxUpdateCount = 50;
var MinAbortTime = 1e3;
var completionPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.debounceUpdate = -1;
    this.running = [];
    this.debounceAccept = -1;
    this.pendingStart = false;
    this.composing = 0;
    for (let active of view.state.field(completionState).active)
      if (active.state == 1)
        this.startQuery(active);
  }
  update(update) {
    let cState = update.state.field(completionState);
    if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)
      return;
    let doesReset = update.transactions.some((tr2) => {
      return (tr2.selection || tr2.docChanged) && !getUserEvent(tr2);
    });
    for (let i2 = 0; i2 < this.running.length; i2++) {
      let query = this.running[i2];
      if (doesReset || query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
        for (let handler of query.context.abortListeners) {
          try {
            handler();
          } catch (e4) {
            logException(this.view.state, e4);
          }
        }
        query.context.abortListeners = null;
        this.running.splice(i2--, 1);
      } else {
        query.updates.push(...update.transactions);
      }
    }
    if (this.debounceUpdate > -1)
      clearTimeout(this.debounceUpdate);
    if (update.transactions.some((tr2) => tr2.effects.some((e4) => e4.is(startCompletionEffect))))
      this.pendingStart = true;
    let delay = this.pendingStart ? 50 : update.state.facet(completionConfig).activateOnTypingDelay;
    this.debounceUpdate = cState.active.some((a3) => a3.state == 1 && !this.running.some((q2) => q2.active.source == a3.source)) ? setTimeout(() => this.startUpdate(), delay) : -1;
    if (this.composing != 0)
      for (let tr2 of update.transactions) {
        if (getUserEvent(tr2) == "input")
          this.composing = 2;
        else if (this.composing == 2 && tr2.selection)
          this.composing = 3;
      }
  }
  startUpdate() {
    this.debounceUpdate = -1;
    this.pendingStart = false;
    let { state } = this.view, cState = state.field(completionState);
    for (let active of cState.active) {
      if (active.state == 1 && !this.running.some((r2) => r2.active.source == active.source))
        this.startQuery(active);
    }
  }
  startQuery(active) {
    let { state } = this.view, pos = cur(state);
    let context = new CompletionContext(state, pos, active.explicitPos == pos);
    let pending = new RunningQuery(active, context);
    this.running.push(pending);
    Promise.resolve(active.source(context)).then((result) => {
      if (!pending.context.aborted) {
        pending.done = result || null;
        this.scheduleAccept();
      }
    }, (err) => {
      this.view.dispatch({ effects: closeCompletionEffect.of(null) });
      logException(this.view.state, err);
    });
  }
  scheduleAccept() {
    if (this.running.every((q2) => q2.done !== void 0))
      this.accept();
    else if (this.debounceAccept < 0)
      this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var _a2;
    if (this.debounceAccept > -1)
      clearTimeout(this.debounceAccept);
    this.debounceAccept = -1;
    let updated = [];
    let conf = this.view.state.facet(completionConfig);
    for (let i2 = 0; i2 < this.running.length; i2++) {
      let query = this.running[i2];
      if (query.done === void 0)
        continue;
      this.running.splice(i2--, 1);
      if (query.done) {
        let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a2 = query.done.to) !== null && _a2 !== void 0 ? _a2 : cur(query.updates.length ? query.updates[0].startState : this.view.state));
        for (let tr2 of query.updates)
          active = active.update(tr2, conf);
        if (active.hasResult()) {
          updated.push(active);
          continue;
        }
      }
      let current = this.view.state.field(completionState).active.find((a3) => a3.source == query.active.source);
      if (current && current.state == 1) {
        if (query.done == null) {
          let active = new ActiveSource(
            query.active.source,
            0
            /* State.Inactive */
          );
          for (let tr2 of query.updates)
            active = active.update(tr2, conf);
          if (active.state != 1)
            updated.push(active);
        } else {
          this.startQuery(current);
        }
      }
    }
    if (updated.length)
      this.view.dispatch({ effects: setActiveEffect.of(updated) });
  }
}, {
  eventHandlers: {
    blur(event) {
      let state = this.view.state.field(completionState, false);
      if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {
        let dialog = state.open && getTooltip(this.view, state.open.tooltip);
        if (!dialog || !dialog.dom.contains(event.relatedTarget))
          setTimeout(() => this.view.dispatch({ effects: closeCompletionEffect.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      if (this.composing == 3) {
        setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);
      }
      this.composing = 0;
    }
  }
});
var baseTheme3 = EditorView.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '""',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: `${400}px`,
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30}px` },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30}px` },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "''" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
var fieldMarker = Decoration.widget({ widget: new class extends WidgetType {
  toDOM() {
    let span = document.createElement("span");
    span.className = "cm-snippetFieldPosition";
    return span;
  }
  ignoreEvent() {
    return false;
  }
}() });
var fieldRange = Decoration.mark({ class: "cm-snippetField" });
var ActiveSnippet = class _ActiveSnippet {
  constructor(ranges, active) {
    this.ranges = ranges;
    this.active = active;
    this.deco = Decoration.set(ranges.map((r2) => (r2.from == r2.to ? fieldMarker : fieldRange).range(r2.from, r2.to)));
  }
  map(changes) {
    let ranges = [];
    for (let r2 of this.ranges) {
      let mapped = r2.map(changes);
      if (!mapped)
        return null;
      ranges.push(mapped);
    }
    return new _ActiveSnippet(ranges, this.active);
  }
  selectionInsideField(sel) {
    return sel.ranges.every((range) => this.ranges.some((r2) => r2.field == this.active && r2.from <= range.from && r2.to >= range.to));
  }
};
var setActive = StateEffect.define({
  map(value, changes) {
    return value && value.map(changes);
  }
});
var moveToField = StateEffect.define();
var snippetState = StateField.define({
  create() {
    return null;
  },
  update(value, tr2) {
    for (let effect4 of tr2.effects) {
      if (effect4.is(setActive))
        return effect4.value;
      if (effect4.is(moveToField) && value)
        return new ActiveSnippet(value.ranges, effect4.value);
    }
    if (value && tr2.docChanged)
      value = value.map(tr2.changes);
    if (value && tr2.selection && !value.selectionInsideField(tr2.selection))
      value = null;
    return value;
  },
  provide: (f) => EditorView.decorations.from(f, (val) => val ? val.deco : Decoration.none)
});
function fieldSelection(ranges, field) {
  return EditorSelection.create(ranges.filter((r2) => r2.field == field).map((r2) => EditorSelection.range(r2.from, r2.to)));
}
function moveField(dir) {
  return ({ state, dispatch }) => {
    let active = state.field(snippetState, false);
    if (!active || dir < 0 && active.active == 0)
      return false;
    let next2 = active.active + dir, last = dir > 0 && !active.ranges.some((r2) => r2.field == next2 + dir);
    dispatch(state.update({
      selection: fieldSelection(active.ranges, next2),
      effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next2)),
      scrollIntoView: true
    }));
    return true;
  };
}
var clearSnippet = ({ state, dispatch }) => {
  let active = state.field(snippetState, false);
  if (!active)
    return false;
  dispatch(state.update({ effects: setActive.of(null) }));
  return true;
};
var nextSnippetField = moveField(1);
var prevSnippetField = moveField(-1);
var defaultSnippetKeymap = [
  { key: "Tab", run: nextSnippetField, shift: prevSnippetField },
  { key: "Escape", run: clearSnippet }
];
var snippetKeymap = Facet.define({
  combine(maps) {
    return maps.length ? maps[0] : defaultSnippetKeymap;
  }
});
var addSnippetKeymap = Prec.highest(keymap.compute([snippetKeymap], (state) => state.facet(snippetKeymap)));
var snippetPointerHandler = EditorView.domEventHandlers({
  mousedown(event, view) {
    let active = view.state.field(snippetState, false), pos;
    if (!active || (pos = view.posAtCoords({ x: event.clientX, y: event.clientY })) == null)
      return false;
    let match3 = active.ranges.find((r2) => r2.from <= pos && r2.to >= pos);
    if (!match3 || match3.field == active.active)
      return false;
    view.dispatch({
      selection: fieldSelection(active.ranges, match3.field),
      effects: setActive.of(active.ranges.some((r2) => r2.field > match3.field) ? new ActiveSnippet(active.ranges, match3.field) : null),
      scrollIntoView: true
    });
    return true;
  }
});
var defaults2 = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
};
var closeBracketEffect = StateEffect.define({
  map(value, mapping) {
    let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
    return mapped == null ? void 0 : mapped;
  }
});
var closedBracket = new class extends RangeValue {
}();
closedBracket.startSide = 1;
closedBracket.endSide = -1;
var bracketState = StateField.define({
  create() {
    return RangeSet.empty;
  },
  update(value, tr2) {
    value = value.map(tr2.changes);
    if (tr2.selection) {
      let line2 = tr2.state.doc.lineAt(tr2.selection.main.head);
      value = value.update({ filter: (from2) => from2 >= line2.from && from2 <= line2.to });
    }
    for (let effect4 of tr2.effects)
      if (effect4.is(closeBracketEffect))
        value = value.update({ add: [closedBracket.range(effect4.value, effect4.value + 1)] });
    return value;
  }
});
function closeBrackets() {
  return [inputHandler2, bracketState];
}
var definedClosing = "()[]{}<>";
function closing(ch) {
  for (let i2 = 0; i2 < definedClosing.length; i2 += 2)
    if (definedClosing.charCodeAt(i2) == ch)
      return definedClosing.charAt(i2 + 1);
  return fromCodePoint(ch < 128 ? ch : ch + 1);
}
function config(state, pos) {
  return state.languageDataAt("closeBrackets", pos)[0] || defaults2;
}
var android = typeof navigator == "object" && /Android\b/.test(navigator.userAgent);
var inputHandler2 = EditorView.inputHandler.of((view, from2, to, insert2) => {
  if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)
    return false;
  let sel = view.state.selection.main;
  if (insert2.length > 2 || insert2.length == 2 && codePointSize(codePointAt(insert2, 0)) == 1 || from2 != sel.from || to != sel.to)
    return false;
  let tr2 = insertBracket(view.state, insert2);
  if (!tr2)
    return false;
  view.dispatch(tr2);
  return true;
});
var deleteBracketPair = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let conf = config(state, state.selection.main.head);
  let tokens2 = conf.brackets || defaults2.brackets;
  let dont = null, changes = state.changeByRange((range) => {
    if (range.empty) {
      let before = prevChar(state.doc, range.head);
      for (let token2 of tokens2) {
        if (token2 == before && nextChar(state.doc, range.head) == closing(codePointAt(token2, 0)))
          return {
            changes: { from: range.head - token2.length, to: range.head + token2.length },
            range: EditorSelection.cursor(range.head - token2.length)
          };
      }
    }
    return { range: dont = range };
  });
  if (!dont)
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "delete.backward" }));
  return !dont;
};
var closeBracketsKeymap = [
  { key: "Backspace", run: deleteBracketPair }
];
function insertBracket(state, bracket2) {
  let conf = config(state, state.selection.main.head);
  let tokens2 = conf.brackets || defaults2.brackets;
  for (let tok of tokens2) {
    let closed = closing(codePointAt(tok, 0));
    if (bracket2 == tok)
      return closed == tok ? handleSame(state, tok, tokens2.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults2.before);
    if (bracket2 == closed && closedBracketAt(state, state.selection.main.from))
      return handleClose(state, tok, closed);
  }
  return null;
}
function closedBracketAt(state, pos) {
  let found = false;
  state.field(bracketState).between(0, state.doc.length, (from2) => {
    if (from2 == pos)
      found = true;
  });
  return found;
}
function nextChar(doc2, pos) {
  let next2 = doc2.sliceString(pos, pos + 2);
  return next2.slice(0, codePointSize(codePointAt(next2, 0)));
}
function prevChar(doc2, pos) {
  let prev2 = doc2.sliceString(pos - 2, pos);
  return codePointSize(codePointAt(prev2, 0)) == prev2.length ? prev2 : prev2.slice(1);
}
function handleOpen(state, open, close, closeBefore) {
  let dont = null, changes = state.changeByRange((range) => {
    if (!range.empty)
      return {
        changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],
        effects: closeBracketEffect.of(range.to + open.length),
        range: EditorSelection.range(range.anchor + open.length, range.head + open.length)
      };
    let next2 = nextChar(state.doc, range.head);
    if (!next2 || /\s/.test(next2) || closeBefore.indexOf(next2) > -1)
      return {
        changes: { insert: open + close, from: range.head },
        effects: closeBracketEffect.of(range.head + open.length),
        range: EditorSelection.cursor(range.head + open.length)
      };
    return { range: dont = range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function handleClose(state, _open, close) {
  let dont = null, changes = state.changeByRange((range) => {
    if (range.empty && nextChar(state.doc, range.head) == close)
      return {
        changes: { from: range.head, to: range.head + close.length, insert: close },
        range: EditorSelection.cursor(range.head + close.length)
      };
    return dont = { range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function handleSame(state, token2, allowTriple, config2) {
  let stringPrefixes = config2.stringPrefixes || defaults2.stringPrefixes;
  let dont = null, changes = state.changeByRange((range) => {
    if (!range.empty)
      return {
        changes: [{ insert: token2, from: range.from }, { insert: token2, from: range.to }],
        effects: closeBracketEffect.of(range.to + token2.length),
        range: EditorSelection.range(range.anchor + token2.length, range.head + token2.length)
      };
    let pos = range.head, next2 = nextChar(state.doc, pos), start2;
    if (next2 == token2) {
      if (nodeStart(state, pos)) {
        return {
          changes: { insert: token2 + token2, from: pos },
          effects: closeBracketEffect.of(pos + token2.length),
          range: EditorSelection.cursor(pos + token2.length)
        };
      } else if (closedBracketAt(state, pos)) {
        let isTriple = allowTriple && state.sliceDoc(pos, pos + token2.length * 3) == token2 + token2 + token2;
        let content2 = isTriple ? token2 + token2 + token2 : token2;
        return {
          changes: { from: pos, to: pos + content2.length, insert: content2 },
          range: EditorSelection.cursor(pos + content2.length)
        };
      }
    } else if (allowTriple && state.sliceDoc(pos - 2 * token2.length, pos) == token2 + token2 && (start2 = canStartStringAt(state, pos - 2 * token2.length, stringPrefixes)) > -1 && nodeStart(state, start2)) {
      return {
        changes: { insert: token2 + token2 + token2 + token2, from: pos },
        effects: closeBracketEffect.of(pos + token2.length),
        range: EditorSelection.cursor(pos + token2.length)
      };
    } else if (state.charCategorizer(pos)(next2) != CharCategory.Word) {
      if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token2, stringPrefixes))
        return {
          changes: { insert: token2 + token2, from: pos },
          effects: closeBracketEffect.of(pos + token2.length),
          range: EditorSelection.cursor(pos + token2.length)
        };
    }
    return { range: dont = range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function nodeStart(state, pos) {
  let tree = syntaxTree(state).resolveInner(pos + 1);
  return tree.parent && tree.from == pos;
}
function probablyInString(state, pos, quoteToken, prefixes) {
  let node3 = syntaxTree(state).resolveInner(pos, -1);
  let maxPrefix = prefixes.reduce((m3, p) => Math.max(m3, p.length), 0);
  for (let i2 = 0; i2 < 5; i2++) {
    let start2 = state.sliceDoc(node3.from, Math.min(node3.to, node3.from + quoteToken.length + maxPrefix));
    let quotePos = start2.indexOf(quoteToken);
    if (!quotePos || quotePos > -1 && prefixes.indexOf(start2.slice(0, quotePos)) > -1) {
      let first = node3.firstChild;
      while (first && first.from == node3.from && first.to - first.from > quoteToken.length + quotePos) {
        if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)
          return false;
        first = first.firstChild;
      }
      return true;
    }
    let parent = node3.to == pos && node3.parent;
    if (!parent)
      break;
    node3 = parent;
  }
  return false;
}
function canStartStringAt(state, pos, prefixes) {
  let charCat = state.charCategorizer(pos);
  if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word)
    return pos;
  for (let prefix3 of prefixes) {
    let start2 = pos - prefix3.length;
    if (state.sliceDoc(start2, pos) == prefix3 && charCat(state.sliceDoc(start2 - 1, start2)) != CharCategory.Word)
      return start2;
  }
  return -1;
}
function autocompletion(config2 = {}) {
  return [
    completionState,
    completionConfig.of(config2),
    completionPlugin,
    completionKeymapExt,
    baseTheme3
  ];
}
var completionKeymap = [
  { key: "Ctrl-Space", run: startCompletion },
  { key: "Escape", run: closeCompletion },
  { key: "ArrowDown", run: moveCompletionSelection(true) },
  { key: "ArrowUp", run: moveCompletionSelection(false) },
  { key: "PageDown", run: moveCompletionSelection(true, "page") },
  { key: "PageUp", run: moveCompletionSelection(false, "page") },
  { key: "Enter", run: acceptCompletion }
];
var completionKeymapExt = Prec.highest(keymap.computeN([completionConfig], (state) => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));
function completionStatus(state) {
  let cState = state.field(completionState, false);
  return cState && cState.active.some(
    (a3) => a3.state == 1
    /* State.Pending */
  ) ? "pending" : cState && cState.active.some(
    (a3) => a3.state != 0
    /* State.Inactive */
  ) ? "active" : null;
}
function setSelectedCompletion(index4) {
  return setSelectedEffect.of(index4);
}

// node_modules/crelt/index.js
function crelt() {
  var elt = arguments[0];
  if (typeof elt == "string")
    elt = document.createElement(elt);
  var i2 = 1, next2 = arguments[1];
  if (next2 && typeof next2 == "object" && next2.nodeType == null && !Array.isArray(next2)) {
    for (var name2 in next2)
      if (Object.prototype.hasOwnProperty.call(next2, name2)) {
        var value = next2[name2];
        if (typeof value == "string")
          elt.setAttribute(name2, value);
        else if (value != null)
          elt[name2] = value;
      }
    i2++;
  }
  for (; i2 < arguments.length; i2++)
    add2(elt, arguments[i2]);
  return elt;
}
function add2(elt, child) {
  if (typeof child == "string") {
    elt.appendChild(document.createTextNode(child));
  } else if (child == null) {
  } else if (child.nodeType != null) {
    elt.appendChild(child);
  } else if (Array.isArray(child)) {
    for (var i2 = 0; i2 < child.length; i2++)
      add2(elt, child[i2]);
  } else {
    throw new RangeError("Unsupported child node: " + child);
  }
}

// node_modules/@codemirror/search/dist/index.js
var basicNormalize = typeof String.prototype.normalize == "function" ? (x2) => x2.normalize("NFKD") : (x2) => x2;
var SearchCursor = class {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(text, query, from2 = 0, to = text.length, normalize, test) {
    this.test = test;
    this.value = { from: 0, to: 0 };
    this.done = false;
    this.matches = [];
    this.buffer = "";
    this.bufferPos = 0;
    this.iter = text.iterRange(from2, to);
    this.bufferStart = from2;
    this.normalize = normalize ? (x2) => normalize(basicNormalize(x2)) : basicNormalize;
    this.query = this.normalize(query);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      this.bufferStart += this.buffer.length;
      this.iter.next();
      if (this.iter.done)
        return -1;
      this.bufferPos = 0;
      this.buffer = this.iter.value;
    }
    return codePointAt(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    while (this.matches.length)
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let next2 = this.peek();
      if (next2 < 0) {
        this.done = true;
        return this;
      }
      let str = fromCodePoint(next2), start2 = this.bufferStart + this.bufferPos;
      this.bufferPos += codePointSize(next2);
      let norm2 = this.normalize(str);
      for (let i2 = 0, pos = start2; ; i2++) {
        let code = norm2.charCodeAt(i2);
        let match3 = this.match(code, pos);
        if (i2 == norm2.length - 1) {
          if (match3) {
            this.value = match3;
            return this;
          }
          break;
        }
        if (pos == start2 && i2 < str.length && str.charCodeAt(i2) == code)
          pos++;
      }
    }
  }
  match(code, pos) {
    let match3 = null;
    for (let i2 = 0; i2 < this.matches.length; i2 += 2) {
      let index4 = this.matches[i2], keep = false;
      if (this.query.charCodeAt(index4) == code) {
        if (index4 == this.query.length - 1) {
          match3 = { from: this.matches[i2 + 1], to: pos + 1 };
        } else {
          this.matches[i2]++;
          keep = true;
        }
      }
      if (!keep) {
        this.matches.splice(i2, 2);
        i2 -= 2;
      }
    }
    if (this.query.charCodeAt(0) == code) {
      if (this.query.length == 1)
        match3 = { from: pos, to: pos + 1 };
      else
        this.matches.push(1, pos);
    }
    if (match3 && this.test && !this.test(match3.from, match3.to, this.buffer, this.bufferStart))
      match3 = null;
    return match3;
  }
};
if (typeof Symbol != "undefined")
  SearchCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
var empty = { from: -1, to: -1, match: /.*/.exec("") };
var baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
var RegExpCursor = class {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(text, query, options2, from2 = 0, to = text.length) {
    this.text = text;
    this.to = to;
    this.curLine = "";
    this.done = false;
    this.value = empty;
    if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
      return new MultilineRegExpCursor(text, query, options2, from2, to);
    this.re = new RegExp(query, baseFlags + ((options2 === null || options2 === void 0 ? void 0 : options2.ignoreCase) ? "i" : ""));
    this.test = options2 === null || options2 === void 0 ? void 0 : options2.test;
    this.iter = text.iter();
    let startLine = text.lineAt(from2);
    this.curLineStart = startLine.from;
    this.matchPos = toCharEnd(text, from2);
    this.getLine(this.curLineStart);
  }
  getLine(skip) {
    this.iter.next(skip);
    if (this.iter.lineBreak) {
      this.curLine = "";
    } else {
      this.curLine = this.iter.value;
      if (this.curLineStart + this.curLine.length > this.to)
        this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
      this.iter.next();
    }
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1;
    if (this.curLineStart > this.to)
      this.curLine = "";
    else
      this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let off2 = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = off2;
      let match3 = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (match3) {
        let from2 = this.curLineStart + match3.index, to = from2 + match3[0].length;
        this.matchPos = toCharEnd(this.text, to + (from2 == to ? 1 : 0));
        if (from2 == this.curLineStart + this.curLine.length)
          this.nextLine();
        if ((from2 < to || from2 > this.value.to) && (!this.test || this.test(from2, to, match3))) {
          this.value = { from: from2, to, match: match3 };
          return this;
        }
        off2 = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to) {
        this.nextLine();
        off2 = 0;
      } else {
        this.done = true;
        return this;
      }
    }
  }
};
var flattened = /* @__PURE__ */ new WeakMap();
var FlattenedDoc = class _FlattenedDoc {
  constructor(from2, text) {
    this.from = from2;
    this.text = text;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(doc2, from2, to) {
    let cached = flattened.get(doc2);
    if (!cached || cached.from >= to || cached.to <= from2) {
      let flat = new _FlattenedDoc(from2, doc2.sliceString(from2, to));
      flattened.set(doc2, flat);
      return flat;
    }
    if (cached.from == from2 && cached.to == to)
      return cached;
    let { text, from: cachedFrom } = cached;
    if (cachedFrom > from2) {
      text = doc2.sliceString(from2, cachedFrom) + text;
      cachedFrom = from2;
    }
    if (cached.to < to)
      text += doc2.sliceString(cached.to, to);
    flattened.set(doc2, new _FlattenedDoc(cachedFrom, text));
    return new _FlattenedDoc(from2, text.slice(from2 - cachedFrom, to - cachedFrom));
  }
};
var MultilineRegExpCursor = class {
  constructor(text, query, options2, from2, to) {
    this.text = text;
    this.to = to;
    this.done = false;
    this.value = empty;
    this.matchPos = toCharEnd(text, from2);
    this.re = new RegExp(query, baseFlags + ((options2 === null || options2 === void 0 ? void 0 : options2.ignoreCase) ? "i" : ""));
    this.test = options2 === null || options2 === void 0 ? void 0 : options2.test;
    this.flat = FlattenedDoc.get(text, from2, this.chunkEnd(
      from2 + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(pos) {
    return pos >= this.to ? this.to : this.text.lineAt(pos).to;
  }
  next() {
    for (; ; ) {
      let off2 = this.re.lastIndex = this.matchPos - this.flat.from;
      let match3 = this.re.exec(this.flat.text);
      if (match3 && !match3[0] && match3.index == off2) {
        this.re.lastIndex = off2 + 1;
        match3 = this.re.exec(this.flat.text);
      }
      if (match3) {
        let from2 = this.flat.from + match3.index, to = from2 + match3[0].length;
        if ((this.flat.to >= this.to || match3.index + match3[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from2, to, match3))) {
          this.value = { from: from2, to, match: match3 };
          this.matchPos = toCharEnd(this.text, to + (from2 == to ? 1 : 0));
          return this;
        }
      }
      if (this.flat.to == this.to) {
        this.done = true;
        return this;
      }
      this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
};
if (typeof Symbol != "undefined") {
  RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
function validRegExp(source) {
  try {
    new RegExp(source, baseFlags);
    return true;
  } catch (_a2) {
    return false;
  }
}
function toCharEnd(text, pos) {
  if (pos >= text.length)
    return pos;
  let line2 = text.lineAt(pos), next2;
  while (pos < line2.to && (next2 = line2.text.charCodeAt(pos - line2.from)) >= 56320 && next2 < 57344)
    pos++;
  return pos;
}
function createLineDialog(view) {
  let line2 = String(view.state.doc.lineAt(view.state.selection.main.head).number);
  let input = crelt("input", { class: "cm-textfield", name: "line", value: line2 });
  let dom = crelt("form", {
    class: "cm-gotoLine",
    onkeydown: (event) => {
      if (event.keyCode == 27) {
        event.preventDefault();
        view.dispatch({ effects: dialogEffect.of(false) });
        view.focus();
      } else if (event.keyCode == 13) {
        event.preventDefault();
        go();
      }
    },
    onsubmit: (event) => {
      event.preventDefault();
      go();
    }
  }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", { class: "cm-button", type: "submit" }, view.state.phrase("go")));
  function go() {
    let match3 = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
    if (!match3)
      return;
    let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);
    let [, sign, ln, cl, percent] = match3;
    let col = cl ? +cl.slice(1) : 0;
    let line3 = ln ? +ln : startLine.number;
    if (ln && percent) {
      let pc = line3 / 100;
      if (sign)
        pc = pc * (sign == "-" ? -1 : 1) + startLine.number / state.doc.lines;
      line3 = Math.round(state.doc.lines * pc);
    } else if (ln && sign) {
      line3 = line3 * (sign == "-" ? -1 : 1) + startLine.number;
    }
    let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line3)));
    let selection = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));
    view.dispatch({
      effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection.from, { y: "center" })],
      selection
    });
    view.focus();
  }
  return { dom };
}
var dialogEffect = StateEffect.define();
var dialogField = StateField.define({
  create() {
    return true;
  },
  update(value, tr2) {
    for (let e4 of tr2.effects)
      if (e4.is(dialogEffect))
        value = e4.value;
    return value;
  },
  provide: (f) => showPanel.from(f, (val) => val ? createLineDialog : null)
});
var gotoLine = (view) => {
  let panel = getPanel(view, createLineDialog);
  if (!panel) {
    let effects = [dialogEffect.of(true)];
    if (view.state.field(dialogField, false) == null)
      effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$13]));
    view.dispatch({ effects });
    panel = getPanel(view, createLineDialog);
  }
  if (panel)
    panel.dom.querySelector("input").select();
  return true;
};
var baseTheme$13 = EditorView.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
});
var defaultHighlightOptions = {
  highlightWordAroundCursor: false,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: false
};
var highlightConfig = Facet.define({
  combine(options2) {
    return combineConfig(options2, defaultHighlightOptions, {
      highlightWordAroundCursor: (a3, b2) => a3 || b2,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
var matchDeco = Decoration.mark({ class: "cm-selectionMatch" });
var mainMatchDeco = Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function insideWordBoundaries(check, state, from2, to) {
  return (from2 == 0 || check(state.sliceDoc(from2 - 1, from2)) != CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);
}
function insideWord(check, state, from2, to) {
  return check(state.sliceDoc(from2, from2 + 1)) == CharCategory.Word && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;
}
var matchHighlighter = ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update) {
    if (update.selectionSet || update.docChanged || update.viewportChanged)
      this.decorations = this.getDeco(update.view);
  }
  getDeco(view) {
    let conf = view.state.facet(highlightConfig);
    let { state } = view, sel = state.selection;
    if (sel.ranges.length > 1)
      return Decoration.none;
    let range = sel.main, query, check = null;
    if (range.empty) {
      if (!conf.highlightWordAroundCursor)
        return Decoration.none;
      let word = state.wordAt(range.head);
      if (!word)
        return Decoration.none;
      check = state.charCategorizer(range.head);
      query = state.sliceDoc(word.from, word.to);
    } else {
      let len = range.to - range.from;
      if (len < conf.minSelectionLength || len > 200)
        return Decoration.none;
      if (conf.wholeWords) {
        query = state.sliceDoc(range.from, range.to);
        check = state.charCategorizer(range.head);
        if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to)))
          return Decoration.none;
      } else {
        query = state.sliceDoc(range.from, range.to).trim();
        if (!query)
          return Decoration.none;
      }
    }
    let deco = [];
    for (let part of view.visibleRanges) {
      let cursor2 = new SearchCursor(state.doc, query, part.from, part.to);
      while (!cursor2.next().done) {
        let { from: from2, to } = cursor2.value;
        if (!check || insideWordBoundaries(check, state, from2, to)) {
          if (range.empty && from2 <= range.from && to >= range.to)
            deco.push(mainMatchDeco.range(from2, to));
          else if (from2 >= range.to || to <= range.from)
            deco.push(matchDeco.range(from2, to));
          if (deco.length > conf.maxMatches)
            return Decoration.none;
        }
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: (v) => v.decorations
});
var defaultTheme2 = EditorView.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
});
var selectWord = ({ state, dispatch }) => {
  let { selection } = state;
  let newSel = EditorSelection.create(selection.ranges.map((range) => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);
  if (newSel.eq(selection))
    return false;
  dispatch(state.update({ selection: newSel }));
  return true;
};
function findNextOccurrence(state, query) {
  let { main: main2, ranges } = state.selection;
  let word = state.wordAt(main2.head), fullWord = word && word.from == main2.from && word.to == main2.to;
  for (let cycled = false, cursor2 = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to); ; ) {
    cursor2.next();
    if (cursor2.done) {
      if (cycled)
        return null;
      cursor2 = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
      cycled = true;
    } else {
      if (cycled && ranges.some((r2) => r2.from == cursor2.value.from))
        continue;
      if (fullWord) {
        let word2 = state.wordAt(cursor2.value.from);
        if (!word2 || word2.from != cursor2.value.from || word2.to != cursor2.value.to)
          continue;
      }
      return cursor2.value;
    }
  }
}
var selectNextOccurrence = ({ state, dispatch }) => {
  let { ranges } = state.selection;
  if (ranges.some((sel) => sel.from === sel.to))
    return selectWord({ state, dispatch });
  let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
  if (state.selection.ranges.some((r2) => state.sliceDoc(r2.from, r2.to) != searchedText))
    return false;
  let range = findNextOccurrence(state, searchedText);
  if (!range)
    return false;
  dispatch(state.update({
    selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),
    effects: EditorView.scrollIntoView(range.to)
  }));
  return true;
};
var searchConfigFacet = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      top: false,
      caseSensitive: false,
      literal: false,
      regexp: false,
      wholeWord: false,
      createPanel: (view) => new SearchPanel(view),
      scrollToMatch: (range) => EditorView.scrollIntoView(range)
    });
  }
});
function search(config2) {
  return config2 ? [searchConfigFacet.of(config2), searchExtensions] : searchExtensions;
}
var SearchQuery = class {
  /**
  Create a query object.
  */
  constructor(config2) {
    this.search = config2.search;
    this.caseSensitive = !!config2.caseSensitive;
    this.literal = !!config2.literal;
    this.regexp = !!config2.regexp;
    this.replace = config2.replace || "";
    this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
    this.unquoted = this.unquote(this.search);
    this.wholeWord = !!config2.wholeWord;
  }
  /**
  @internal
  */
  unquote(text) {
    return this.literal ? text : text.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(other) {
    return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(state, from2 = 0, to) {
    let st2 = state.doc ? state : EditorState.create({ doc: state });
    if (to == null)
      to = st2.doc.length;
    return this.regexp ? regexpCursor(this, st2, from2, to) : stringCursor(this, st2, from2, to);
  }
};
var QueryType2 = class {
  constructor(spec) {
    this.spec = spec;
  }
};
function stringCursor(spec, state, from2, to) {
  return new SearchCursor(state.doc, spec.unquoted, from2, to, spec.caseSensitive ? void 0 : (x2) => x2.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : void 0);
}
function stringWordTest(doc2, categorizer) {
  return (from2, to, buf, bufPos) => {
    if (bufPos > from2 || bufPos + buf.length < to) {
      bufPos = Math.max(0, from2 - 2);
      buf = doc2.sliceString(bufPos, Math.min(doc2.length, to + 2));
    }
    return (categorizer(charBefore(buf, from2 - bufPos)) != CharCategory.Word || categorizer(charAfter(buf, from2 - bufPos)) != CharCategory.Word) && (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word || categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);
  };
}
var StringQuery = class extends QueryType2 {
  constructor(spec) {
    super(spec);
  }
  nextMatch(state, curFrom, curTo) {
    let cursor2 = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
    if (cursor2.done)
      cursor2 = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();
    return cursor2.done ? null : cursor2.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(state, from2, to) {
    for (let pos = to; ; ) {
      let start2 = Math.max(from2, pos - 1e4 - this.spec.unquoted.length);
      let cursor2 = stringCursor(this.spec, state, start2, pos), range = null;
      while (!cursor2.nextOverlapping().done)
        range = cursor2.value;
      if (range)
        return range;
      if (start2 == from2)
        return null;
      pos -= 1e4;
    }
  }
  prevMatch(state, curFrom, curTo) {
    return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
  }
  getReplacement(_result) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(state, limit) {
    let cursor2 = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];
    while (!cursor2.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor2.value);
    }
    return ranges;
  }
  highlight(state, from2, to, add3) {
    let cursor2 = stringCursor(this.spec, state, Math.max(0, from2 - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));
    while (!cursor2.next().done)
      add3(cursor2.value.from, cursor2.value.to);
  }
};
function regexpCursor(spec, state, from2, to) {
  return new RegExpCursor(state.doc, spec.search, {
    ignoreCase: !spec.caseSensitive,
    test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : void 0
  }, from2, to);
}
function charBefore(str, index4) {
  return str.slice(findClusterBreak(str, index4, false), index4);
}
function charAfter(str, index4) {
  return str.slice(index4, findClusterBreak(str, index4));
}
function regexpWordTest(categorizer) {
  return (_from, _to, match3) => !match3[0].length || (categorizer(charBefore(match3.input, match3.index)) != CharCategory.Word || categorizer(charAfter(match3.input, match3.index)) != CharCategory.Word) && (categorizer(charAfter(match3.input, match3.index + match3[0].length)) != CharCategory.Word || categorizer(charBefore(match3.input, match3.index + match3[0].length)) != CharCategory.Word);
}
var RegExpQuery = class extends QueryType2 {
  nextMatch(state, curFrom, curTo) {
    let cursor2 = regexpCursor(this.spec, state, curTo, state.doc.length).next();
    if (cursor2.done)
      cursor2 = regexpCursor(this.spec, state, 0, curFrom).next();
    return cursor2.done ? null : cursor2.value;
  }
  prevMatchInRange(state, from2, to) {
    for (let size3 = 1; ; size3++) {
      let start2 = Math.max(
        from2,
        to - size3 * 1e4
        /* FindPrev.ChunkSize */
      );
      let cursor2 = regexpCursor(this.spec, state, start2, to), range = null;
      while (!cursor2.next().done)
        range = cursor2.value;
      if (range && (start2 == from2 || range.from > start2 + 10))
        return range;
      if (start2 == from2)
        return null;
    }
  }
  prevMatch(state, curFrom, curTo) {
    return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
  }
  getReplacement(result) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (m3, i2) => i2 == "$" ? "$" : i2 == "&" ? result.match[0] : i2 != "0" && +i2 < result.match.length ? result.match[i2] : m3);
  }
  matchAll(state, limit) {
    let cursor2 = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];
    while (!cursor2.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor2.value);
    }
    return ranges;
  }
  highlight(state, from2, to, add3) {
    let cursor2 = regexpCursor(this.spec, state, Math.max(
      0,
      from2 - 250
      /* RegExp.HighlightMargin */
    ), Math.min(to + 250, state.doc.length));
    while (!cursor2.next().done)
      add3(cursor2.value.from, cursor2.value.to);
  }
};
var setSearchQuery = StateEffect.define();
var togglePanel = StateEffect.define();
var searchState = StateField.define({
  create(state) {
    return new SearchState(defaultQuery(state).create(), null);
  },
  update(value, tr2) {
    for (let effect4 of tr2.effects) {
      if (effect4.is(setSearchQuery))
        value = new SearchState(effect4.value.create(), value.panel);
      else if (effect4.is(togglePanel))
        value = new SearchState(value.query, effect4.value ? createSearchPanel : null);
    }
    return value;
  },
  provide: (f) => showPanel.from(f, (val) => val.panel)
});
function getSearchQuery(state) {
  let curState = state.field(searchState, false);
  return curState ? curState.query.spec : defaultQuery(state);
}
var SearchState = class {
  constructor(query, panel) {
    this.query = query;
    this.panel = panel;
  }
};
var matchMark = Decoration.mark({ class: "cm-searchMatch" });
var selectedMatchMark = Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
var searchHighlighter = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.decorations = this.highlight(view.state.field(searchState));
  }
  update(update) {
    let state = update.state.field(searchState);
    if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
      this.decorations = this.highlight(state);
  }
  highlight({ query, panel }) {
    if (!panel || !query.spec.valid)
      return Decoration.none;
    let { view } = this;
    let builder = new RangeSetBuilder();
    for (let i2 = 0, ranges = view.visibleRanges, l = ranges.length; i2 < l; i2++) {
      let { from: from2, to } = ranges[i2];
      while (i2 < l - 1 && to > ranges[i2 + 1].from - 2 * 250)
        to = ranges[++i2].to;
      query.highlight(view.state, from2, to, (from3, to2) => {
        let selected = view.state.selection.ranges.some((r2) => r2.from == from3 && r2.to == to2);
        builder.add(from3, to2, selected ? selectedMatchMark : matchMark);
      });
    }
    return builder.finish();
  }
}, {
  decorations: (v) => v.decorations
});
function searchCommand(f) {
  return (view) => {
    let state = view.state.field(searchState, false);
    return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);
  };
}
var findNext = searchCommand((view, { query }) => {
  let { to } = view.state.selection.main;
  let next2 = query.nextMatch(view.state, to, to);
  if (!next2)
    return false;
  let selection = EditorSelection.single(next2.from, next2.to);
  let config2 = view.state.facet(searchConfigFacet);
  view.dispatch({
    selection,
    effects: [announceMatch(view, next2), config2.scrollToMatch(selection.main, view)],
    userEvent: "select.search"
  });
  selectSearchInput(view);
  return true;
});
var findPrevious = searchCommand((view, { query }) => {
  let { state } = view, { from: from2 } = state.selection.main;
  let prev2 = query.prevMatch(state, from2, from2);
  if (!prev2)
    return false;
  let selection = EditorSelection.single(prev2.from, prev2.to);
  let config2 = view.state.facet(searchConfigFacet);
  view.dispatch({
    selection,
    effects: [announceMatch(view, prev2), config2.scrollToMatch(selection.main, view)],
    userEvent: "select.search"
  });
  selectSearchInput(view);
  return true;
});
var selectMatches = searchCommand((view, { query }) => {
  let ranges = query.matchAll(view.state, 1e3);
  if (!ranges || !ranges.length)
    return false;
  view.dispatch({
    selection: EditorSelection.create(ranges.map((r2) => EditorSelection.range(r2.from, r2.to))),
    userEvent: "select.search.matches"
  });
  return true;
});
var selectSelectionMatches = ({ state, dispatch }) => {
  let sel = state.selection;
  if (sel.ranges.length > 1 || sel.main.empty)
    return false;
  let { from: from2, to } = sel.main;
  let ranges = [], main2 = 0;
  for (let cur2 = new SearchCursor(state.doc, state.sliceDoc(from2, to)); !cur2.next().done; ) {
    if (ranges.length > 1e3)
      return false;
    if (cur2.value.from == from2)
      main2 = ranges.length;
    ranges.push(EditorSelection.range(cur2.value.from, cur2.value.to));
  }
  dispatch(state.update({
    selection: EditorSelection.create(ranges, main2),
    userEvent: "select.search.matches"
  }));
  return true;
};
var replaceNext = searchCommand((view, { query }) => {
  let { state } = view, { from: from2, to } = state.selection.main;
  if (state.readOnly)
    return false;
  let next2 = query.nextMatch(state, from2, from2);
  if (!next2)
    return false;
  let changes = [], selection, replacement;
  let effects = [];
  if (next2.from == from2 && next2.to == to) {
    replacement = state.toText(query.getReplacement(next2));
    changes.push({ from: next2.from, to: next2.to, insert: replacement });
    next2 = query.nextMatch(state, next2.from, next2.to);
    effects.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from2).number) + "."));
  }
  if (next2) {
    let off2 = changes.length == 0 || changes[0].from >= next2.to ? 0 : next2.to - next2.from - replacement.length;
    selection = EditorSelection.single(next2.from - off2, next2.to - off2);
    effects.push(announceMatch(view, next2));
    effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));
  }
  view.dispatch({
    changes,
    selection,
    effects,
    userEvent: "input.replace"
  });
  return true;
});
var replaceAll = searchCommand((view, { query }) => {
  if (view.state.readOnly)
    return false;
  let changes = query.matchAll(view.state, 1e9).map((match3) => {
    let { from: from2, to } = match3;
    return { from: from2, to, insert: query.getReplacement(match3) };
  });
  if (!changes.length)
    return false;
  let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
  view.dispatch({
    changes,
    effects: EditorView.announce.of(announceText),
    userEvent: "input.replace.all"
  });
  return true;
});
function createSearchPanel(view) {
  return view.state.facet(searchConfigFacet).createPanel(view);
}
function defaultQuery(state, fallback) {
  var _a2, _b, _c, _d, _e2;
  let sel = state.selection.main;
  let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
  if (fallback && !selText)
    return fallback;
  let config2 = state.facet(searchConfigFacet);
  return new SearchQuery({
    search: ((_a2 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a2 !== void 0 ? _a2 : config2.literal) ? selText : selText.replace(/\n/g, "\\n"),
    caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config2.caseSensitive,
    literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config2.literal,
    regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config2.regexp,
    wholeWord: (_e2 = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e2 !== void 0 ? _e2 : config2.wholeWord
  });
}
function getSearchInput(view) {
  let panel = getPanel(view, createSearchPanel);
  return panel && panel.dom.querySelector("[main-field]");
}
function selectSearchInput(view) {
  let input = getSearchInput(view);
  if (input && input == view.root.activeElement)
    input.select();
}
var openSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (state && state.panel) {
    let searchInput = getSearchInput(view);
    if (searchInput && searchInput != view.root.activeElement) {
      let query = defaultQuery(view.state, state.query.spec);
      if (query.valid)
        view.dispatch({ effects: setSearchQuery.of(query) });
      searchInput.focus();
      searchInput.select();
    }
  } else {
    view.dispatch({ effects: [
      togglePanel.of(true),
      state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
    ] });
  }
  return true;
};
var closeSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (!state || !state.panel)
    return false;
  let panel = getPanel(view, createSearchPanel);
  if (panel && panel.dom.contains(view.root.activeElement))
    view.focus();
  view.dispatch({ effects: togglePanel.of(false) });
  return true;
};
var searchKeymap = [
  { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
  { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
  { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
  { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: selectSelectionMatches },
  { key: "Mod-Alt-g", run: gotoLine },
  { key: "Mod-d", run: selectNextOccurrence, preventDefault: true }
];
var SearchPanel = class {
  constructor(view) {
    this.view = view;
    let query = this.query = view.state.field(searchState).query.spec;
    this.commit = this.commit.bind(this);
    this.searchField = crelt("input", {
      value: query.search,
      placeholder: phrase(view, "Find"),
      "aria-label": phrase(view, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.replaceField = crelt("input", {
      value: query.replace,
      placeholder: phrase(view, "Replace"),
      "aria-label": phrase(view, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.caseField = crelt("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: query.caseSensitive,
      onchange: this.commit
    });
    this.reField = crelt("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: query.regexp,
      onchange: this.commit
    });
    this.wordField = crelt("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: query.wholeWord,
      onchange: this.commit
    });
    function button(name2, onclick, content2) {
      return crelt("button", { class: "cm-button", name: name2, onclick, type: "button" }, content2);
    }
    this.dom = crelt("div", { onkeydown: (e4) => this.keydown(e4), class: "cm-search" }, [
      this.searchField,
      button("next", () => findNext(view), [phrase(view, "next")]),
      button("prev", () => findPrevious(view), [phrase(view, "previous")]),
      button("select", () => selectMatches(view), [phrase(view, "all")]),
      crelt("label", null, [this.caseField, phrase(view, "match case")]),
      crelt("label", null, [this.reField, phrase(view, "regexp")]),
      crelt("label", null, [this.wordField, phrase(view, "by word")]),
      ...view.state.readOnly ? [] : [
        crelt("br"),
        this.replaceField,
        button("replace", () => replaceNext(view), [phrase(view, "replace")]),
        button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")])
      ],
      crelt("button", {
        name: "close",
        onclick: () => closeSearchPanel(view),
        "aria-label": phrase(view, "close"),
        type: "button"
      }, [""])
    ]);
  }
  commit() {
    let query = new SearchQuery({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    if (!query.eq(this.query)) {
      this.query = query;
      this.view.dispatch({ effects: setSearchQuery.of(query) });
    }
  }
  keydown(e4) {
    if (runScopeHandlers(this.view, e4, "search-panel")) {
      e4.preventDefault();
    } else if (e4.keyCode == 13 && e4.target == this.searchField) {
      e4.preventDefault();
      (e4.shiftKey ? findPrevious : findNext)(this.view);
    } else if (e4.keyCode == 13 && e4.target == this.replaceField) {
      e4.preventDefault();
      replaceNext(this.view);
    }
  }
  update(update) {
    for (let tr2 of update.transactions)
      for (let effect4 of tr2.effects) {
        if (effect4.is(setSearchQuery) && !effect4.value.eq(this.query))
          this.setQuery(effect4.value);
      }
  }
  setQuery(query) {
    this.query = query;
    this.searchField.value = query.search;
    this.replaceField.value = query.replace;
    this.caseField.checked = query.caseSensitive;
    this.reField.checked = query.regexp;
    this.wordField.checked = query.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(searchConfigFacet).top;
  }
};
function phrase(view, phrase2) {
  return view.state.phrase(phrase2);
}
var AnnounceMargin = 30;
var Break = /[\s\.,:;?!]/;
function announceMatch(view, { from: from2, to }) {
  let line2 = view.state.doc.lineAt(from2), lineEnd = view.state.doc.lineAt(to).to;
  let start2 = Math.max(line2.from, from2 - AnnounceMargin), end2 = Math.min(lineEnd, to + AnnounceMargin);
  let text = view.state.sliceDoc(start2, end2);
  if (start2 != line2.from) {
    for (let i2 = 0; i2 < AnnounceMargin; i2++)
      if (!Break.test(text[i2 + 1]) && Break.test(text[i2])) {
        text = text.slice(i2);
        break;
      }
  }
  if (end2 != lineEnd) {
    for (let i2 = text.length - 1; i2 > text.length - AnnounceMargin; i2--)
      if (!Break.test(text[i2 - 1]) && Break.test(text[i2])) {
        text = text.slice(0, i2);
        break;
      }
  }
  return EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${line2.number}.`);
}
var baseTheme4 = EditorView.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
});
var searchExtensions = [
  searchState,
  Prec.low(searchHighlighter),
  baseTheme4
];

// node_modules/@neo4j-cypher/codemirror/es/cypher-codemirror-base.js
var _excluded11 = ["line", "column"];
var _excluded22 = ["line", "column"];
function ownKeys6(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread5(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys6(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys6(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var THEME_LIGHT = "light";
var THEME_DARK = "dark";
var THEME_AUTO = "auto";
var defaultLineNumberFormatter = (line2, lineCount) => {
  if (lineCount === 1) {
    return "$";
  } else {
    return line2;
  }
};
var defaultAutocompleteTriggerStrings = [".", ":", "[]", "()", "{}", "[", "(", "{", "$"];
var defaultOptions2 = {
  autocomplete: true,
  autocompleteCloseOnBlur: true,
  autocompleteOpen: false,
  autocompleteTriggerStrings: defaultAutocompleteTriggerStrings,
  autofocus: true,
  autofocusProps: ["cursorWide", "position", "readOnly", "selection", "value"],
  bracketMatching: true,
  clearHistoryProps: ["cypherLanguage"],
  closeBrackets: true,
  cursorWide: true,
  cypherLanguage: true,
  history: true,
  indentUnit: "  ",
  lineNumberFormatter: defaultLineNumberFormatter,
  lineNumbers: true,
  lineWrapping: false,
  lint: false,
  parseOnSetValue: true,
  placeholder: void 0,
  position: void 0,
  readOnly: false,
  readOnlyCursor: false,
  schema: void 0,
  search: true,
  searchMatches: 0,
  searchOpen: false,
  searchText: "",
  searchTop: false,
  selection: void 0,
  tabKey: true,
  theme: THEME_LIGHT,
  tooltipAbsolute: true,
  value: "",
  preExtensions: [],
  postExtensions: []
};
var reactiveOptionKeys = [
  "autocomplete",
  "autocompleteCloseOnBlur",
  "autocompleteOpen",
  "autocompleteTriggerStrings",
  "bracketMatching",
  "closeBrackets",
  "cursorWide",
  "cypherLanguage",
  // "autofocus",
  "history",
  "indentUnit",
  "lineNumberFormatter",
  "lineNumbers",
  "lineWrapping",
  "lint",
  "placeholder",
  "position",
  "readOnly",
  "readOnlyCursor",
  "schema",
  "search",
  "searchMatches",
  "searchOpen",
  "searchText",
  "searchTop",
  "selection",
  "tabKey",
  "theme",
  "tooltipAbsolute",
  // "parseOnSetValue",
  "value",
  "preExtensions",
  "postExtensions"
];
var isNumber = (v) => v !== void 0 && (typeof v === "number" || v instanceof Number) && isFinite(v);
var isInteger = (v) => isNumber(v) && v % 1 === 0;
var isObject2 = (v) => typeof v === "object" && v !== null;
var isAbsolutePosition = (v) => isInteger(v) && v >= 0;
var isLineColumnPosition = (v) => isObject2(v) && isInteger(v.line) && v.line >= 1 && isInteger(v.column) && v.column >= 0;
var isLineColumnAbsolutePosition = (v) => isObject2(v) && isInteger(v.position) && v.position >= 0;
var positionColumnNewToOld = (_ref4) => {
  let {
    line: line2,
    column: column2
  } = _ref4, rest = _objectWithoutProperties2(_ref4, _excluded11);
  return _objectSpread5({
    line: line2,
    column: column2 - 1
  }, rest);
};
var positionColumnOldToNew = (_ref23) => {
  let {
    line: line2,
    column: column2
  } = _ref23, rest = _objectWithoutProperties2(_ref23, _excluded22);
  return _objectSpread5({
    line: line2,
    column: column2 + 1
  }, rest);
};
var positionNewToOld = (positionValue) => isLineColumnPosition(positionValue) ? positionColumnNewToOld(positionValue) : positionValue;
var positionOldToNew = (positionValue) => isLineColumnPosition(positionValue) ? positionColumnOldToNew(positionValue) : positionValue;
var createEventHandlers = () => {
  const listeners = [];
  const off2 = (listener) => {
    const index4 = listeners.findIndex((l) => l === listener);
    if (index4 >= 0) {
      listeners.splice(index4, 1);
      return true;
    }
    return false;
  };
  const on2 = (listener) => {
    listeners.push(listener);
    return () => {
      off2(listener);
    };
  };
  const fire = (...args) => {
    for (let listener of listeners) {
      listener(...args);
    }
  };
  const count2 = () => {
    return listeners.length;
  };
  return {
    on: on2,
    off: off2,
    listeners,
    fire,
    count: count2
  };
};

// node_modules/@neo4j-cypher/editor-support/es/completion/CompletionTypes.js
var KEYWORD = "keyword";
var LABEL = "label";
var VARIABLE = "variable";
var PARAMETER = "parameter";
var PROPERTY_KEY = "propertyKey";
var RELATIONSHIP_TYPE = "relationshipType";
var FUNCTION_NAME = "function";
var PROCEDURE_NAME = "procedure";
var CONSOLE_COMMAND_NAME = "consoleCommand";
var CONSOLE_COMMAND_SUBCOMMAND = "consoleCommandSubcommand";
var PROCEDURE_OUTPUT = "procedureOutput";
var NOOP3 = "noop";
var ALL = [VARIABLE, PARAMETER, PROPERTY_KEY, FUNCTION_NAME, KEYWORD].map((type) => ({
  type
}));

// node_modules/antlr4/src/antlr4/utils/stringHashCode.js
String.prototype.seed = String.prototype.seed || Math.round(Math.random() * Math.pow(2, 32));
String.prototype.hashCode = function() {
  const key = this.toString();
  let h1b, k1;
  const remainder = key.length & 3;
  const bytes = key.length - remainder;
  let h1 = String.prototype.seed;
  const c1 = 3432918353;
  const c2 = 461845907;
  let i2 = 0;
  while (i2 < bytes) {
    k1 = key.charCodeAt(i2) & 255 | (key.charCodeAt(++i2) & 255) << 8 | (key.charCodeAt(++i2) & 255) << 16 | (key.charCodeAt(++i2) & 255) << 24;
    ++i2;
    k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;
    k1 = k1 << 15 | k1 >>> 17;
    k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;
    h1 ^= k1;
    h1 = h1 << 13 | h1 >>> 19;
    h1b = (h1 & 65535) * 5 + (((h1 >>> 16) * 5 & 65535) << 16) & 4294967295;
    h1 = (h1b & 65535) + 27492 + (((h1b >>> 16) + 58964 & 65535) << 16);
  }
  k1 = 0;
  switch (remainder) {
    case 3:
      k1 ^= (key.charCodeAt(i2 + 2) & 255) << 16;
    case 2:
      k1 ^= (key.charCodeAt(i2 + 1) & 255) << 8;
    case 1:
      k1 ^= key.charCodeAt(i2) & 255;
      k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;
      k1 = k1 << 15 | k1 >>> 17;
      k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;
      h1 ^= k1;
  }
  h1 ^= key.length;
  h1 ^= h1 >>> 16;
  h1 = (h1 & 65535) * 2246822507 + (((h1 >>> 16) * 2246822507 & 65535) << 16) & 4294967295;
  h1 ^= h1 >>> 13;
  h1 = (h1 & 65535) * 3266489909 + (((h1 >>> 16) * 3266489909 & 65535) << 16) & 4294967295;
  h1 ^= h1 >>> 16;
  return h1 >>> 0;
};

// node_modules/antlr4/src/antlr4/polyfills/codepointat.js
if (!String.prototype.codePointAt) {
  (function() {
    "use strict";
    var defineProperty = function() {
      let result;
      try {
        const object2 = {};
        const $defineProperty = Object.defineProperty;
        result = $defineProperty(object2, object2, object2) && $defineProperty;
      } catch (error) {
      }
      return result;
    }();
    const codePointAt2 = function(position2) {
      if (this == null) {
        throw TypeError();
      }
      const string3 = String(this);
      const size3 = string3.length;
      let index4 = position2 ? Number(position2) : 0;
      if (index4 !== index4) {
        index4 = 0;
      }
      if (index4 < 0 || index4 >= size3) {
        return void 0;
      }
      const first = string3.charCodeAt(index4);
      let second;
      if (
        // check if its the start of a surrogate pair
        first >= 55296 && first <= 56319 && // high surrogate
        size3 > index4 + 1
      ) {
        second = string3.charCodeAt(index4 + 1);
        if (second >= 56320 && second <= 57343) {
          return (first - 55296) * 1024 + second - 56320 + 65536;
        }
      }
      return first;
    };
    if (defineProperty) {
      defineProperty(String.prototype, "codePointAt", {
        "value": codePointAt2,
        "configurable": true,
        "writable": true
      });
    } else {
      String.prototype.codePointAt = codePointAt2;
    }
  })();
}

// node_modules/antlr4/src/antlr4/polyfills/fromcodepoint.js
if (!String.fromCodePoint) {
  (function() {
    const defineProperty = function() {
      let result;
      try {
        const object2 = {};
        const $defineProperty = Object.defineProperty;
        result = $defineProperty(object2, object2, object2) && $defineProperty;
      } catch (error) {
      }
      return result;
    }();
    const stringFromCharCode = String.fromCharCode;
    const floor2 = Math.floor;
    const fromCodePoint2 = function(_) {
      const MAX_SIZE = 16384;
      const codeUnits = [];
      let highSurrogate;
      let lowSurrogate;
      let index4 = -1;
      const length2 = arguments.length;
      if (!length2) {
        return "";
      }
      let result = "";
      while (++index4 < length2) {
        let codePoint = Number(arguments[index4]);
        if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
        codePoint < 0 || // not a valid Unicode code point
        codePoint > 1114111 || // not a valid Unicode code point
        floor2(codePoint) !== codePoint) {
          throw RangeError("Invalid code point: " + codePoint);
        }
        if (codePoint <= 65535) {
          codeUnits.push(codePoint);
        } else {
          codePoint -= 65536;
          highSurrogate = (codePoint >> 10) + 55296;
          lowSurrogate = codePoint % 1024 + 56320;
          codeUnits.push(highSurrogate, lowSurrogate);
        }
        if (index4 + 1 === length2 || codeUnits.length > MAX_SIZE) {
          result += stringFromCharCode.apply(null, codeUnits);
          codeUnits.length = 0;
        }
      }
      return result;
    };
    if (defineProperty) {
      defineProperty(String, "fromCodePoint", {
        "value": fromCodePoint2,
        "configurable": true,
        "writable": true
      });
    } else {
      String.fromCodePoint = fromCodePoint2;
    }
  })();
}

// node_modules/antlr4/src/antlr4/Token.js
var Token = class {
  constructor() {
    this.source = null;
    this.type = null;
    this.channel = null;
    this.start = null;
    this.stop = null;
    this.tokenIndex = null;
    this.line = null;
    this.column = null;
    this._text = null;
  }
  getTokenSource() {
    return this.source[0];
  }
  getInputStream() {
    return this.source[1];
  }
  get text() {
    return this._text;
  }
  set text(text) {
    this._text = text;
  }
};
Token.INVALID_TYPE = 0;
Token.EPSILON = -2;
Token.MIN_USER_TOKEN_TYPE = 1;
Token.EOF = -1;
Token.DEFAULT_CHANNEL = 0;
Token.HIDDEN_CHANNEL = 1;

// node_modules/antlr4/src/antlr4/utils/equalArrays.js
function equalArrays(a3, b2) {
  if (!Array.isArray(a3) || !Array.isArray(b2))
    return false;
  if (a3 === b2)
    return true;
  if (a3.length !== b2.length)
    return false;
  for (let i2 = 0; i2 < a3.length; i2++) {
    if (a3[i2] === b2[i2])
      continue;
    if (!a3[i2].equals || !a3[i2].equals(b2[i2]))
      return false;
  }
  return true;
}

// node_modules/antlr4/src/antlr4/misc/HashCode.js
var HashCode = class _HashCode {
  constructor() {
    this.count = 0;
    this.hash = 0;
  }
  update() {
    for (let i2 = 0; i2 < arguments.length; i2++) {
      const value = arguments[i2];
      if (value == null)
        continue;
      if (Array.isArray(value))
        this.update.apply(this, value);
      else {
        let k2 = 0;
        switch (typeof value) {
          case "undefined":
          case "function":
            continue;
          case "number":
          case "boolean":
            k2 = value;
            break;
          case "string":
            k2 = value.hashCode();
            break;
          default:
            if (value.updateHashCode)
              value.updateHashCode(this);
            else
              console.log("No updateHashCode for " + value.toString());
            continue;
        }
        k2 = k2 * 3432918353;
        k2 = k2 << 15 | k2 >>> 32 - 15;
        k2 = k2 * 461845907;
        this.count = this.count + 1;
        let hash4 = this.hash ^ k2;
        hash4 = hash4 << 13 | hash4 >>> 32 - 13;
        hash4 = hash4 * 5 + 3864292196;
        this.hash = hash4;
      }
    }
  }
  finish() {
    let hash4 = this.hash ^ this.count * 4;
    hash4 = hash4 ^ hash4 >>> 16;
    hash4 = hash4 * 2246822507;
    hash4 = hash4 ^ hash4 >>> 13;
    hash4 = hash4 * 3266489909;
    hash4 = hash4 ^ hash4 >>> 16;
    return hash4;
  }
  static hashStuff() {
    const hash4 = new _HashCode();
    hash4.update.apply(hash4, arguments);
    return hash4.finish();
  }
};

// node_modules/antlr4/src/antlr4/utils/standardHashCodeFunction.js
function standardHashCodeFunction(a3) {
  return a3 ? a3.hashCode() : -1;
}

// node_modules/antlr4/src/antlr4/utils/standardEqualsFunction.js
function standardEqualsFunction(a3, b2) {
  return a3 ? a3.equals(b2) : a3 === b2;
}

// node_modules/antlr4/src/antlr4/utils/valueToString.js
function valueToString(v) {
  return v === null ? "null" : v;
}

// node_modules/antlr4/src/antlr4/utils/arrayToString.js
function arrayToString(a3) {
  return Array.isArray(a3) ? "[" + a3.map(valueToString).join(", ") + "]" : "null";
}

// node_modules/antlr4/src/antlr4/misc/HashSet.js
var HASH_KEY_PREFIX = "h-";
var HashSet = class {
  constructor(hashFunction, equalsFunction) {
    this.data = {};
    this.hashFunction = hashFunction || standardHashCodeFunction;
    this.equalsFunction = equalsFunction || standardEqualsFunction;
  }
  add(value) {
    const key = HASH_KEY_PREFIX + this.hashFunction(value);
    if (key in this.data) {
      const values = this.data[key];
      for (let i2 = 0; i2 < values.length; i2++) {
        if (this.equalsFunction(value, values[i2])) {
          return values[i2];
        }
      }
      values.push(value);
      return value;
    } else {
      this.data[key] = [value];
      return value;
    }
  }
  has(value) {
    return this.get(value) != null;
  }
  get(value) {
    const key = HASH_KEY_PREFIX + this.hashFunction(value);
    if (key in this.data) {
      const values = this.data[key];
      for (let i2 = 0; i2 < values.length; i2++) {
        if (this.equalsFunction(value, values[i2])) {
          return values[i2];
        }
      }
    }
    return null;
  }
  values() {
    return Object.keys(this.data).filter((key) => key.startsWith(HASH_KEY_PREFIX)).flatMap((key) => this.data[key], this);
  }
  toString() {
    return arrayToString(this.values());
  }
  get length() {
    return Object.keys(this.data).filter((key) => key.startsWith(HASH_KEY_PREFIX)).map((key) => this.data[key].length, this).reduce((accum, item) => accum + item, 0);
  }
};

// node_modules/antlr4/src/antlr4/atn/SemanticContext.js
var SemanticContext = class _SemanticContext {
  hashCode() {
    const hash4 = new HashCode();
    this.updateHashCode(hash4);
    return hash4.finish();
  }
  /**
   * For context independent predicates, we evaluate them without a local
   * context (i.e., null context). That way, we can evaluate them without
   * having to create proper rule-specific context during prediction (as
   * opposed to the parser, which creates them naturally). In a practical
   * sense, this avoids a cast exception from RuleContext to myruleContext.
   *
   * <p>For context dependent predicates, we must pass in a local context so that
   * references such as $arg evaluate properly as _localctx.arg. We only
   * capture context dependent predicates in the context in which we begin
   * prediction, so we passed in the outer context here in case of context
   * dependent predicate evaluation.</p>
   */
  evaluate(parser, outerContext) {
  }
  /**
   * Evaluate the precedence predicates for the context and reduce the result.
   *
   * @param parser The parser instance.
   * @param outerContext The current parser context object.
   * @return The simplified semantic context after precedence predicates are
   * evaluated, which will be one of the following values.
   * <ul>
   * <li>{@link //NONE}: if the predicate simplifies to {@code true} after
   * precedence predicates are evaluated.</li>
   * <li>{@code null}: if the predicate simplifies to {@code false} after
   * precedence predicates are evaluated.</li>
   * <li>{@code this}: if the semantic context is not changed as a result of
   * precedence predicate evaluation.</li>
   * <li>A non-{@code null} {@link SemanticContext}: the new simplified
   * semantic context after precedence predicates are evaluated.</li>
   * </ul>
   */
  evalPrecedence(parser, outerContext) {
    return this;
  }
  static andContext(a3, b2) {
    if (a3 === null || a3 === _SemanticContext.NONE) {
      return b2;
    }
    if (b2 === null || b2 === _SemanticContext.NONE) {
      return a3;
    }
    const result = new AND(a3, b2);
    if (result.opnds.length === 1) {
      return result.opnds[0];
    } else {
      return result;
    }
  }
  static orContext(a3, b2) {
    if (a3 === null) {
      return b2;
    }
    if (b2 === null) {
      return a3;
    }
    if (a3 === _SemanticContext.NONE || b2 === _SemanticContext.NONE) {
      return _SemanticContext.NONE;
    }
    const result = new OR(a3, b2);
    if (result.opnds.length === 1) {
      return result.opnds[0];
    } else {
      return result;
    }
  }
};
var AND = class _AND extends SemanticContext {
  /**
   * A semantic context which is true whenever none of the contained contexts
   * is false
   */
  constructor(a3, b2) {
    super();
    const operands = new HashSet();
    if (a3 instanceof _AND) {
      a3.opnds.map(function(o) {
        operands.add(o);
      });
    } else {
      operands.add(a3);
    }
    if (b2 instanceof _AND) {
      b2.opnds.map(function(o) {
        operands.add(o);
      });
    } else {
      operands.add(b2);
    }
    const precedencePredicates = filterPrecedencePredicates(operands);
    if (precedencePredicates.length > 0) {
      let reduced = null;
      precedencePredicates.map(function(p) {
        if (reduced === null || p.precedence < reduced.precedence) {
          reduced = p;
        }
      });
      operands.add(reduced);
    }
    this.opnds = Array.from(operands.values());
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof _AND)) {
      return false;
    } else {
      return equalArrays(this.opnds, other.opnds);
    }
  }
  updateHashCode(hash4) {
    hash4.update(this.opnds, "AND");
  }
  /**
   * {@inheritDoc}
   *
   * <p>
   * The evaluation of predicates by this context is short-circuiting, but
   * unordered.</p>
   */
  evaluate(parser, outerContext) {
    for (let i2 = 0; i2 < this.opnds.length; i2++) {
      if (!this.opnds[i2].evaluate(parser, outerContext)) {
        return false;
      }
    }
    return true;
  }
  evalPrecedence(parser, outerContext) {
    let differs = false;
    const operands = [];
    for (let i2 = 0; i2 < this.opnds.length; i2++) {
      const context = this.opnds[i2];
      const evaluated = context.evalPrecedence(parser, outerContext);
      differs |= evaluated !== context;
      if (evaluated === null) {
        return null;
      } else if (evaluated !== SemanticContext.NONE) {
        operands.push(evaluated);
      }
    }
    if (!differs) {
      return this;
    }
    if (operands.length === 0) {
      return SemanticContext.NONE;
    }
    let result = null;
    operands.map(function(o) {
      result = result === null ? o : SemanticContext.andContext(result, o);
    });
    return result;
  }
  toString() {
    const s3 = this.opnds.map((o) => o.toString());
    return (s3.length > 3 ? s3.slice(3) : s3).join("&&");
  }
};
var OR = class _OR extends SemanticContext {
  /**
   * A semantic context which is true whenever at least one of the contained
   * contexts is true
   */
  constructor(a3, b2) {
    super();
    const operands = new HashSet();
    if (a3 instanceof _OR) {
      a3.opnds.map(function(o) {
        operands.add(o);
      });
    } else {
      operands.add(a3);
    }
    if (b2 instanceof _OR) {
      b2.opnds.map(function(o) {
        operands.add(o);
      });
    } else {
      operands.add(b2);
    }
    const precedencePredicates = filterPrecedencePredicates(operands);
    if (precedencePredicates.length > 0) {
      const s3 = precedencePredicates.sort(function(a4, b3) {
        return a4.compareTo(b3);
      });
      const reduced = s3[s3.length - 1];
      operands.add(reduced);
    }
    this.opnds = Array.from(operands.values());
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof _OR)) {
      return false;
    } else {
      return equalArrays(this.opnds, other.opnds);
    }
  }
  updateHashCode(hash4) {
    hash4.update(this.opnds, "OR");
  }
  /**
   * <p>
   * The evaluation of predicates by this context is short-circuiting, but
   * unordered.</p>
   */
  evaluate(parser, outerContext) {
    for (let i2 = 0; i2 < this.opnds.length; i2++) {
      if (this.opnds[i2].evaluate(parser, outerContext)) {
        return true;
      }
    }
    return false;
  }
  evalPrecedence(parser, outerContext) {
    let differs = false;
    const operands = [];
    for (let i2 = 0; i2 < this.opnds.length; i2++) {
      const context = this.opnds[i2];
      const evaluated = context.evalPrecedence(parser, outerContext);
      differs |= evaluated !== context;
      if (evaluated === SemanticContext.NONE) {
        return SemanticContext.NONE;
      } else if (evaluated !== null) {
        operands.push(evaluated);
      }
    }
    if (!differs) {
      return this;
    }
    if (operands.length === 0) {
      return null;
    }
    const result = null;
    operands.map(function(o) {
      return result === null ? o : SemanticContext.orContext(result, o);
    });
    return result;
  }
  toString() {
    const s3 = this.opnds.map((o) => o.toString());
    return (s3.length > 3 ? s3.slice(3) : s3).join("||");
  }
};
function filterPrecedencePredicates(set2) {
  const result = [];
  set2.values().map(function(context) {
    if (context instanceof SemanticContext.PrecedencePredicate) {
      result.push(context);
    }
  });
  return result;
}

// node_modules/antlr4/src/antlr4/atn/ATNConfig.js
function checkParams(params, isCfg) {
  if (params === null) {
    const result = { state: null, alt: null, context: null, semanticContext: null };
    if (isCfg) {
      result.reachesIntoOuterContext = 0;
    }
    return result;
  } else {
    const props = {};
    props.state = params.state || null;
    props.alt = params.alt === void 0 ? null : params.alt;
    props.context = params.context || null;
    props.semanticContext = params.semanticContext || null;
    if (isCfg) {
      props.reachesIntoOuterContext = params.reachesIntoOuterContext || 0;
      props.precedenceFilterSuppressed = params.precedenceFilterSuppressed || false;
    }
    return props;
  }
}
var ATNConfig = class _ATNConfig {
  /**
   * @param {Object} params A tuple: (ATN state, predicted alt, syntactic, semantic context).
   * The syntactic context is a graph-structured stack node whose
   * path(s) to the root is the rule invocation(s)
   * chain used to arrive at the state.  The semantic context is
   * the tree of semantic predicates encountered before reaching
   * an ATN state
   */
  constructor(params, config2) {
    this.checkContext(params, config2);
    params = checkParams(params);
    config2 = checkParams(config2, true);
    this.state = params.state !== null ? params.state : config2.state;
    this.alt = params.alt !== null ? params.alt : config2.alt;
    this.context = params.context !== null ? params.context : config2.context;
    this.semanticContext = params.semanticContext !== null ? params.semanticContext : config2.semanticContext !== null ? config2.semanticContext : SemanticContext.NONE;
    this.reachesIntoOuterContext = config2.reachesIntoOuterContext;
    this.precedenceFilterSuppressed = config2.precedenceFilterSuppressed;
  }
  checkContext(params, config2) {
    if ((params.context === null || params.context === void 0) && (config2 === null || config2.context === null || config2.context === void 0)) {
      this.context = null;
    }
  }
  hashCode() {
    const hash4 = new HashCode();
    this.updateHashCode(hash4);
    return hash4.finish();
  }
  updateHashCode(hash4) {
    hash4.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);
  }
  /**
   * An ATN configuration is equal to another if both have
   * the same state, they predict the same alternative, and
   * syntactic/semantic contexts are the same
   */
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof _ATNConfig)) {
      return false;
    } else {
      return this.state.stateNumber === other.state.stateNumber && this.alt === other.alt && (this.context === null ? other.context === null : this.context.equals(other.context)) && this.semanticContext.equals(other.semanticContext) && this.precedenceFilterSuppressed === other.precedenceFilterSuppressed;
    }
  }
  hashCodeForConfigSet() {
    const hash4 = new HashCode();
    hash4.update(this.state.stateNumber, this.alt, this.semanticContext);
    return hash4.finish();
  }
  equalsForConfigSet(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof _ATNConfig)) {
      return false;
    } else {
      return this.state.stateNumber === other.state.stateNumber && this.alt === other.alt && this.semanticContext.equals(other.semanticContext);
    }
  }
  toString() {
    return "(" + this.state + "," + this.alt + (this.context !== null ? ",[" + this.context.toString() + "]" : "") + (this.semanticContext !== SemanticContext.NONE ? "," + this.semanticContext.toString() : "") + (this.reachesIntoOuterContext > 0 ? ",up=" + this.reachesIntoOuterContext : "") + ")";
  }
};

// node_modules/antlr4/src/antlr4/misc/Interval.js
var Interval = class _Interval {
  constructor(start2, stop) {
    this.start = start2;
    this.stop = stop;
  }
  clone() {
    return new _Interval(this.start, this.stop);
  }
  contains(item) {
    return item >= this.start && item < this.stop;
  }
  toString() {
    if (this.start === this.stop - 1) {
      return this.start.toString();
    } else {
      return this.start.toString() + ".." + (this.stop - 1).toString();
    }
  }
  get length() {
    return this.stop - this.start;
  }
};
Interval.INVALID_INTERVAL = new Interval(-1, -2);

// node_modules/antlr4/src/antlr4/misc/IntervalSet.js
var IntervalSet = class _IntervalSet {
  constructor() {
    this.intervals = null;
    this.readOnly = false;
  }
  first(v) {
    if (this.intervals === null || this.intervals.length === 0) {
      return Token.INVALID_TYPE;
    } else {
      return this.intervals[0].start;
    }
  }
  addOne(v) {
    this.addInterval(new Interval(v, v + 1));
  }
  addRange(l, h3) {
    this.addInterval(new Interval(l, h3 + 1));
  }
  addInterval(toAdd) {
    if (this.intervals === null) {
      this.intervals = [];
      this.intervals.push(toAdd.clone());
    } else {
      for (let pos = 0; pos < this.intervals.length; pos++) {
        const existing = this.intervals[pos];
        if (toAdd.stop < existing.start) {
          this.intervals.splice(pos, 0, toAdd);
          return;
        } else if (toAdd.stop === existing.start) {
          this.intervals[pos] = new Interval(toAdd.start, existing.stop);
          return;
        } else if (toAdd.start <= existing.stop) {
          this.intervals[pos] = new Interval(Math.min(existing.start, toAdd.start), Math.max(existing.stop, toAdd.stop));
          this.reduce(pos);
          return;
        }
      }
      this.intervals.push(toAdd.clone());
    }
  }
  addSet(other) {
    if (other.intervals !== null) {
      other.intervals.forEach((toAdd) => this.addInterval(toAdd), this);
    }
    return this;
  }
  reduce(pos) {
    if (pos < this.intervals.length - 1) {
      const current = this.intervals[pos];
      const next2 = this.intervals[pos + 1];
      if (current.stop >= next2.stop) {
        this.intervals.splice(pos + 1, 1);
        this.reduce(pos);
      } else if (current.stop >= next2.start) {
        this.intervals[pos] = new Interval(current.start, next2.stop);
        this.intervals.splice(pos + 1, 1);
      }
    }
  }
  complement(start2, stop) {
    const result = new _IntervalSet();
    result.addInterval(new Interval(start2, stop + 1));
    if (this.intervals !== null)
      this.intervals.forEach((toRemove) => result.removeRange(toRemove));
    return result;
  }
  contains(item) {
    if (this.intervals === null) {
      return false;
    } else {
      for (let k2 = 0; k2 < this.intervals.length; k2++) {
        if (this.intervals[k2].contains(item)) {
          return true;
        }
      }
      return false;
    }
  }
  removeRange(toRemove) {
    if (toRemove.start === toRemove.stop - 1) {
      this.removeOne(toRemove.start);
    } else if (this.intervals !== null) {
      let pos = 0;
      for (let n = 0; n < this.intervals.length; n++) {
        const existing = this.intervals[pos];
        if (toRemove.stop <= existing.start) {
          return;
        } else if (toRemove.start > existing.start && toRemove.stop < existing.stop) {
          this.intervals[pos] = new Interval(existing.start, toRemove.start);
          const x2 = new Interval(toRemove.stop, existing.stop);
          this.intervals.splice(pos, 0, x2);
          return;
        } else if (toRemove.start <= existing.start && toRemove.stop >= existing.stop) {
          this.intervals.splice(pos, 1);
          pos = pos - 1;
        } else if (toRemove.start < existing.stop) {
          this.intervals[pos] = new Interval(existing.start, toRemove.start);
        } else if (toRemove.stop < existing.stop) {
          this.intervals[pos] = new Interval(toRemove.stop, existing.stop);
        }
        pos += 1;
      }
    }
  }
  removeOne(value) {
    if (this.intervals !== null) {
      for (let i2 = 0; i2 < this.intervals.length; i2++) {
        const existing = this.intervals[i2];
        if (value < existing.start) {
          return;
        } else if (value === existing.start && value === existing.stop - 1) {
          this.intervals.splice(i2, 1);
          return;
        } else if (value === existing.start) {
          this.intervals[i2] = new Interval(existing.start + 1, existing.stop);
          return;
        } else if (value === existing.stop - 1) {
          this.intervals[i2] = new Interval(existing.start, existing.stop - 1);
          return;
        } else if (value < existing.stop - 1) {
          const replace2 = new Interval(existing.start, value);
          existing.start = value + 1;
          this.intervals.splice(i2, 0, replace2);
          return;
        }
      }
    }
  }
  toString(literalNames, symbolicNames, elemsAreChar) {
    literalNames = literalNames || null;
    symbolicNames = symbolicNames || null;
    elemsAreChar = elemsAreChar || false;
    if (this.intervals === null) {
      return "{}";
    } else if (literalNames !== null || symbolicNames !== null) {
      return this.toTokenString(literalNames, symbolicNames);
    } else if (elemsAreChar) {
      return this.toCharString();
    } else {
      return this.toIndexString();
    }
  }
  toCharString() {
    const names2 = [];
    for (let i2 = 0; i2 < this.intervals.length; i2++) {
      const existing = this.intervals[i2];
      if (existing.stop === existing.start + 1) {
        if (existing.start === Token.EOF) {
          names2.push("<EOF>");
        } else {
          names2.push("'" + String.fromCharCode(existing.start) + "'");
        }
      } else {
        names2.push("'" + String.fromCharCode(existing.start) + "'..'" + String.fromCharCode(existing.stop - 1) + "'");
      }
    }
    if (names2.length > 1) {
      return "{" + names2.join(", ") + "}";
    } else {
      return names2[0];
    }
  }
  toIndexString() {
    const names2 = [];
    for (let i2 = 0; i2 < this.intervals.length; i2++) {
      const existing = this.intervals[i2];
      if (existing.stop === existing.start + 1) {
        if (existing.start === Token.EOF) {
          names2.push("<EOF>");
        } else {
          names2.push(existing.start.toString());
        }
      } else {
        names2.push(existing.start.toString() + ".." + (existing.stop - 1).toString());
      }
    }
    if (names2.length > 1) {
      return "{" + names2.join(", ") + "}";
    } else {
      return names2[0];
    }
  }
  toTokenString(literalNames, symbolicNames) {
    const names2 = [];
    for (let i2 = 0; i2 < this.intervals.length; i2++) {
      const existing = this.intervals[i2];
      for (let j = existing.start; j < existing.stop; j++) {
        names2.push(this.elementName(literalNames, symbolicNames, j));
      }
    }
    if (names2.length > 1) {
      return "{" + names2.join(", ") + "}";
    } else {
      return names2[0];
    }
  }
  elementName(literalNames, symbolicNames, token2) {
    if (token2 === Token.EOF) {
      return "<EOF>";
    } else if (token2 === Token.EPSILON) {
      return "<EPSILON>";
    } else {
      return literalNames[token2] || symbolicNames[token2];
    }
  }
  get length() {
    return this.intervals.map((interval) => interval.length).reduce((acc, val) => acc + val);
  }
};

// node_modules/antlr4/src/antlr4/state/ATNState.js
var ATNState = class _ATNState {
  constructor() {
    this.atn = null;
    this.stateNumber = _ATNState.INVALID_STATE_NUMBER;
    this.stateType = null;
    this.ruleIndex = 0;
    this.epsilonOnlyTransitions = false;
    this.transitions = [];
    this.nextTokenWithinRule = null;
  }
  toString() {
    return this.stateNumber;
  }
  equals(other) {
    if (other instanceof _ATNState) {
      return this.stateNumber === other.stateNumber;
    } else {
      return false;
    }
  }
  isNonGreedyExitState() {
    return false;
  }
  addTransition(trans, index4) {
    if (index4 === void 0) {
      index4 = -1;
    }
    if (this.transitions.length === 0) {
      this.epsilonOnlyTransitions = trans.isEpsilon;
    } else if (this.epsilonOnlyTransitions !== trans.isEpsilon) {
      this.epsilonOnlyTransitions = false;
    }
    if (index4 === -1) {
      this.transitions.push(trans);
    } else {
      this.transitions.splice(index4, 1, trans);
    }
  }
};
ATNState.INVALID_TYPE = 0;
ATNState.BASIC = 1;
ATNState.RULE_START = 2;
ATNState.BLOCK_START = 3;
ATNState.PLUS_BLOCK_START = 4;
ATNState.STAR_BLOCK_START = 5;
ATNState.TOKEN_START = 6;
ATNState.RULE_STOP = 7;
ATNState.BLOCK_END = 8;
ATNState.STAR_LOOP_BACK = 9;
ATNState.STAR_LOOP_ENTRY = 10;
ATNState.PLUS_LOOP_BACK = 11;
ATNState.LOOP_END = 12;
ATNState.serializationNames = [
  "INVALID",
  "BASIC",
  "RULE_START",
  "BLOCK_START",
  "PLUS_BLOCK_START",
  "STAR_BLOCK_START",
  "TOKEN_START",
  "RULE_STOP",
  "BLOCK_END",
  "STAR_LOOP_BACK",
  "STAR_LOOP_ENTRY",
  "PLUS_LOOP_BACK",
  "LOOP_END"
];
ATNState.INVALID_STATE_NUMBER = -1;

// node_modules/antlr4/src/antlr4/state/RuleStopState.js
var RuleStopState = class extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.RULE_STOP;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/transition/Transition.js
var Transition = class {
  constructor(target) {
    if (target === void 0 || target === null) {
      throw "target cannot be null.";
    }
    this.target = target;
    this.isEpsilon = false;
    this.label = null;
  }
};
Transition.EPSILON = 1;
Transition.RANGE = 2;
Transition.RULE = 3;
Transition.PREDICATE = 4;
Transition.ATOM = 5;
Transition.ACTION = 6;
Transition.SET = 7;
Transition.NOT_SET = 8;
Transition.WILDCARD = 9;
Transition.PRECEDENCE = 10;
Transition.serializationNames = [
  "INVALID",
  "EPSILON",
  "RANGE",
  "RULE",
  "PREDICATE",
  "ATOM",
  "ACTION",
  "SET",
  "NOT_SET",
  "WILDCARD",
  "PRECEDENCE"
];
Transition.serializationTypes = {
  EpsilonTransition: Transition.EPSILON,
  RangeTransition: Transition.RANGE,
  RuleTransition: Transition.RULE,
  PredicateTransition: Transition.PREDICATE,
  AtomTransition: Transition.ATOM,
  ActionTransition: Transition.ACTION,
  SetTransition: Transition.SET,
  NotSetTransition: Transition.NOT_SET,
  WildcardTransition: Transition.WILDCARD,
  PrecedencePredicateTransition: Transition.PRECEDENCE
};

// node_modules/antlr4/src/antlr4/transition/RuleTransition.js
var RuleTransition = class extends Transition {
  constructor(ruleStart, ruleIndex, precedence, followState) {
    super(ruleStart);
    this.ruleIndex = ruleIndex;
    this.precedence = precedence;
    this.followState = followState;
    this.serializationType = Transition.RULE;
    this.isEpsilon = true;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return false;
  }
};

// node_modules/antlr4/src/antlr4/transition/SetTransition.js
var SetTransition = class extends Transition {
  constructor(target, set2) {
    super(target);
    this.serializationType = Transition.SET;
    if (set2 !== void 0 && set2 !== null) {
      this.label = set2;
    } else {
      this.label = new IntervalSet();
      this.label.addOne(Token.INVALID_TYPE);
    }
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return this.label.contains(symbol);
  }
  toString() {
    return this.label.toString();
  }
};

// node_modules/antlr4/src/antlr4/transition/NotSetTransition.js
var NotSetTransition = class extends SetTransition {
  constructor(target, set2) {
    super(target, set2);
    this.serializationType = Transition.NOT_SET;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && !super.matches(symbol, minVocabSymbol, maxVocabSymbol);
  }
  toString() {
    return "~" + super.toString();
  }
};

// node_modules/antlr4/src/antlr4/transition/WildcardTransition.js
var WildcardTransition = class extends Transition {
  constructor(target) {
    super(target);
    this.serializationType = Transition.WILDCARD;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;
  }
  toString() {
    return ".";
  }
};

// node_modules/antlr4/src/antlr4/atn/AbstractPredicateTransition.js
var AbstractPredicateTransition = class extends Transition {
  constructor(target) {
    super(target);
  }
};

// node_modules/antlr4/src/antlr4/tree/Tree.js
var Tree2 = class {
};

// node_modules/antlr4/src/antlr4/tree/SyntaxTree.js
var SyntaxTree = class extends Tree2 {
};

// node_modules/antlr4/src/antlr4/tree/ParseTree.js
var ParseTree = class extends SyntaxTree {
};

// node_modules/antlr4/src/antlr4/tree/RuleNode.js
var RuleNode = class extends ParseTree {
  getRuleContext() {
    throw new Error("missing interface implementation");
  }
};

// node_modules/antlr4/src/antlr4/tree/TerminalNode.js
var TerminalNode = class extends ParseTree {
};

// node_modules/antlr4/src/antlr4/tree/ErrorNode.js
var ErrorNode = class extends TerminalNode {
};

// node_modules/antlr4/src/antlr4/utils/escapeWhitespace.js
function escapeWhitespace(s3, escapeSpaces) {
  s3 = s3.replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r");
  if (escapeSpaces) {
    s3 = s3.replace(/ /g, "");
  }
  return s3;
}

// node_modules/antlr4/src/antlr4/tree/Trees.js
var Trees = {
  /**
   * Print out a whole tree in LISP form. {@link //getNodeText} is used on the
   *  node payloads to get the text for the nodes.  Detect
   *  parse trees and extract data appropriately.
   */
  toStringTree: function(tree, ruleNames, recog) {
    ruleNames = ruleNames || null;
    recog = recog || null;
    if (recog !== null) {
      ruleNames = recog.ruleNames;
    }
    let s3 = Trees.getNodeText(tree, ruleNames);
    s3 = escapeWhitespace(s3, false);
    const c2 = tree.getChildCount();
    if (c2 === 0) {
      return s3;
    }
    let res = "(" + s3 + " ";
    if (c2 > 0) {
      s3 = Trees.toStringTree(tree.getChild(0), ruleNames);
      res = res.concat(s3);
    }
    for (let i2 = 1; i2 < c2; i2++) {
      s3 = Trees.toStringTree(tree.getChild(i2), ruleNames);
      res = res.concat(" " + s3);
    }
    res = res.concat(")");
    return res;
  },
  getNodeText: function(t4, ruleNames, recog) {
    ruleNames = ruleNames || null;
    recog = recog || null;
    if (recog !== null) {
      ruleNames = recog.ruleNames;
    }
    if (ruleNames !== null) {
      if (t4 instanceof RuleNode) {
        const context = t4.getRuleContext();
        const altNumber = context.getAltNumber();
        if (altNumber != 0) {
          return ruleNames[t4.ruleIndex] + ":" + altNumber;
        }
        return ruleNames[t4.ruleIndex];
      } else if (t4 instanceof ErrorNode) {
        return t4.toString();
      } else if (t4 instanceof TerminalNode) {
        if (t4.symbol !== null) {
          return t4.symbol.text;
        }
      }
    }
    const payload = t4.getPayload();
    if (payload instanceof Token) {
      return payload.text;
    }
    return t4.getPayload().toString();
  },
  /**
   * Return ordered list of all children of this node
   */
  getChildren: function(t4) {
    const list = [];
    for (let i2 = 0; i2 < t4.getChildCount(); i2++) {
      list.push(t4.getChild(i2));
    }
    return list;
  },
  /**
   * Return a list of all ancestors of this node.  The first node of
   * list is the root and the last is the parent of this node.
   */
  getAncestors: function(t4) {
    let ancestors = [];
    t4 = t4.getParent();
    while (t4 !== null) {
      ancestors = [t4].concat(ancestors);
      t4 = t4.getParent();
    }
    return ancestors;
  },
  findAllTokenNodes: function(t4, ttype) {
    return Trees.findAllNodes(t4, ttype, true);
  },
  findAllRuleNodes: function(t4, ruleIndex) {
    return Trees.findAllNodes(t4, ruleIndex, false);
  },
  findAllNodes: function(t4, index4, findTokens) {
    const nodes = [];
    Trees._findAllNodes(t4, index4, findTokens, nodes);
    return nodes;
  },
  _findAllNodes: function(t4, index4, findTokens, nodes) {
    if (findTokens && t4 instanceof TerminalNode) {
      if (t4.symbol.type === index4) {
        nodes.push(t4);
      }
    } else if (!findTokens && t4 instanceof RuleNode) {
      if (t4.ruleIndex === index4) {
        nodes.push(t4);
      }
    }
    for (let i2 = 0; i2 < t4.getChildCount(); i2++) {
      Trees._findAllNodes(t4.getChild(i2), index4, findTokens, nodes);
    }
  },
  descendants: function(t4) {
    let nodes = [t4];
    for (let i2 = 0; i2 < t4.getChildCount(); i2++) {
      nodes = nodes.concat(Trees.descendants(t4.getChild(i2)));
    }
    return nodes;
  }
};
var Trees_default = Trees;

// node_modules/antlr4/src/antlr4/context/RuleContext.js
var RuleContext = class extends RuleNode {
  /** A rule context is a record of a single rule invocation. It knows
   * which context invoked it, if any. If there is no parent context, then
   * naturally the invoking state is not valid.  The parent link
   * provides a chain upwards from the current rule invocation to the root
   * of the invocation tree, forming a stack. We actually carry no
   * information about the rule associated with this context (except
   * when parsing). We keep only the state number of the invoking state from
   * the ATN submachine that invoked this. Contrast this with the s
   * pointer inside ParserRuleContext that tracks the current state
   * being "executed" for the current rule.
   *
   * The parent contexts are useful for computing lookahead sets and
   * getting error information.
   *
   * These objects are used during parsing and prediction.
   * For the special case of parsers, we use the subclass
   * ParserRuleContext.
   *
   * @see ParserRuleContext
   */
  constructor(parent, invokingState) {
    super();
    this.parentCtx = parent || null;
    this.invokingState = invokingState || -1;
  }
  depth() {
    let n = 0;
    let p = this;
    while (p !== null) {
      p = p.parentCtx;
      n += 1;
    }
    return n;
  }
  /**
   * A context is empty if there is no invoking state; meaning nobody call
   * current context.
   */
  isEmpty() {
    return this.invokingState === -1;
  }
  // satisfy the ParseTree / SyntaxTree interface
  getSourceInterval() {
    return Interval.INVALID_INTERVAL;
  }
  getRuleContext() {
    return this;
  }
  getPayload() {
    return this;
  }
  /**
   * Return the combined text of all child nodes. This method only considers
   * tokens which have been added to the parse tree.
   * <p>
   * Since tokens on hidden channels (e.g. whitespace or comments) are not
   * added to the parse trees, they will not appear in the output of this
   * method.
   */
  getText() {
    if (this.getChildCount() === 0) {
      return "";
    } else {
      return this.children.map(function(child) {
        return child.getText();
      }).join("");
    }
  }
  /**
   * For rule associated with this parse tree internal node, return
   * the outer alternative number used to match the input. Default
   * implementation does not compute nor store this alt num. Create
   * a subclass of ParserRuleContext with backing field and set
   * option contextSuperClass.
   * to set it.
   */
  getAltNumber() {
    return 0;
  }
  /**
   * Set the outer alternative number for this context node. Default
   * implementation does nothing to avoid backing field overhead for
   * trees that don't need it.  Create
   * a subclass of ParserRuleContext with backing field and set
   * option contextSuperClass.
   */
  setAltNumber(altNumber) {
  }
  getChild(i2) {
    return null;
  }
  getChildCount() {
    return 0;
  }
  accept(visitor) {
    return visitor.visitChildren(this);
  }
  /**
   * Print out a whole tree, not just a node, in LISP format
   * (root child1 .. childN). Print just a node if this is a leaf.
   */
  toStringTree(ruleNames, recog) {
    return Trees_default.toStringTree(this, ruleNames, recog);
  }
  toString(ruleNames, stop) {
    ruleNames = ruleNames || null;
    stop = stop || null;
    let p = this;
    let s3 = "[";
    while (p !== null && p !== stop) {
      if (ruleNames === null) {
        if (!p.isEmpty()) {
          s3 += p.invokingState;
        }
      } else {
        const ri = p.ruleIndex;
        const ruleName = ri >= 0 && ri < ruleNames.length ? ruleNames[ri] : "" + ri;
        s3 += ruleName;
      }
      if (p.parentCtx !== null && (ruleNames !== null || !p.parentCtx.isEmpty())) {
        s3 += " ";
      }
      p = p.parentCtx;
    }
    s3 += "]";
    return s3;
  }
};

// node_modules/antlr4/src/antlr4/context/PredictionContext.js
var PredictionContext = class _PredictionContext {
  constructor(cachedHashCode) {
    this.cachedHashCode = cachedHashCode;
  }
  /**
   * Stores the computed hash code of this {@link PredictionContext}. The hash
   * code is computed in parts to match the following reference algorithm.
   *
   * <pre>
   * private int referenceHashCode() {
   * int hash = {@link MurmurHash//initialize MurmurHash.initialize}({@link
   * //INITIAL_HASH});
   *
   * for (int i = 0; i &lt; {@link //size()}; i++) {
   * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link //getParent
   * getParent}(i));
   * }
   *
   * for (int i = 0; i &lt; {@link //size()}; i++) {
   * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link
   * //getReturnState getReturnState}(i));
   * }
   *
   * hash = {@link MurmurHash//finish MurmurHash.finish}(hash, 2// {@link
   * //size()});
   * return hash;
   * }
   * </pre>
   * This means only the {@link //EMPTY} context is in set.
   */
  isEmpty() {
    return this === _PredictionContext.EMPTY;
  }
  hasEmptyPath() {
    return this.getReturnState(this.length - 1) === _PredictionContext.EMPTY_RETURN_STATE;
  }
  hashCode() {
    return this.cachedHashCode;
  }
  updateHashCode(hash4) {
    hash4.update(this.cachedHashCode);
  }
};
PredictionContext.EMPTY = null;
PredictionContext.EMPTY_RETURN_STATE = 2147483647;
PredictionContext.globalNodeCount = 1;
PredictionContext.id = PredictionContext.globalNodeCount;

// node_modules/antlr4/src/antlr4/context/ArrayPredictionContext.js
var ArrayPredictionContext = class _ArrayPredictionContext extends PredictionContext {
  constructor(parents, returnStates) {
    const h3 = new HashCode();
    h3.update(parents, returnStates);
    const hashCode = h3.finish();
    super(hashCode);
    this.parents = parents;
    this.returnStates = returnStates;
    return this;
  }
  isEmpty() {
    return this.returnStates[0] === PredictionContext.EMPTY_RETURN_STATE;
  }
  getParent(index4) {
    return this.parents[index4];
  }
  getReturnState(index4) {
    return this.returnStates[index4];
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof _ArrayPredictionContext)) {
      return false;
    } else if (this.hashCode() !== other.hashCode()) {
      return false;
    } else {
      return equalArrays(this.returnStates, other.returnStates) && equalArrays(this.parents, other.parents);
    }
  }
  toString() {
    if (this.isEmpty()) {
      return "[]";
    } else {
      let s3 = "[";
      for (let i2 = 0; i2 < this.returnStates.length; i2++) {
        if (i2 > 0) {
          s3 = s3 + ", ";
        }
        if (this.returnStates[i2] === PredictionContext.EMPTY_RETURN_STATE) {
          s3 = s3 + "$";
          continue;
        }
        s3 = s3 + this.returnStates[i2];
        if (this.parents[i2] !== null) {
          s3 = s3 + " " + this.parents[i2];
        } else {
          s3 = s3 + "null";
        }
      }
      return s3 + "]";
    }
  }
  get length() {
    return this.returnStates.length;
  }
};

// node_modules/antlr4/src/antlr4/context/SingletonPredictionContext.js
var SingletonPredictionContext = class _SingletonPredictionContext extends PredictionContext {
  constructor(parent, returnState) {
    let hashCode = 0;
    const hash4 = new HashCode();
    if (parent !== null) {
      hash4.update(parent, returnState);
    } else {
      hash4.update(1);
    }
    hashCode = hash4.finish();
    super(hashCode);
    this.parentCtx = parent;
    this.returnState = returnState;
  }
  getParent(index4) {
    return this.parentCtx;
  }
  getReturnState(index4) {
    return this.returnState;
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof _SingletonPredictionContext)) {
      return false;
    } else if (this.hashCode() !== other.hashCode()) {
      return false;
    } else {
      if (this.returnState !== other.returnState)
        return false;
      else if (this.parentCtx == null)
        return other.parentCtx == null;
      else
        return this.parentCtx.equals(other.parentCtx);
    }
  }
  toString() {
    const up = this.parentCtx === null ? "" : this.parentCtx.toString();
    if (up.length === 0) {
      if (this.returnState === PredictionContext.EMPTY_RETURN_STATE) {
        return "$";
      } else {
        return "" + this.returnState;
      }
    } else {
      return "" + this.returnState + " " + up;
    }
  }
  get length() {
    return 1;
  }
  static create(parent, returnState) {
    if (returnState === PredictionContext.EMPTY_RETURN_STATE && parent === null) {
      return PredictionContext.EMPTY;
    } else {
      return new _SingletonPredictionContext(parent, returnState);
    }
  }
};

// node_modules/antlr4/src/antlr4/context/EmptyPredictionContext.js
var EmptyPredictionContext = class extends SingletonPredictionContext {
  constructor() {
    super(null, PredictionContext.EMPTY_RETURN_STATE);
  }
  isEmpty() {
    return true;
  }
  getParent(index4) {
    return null;
  }
  getReturnState(index4) {
    return this.returnState;
  }
  equals(other) {
    return this === other;
  }
  toString() {
    return "$";
  }
};
PredictionContext.EMPTY = new EmptyPredictionContext();

// node_modules/antlr4/src/antlr4/misc/HashMap.js
var HASH_KEY_PREFIX2 = "h-";
var HashMap = class {
  constructor(hashFunction, equalsFunction) {
    this.data = {};
    this.hashFunction = hashFunction || standardHashCodeFunction;
    this.equalsFunction = equalsFunction || standardEqualsFunction;
  }
  set(key, value) {
    const hashKey = HASH_KEY_PREFIX2 + this.hashFunction(key);
    if (hashKey in this.data) {
      const entries = this.data[hashKey];
      for (let i2 = 0; i2 < entries.length; i2++) {
        const entry = entries[i2];
        if (this.equalsFunction(key, entry.key)) {
          const oldValue = entry.value;
          entry.value = value;
          return oldValue;
        }
      }
      entries.push({ key, value });
      return value;
    } else {
      this.data[hashKey] = [{ key, value }];
      return value;
    }
  }
  containsKey(key) {
    const hashKey = HASH_KEY_PREFIX2 + this.hashFunction(key);
    if (hashKey in this.data) {
      const entries = this.data[hashKey];
      for (let i2 = 0; i2 < entries.length; i2++) {
        const entry = entries[i2];
        if (this.equalsFunction(key, entry.key))
          return true;
      }
    }
    return false;
  }
  get(key) {
    const hashKey = HASH_KEY_PREFIX2 + this.hashFunction(key);
    if (hashKey in this.data) {
      const entries = this.data[hashKey];
      for (let i2 = 0; i2 < entries.length; i2++) {
        const entry = entries[i2];
        if (this.equalsFunction(key, entry.key))
          return entry.value;
      }
    }
    return null;
  }
  entries() {
    return Object.keys(this.data).filter((key) => key.startsWith(HASH_KEY_PREFIX2)).flatMap((key) => this.data[key], this);
  }
  getKeys() {
    return this.entries().map((e4) => e4.key);
  }
  getValues() {
    return this.entries().map((e4) => e4.value);
  }
  toString() {
    const ss = this.entries().map((e4) => "{" + e4.key + ":" + e4.value + "}");
    return "[" + ss.join(", ") + "]";
  }
  get length() {
    return Object.keys(this.data).filter((key) => key.startsWith(HASH_KEY_PREFIX2)).map((key) => this.data[key].length, this).reduce((accum, item) => accum + item, 0);
  }
};

// node_modules/antlr4/src/antlr4/context/PredictionContextUtils.js
function predictionContextFromRuleContext(atn3, outerContext) {
  if (outerContext === void 0 || outerContext === null) {
    outerContext = RuleContext.EMPTY;
  }
  if (outerContext.parentCtx === null || outerContext === RuleContext.EMPTY) {
    return PredictionContext.EMPTY;
  }
  const parent = predictionContextFromRuleContext(atn3, outerContext.parentCtx);
  const state = atn3.states[outerContext.invokingState];
  const transition = state.transitions[0];
  return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
}
function getCachedPredictionContext(context, contextCache, visited) {
  if (context.isEmpty()) {
    return context;
  }
  let existing = visited.get(context) || null;
  if (existing !== null) {
    return existing;
  }
  existing = contextCache.get(context);
  if (existing !== null) {
    visited.set(context, existing);
    return existing;
  }
  let changed = false;
  let parents = [];
  for (let i2 = 0; i2 < parents.length; i2++) {
    const parent = getCachedPredictionContext(context.getParent(i2), contextCache, visited);
    if (changed || parent !== context.getParent(i2)) {
      if (!changed) {
        parents = [];
        for (let j = 0; j < context.length; j++) {
          parents[j] = context.getParent(j);
        }
        changed = true;
      }
      parents[i2] = parent;
    }
  }
  if (!changed) {
    contextCache.add(context);
    visited.set(context, context);
    return context;
  }
  let updated = null;
  if (parents.length === 0) {
    updated = PredictionContext.EMPTY;
  } else if (parents.length === 1) {
    updated = SingletonPredictionContext.create(parents[0], context.getReturnState(0));
  } else {
    updated = new ArrayPredictionContext(parents, context.returnStates);
  }
  contextCache.add(updated);
  visited.set(updated, updated);
  visited.set(context, updated);
  return updated;
}
function merge2(a3, b2, rootIsWildcard, mergeCache) {
  if (a3 === b2) {
    return a3;
  }
  if (a3 instanceof SingletonPredictionContext && b2 instanceof SingletonPredictionContext) {
    return mergeSingletons(a3, b2, rootIsWildcard, mergeCache);
  }
  if (rootIsWildcard) {
    if (a3 instanceof EmptyPredictionContext) {
      return a3;
    }
    if (b2 instanceof EmptyPredictionContext) {
      return b2;
    }
  }
  if (a3 instanceof SingletonPredictionContext) {
    a3 = new ArrayPredictionContext([a3.getParent()], [a3.returnState]);
  }
  if (b2 instanceof SingletonPredictionContext) {
    b2 = new ArrayPredictionContext([b2.getParent()], [b2.returnState]);
  }
  return mergeArrays(a3, b2, rootIsWildcard, mergeCache);
}
function mergeArrays(a3, b2, rootIsWildcard, mergeCache) {
  if (mergeCache !== null) {
    let previous = mergeCache.get(a3, b2);
    if (previous !== null) {
      return previous;
    }
    previous = mergeCache.get(b2, a3);
    if (previous !== null) {
      return previous;
    }
  }
  let i2 = 0;
  let j = 0;
  let k2 = 0;
  let mergedReturnStates = [];
  let mergedParents = [];
  while (i2 < a3.returnStates.length && j < b2.returnStates.length) {
    const a_parent = a3.parents[i2];
    const b_parent = b2.parents[j];
    if (a3.returnStates[i2] === b2.returnStates[j]) {
      const payload = a3.returnStates[i2];
      const bothDollars = payload === PredictionContext.EMPTY_RETURN_STATE && a_parent === null && b_parent === null;
      const ax_ax = a_parent !== null && b_parent !== null && a_parent === b_parent;
      if (bothDollars || ax_ax) {
        mergedParents[k2] = a_parent;
        mergedReturnStates[k2] = payload;
      } else {
        mergedParents[k2] = merge2(a_parent, b_parent, rootIsWildcard, mergeCache);
        mergedReturnStates[k2] = payload;
      }
      i2 += 1;
      j += 1;
    } else if (a3.returnStates[i2] < b2.returnStates[j]) {
      mergedParents[k2] = a_parent;
      mergedReturnStates[k2] = a3.returnStates[i2];
      i2 += 1;
    } else {
      mergedParents[k2] = b_parent;
      mergedReturnStates[k2] = b2.returnStates[j];
      j += 1;
    }
    k2 += 1;
  }
  if (i2 < a3.returnStates.length) {
    for (let p = i2; p < a3.returnStates.length; p++) {
      mergedParents[k2] = a3.parents[p];
      mergedReturnStates[k2] = a3.returnStates[p];
      k2 += 1;
    }
  } else {
    for (let p = j; p < b2.returnStates.length; p++) {
      mergedParents[k2] = b2.parents[p];
      mergedReturnStates[k2] = b2.returnStates[p];
      k2 += 1;
    }
  }
  if (k2 < mergedParents.length) {
    if (k2 === 1) {
      const a_ = SingletonPredictionContext.create(
        mergedParents[0],
        mergedReturnStates[0]
      );
      if (mergeCache !== null) {
        mergeCache.set(a3, b2, a_);
      }
      return a_;
    }
    mergedParents = mergedParents.slice(0, k2);
    mergedReturnStates = mergedReturnStates.slice(0, k2);
  }
  const M3 = new ArrayPredictionContext(mergedParents, mergedReturnStates);
  if (M3 === a3) {
    if (mergeCache !== null) {
      mergeCache.set(a3, b2, a3);
    }
    return a3;
  }
  if (M3 === b2) {
    if (mergeCache !== null) {
      mergeCache.set(a3, b2, b2);
    }
    return b2;
  }
  combineCommonParents(mergedParents);
  if (mergeCache !== null) {
    mergeCache.set(a3, b2, M3);
  }
  return M3;
}
function combineCommonParents(parents) {
  const uniqueParents = new HashMap();
  for (let p = 0; p < parents.length; p++) {
    const parent = parents[p];
    if (!uniqueParents.containsKey(parent)) {
      uniqueParents.set(parent, parent);
    }
  }
  for (let q2 = 0; q2 < parents.length; q2++) {
    parents[q2] = uniqueParents.get(parents[q2]);
  }
}
function mergeSingletons(a3, b2, rootIsWildcard, mergeCache) {
  if (mergeCache !== null) {
    let previous = mergeCache.get(a3, b2);
    if (previous !== null) {
      return previous;
    }
    previous = mergeCache.get(b2, a3);
    if (previous !== null) {
      return previous;
    }
  }
  const rootMerge = mergeRoot(a3, b2, rootIsWildcard);
  if (rootMerge !== null) {
    if (mergeCache !== null) {
      mergeCache.set(a3, b2, rootMerge);
    }
    return rootMerge;
  }
  if (a3.returnState === b2.returnState) {
    const parent = merge2(a3.parentCtx, b2.parentCtx, rootIsWildcard, mergeCache);
    if (parent === a3.parentCtx) {
      return a3;
    }
    if (parent === b2.parentCtx) {
      return b2;
    }
    const spc = SingletonPredictionContext.create(parent, a3.returnState);
    if (mergeCache !== null) {
      mergeCache.set(a3, b2, spc);
    }
    return spc;
  } else {
    let singleParent = null;
    if (a3 === b2 || a3.parentCtx !== null && a3.parentCtx === b2.parentCtx) {
      singleParent = a3.parentCtx;
    }
    if (singleParent !== null) {
      const payloads2 = [a3.returnState, b2.returnState];
      if (a3.returnState > b2.returnState) {
        payloads2[0] = b2.returnState;
        payloads2[1] = a3.returnState;
      }
      const parents2 = [singleParent, singleParent];
      const apc = new ArrayPredictionContext(parents2, payloads2);
      if (mergeCache !== null) {
        mergeCache.set(a3, b2, apc);
      }
      return apc;
    }
    const payloads = [a3.returnState, b2.returnState];
    let parents = [a3.parentCtx, b2.parentCtx];
    if (a3.returnState > b2.returnState) {
      payloads[0] = b2.returnState;
      payloads[1] = a3.returnState;
      parents = [b2.parentCtx, a3.parentCtx];
    }
    const a_ = new ArrayPredictionContext(parents, payloads);
    if (mergeCache !== null) {
      mergeCache.set(a3, b2, a_);
    }
    return a_;
  }
}
function mergeRoot(a3, b2, rootIsWildcard) {
  if (rootIsWildcard) {
    if (a3 === PredictionContext.EMPTY) {
      return PredictionContext.EMPTY;
    }
    if (b2 === PredictionContext.EMPTY) {
      return PredictionContext.EMPTY;
    }
  } else {
    if (a3 === PredictionContext.EMPTY && b2 === PredictionContext.EMPTY) {
      return PredictionContext.EMPTY;
    } else if (a3 === PredictionContext.EMPTY) {
      const payloads = [
        b2.returnState,
        PredictionContext.EMPTY_RETURN_STATE
      ];
      const parents = [b2.parentCtx, null];
      return new ArrayPredictionContext(parents, payloads);
    } else if (b2 === PredictionContext.EMPTY) {
      const payloads = [a3.returnState, PredictionContext.EMPTY_RETURN_STATE];
      const parents = [a3.parentCtx, null];
      return new ArrayPredictionContext(parents, payloads);
    }
  }
  return null;
}

// node_modules/antlr4/src/antlr4/misc/BitSet.js
var BitSet = class _BitSet {
  constructor() {
    this.data = [];
  }
  add(value) {
    this.data[value] = true;
  }
  or(set2) {
    Object.keys(set2.data).map((alt) => this.add(alt), this);
  }
  remove(value) {
    delete this.data[value];
  }
  has(value) {
    return this.data[value] === true;
  }
  values() {
    return Object.keys(this.data);
  }
  minValue() {
    return Math.min.apply(null, this.values());
  }
  hashCode() {
    return HashCode.hashStuff(this.values());
  }
  equals(other) {
    return other instanceof _BitSet && equalArrays(this.data, other.data);
  }
  toString() {
    return "{" + this.values().join(", ") + "}";
  }
  get length() {
    return this.values().length;
  }
};

// node_modules/antlr4/src/antlr4/atn/LL1Analyzer.js
var LL1Analyzer = class _LL1Analyzer {
  constructor(atn3) {
    this.atn = atn3;
  }
  /**
   * Calculates the SLL(1) expected lookahead set for each outgoing transition
   * of an {@link ATNState}. The returned array has one element for each
   * outgoing transition in {@code s}. If the closure from transition
   * <em>i</em> leads to a semantic predicate before matching a symbol, the
   * element at index <em>i</em> of the result will be {@code null}.
   *
   * @param s the ATN state
   * @return the expected symbols for each outgoing transition of {@code s}.
   */
  getDecisionLookahead(s3) {
    if (s3 === null) {
      return null;
    }
    const count2 = s3.transitions.length;
    const look = [];
    for (let alt = 0; alt < count2; alt++) {
      look[alt] = new IntervalSet();
      const lookBusy = new HashSet();
      const seeThruPreds = false;
      this._LOOK(
        s3.transition(alt).target,
        null,
        PredictionContext.EMPTY,
        look[alt],
        lookBusy,
        new BitSet(),
        seeThruPreds,
        false
      );
      if (look[alt].length === 0 || look[alt].contains(_LL1Analyzer.HIT_PRED)) {
        look[alt] = null;
      }
    }
    return look;
  }
  /**
   * Compute set of tokens that can follow {@code s} in the ATN in the
   * specified {@code ctx}.
   *
   * <p>If {@code ctx} is {@code null} and the end of the rule containing
   * {@code s} is reached, {@link Token//EPSILON} is added to the result set.
   * If {@code ctx} is not {@code null} and the end of the outermost rule is
   * reached, {@link Token//EOF} is added to the result set.</p>
   *
   * @param s the ATN state
   * @param stopState the ATN state to stop at. This can be a
   * {@link BlockEndState} to detect epsilon paths through a closure.
   * @param ctx the complete parser context, or {@code null} if the context
   * should be ignored
   *
   * @return The set of tokens that can follow {@code s} in the ATN in the
   * specified {@code ctx}.
   */
  LOOK(s3, stopState, ctx) {
    const r2 = new IntervalSet();
    const seeThruPreds = true;
    ctx = ctx || null;
    const lookContext = ctx !== null ? predictionContextFromRuleContext(s3.atn, ctx) : null;
    this._LOOK(s3, stopState, lookContext, r2, new HashSet(), new BitSet(), seeThruPreds, true);
    return r2;
  }
  /**
   * Compute set of tokens that can follow {@code s} in the ATN in the
   * specified {@code ctx}.
   *
   * <p>If {@code ctx} is {@code null} and {@code stopState} or the end of the
   * rule containing {@code s} is reached, {@link Token//EPSILON} is added to
   * the result set. If {@code ctx} is not {@code null} and {@code addEOF} is
   * {@code true} and {@code stopState} or the end of the outermost rule is
   * reached, {@link Token//EOF} is added to the result set.</p>
   *
   * @param s the ATN state.
   * @param stopState the ATN state to stop at. This can be a
   * {@link BlockEndState} to detect epsilon paths through a closure.
   * @param ctx The outer context, or {@code null} if the outer context should
   * not be used.
   * @param look The result lookahead set.
   * @param lookBusy A set used for preventing epsilon closures in the ATN
   * from causing a stack overflow. Outside code should pass
   * {@code new CustomizedSet<ATNConfig>} for this argument.
   * @param calledRuleStack A set used for preventing left recursion in the
   * ATN from causing a stack overflow. Outside code should pass
   * {@code new BitSet()} for this argument.
   * @param seeThruPreds {@code true} to true semantic predicates as
   * implicitly {@code true} and "see through them", otherwise {@code false}
   * to treat semantic predicates as opaque and add {@link //HIT_PRED} to the
   * result if one is encountered.
   * @param addEOF Add {@link Token//EOF} to the result if the end of the
   * outermost context is reached. This parameter has no effect if {@code ctx}
   * is {@code null}.
   */
  _LOOK(s3, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {
    const c2 = new ATNConfig({ state: s3, alt: 0, context: ctx }, null);
    if (lookBusy.has(c2)) {
      return;
    }
    lookBusy.add(c2);
    if (s3 === stopState) {
      if (ctx === null) {
        look.addOne(Token.EPSILON);
        return;
      } else if (ctx.isEmpty() && addEOF) {
        look.addOne(Token.EOF);
        return;
      }
    }
    if (s3 instanceof RuleStopState) {
      if (ctx === null) {
        look.addOne(Token.EPSILON);
        return;
      } else if (ctx.isEmpty() && addEOF) {
        look.addOne(Token.EOF);
        return;
      }
      if (ctx !== PredictionContext.EMPTY) {
        const removed = calledRuleStack.has(s3.ruleIndex);
        try {
          calledRuleStack.remove(s3.ruleIndex);
          for (let i2 = 0; i2 < ctx.length; i2++) {
            const returnState = this.atn.states[ctx.getReturnState(i2)];
            this._LOOK(returnState, stopState, ctx.getParent(i2), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
          }
        } finally {
          if (removed) {
            calledRuleStack.add(s3.ruleIndex);
          }
        }
        return;
      }
    }
    for (let j = 0; j < s3.transitions.length; j++) {
      const t4 = s3.transitions[j];
      if (t4.constructor === RuleTransition) {
        if (calledRuleStack.has(t4.target.ruleIndex)) {
          continue;
        }
        const newContext = SingletonPredictionContext.create(ctx, t4.followState.stateNumber);
        try {
          calledRuleStack.add(t4.target.ruleIndex);
          this._LOOK(t4.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
        } finally {
          calledRuleStack.remove(t4.target.ruleIndex);
        }
      } else if (t4 instanceof AbstractPredicateTransition) {
        if (seeThruPreds) {
          this._LOOK(t4.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
        } else {
          look.addOne(_LL1Analyzer.HIT_PRED);
        }
      } else if (t4.isEpsilon) {
        this._LOOK(t4.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
      } else if (t4.constructor === WildcardTransition) {
        look.addRange(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
      } else {
        let set2 = t4.label;
        if (set2 !== null) {
          if (t4 instanceof NotSetTransition) {
            set2 = set2.complement(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
          }
          look.addSet(set2);
        }
      }
    }
  }
};
LL1Analyzer.HIT_PRED = Token.INVALID_TYPE;

// node_modules/antlr4/src/antlr4/atn/ATN.js
var ATN = class {
  constructor(grammarType, maxTokenType) {
    this.grammarType = grammarType;
    this.maxTokenType = maxTokenType;
    this.states = [];
    this.decisionToState = [];
    this.ruleToStartState = [];
    this.ruleToStopState = null;
    this.modeNameToStartState = {};
    this.ruleToTokenType = null;
    this.lexerActions = null;
    this.modeToStartState = [];
  }
  /**
   * Compute the set of valid tokens that can occur starting in state {@code s}.
   * If {@code ctx} is null, the set of tokens will not include what can follow
   * the rule surrounding {@code s}. In other words, the set will be
   * restricted to tokens reachable staying within {@code s}'s rule
   */
  nextTokensInContext(s3, ctx) {
    const anal = new LL1Analyzer(this);
    return anal.LOOK(s3, null, ctx);
  }
  /**
   * Compute the set of valid tokens that can occur starting in {@code s} and
   * staying in same rule. {@link Token//EPSILON} is in set if we reach end of
   * rule
   */
  nextTokensNoContext(s3) {
    if (s3.nextTokenWithinRule !== null) {
      return s3.nextTokenWithinRule;
    }
    s3.nextTokenWithinRule = this.nextTokensInContext(s3, null);
    s3.nextTokenWithinRule.readOnly = true;
    return s3.nextTokenWithinRule;
  }
  nextTokens(s3, ctx) {
    if (ctx === void 0) {
      return this.nextTokensNoContext(s3);
    } else {
      return this.nextTokensInContext(s3, ctx);
    }
  }
  addState(state) {
    if (state !== null) {
      state.atn = this;
      state.stateNumber = this.states.length;
    }
    this.states.push(state);
  }
  removeState(state) {
    this.states[state.stateNumber] = null;
  }
  defineDecisionState(s3) {
    this.decisionToState.push(s3);
    s3.decision = this.decisionToState.length - 1;
    return s3.decision;
  }
  getDecisionState(decision) {
    if (this.decisionToState.length === 0) {
      return null;
    } else {
      return this.decisionToState[decision];
    }
  }
  /**
   * Computes the set of input symbols which could follow ATN state number
   * {@code stateNumber} in the specified full {@code context}. This method
   * considers the complete parser context, but does not evaluate semantic
   * predicates (i.e. all predicates encountered during the calculation are
   * assumed true). If a path in the ATN exists from the starting state to the
   * {@link RuleStopState} of the outermost context without matching any
   * symbols, {@link Token//EOF} is added to the returned set.
   *
   * <p>If {@code context} is {@code null}, it is treated as
   * {@link ParserRuleContext//EMPTY}.</p>
   *
   * @param stateNumber the ATN state number
   * @param ctx the full parse context
   *
   * @return {IntervalSet} The set of potentially valid input symbols which could follow the
   * specified state in the specified context.
   *
   * @throws IllegalArgumentException if the ATN does not contain a state with
   * number {@code stateNumber}
   */
  getExpectedTokens(stateNumber, ctx) {
    if (stateNumber < 0 || stateNumber >= this.states.length) {
      throw "Invalid state number.";
    }
    const s3 = this.states[stateNumber];
    let following = this.nextTokens(s3);
    if (!following.contains(Token.EPSILON)) {
      return following;
    }
    const expected = new IntervalSet();
    expected.addSet(following);
    expected.removeOne(Token.EPSILON);
    while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
      const invokingState = this.states[ctx.invokingState];
      const rt2 = invokingState.transitions[0];
      following = this.nextTokens(rt2.followState);
      expected.addSet(following);
      expected.removeOne(Token.EPSILON);
      ctx = ctx.parentCtx;
    }
    if (following.contains(Token.EPSILON)) {
      expected.addOne(Token.EOF);
    }
    return expected;
  }
};
ATN.INVALID_ALT_NUMBER = 0;

// node_modules/antlr4/src/antlr4/atn/ATNType.js
var ATNType_default = {
  LEXER: 0,
  PARSER: 1
};

// node_modules/antlr4/src/antlr4/state/BasicState.js
var BasicState = class extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.BASIC;
  }
};

// node_modules/antlr4/src/antlr4/state/DecisionState.js
var DecisionState = class extends ATNState {
  constructor() {
    super();
    this.decision = -1;
    this.nonGreedy = false;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/state/BlockStartState.js
var BlockStartState = class extends DecisionState {
  constructor() {
    super();
    this.endState = null;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/state/BlockEndState.js
var BlockEndState = class extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.BLOCK_END;
    this.startState = null;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/state/LoopEndState.js
var LoopEndState = class extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.LOOP_END;
    this.loopBackState = null;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/state/RuleStartState.js
var RuleStartState = class extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.RULE_START;
    this.stopState = null;
    this.isPrecedenceRule = false;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/state/TokensStartState.js
var TokensStartState = class extends DecisionState {
  constructor() {
    super();
    this.stateType = ATNState.TOKEN_START;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/state/PlusLoopbackState.js
var PlusLoopbackState = class extends DecisionState {
  constructor() {
    super();
    this.stateType = ATNState.PLUS_LOOP_BACK;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/state/StarLoopbackState.js
var StarLoopbackState = class extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.STAR_LOOP_BACK;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/state/StarLoopEntryState.js
var StarLoopEntryState = class extends DecisionState {
  constructor() {
    super();
    this.stateType = ATNState.STAR_LOOP_ENTRY;
    this.loopBackState = null;
    this.isPrecedenceDecision = null;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/state/PlusBlockStartState.js
var PlusBlockStartState = class extends BlockStartState {
  constructor() {
    super();
    this.stateType = ATNState.PLUS_BLOCK_START;
    this.loopBackState = null;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/state/StarBlockStartState.js
var StarBlockStartState = class extends BlockStartState {
  constructor() {
    super();
    this.stateType = ATNState.STAR_BLOCK_START;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/state/BasicBlockStartState.js
var BasicBlockStartState = class extends BlockStartState {
  constructor() {
    super();
    this.stateType = ATNState.BLOCK_START;
    return this;
  }
};

// node_modules/antlr4/src/antlr4/transition/AtomTransition.js
var AtomTransition = class extends Transition {
  constructor(target, label) {
    super(target);
    this.label_ = label;
    this.label = this.makeLabel();
    this.serializationType = Transition.ATOM;
  }
  makeLabel() {
    const s3 = new IntervalSet();
    s3.addOne(this.label_);
    return s3;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return this.label_ === symbol;
  }
  toString() {
    return this.label_;
  }
};

// node_modules/antlr4/src/antlr4/transition/RangeTransition.js
var RangeTransition = class extends Transition {
  constructor(target, start2, stop) {
    super(target);
    this.serializationType = Transition.RANGE;
    this.start = start2;
    this.stop = stop;
    this.label = this.makeLabel();
  }
  makeLabel() {
    const s3 = new IntervalSet();
    s3.addRange(this.start, this.stop);
    return s3;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return symbol >= this.start && symbol <= this.stop;
  }
  toString() {
    return "'" + String.fromCharCode(this.start) + "'..'" + String.fromCharCode(this.stop) + "'";
  }
};

// node_modules/antlr4/src/antlr4/transition/ActionTransition.js
var ActionTransition = class extends Transition {
  constructor(target, ruleIndex, actionIndex, isCtxDependent) {
    super(target);
    this.serializationType = Transition.ACTION;
    this.ruleIndex = ruleIndex;
    this.actionIndex = actionIndex === void 0 ? -1 : actionIndex;
    this.isCtxDependent = isCtxDependent === void 0 ? false : isCtxDependent;
    this.isEpsilon = true;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return false;
  }
  toString() {
    return "action_" + this.ruleIndex + ":" + this.actionIndex;
  }
};

// node_modules/antlr4/src/antlr4/transition/EpsilonTransition.js
var EpsilonTransition = class extends Transition {
  constructor(target, outermostPrecedenceReturn) {
    super(target);
    this.serializationType = Transition.EPSILON;
    this.isEpsilon = true;
    this.outermostPrecedenceReturn = outermostPrecedenceReturn;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return false;
  }
  toString() {
    return "epsilon";
  }
};

// node_modules/antlr4/src/antlr4/atn/Predicate.js
var Predicate = class _Predicate extends SemanticContext {
  constructor(ruleIndex, predIndex, isCtxDependent) {
    super();
    this.ruleIndex = ruleIndex === void 0 ? -1 : ruleIndex;
    this.predIndex = predIndex === void 0 ? -1 : predIndex;
    this.isCtxDependent = isCtxDependent === void 0 ? false : isCtxDependent;
  }
  evaluate(parser, outerContext) {
    const localctx = this.isCtxDependent ? outerContext : null;
    return parser.sempred(localctx, this.ruleIndex, this.predIndex);
  }
  updateHashCode(hash4) {
    hash4.update(this.ruleIndex, this.predIndex, this.isCtxDependent);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof _Predicate)) {
      return false;
    } else {
      return this.ruleIndex === other.ruleIndex && this.predIndex === other.predIndex && this.isCtxDependent === other.isCtxDependent;
    }
  }
  toString() {
    return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
  }
};
SemanticContext.NONE = new Predicate();

// node_modules/antlr4/src/antlr4/transition/PredicateTransition.js
var PredicateTransition = class extends AbstractPredicateTransition {
  constructor(target, ruleIndex, predIndex, isCtxDependent) {
    super(target);
    this.serializationType = Transition.PREDICATE;
    this.ruleIndex = ruleIndex;
    this.predIndex = predIndex;
    this.isCtxDependent = isCtxDependent;
    this.isEpsilon = true;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return false;
  }
  getPredicate() {
    return new Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);
  }
  toString() {
    return "pred_" + this.ruleIndex + ":" + this.predIndex;
  }
};

// node_modules/antlr4/src/antlr4/atn/PrecedencePredicate.js
var PrecedencePredicate = class _PrecedencePredicate extends SemanticContext {
  constructor(precedence) {
    super();
    this.precedence = precedence === void 0 ? 0 : precedence;
  }
  evaluate(parser, outerContext) {
    return parser.precpred(outerContext, this.precedence);
  }
  evalPrecedence(parser, outerContext) {
    if (parser.precpred(outerContext, this.precedence)) {
      return SemanticContext.NONE;
    } else {
      return null;
    }
  }
  compareTo(other) {
    return this.precedence - other.precedence;
  }
  updateHashCode(hash4) {
    hash4.update(this.precedence);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof _PrecedencePredicate)) {
      return false;
    } else {
      return this.precedence === other.precedence;
    }
  }
  toString() {
    return "{" + this.precedence + ">=prec}?";
  }
};
SemanticContext.PrecedencePredicate = PrecedencePredicate;

// node_modules/antlr4/src/antlr4/transition/PrecedencePredicateTransition.js
var PrecedencePredicateTransition = class extends AbstractPredicateTransition {
  constructor(target, precedence) {
    super(target);
    this.serializationType = Transition.PRECEDENCE;
    this.precedence = precedence;
    this.isEpsilon = true;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return false;
  }
  getPredicate() {
    return new PrecedencePredicate(this.precedence);
  }
  toString() {
    return this.precedence + " >= _p";
  }
};

// node_modules/antlr4/src/antlr4/atn/ATNDeserializationOptions.js
var ATNDeserializationOptions = class {
  constructor(copyFrom) {
    if (copyFrom === void 0) {
      copyFrom = null;
    }
    this.readOnly = false;
    this.verifyATN = copyFrom === null ? true : copyFrom.verifyATN;
    this.generateRuleBypassTransitions = copyFrom === null ? false : copyFrom.generateRuleBypassTransitions;
  }
};
ATNDeserializationOptions.defaultOptions = new ATNDeserializationOptions();
ATNDeserializationOptions.defaultOptions.readOnly = true;

// node_modules/antlr4/src/antlr4/atn/LexerActionType.js
var LexerActionType_default = {
  // The type of a {@link LexerChannelAction} action.
  CHANNEL: 0,
  // The type of a {@link LexerCustomAction} action
  CUSTOM: 1,
  // The type of a {@link LexerModeAction} action.
  MODE: 2,
  //The type of a {@link LexerMoreAction} action.
  MORE: 3,
  //The type of a {@link LexerPopModeAction} action.
  POP_MODE: 4,
  //The type of a {@link LexerPushModeAction} action.
  PUSH_MODE: 5,
  //The type of a {@link LexerSkipAction} action.
  SKIP: 6,
  //The type of a {@link LexerTypeAction} action.
  TYPE: 7
};

// node_modules/antlr4/src/antlr4/action/LexerAction.js
var LexerAction = class {
  constructor(action) {
    this.actionType = action;
    this.isPositionDependent = false;
  }
  hashCode() {
    const hash4 = new HashCode();
    this.updateHashCode(hash4);
    return hash4.finish();
  }
  updateHashCode(hash4) {
    hash4.update(this.actionType);
  }
  equals(other) {
    return this === other;
  }
};

// node_modules/antlr4/src/antlr4/action/LexerSkipAction.js
var LexerSkipAction = class extends LexerAction {
  constructor() {
    super(LexerActionType_default.SKIP);
  }
  execute(lexer) {
    lexer.skip();
  }
  toString() {
    return "skip";
  }
};
LexerSkipAction.INSTANCE = new LexerSkipAction();

// node_modules/antlr4/src/antlr4/action/LexerChannelAction.js
var LexerChannelAction = class _LexerChannelAction extends LexerAction {
  constructor(channel) {
    super(LexerActionType_default.CHANNEL);
    this.channel = channel;
  }
  /**
   * <p>This action is implemented by calling {@link Lexer//setChannel} with the
   * value provided by {@link //getChannel}.</p>
   */
  execute(lexer) {
    lexer._channel = this.channel;
  }
  updateHashCode(hash4) {
    hash4.update(this.actionType, this.channel);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof _LexerChannelAction)) {
      return false;
    } else {
      return this.channel === other.channel;
    }
  }
  toString() {
    return "channel(" + this.channel + ")";
  }
};

// node_modules/antlr4/src/antlr4/action/LexerCustomAction.js
var LexerCustomAction = class _LexerCustomAction extends LexerAction {
  /**
   * Constructs a custom lexer action with the specified rule and action
   * indexes.
   *
   * @param ruleIndex The rule index to use for calls to
   * {@link Recognizer//action}.
   * @param actionIndex The action index to use for calls to
   * {@link Recognizer//action}.
   */
  constructor(ruleIndex, actionIndex) {
    super(LexerActionType_default.CUSTOM);
    this.ruleIndex = ruleIndex;
    this.actionIndex = actionIndex;
    this.isPositionDependent = true;
  }
  /**
   * <p>Custom actions are implemented by calling {@link Lexer//action} with the
   * appropriate rule and action indexes.</p>
   */
  execute(lexer) {
    lexer.action(null, this.ruleIndex, this.actionIndex);
  }
  updateHashCode(hash4) {
    hash4.update(this.actionType, this.ruleIndex, this.actionIndex);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof _LexerCustomAction)) {
      return false;
    } else {
      return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;
    }
  }
};

// node_modules/antlr4/src/antlr4/action/LexerMoreAction.js
var LexerMoreAction = class extends LexerAction {
  constructor() {
    super(LexerActionType_default.MORE);
  }
  /**
   * <p>This action is implemented by calling {@link Lexer//popMode}.</p>
   */
  execute(lexer) {
    lexer.more();
  }
  toString() {
    return "more";
  }
};
LexerMoreAction.INSTANCE = new LexerMoreAction();

// node_modules/antlr4/src/antlr4/action/LexerTypeAction.js
var LexerTypeAction = class _LexerTypeAction extends LexerAction {
  constructor(type) {
    super(LexerActionType_default.TYPE);
    this.type = type;
  }
  execute(lexer) {
    lexer.type = this.type;
  }
  updateHashCode(hash4) {
    hash4.update(this.actionType, this.type);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof _LexerTypeAction)) {
      return false;
    } else {
      return this.type === other.type;
    }
  }
  toString() {
    return "type(" + this.type + ")";
  }
};

// node_modules/antlr4/src/antlr4/action/LexerPushModeAction.js
var LexerPushModeAction = class _LexerPushModeAction extends LexerAction {
  constructor(mode) {
    super(LexerActionType_default.PUSH_MODE);
    this.mode = mode;
  }
  /**
   * <p>This action is implemented by calling {@link Lexer//pushMode} with the
   * value provided by {@link //getMode}.</p>
   */
  execute(lexer) {
    lexer.pushMode(this.mode);
  }
  updateHashCode(hash4) {
    hash4.update(this.actionType, this.mode);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof _LexerPushModeAction)) {
      return false;
    } else {
      return this.mode === other.mode;
    }
  }
  toString() {
    return "pushMode(" + this.mode + ")";
  }
};

// node_modules/antlr4/src/antlr4/action/LexerPopModeAction.js
var LexerPopModeAction = class extends LexerAction {
  constructor() {
    super(LexerActionType_default.POP_MODE);
  }
  /**
   * <p>This action is implemented by calling {@link Lexer//popMode}.</p>
   */
  execute(lexer) {
    lexer.popMode();
  }
  toString() {
    return "popMode";
  }
};
LexerPopModeAction.INSTANCE = new LexerPopModeAction();

// node_modules/antlr4/src/antlr4/action/LexerModeAction.js
var LexerModeAction = class _LexerModeAction extends LexerAction {
  constructor(mode) {
    super(LexerActionType_default.MODE);
    this.mode = mode;
  }
  /**
   * <p>This action is implemented by calling {@link Lexer//mode} with the
   * value provided by {@link //getMode}.</p>
   */
  execute(lexer) {
    lexer.mode(this.mode);
  }
  updateHashCode(hash4) {
    hash4.update(this.actionType, this.mode);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof _LexerModeAction)) {
      return false;
    } else {
      return this.mode === other.mode;
    }
  }
  toString() {
    return "mode(" + this.mode + ")";
  }
};

// node_modules/antlr4/src/antlr4/atn/ATNDeserializer.js
var SERIALIZED_VERSION = 4;
function initArray(length2, value) {
  const tmp = [];
  tmp[length2 - 1] = value;
  return tmp.map(function(i2) {
    return value;
  });
}
var ATNDeserializer = class {
  constructor(options2) {
    if (options2 === void 0 || options2 === null) {
      options2 = ATNDeserializationOptions.defaultOptions;
    }
    this.deserializationOptions = options2;
    this.stateFactories = null;
    this.actionFactories = null;
  }
  deserialize(data) {
    const legacy = this.reset(data);
    this.checkVersion(legacy);
    if (legacy)
      this.skipUUID();
    const atn3 = this.readATN();
    this.readStates(atn3, legacy);
    this.readRules(atn3, legacy);
    this.readModes(atn3);
    const sets = [];
    this.readSets(atn3, sets, this.readInt.bind(this));
    if (legacy)
      this.readSets(atn3, sets, this.readInt32.bind(this));
    this.readEdges(atn3, sets);
    this.readDecisions(atn3);
    this.readLexerActions(atn3, legacy);
    this.markPrecedenceDecisions(atn3);
    this.verifyATN(atn3);
    if (this.deserializationOptions.generateRuleBypassTransitions && atn3.grammarType === ATNType_default.PARSER) {
      this.generateRuleBypassTransitions(atn3);
      this.verifyATN(atn3);
    }
    return atn3;
  }
  reset(data) {
    const version = data.charCodeAt ? data.charCodeAt(0) : data[0];
    if (version === SERIALIZED_VERSION - 1) {
      const adjust = function(c2) {
        const v = c2.charCodeAt(0);
        return v > 1 ? v - 2 : v + 65534;
      };
      const temp = data.split("").map(adjust);
      temp[0] = data.charCodeAt(0);
      this.data = temp;
      this.pos = 0;
      return true;
    } else {
      this.data = data;
      this.pos = 0;
      return false;
    }
  }
  skipUUID() {
    let count2 = 0;
    while (count2++ < 8)
      this.readInt();
  }
  checkVersion(legacy) {
    const version = this.readInt();
    if (!legacy && version !== SERIALIZED_VERSION) {
      throw "Could not deserialize ATN with version " + version + " (expected " + SERIALIZED_VERSION + ").";
    }
  }
  readATN() {
    const grammarType = this.readInt();
    const maxTokenType = this.readInt();
    return new ATN(grammarType, maxTokenType);
  }
  readStates(atn3, legacy) {
    let j, pair, stateNumber;
    const loopBackStateNumbers = [];
    const endStateNumbers = [];
    const nstates = this.readInt();
    for (let i2 = 0; i2 < nstates; i2++) {
      const stype = this.readInt();
      if (stype === ATNState.INVALID_TYPE) {
        atn3.addState(null);
        continue;
      }
      let ruleIndex = this.readInt();
      if (legacy && ruleIndex === 65535) {
        ruleIndex = -1;
      }
      const s3 = this.stateFactory(stype, ruleIndex);
      if (stype === ATNState.LOOP_END) {
        const loopBackStateNumber = this.readInt();
        loopBackStateNumbers.push([s3, loopBackStateNumber]);
      } else if (s3 instanceof BlockStartState) {
        const endStateNumber = this.readInt();
        endStateNumbers.push([s3, endStateNumber]);
      }
      atn3.addState(s3);
    }
    for (j = 0; j < loopBackStateNumbers.length; j++) {
      pair = loopBackStateNumbers[j];
      pair[0].loopBackState = atn3.states[pair[1]];
    }
    for (j = 0; j < endStateNumbers.length; j++) {
      pair = endStateNumbers[j];
      pair[0].endState = atn3.states[pair[1]];
    }
    let numNonGreedyStates = this.readInt();
    for (j = 0; j < numNonGreedyStates; j++) {
      stateNumber = this.readInt();
      atn3.states[stateNumber].nonGreedy = true;
    }
    let numPrecedenceStates = this.readInt();
    for (j = 0; j < numPrecedenceStates; j++) {
      stateNumber = this.readInt();
      atn3.states[stateNumber].isPrecedenceRule = true;
    }
  }
  readRules(atn3, legacy) {
    let i2;
    const nrules = this.readInt();
    if (atn3.grammarType === ATNType_default.LEXER) {
      atn3.ruleToTokenType = initArray(nrules, 0);
    }
    atn3.ruleToStartState = initArray(nrules, 0);
    for (i2 = 0; i2 < nrules; i2++) {
      const s3 = this.readInt();
      atn3.ruleToStartState[i2] = atn3.states[s3];
      if (atn3.grammarType === ATNType_default.LEXER) {
        let tokenType = this.readInt();
        if (legacy && tokenType === 65535) {
          tokenType = Token.EOF;
        }
        atn3.ruleToTokenType[i2] = tokenType;
      }
    }
    atn3.ruleToStopState = initArray(nrules, 0);
    for (i2 = 0; i2 < atn3.states.length; i2++) {
      const state = atn3.states[i2];
      if (!(state instanceof RuleStopState)) {
        continue;
      }
      atn3.ruleToStopState[state.ruleIndex] = state;
      atn3.ruleToStartState[state.ruleIndex].stopState = state;
    }
  }
  readModes(atn3) {
    const nmodes = this.readInt();
    for (let i2 = 0; i2 < nmodes; i2++) {
      let s3 = this.readInt();
      atn3.modeToStartState.push(atn3.states[s3]);
    }
  }
  readSets(atn3, sets, reader) {
    const m3 = this.readInt();
    for (let i2 = 0; i2 < m3; i2++) {
      const iset = new IntervalSet();
      sets.push(iset);
      const n = this.readInt();
      const containsEof = this.readInt();
      if (containsEof !== 0) {
        iset.addOne(-1);
      }
      for (let j = 0; j < n; j++) {
        const i1 = reader();
        const i22 = reader();
        iset.addRange(i1, i22);
      }
    }
  }
  readEdges(atn3, sets) {
    let i2, j, state, trans, target;
    const nedges = this.readInt();
    for (i2 = 0; i2 < nedges; i2++) {
      const src = this.readInt();
      const trg = this.readInt();
      const ttype = this.readInt();
      const arg1 = this.readInt();
      const arg2 = this.readInt();
      const arg3 = this.readInt();
      trans = this.edgeFactory(atn3, ttype, src, trg, arg1, arg2, arg3, sets);
      const srcState = atn3.states[src];
      srcState.addTransition(trans);
    }
    for (i2 = 0; i2 < atn3.states.length; i2++) {
      state = atn3.states[i2];
      for (j = 0; j < state.transitions.length; j++) {
        const t4 = state.transitions[j];
        if (!(t4 instanceof RuleTransition)) {
          continue;
        }
        let outermostPrecedenceReturn = -1;
        if (atn3.ruleToStartState[t4.target.ruleIndex].isPrecedenceRule) {
          if (t4.precedence === 0) {
            outermostPrecedenceReturn = t4.target.ruleIndex;
          }
        }
        trans = new EpsilonTransition(t4.followState, outermostPrecedenceReturn);
        atn3.ruleToStopState[t4.target.ruleIndex].addTransition(trans);
      }
    }
    for (i2 = 0; i2 < atn3.states.length; i2++) {
      state = atn3.states[i2];
      if (state instanceof BlockStartState) {
        if (state.endState === null) {
          throw "IllegalState";
        }
        if (state.endState.startState !== null) {
          throw "IllegalState";
        }
        state.endState.startState = state;
      }
      if (state instanceof PlusLoopbackState) {
        for (j = 0; j < state.transitions.length; j++) {
          target = state.transitions[j].target;
          if (target instanceof PlusBlockStartState) {
            target.loopBackState = state;
          }
        }
      } else if (state instanceof StarLoopbackState) {
        for (j = 0; j < state.transitions.length; j++) {
          target = state.transitions[j].target;
          if (target instanceof StarLoopEntryState) {
            target.loopBackState = state;
          }
        }
      }
    }
  }
  readDecisions(atn3) {
    const ndecisions = this.readInt();
    for (let i2 = 0; i2 < ndecisions; i2++) {
      const s3 = this.readInt();
      const decState = atn3.states[s3];
      atn3.decisionToState.push(decState);
      decState.decision = i2;
    }
  }
  readLexerActions(atn3, legacy) {
    if (atn3.grammarType === ATNType_default.LEXER) {
      const count2 = this.readInt();
      atn3.lexerActions = initArray(count2, null);
      for (let i2 = 0; i2 < count2; i2++) {
        const actionType = this.readInt();
        let data1 = this.readInt();
        if (legacy && data1 === 65535) {
          data1 = -1;
        }
        let data2 = this.readInt();
        if (legacy && data2 === 65535) {
          data2 = -1;
        }
        atn3.lexerActions[i2] = this.lexerActionFactory(actionType, data1, data2);
      }
    }
  }
  generateRuleBypassTransitions(atn3) {
    let i2;
    const count2 = atn3.ruleToStartState.length;
    for (i2 = 0; i2 < count2; i2++) {
      atn3.ruleToTokenType[i2] = atn3.maxTokenType + i2 + 1;
    }
    for (i2 = 0; i2 < count2; i2++) {
      this.generateRuleBypassTransition(atn3, i2);
    }
  }
  generateRuleBypassTransition(atn3, idx) {
    let i2, state;
    const bypassStart = new BasicBlockStartState();
    bypassStart.ruleIndex = idx;
    atn3.addState(bypassStart);
    const bypassStop = new BlockEndState();
    bypassStop.ruleIndex = idx;
    atn3.addState(bypassStop);
    bypassStart.endState = bypassStop;
    atn3.defineDecisionState(bypassStart);
    bypassStop.startState = bypassStart;
    let excludeTransition = null;
    let endState = null;
    if (atn3.ruleToStartState[idx].isPrecedenceRule) {
      endState = null;
      for (i2 = 0; i2 < atn3.states.length; i2++) {
        state = atn3.states[i2];
        if (this.stateIsEndStateFor(state, idx)) {
          endState = state;
          excludeTransition = state.loopBackState.transitions[0];
          break;
        }
      }
      if (excludeTransition === null) {
        throw "Couldn't identify final state of the precedence rule prefix section.";
      }
    } else {
      endState = atn3.ruleToStopState[idx];
    }
    for (i2 = 0; i2 < atn3.states.length; i2++) {
      state = atn3.states[i2];
      for (let j = 0; j < state.transitions.length; j++) {
        const transition = state.transitions[j];
        if (transition === excludeTransition) {
          continue;
        }
        if (transition.target === endState) {
          transition.target = bypassStop;
        }
      }
    }
    const ruleToStartState = atn3.ruleToStartState[idx];
    const count2 = ruleToStartState.transitions.length;
    while (count2 > 0) {
      bypassStart.addTransition(ruleToStartState.transitions[count2 - 1]);
      ruleToStartState.transitions = ruleToStartState.transitions.slice(-1);
    }
    atn3.ruleToStartState[idx].addTransition(new EpsilonTransition(bypassStart));
    bypassStop.addTransition(new EpsilonTransition(endState));
    const matchState = new BasicState();
    atn3.addState(matchState);
    matchState.addTransition(new AtomTransition(bypassStop, atn3.ruleToTokenType[idx]));
    bypassStart.addTransition(new EpsilonTransition(matchState));
  }
  stateIsEndStateFor(state, idx) {
    if (state.ruleIndex !== idx) {
      return null;
    }
    if (!(state instanceof StarLoopEntryState)) {
      return null;
    }
    const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
    if (!(maybeLoopEndState instanceof LoopEndState)) {
      return null;
    }
    if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof RuleStopState) {
      return state;
    } else {
      return null;
    }
  }
  /**
   * Analyze the {@link StarLoopEntryState} states in the specified ATN to set
   * the {@link StarLoopEntryState//isPrecedenceDecision} field to the
   * correct value.
   * @param atn The ATN.
   */
  markPrecedenceDecisions(atn3) {
    for (let i2 = 0; i2 < atn3.states.length; i2++) {
      const state = atn3.states[i2];
      if (!(state instanceof StarLoopEntryState)) {
        continue;
      }
      if (atn3.ruleToStartState[state.ruleIndex].isPrecedenceRule) {
        const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
        if (maybeLoopEndState instanceof LoopEndState) {
          if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof RuleStopState) {
            state.isPrecedenceDecision = true;
          }
        }
      }
    }
  }
  verifyATN(atn3) {
    if (!this.deserializationOptions.verifyATN) {
      return;
    }
    for (let i2 = 0; i2 < atn3.states.length; i2++) {
      const state = atn3.states[i2];
      if (state === null) {
        continue;
      }
      this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);
      if (state instanceof PlusBlockStartState) {
        this.checkCondition(state.loopBackState !== null);
      } else if (state instanceof StarLoopEntryState) {
        this.checkCondition(state.loopBackState !== null);
        this.checkCondition(state.transitions.length === 2);
        if (state.transitions[0].target instanceof StarBlockStartState) {
          this.checkCondition(state.transitions[1].target instanceof LoopEndState);
          this.checkCondition(!state.nonGreedy);
        } else if (state.transitions[0].target instanceof LoopEndState) {
          this.checkCondition(state.transitions[1].target instanceof StarBlockStartState);
          this.checkCondition(state.nonGreedy);
        } else {
          throw "IllegalState";
        }
      } else if (state instanceof StarLoopbackState) {
        this.checkCondition(state.transitions.length === 1);
        this.checkCondition(state.transitions[0].target instanceof StarLoopEntryState);
      } else if (state instanceof LoopEndState) {
        this.checkCondition(state.loopBackState !== null);
      } else if (state instanceof RuleStartState) {
        this.checkCondition(state.stopState !== null);
      } else if (state instanceof BlockStartState) {
        this.checkCondition(state.endState !== null);
      } else if (state instanceof BlockEndState) {
        this.checkCondition(state.startState !== null);
      } else if (state instanceof DecisionState) {
        this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);
      } else {
        this.checkCondition(state.transitions.length <= 1 || state instanceof RuleStopState);
      }
    }
  }
  checkCondition(condition, message) {
    if (!condition) {
      if (message === void 0 || message === null) {
        message = "IllegalState";
      }
      throw message;
    }
  }
  readInt() {
    return this.data[this.pos++];
  }
  readInt32() {
    const low = this.readInt();
    const high = this.readInt();
    return low | high << 16;
  }
  edgeFactory(atn3, type, src, trg, arg1, arg2, arg3, sets) {
    const target = atn3.states[trg];
    switch (type) {
      case Transition.EPSILON:
        return new EpsilonTransition(target);
      case Transition.RANGE:
        return arg3 !== 0 ? new RangeTransition(target, Token.EOF, arg2) : new RangeTransition(target, arg1, arg2);
      case Transition.RULE:
        return new RuleTransition(atn3.states[arg1], arg2, arg3, target);
      case Transition.PREDICATE:
        return new PredicateTransition(target, arg1, arg2, arg3 !== 0);
      case Transition.PRECEDENCE:
        return new PrecedencePredicateTransition(target, arg1);
      case Transition.ATOM:
        return arg3 !== 0 ? new AtomTransition(target, Token.EOF) : new AtomTransition(target, arg1);
      case Transition.ACTION:
        return new ActionTransition(target, arg1, arg2, arg3 !== 0);
      case Transition.SET:
        return new SetTransition(target, sets[arg1]);
      case Transition.NOT_SET:
        return new NotSetTransition(target, sets[arg1]);
      case Transition.WILDCARD:
        return new WildcardTransition(target);
      default:
        throw "The specified transition type: " + type + " is not valid.";
    }
  }
  stateFactory(type, ruleIndex) {
    if (this.stateFactories === null) {
      const sf = [];
      sf[ATNState.INVALID_TYPE] = null;
      sf[ATNState.BASIC] = () => new BasicState();
      sf[ATNState.RULE_START] = () => new RuleStartState();
      sf[ATNState.BLOCK_START] = () => new BasicBlockStartState();
      sf[ATNState.PLUS_BLOCK_START] = () => new PlusBlockStartState();
      sf[ATNState.STAR_BLOCK_START] = () => new StarBlockStartState();
      sf[ATNState.TOKEN_START] = () => new TokensStartState();
      sf[ATNState.RULE_STOP] = () => new RuleStopState();
      sf[ATNState.BLOCK_END] = () => new BlockEndState();
      sf[ATNState.STAR_LOOP_BACK] = () => new StarLoopbackState();
      sf[ATNState.STAR_LOOP_ENTRY] = () => new StarLoopEntryState();
      sf[ATNState.PLUS_LOOP_BACK] = () => new PlusLoopbackState();
      sf[ATNState.LOOP_END] = () => new LoopEndState();
      this.stateFactories = sf;
    }
    if (type > this.stateFactories.length || this.stateFactories[type] === null) {
      throw "The specified state type " + type + " is not valid.";
    } else {
      const s3 = this.stateFactories[type]();
      if (s3 !== null) {
        s3.ruleIndex = ruleIndex;
        return s3;
      }
    }
  }
  lexerActionFactory(type, data1, data2) {
    if (this.actionFactories === null) {
      const af = [];
      af[LexerActionType_default.CHANNEL] = (data12, data22) => new LexerChannelAction(data12);
      af[LexerActionType_default.CUSTOM] = (data12, data22) => new LexerCustomAction(data12, data22);
      af[LexerActionType_default.MODE] = (data12, data22) => new LexerModeAction(data12);
      af[LexerActionType_default.MORE] = (data12, data22) => LexerMoreAction.INSTANCE;
      af[LexerActionType_default.POP_MODE] = (data12, data22) => LexerPopModeAction.INSTANCE;
      af[LexerActionType_default.PUSH_MODE] = (data12, data22) => new LexerPushModeAction(data12);
      af[LexerActionType_default.SKIP] = (data12, data22) => LexerSkipAction.INSTANCE;
      af[LexerActionType_default.TYPE] = (data12, data22) => new LexerTypeAction(data12);
      this.actionFactories = af;
    }
    if (type > this.actionFactories.length || this.actionFactories[type] === null) {
      throw "The specified lexer action type " + type + " is not valid.";
    } else {
      return this.actionFactories[type](data1, data2);
    }
  }
};

// node_modules/antlr4/src/antlr4/error/ErrorListener.js
var ErrorListener = class {
  syntaxError(recognizer, offendingSymbol, line2, column2, msg, e4) {
  }
  reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
  }
  reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
  }
  reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
  }
};

// node_modules/antlr4/src/antlr4/error/ConsoleErrorListener.js
var ConsoleErrorListener = class extends ErrorListener {
  constructor() {
    super();
  }
  syntaxError(recognizer, offendingSymbol, line2, column2, msg, e4) {
    console.error("line " + line2 + ":" + column2 + " " + msg);
  }
};
ConsoleErrorListener.INSTANCE = new ConsoleErrorListener();

// node_modules/antlr4/src/antlr4/error/ProxyErrorListener.js
var ProxyErrorListener = class extends ErrorListener {
  constructor(delegates) {
    super();
    if (delegates === null) {
      throw "delegates";
    }
    this.delegates = delegates;
    return this;
  }
  syntaxError(recognizer, offendingSymbol, line2, column2, msg, e4) {
    this.delegates.map((d3) => d3.syntaxError(recognizer, offendingSymbol, line2, column2, msg, e4));
  }
  reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
    this.delegates.map((d3) => d3.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs));
  }
  reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
    this.delegates.map((d3) => d3.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs));
  }
  reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
    this.delegates.map((d3) => d3.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs));
  }
};

// node_modules/antlr4/src/antlr4/Recognizer.js
var Recognizer = class {
  constructor() {
    this._listeners = [ConsoleErrorListener.INSTANCE];
    this._interp = null;
    this._stateNumber = -1;
  }
  checkVersion(toolVersion) {
    const runtimeVersion = "4.10.1";
    if (runtimeVersion !== toolVersion) {
      console.log("ANTLR runtime and generated code versions disagree: " + runtimeVersion + "!=" + toolVersion);
    }
  }
  addErrorListener(listener) {
    this._listeners.push(listener);
  }
  removeErrorListeners() {
    this._listeners = [];
  }
  getLiteralNames() {
    return Object.getPrototypeOf(this).constructor.literalNames || [];
  }
  getSymbolicNames() {
    return Object.getPrototypeOf(this).constructor.symbolicNames || [];
  }
  getTokenNames() {
    if (!this.tokenNames) {
      const literalNames = this.getLiteralNames();
      const symbolicNames = this.getSymbolicNames();
      const length2 = literalNames.length > symbolicNames.length ? literalNames.length : symbolicNames.length;
      this.tokenNames = [];
      for (let i2 = 0; i2 < length2; i2++) {
        this.tokenNames[i2] = literalNames[i2] || symbolicNames[i2] || "<INVALID";
      }
    }
    return this.tokenNames;
  }
  getTokenTypeMap() {
    const tokenNames = this.getTokenNames();
    if (tokenNames === null) {
      throw "The current recognizer does not provide a list of token names.";
    }
    let result = this.tokenTypeMapCache[tokenNames];
    if (result === void 0) {
      result = tokenNames.reduce(function(o, k2, i2) {
        o[k2] = i2;
      });
      result.EOF = Token.EOF;
      this.tokenTypeMapCache[tokenNames] = result;
    }
    return result;
  }
  /**
   * Get a map from rule names to rule indexes.
   * <p>Used for XPath and tree pattern compilation.</p>
   */
  getRuleIndexMap() {
    const ruleNames = this.ruleNames;
    if (ruleNames === null) {
      throw "The current recognizer does not provide a list of rule names.";
    }
    let result = this.ruleIndexMapCache[ruleNames];
    if (result === void 0) {
      result = ruleNames.reduce(function(o, k2, i2) {
        o[k2] = i2;
      });
      this.ruleIndexMapCache[ruleNames] = result;
    }
    return result;
  }
  getTokenType(tokenName) {
    const ttype = this.getTokenTypeMap()[tokenName];
    if (ttype !== void 0) {
      return ttype;
    } else {
      return Token.INVALID_TYPE;
    }
  }
  // What is the error header, normally line/character position information?
  getErrorHeader(e4) {
    const line2 = e4.getOffendingToken().line;
    const column2 = e4.getOffendingToken().column;
    return "line " + line2 + ":" + column2;
  }
  /**
   * How should a token be displayed in an error message? The default
   * is to display just the text, but during development you might
   * want to have a lot of information spit out.  Override in that case
   * to use t.toString() (which, for CommonToken, dumps everything about
   * the token). This is better than forcing you to override a method in
   * your token objects because you don't have to go modify your lexer
   * so that it creates a new Java type.
   *
   * @deprecated This method is not called by the ANTLR 4 Runtime. Specific
   * implementations of {@link ANTLRErrorStrategy} may provide a similar
   * feature when necessary. For example, see
   * {@link DefaultErrorStrategy//getTokenErrorDisplay}.*/
  getTokenErrorDisplay(t4) {
    if (t4 === null) {
      return "<no token>";
    }
    let s3 = t4.text;
    if (s3 === null) {
      if (t4.type === Token.EOF) {
        s3 = "<EOF>";
      } else {
        s3 = "<" + t4.type + ">";
      }
    }
    s3 = s3.replace("\n", "\\n").replace("\r", "\\r").replace("	", "\\t");
    return "'" + s3 + "'";
  }
  getErrorListenerDispatch() {
    return new ProxyErrorListener(this._listeners);
  }
  /**
   * subclass needs to override these if there are sempreds or actions
   * that the ATN interp needs to execute
   */
  sempred(localctx, ruleIndex, actionIndex) {
    return true;
  }
  precpred(localctx, precedence) {
    return true;
  }
  get state() {
    return this._stateNumber;
  }
  set state(state) {
    this._stateNumber = state;
  }
};
Recognizer.tokenTypeMapCache = {};
Recognizer.ruleIndexMapCache = {};

// node_modules/antlr4/src/antlr4/CommonToken.js
var CommonToken = class _CommonToken extends Token {
  constructor(source, type, channel, start2, stop) {
    super();
    this.source = source !== void 0 ? source : _CommonToken.EMPTY_SOURCE;
    this.type = type !== void 0 ? type : null;
    this.channel = channel !== void 0 ? channel : Token.DEFAULT_CHANNEL;
    this.start = start2 !== void 0 ? start2 : -1;
    this.stop = stop !== void 0 ? stop : -1;
    this.tokenIndex = -1;
    if (this.source[0] !== null) {
      this.line = source[0].line;
      this.column = source[0].column;
    } else {
      this.column = -1;
    }
  }
  /**
   * Constructs a new {@link CommonToken} as a copy of another {@link Token}.
   *
   * <p>
   * If {@code oldToken} is also a {@link CommonToken} instance, the newly
   * constructed token will share a reference to the {@link //text} field and
   * the {@link Pair} stored in {@link //source}. Otherwise, {@link //text} will
   * be assigned the result of calling {@link //getText}, and {@link //source}
   * will be constructed from the result of {@link Token//getTokenSource} and
   * {@link Token//getInputStream}.</p>
   *
   * @param oldToken The token to copy.
   */
  clone() {
    const t4 = new _CommonToken(this.source, this.type, this.channel, this.start, this.stop);
    t4.tokenIndex = this.tokenIndex;
    t4.line = this.line;
    t4.column = this.column;
    t4.text = this.text;
    return t4;
  }
  toString() {
    let txt = this.text;
    if (txt !== null) {
      txt = txt.replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
    } else {
      txt = "<no text>";
    }
    return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + txt + "',<" + this.type + ">" + (this.channel > 0 ? ",channel=" + this.channel : "") + "," + this.line + ":" + this.column + "]";
  }
  get text() {
    if (this._text !== null) {
      return this._text;
    }
    const input = this.getInputStream();
    if (input === null) {
      return null;
    }
    const n = input.size;
    if (this.start < n && this.stop < n) {
      return input.getText(this.start, this.stop);
    } else {
      return "<EOF>";
    }
  }
  set text(text) {
    this._text = text;
  }
};
CommonToken.EMPTY_SOURCE = [null, null];

// node_modules/antlr4/src/antlr4/CommonTokenFactory.js
var TokenFactory = class {
};
var CommonTokenFactory = class extends TokenFactory {
  constructor(copyText) {
    super();
    this.copyText = copyText === void 0 ? false : copyText;
  }
  create(source, type, text, channel, start2, stop, line2, column2) {
    const t4 = new CommonToken(source, type, channel, start2, stop);
    t4.line = line2;
    t4.column = column2;
    if (text !== null) {
      t4.text = text;
    } else if (this.copyText && source[1] !== null) {
      t4.text = source[1].getText(start2, stop);
    }
    return t4;
  }
  createThin(type, text) {
    const t4 = new CommonToken(null, type);
    t4.text = text;
    return t4;
  }
};
CommonTokenFactory.DEFAULT = new CommonTokenFactory();

// node_modules/antlr4/src/antlr4/error/RecognitionException.js
var RecognitionException = class _RecognitionException extends Error {
  constructor(params) {
    super(params.message);
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, _RecognitionException);
    this.message = params.message;
    this.recognizer = params.recognizer;
    this.input = params.input;
    this.ctx = params.ctx;
    this.offendingToken = null;
    this.offendingState = -1;
    if (this.recognizer !== null) {
      this.offendingState = this.recognizer.state;
    }
  }
  /**
   * Gets the set of input symbols which could potentially follow the
   * previously matched symbol at the time this exception was thrown.
   *
   * <p>If the set of expected tokens is not known and could not be computed,
   * this method returns {@code null}.</p>
   *
   * @return The set of token types that could potentially follow the current
   * state in the ATN, or {@code null} if the information is not available.
   */
  getExpectedTokens() {
    if (this.recognizer !== null) {
      return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);
    } else {
      return null;
    }
  }
  // <p>If the state number is not known, this method returns -1.</p>
  toString() {
    return this.message;
  }
};

// node_modules/antlr4/src/antlr4/error/LexerNoViableAltException.js
var LexerNoViableAltException = class extends RecognitionException {
  constructor(lexer, input, startIndex, deadEndConfigs) {
    super({ message: "", recognizer: lexer, input, ctx: null });
    this.startIndex = startIndex;
    this.deadEndConfigs = deadEndConfigs;
  }
  toString() {
    let symbol = "";
    if (this.startIndex >= 0 && this.startIndex < this.input.size) {
      symbol = this.input.getText(new Interval(this.startIndex, this.startIndex));
    }
    return "LexerNoViableAltException" + symbol;
  }
};

// node_modules/antlr4/src/antlr4/Lexer.js
var Lexer = class _Lexer extends Recognizer {
  constructor(input) {
    super();
    this._input = input;
    this._factory = CommonTokenFactory.DEFAULT;
    this._tokenFactorySourcePair = [this, input];
    this._interp = null;
    this._token = null;
    this._tokenStartCharIndex = -1;
    this._tokenStartLine = -1;
    this._tokenStartColumn = -1;
    this._hitEOF = false;
    this._channel = Token.DEFAULT_CHANNEL;
    this._type = Token.INVALID_TYPE;
    this._modeStack = [];
    this._mode = _Lexer.DEFAULT_MODE;
    this._text = null;
  }
  reset() {
    if (this._input !== null) {
      this._input.seek(0);
    }
    this._token = null;
    this._type = Token.INVALID_TYPE;
    this._channel = Token.DEFAULT_CHANNEL;
    this._tokenStartCharIndex = -1;
    this._tokenStartColumn = -1;
    this._tokenStartLine = -1;
    this._text = null;
    this._hitEOF = false;
    this._mode = _Lexer.DEFAULT_MODE;
    this._modeStack = [];
    this._interp.reset();
  }
  // Return a token from this source; i.e., match a token on the char stream.
  nextToken() {
    if (this._input === null) {
      throw "nextToken requires a non-null input stream.";
    }
    const tokenStartMarker = this._input.mark();
    try {
      for (; ; ) {
        if (this._hitEOF) {
          this.emitEOF();
          return this._token;
        }
        this._token = null;
        this._channel = Token.DEFAULT_CHANNEL;
        this._tokenStartCharIndex = this._input.index;
        this._tokenStartColumn = this._interp.column;
        this._tokenStartLine = this._interp.line;
        this._text = null;
        let continueOuter = false;
        for (; ; ) {
          this._type = Token.INVALID_TYPE;
          let ttype = _Lexer.SKIP;
          try {
            ttype = this._interp.match(this._input, this._mode);
          } catch (e4) {
            if (e4 instanceof RecognitionException) {
              this.notifyListeners(e4);
              this.recover(e4);
            } else {
              console.log(e4.stack);
              throw e4;
            }
          }
          if (this._input.LA(1) === Token.EOF) {
            this._hitEOF = true;
          }
          if (this._type === Token.INVALID_TYPE) {
            this._type = ttype;
          }
          if (this._type === _Lexer.SKIP) {
            continueOuter = true;
            break;
          }
          if (this._type !== _Lexer.MORE) {
            break;
          }
        }
        if (continueOuter) {
          continue;
        }
        if (this._token === null) {
          this.emit();
        }
        return this._token;
      }
    } finally {
      this._input.release(tokenStartMarker);
    }
  }
  /**
   * Instruct the lexer to skip creating a token for current lexer rule
   * and look for another token. nextToken() knows to keep looking when
   * a lexer rule finishes with token set to SKIP_TOKEN. Recall that
   * if token==null at end of any token rule, it creates one for you
   * and emits it.
   */
  skip() {
    this._type = _Lexer.SKIP;
  }
  more() {
    this._type = _Lexer.MORE;
  }
  mode(m3) {
    this._mode = m3;
  }
  pushMode(m3) {
    if (this._interp.debug) {
      console.log("pushMode " + m3);
    }
    this._modeStack.push(this._mode);
    this.mode(m3);
  }
  popMode() {
    if (this._modeStack.length === 0) {
      throw "Empty Stack";
    }
    if (this._interp.debug) {
      console.log("popMode back to " + this._modeStack.slice(0, -1));
    }
    this.mode(this._modeStack.pop());
    return this._mode;
  }
  /**
   * By default does not support multiple emits per nextToken invocation
   * for efficiency reasons. Subclass and override this method, nextToken,
   * and getToken (to push tokens into a list and pull from that list
   * rather than a single variable as this implementation does).
   */
  emitToken(token2) {
    this._token = token2;
  }
  /**
   * The standard method called to automatically emit a token at the
   * outermost lexical rule. The token object should point into the
   * char buffer start..stop. If there is a text override in 'text',
   * use that to set the token's text. Override this method to emit
   * custom Token objects or provide a new factory.
   */
  emit() {
    const t4 = this._factory.create(
      this._tokenFactorySourcePair,
      this._type,
      this._text,
      this._channel,
      this._tokenStartCharIndex,
      this.getCharIndex() - 1,
      this._tokenStartLine,
      this._tokenStartColumn
    );
    this.emitToken(t4);
    return t4;
  }
  emitEOF() {
    const cpos = this.column;
    const lpos = this.line;
    const eof = this._factory.create(
      this._tokenFactorySourcePair,
      Token.EOF,
      null,
      Token.DEFAULT_CHANNEL,
      this._input.index,
      this._input.index - 1,
      lpos,
      cpos
    );
    this.emitToken(eof);
    return eof;
  }
  // What is the index of the current character of lookahead?///
  getCharIndex() {
    return this._input.index;
  }
  /**
   * Return a list of all Token objects in input char stream.
   * Forces load of all tokens. Does not include EOF token.
   */
  getAllTokens() {
    const tokens2 = [];
    let t4 = this.nextToken();
    while (t4.type !== Token.EOF) {
      tokens2.push(t4);
      t4 = this.nextToken();
    }
    return tokens2;
  }
  notifyListeners(e4) {
    const start2 = this._tokenStartCharIndex;
    const stop = this._input.index;
    const text = this._input.getText(start2, stop);
    const msg = "token recognition error at: '" + this.getErrorDisplay(text) + "'";
    const listener = this.getErrorListenerDispatch();
    listener.syntaxError(
      this,
      null,
      this._tokenStartLine,
      this._tokenStartColumn,
      msg,
      e4
    );
  }
  getErrorDisplay(s3) {
    const d3 = [];
    for (let i2 = 0; i2 < s3.length; i2++) {
      d3.push(s3[i2]);
    }
    return d3.join("");
  }
  getErrorDisplayForChar(c2) {
    if (c2.charCodeAt(0) === Token.EOF) {
      return "<EOF>";
    } else if (c2 === "\n") {
      return "\\n";
    } else if (c2 === "	") {
      return "\\t";
    } else if (c2 === "\r") {
      return "\\r";
    } else {
      return c2;
    }
  }
  getCharErrorDisplay(c2) {
    return "'" + this.getErrorDisplayForChar(c2) + "'";
  }
  /**
   * Lexers can normally match any char in it's vocabulary after matching
   * a token, so do the easy thing and just kill a character and hope
   * it all works out. You can instead use the rule invocation stack
   * to do sophisticated error recovery if you are in a fragment rule.
   */
  recover(re) {
    if (this._input.LA(1) !== Token.EOF) {
      if (re instanceof LexerNoViableAltException) {
        this._interp.consume(this._input);
      } else {
        this._input.consume();
      }
    }
  }
  get inputStream() {
    return this._input;
  }
  set inputStream(input) {
    this._input = null;
    this._tokenFactorySourcePair = [this, this._input];
    this.reset();
    this._input = input;
    this._tokenFactorySourcePair = [this, this._input];
  }
  get sourceName() {
    return this._input.sourceName;
  }
  get type() {
    return this._type;
  }
  set type(type) {
    this._type = type;
  }
  get line() {
    return this._interp.line;
  }
  set line(line2) {
    this._interp.line = line2;
  }
  get column() {
    return this._interp.column;
  }
  set column(column2) {
    this._interp.column = column2;
  }
  get text() {
    if (this._text !== null) {
      return this._text;
    } else {
      return this._interp.getText(this._input);
    }
  }
  set text(text) {
    this._text = text;
  }
};
Lexer.DEFAULT_MODE = 0;
Lexer.MORE = -2;
Lexer.SKIP = -3;
Lexer.DEFAULT_TOKEN_CHANNEL = Token.DEFAULT_CHANNEL;
Lexer.HIDDEN = Token.HIDDEN_CHANNEL;
Lexer.MIN_CHAR_VALUE = 0;
Lexer.MAX_CHAR_VALUE = 1114111;

// node_modules/antlr4/src/antlr4/atn/ATNConfigSet.js
function hashATNConfig(c2) {
  return c2.hashCodeForConfigSet();
}
function equalATNConfigs(a3, b2) {
  if (a3 === b2) {
    return true;
  } else if (a3 === null || b2 === null) {
    return false;
  } else
    return a3.equalsForConfigSet(b2);
}
var ATNConfigSet = class _ATNConfigSet {
  constructor(fullCtx) {
    this.configLookup = new HashSet(hashATNConfig, equalATNConfigs);
    this.fullCtx = fullCtx === void 0 ? true : fullCtx;
    this.readOnly = false;
    this.configs = [];
    this.uniqueAlt = 0;
    this.conflictingAlts = null;
    this.hasSemanticContext = false;
    this.dipsIntoOuterContext = false;
    this.cachedHashCode = -1;
  }
  /**
   * Adding a new config means merging contexts with existing configs for
   * {@code (s, i, pi, _)}, where {@code s} is the
   * {@link ATNConfig//state}, {@code i} is the {@link ATNConfig//alt}, and
   * {@code pi} is the {@link ATNConfig//semanticContext}. We use
   * {@code (s,i,pi)} as key.
   *
   * <p>This method updates {@link //dipsIntoOuterContext} and
   * {@link //hasSemanticContext} when necessary.</p>
   */
  add(config2, mergeCache) {
    if (mergeCache === void 0) {
      mergeCache = null;
    }
    if (this.readOnly) {
      throw "This set is readonly";
    }
    if (config2.semanticContext !== SemanticContext.NONE) {
      this.hasSemanticContext = true;
    }
    if (config2.reachesIntoOuterContext > 0) {
      this.dipsIntoOuterContext = true;
    }
    const existing = this.configLookup.add(config2);
    if (existing === config2) {
      this.cachedHashCode = -1;
      this.configs.push(config2);
      return true;
    }
    const rootIsWildcard = !this.fullCtx;
    const merged = merge2(existing.context, config2.context, rootIsWildcard, mergeCache);
    existing.reachesIntoOuterContext = Math.max(existing.reachesIntoOuterContext, config2.reachesIntoOuterContext);
    if (config2.precedenceFilterSuppressed) {
      existing.precedenceFilterSuppressed = true;
    }
    existing.context = merged;
    return true;
  }
  getStates() {
    const states = new HashSet();
    for (let i2 = 0; i2 < this.configs.length; i2++) {
      states.add(this.configs[i2].state);
    }
    return states;
  }
  getPredicates() {
    const preds = [];
    for (let i2 = 0; i2 < this.configs.length; i2++) {
      const c2 = this.configs[i2].semanticContext;
      if (c2 !== SemanticContext.NONE) {
        preds.push(c2.semanticContext);
      }
    }
    return preds;
  }
  optimizeConfigs(interpreter) {
    if (this.readOnly) {
      throw "This set is readonly";
    }
    if (this.configLookup.length === 0) {
      return;
    }
    for (let i2 = 0; i2 < this.configs.length; i2++) {
      const config2 = this.configs[i2];
      config2.context = interpreter.getCachedContext(config2.context);
    }
  }
  addAll(coll) {
    for (let i2 = 0; i2 < coll.length; i2++) {
      this.add(coll[i2]);
    }
    return false;
  }
  equals(other) {
    return this === other || other instanceof _ATNConfigSet && equalArrays(this.configs, other.configs) && this.fullCtx === other.fullCtx && this.uniqueAlt === other.uniqueAlt && this.conflictingAlts === other.conflictingAlts && this.hasSemanticContext === other.hasSemanticContext && this.dipsIntoOuterContext === other.dipsIntoOuterContext;
  }
  hashCode() {
    const hash4 = new HashCode();
    hash4.update(this.configs);
    return hash4.finish();
  }
  updateHashCode(hash4) {
    if (this.readOnly) {
      if (this.cachedHashCode === -1) {
        this.cachedHashCode = this.hashCode();
      }
      hash4.update(this.cachedHashCode);
    } else {
      hash4.update(this.hashCode());
    }
  }
  isEmpty() {
    return this.configs.length === 0;
  }
  contains(item) {
    if (this.configLookup === null) {
      throw "This method is not implemented for readonly sets.";
    }
    return this.configLookup.contains(item);
  }
  containsFast(item) {
    if (this.configLookup === null) {
      throw "This method is not implemented for readonly sets.";
    }
    return this.configLookup.containsFast(item);
  }
  clear() {
    if (this.readOnly) {
      throw "This set is readonly";
    }
    this.configs = [];
    this.cachedHashCode = -1;
    this.configLookup = new HashSet();
  }
  setReadonly(readOnly2) {
    this.readOnly = readOnly2;
    if (readOnly2) {
      this.configLookup = null;
    }
  }
  toString() {
    return arrayToString(this.configs) + (this.hasSemanticContext ? ",hasSemanticContext=" + this.hasSemanticContext : "") + (this.uniqueAlt !== ATN.INVALID_ALT_NUMBER ? ",uniqueAlt=" + this.uniqueAlt : "") + (this.conflictingAlts !== null ? ",conflictingAlts=" + this.conflictingAlts : "") + (this.dipsIntoOuterContext ? ",dipsIntoOuterContext" : "");
  }
  get items() {
    return this.configs;
  }
  get length() {
    return this.configs.length;
  }
};

// node_modules/antlr4/src/antlr4/dfa/DFAState.js
var DFAState = class _DFAState {
  constructor(stateNumber, configs) {
    if (stateNumber === null) {
      stateNumber = -1;
    }
    if (configs === null) {
      configs = new ATNConfigSet();
    }
    this.stateNumber = stateNumber;
    this.configs = configs;
    this.edges = null;
    this.isAcceptState = false;
    this.prediction = 0;
    this.lexerActionExecutor = null;
    this.requiresFullContext = false;
    this.predicates = null;
    return this;
  }
  /**
   * Get the set of all alts mentioned by all ATN configurations in this
   * DFA state.
   */
  getAltSet() {
    const alts = new HashSet();
    if (this.configs !== null) {
      for (let i2 = 0; i2 < this.configs.length; i2++) {
        const c2 = this.configs[i2];
        alts.add(c2.alt);
      }
    }
    if (alts.length === 0) {
      return null;
    } else {
      return alts;
    }
  }
  /**
   * Two {@link DFAState} instances are equal if their ATN configuration sets
   * are the same. This method is used to see if a state already exists.
   *
   * <p>Because the number of alternatives and number of ATN configurations are
   * finite, there is a finite number of DFA states that can be processed.
   * This is necessary to show that the algorithm terminates.</p>
   *
   * <p>Cannot test the DFA state numbers here because in
   * {@link ParserATNSimulator//addDFAState} we need to know if any other state
   * exists that has this exact set of ATN configurations. The
   * {@link //stateNumber} is irrelevant.</p>
   */
  equals(other) {
    return this === other || other instanceof _DFAState && this.configs.equals(other.configs);
  }
  toString() {
    let s3 = "" + this.stateNumber + ":" + this.configs;
    if (this.isAcceptState) {
      s3 = s3 + "=>";
      if (this.predicates !== null)
        s3 = s3 + this.predicates;
      else
        s3 = s3 + this.prediction;
    }
    return s3;
  }
  hashCode() {
    const hash4 = new HashCode();
    hash4.update(this.configs);
    return hash4.finish();
  }
};

// node_modules/antlr4/src/antlr4/atn/ATNSimulator.js
var ATNSimulator = class {
  constructor(atn3, sharedContextCache2) {
    this.atn = atn3;
    this.sharedContextCache = sharedContextCache2;
    return this;
  }
  getCachedContext(context) {
    if (this.sharedContextCache === null) {
      return context;
    }
    const visited = new HashMap();
    return getCachedPredictionContext(context, this.sharedContextCache, visited);
  }
};
ATNSimulator.ERROR = new DFAState(2147483647, new ATNConfigSet());

// node_modules/antlr4/src/antlr4/atn/OrderedATNConfigSet.js
var OrderedATNConfigSet = class extends ATNConfigSet {
  constructor() {
    super();
    this.configLookup = new HashSet();
  }
};

// node_modules/antlr4/src/antlr4/atn/LexerATNConfig.js
var LexerATNConfig = class _LexerATNConfig extends ATNConfig {
  constructor(params, config2) {
    super(params, config2);
    const lexerActionExecutor = params.lexerActionExecutor || null;
    this.lexerActionExecutor = lexerActionExecutor || (config2 !== null ? config2.lexerActionExecutor : null);
    this.passedThroughNonGreedyDecision = config2 !== null ? this.checkNonGreedyDecision(config2, this.state) : false;
    this.hashCodeForConfigSet = _LexerATNConfig.prototype.hashCode;
    this.equalsForConfigSet = _LexerATNConfig.prototype.equals;
    return this;
  }
  updateHashCode(hash4) {
    hash4.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);
  }
  equals(other) {
    return this === other || other instanceof _LexerATNConfig && this.passedThroughNonGreedyDecision === other.passedThroughNonGreedyDecision && (this.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) && super.equals(other);
  }
  checkNonGreedyDecision(source, target) {
    return source.passedThroughNonGreedyDecision || target instanceof DecisionState && target.nonGreedy;
  }
};

// node_modules/antlr4/src/antlr4/action/LexerIndexedCustomAction.js
var LexerIndexedCustomAction = class _LexerIndexedCustomAction extends LexerAction {
  constructor(offset3, action) {
    super(action.actionType);
    this.offset = offset3;
    this.action = action;
    this.isPositionDependent = true;
  }
  /**
   * <p>This method calls {@link //execute} on the result of {@link //getAction}
   * using the provided {@code lexer}.</p>
   */
  execute(lexer) {
    this.action.execute(lexer);
  }
  updateHashCode(hash4) {
    hash4.update(this.actionType, this.offset, this.action);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof _LexerIndexedCustomAction)) {
      return false;
    } else {
      return this.offset === other.offset && this.action === other.action;
    }
  }
};

// node_modules/antlr4/src/antlr4/atn/LexerActionExecutor.js
var LexerActionExecutor = class _LexerActionExecutor {
  /**
   * Represents an executor for a sequence of lexer actions which traversed during
   * the matching operation of a lexer rule (token).
   *
   * <p>The executor tracks position information for position-dependent lexer actions
   * efficiently, ensuring that actions appearing only at the end of the rule do
   * not cause bloating of the {@link DFA} created for the lexer.</p>
   */
  constructor(lexerActions) {
    this.lexerActions = lexerActions === null ? [] : lexerActions;
    this.cachedHashCode = HashCode.hashStuff(lexerActions);
    return this;
  }
  /**
   * Creates a {@link LexerActionExecutor} which encodes the current offset
   * for position-dependent lexer actions.
   *
   * <p>Normally, when the executor encounters lexer actions where
   * {@link LexerAction//isPositionDependent} returns {@code true}, it calls
   * {@link IntStream//seek} on the input {@link CharStream} to set the input
   * position to the <em>end</em> of the current token. This behavior provides
   * for efficient DFA representation of lexer actions which appear at the end
   * of a lexer rule, even when the lexer rule matches a variable number of
   * characters.</p>
   *
   * <p>Prior to traversing a match transition in the ATN, the current offset
   * from the token start index is assigned to all position-dependent lexer
   * actions which have not already been assigned a fixed offset. By storing
   * the offsets relative to the token start index, the DFA representation of
   * lexer actions which appear in the middle of tokens remains efficient due
   * to sharing among tokens of the same length, regardless of their absolute
   * position in the input stream.</p>
   *
   * <p>If the current executor already has offsets assigned to all
   * position-dependent lexer actions, the method returns {@code this}.</p>
   *
   * @param offset The current offset to assign to all position-dependent
   * lexer actions which do not already have offsets assigned.
   *
   * @return {LexerActionExecutor} A {@link LexerActionExecutor} which stores input stream offsets
   * for all position-dependent lexer actions.
   */
  fixOffsetBeforeMatch(offset3) {
    let updatedLexerActions = null;
    for (let i2 = 0; i2 < this.lexerActions.length; i2++) {
      if (this.lexerActions[i2].isPositionDependent && !(this.lexerActions[i2] instanceof LexerIndexedCustomAction)) {
        if (updatedLexerActions === null) {
          updatedLexerActions = this.lexerActions.concat([]);
        }
        updatedLexerActions[i2] = new LexerIndexedCustomAction(
          offset3,
          this.lexerActions[i2]
        );
      }
    }
    if (updatedLexerActions === null) {
      return this;
    } else {
      return new _LexerActionExecutor(updatedLexerActions);
    }
  }
  /**
   * Execute the actions encapsulated by this executor within the context of a
   * particular {@link Lexer}.
   *
   * <p>This method calls {@link IntStream//seek} to set the position of the
   * {@code input} {@link CharStream} prior to calling
   * {@link LexerAction//execute} on a position-dependent action. Before the
   * method returns, the input position will be restored to the same position
   * it was in when the method was invoked.</p>
   *
   * @param lexer The lexer instance.
   * @param input The input stream which is the source for the current token.
   * When this method is called, the current {@link IntStream//index} for
   * {@code input} should be the start of the following token, i.e. 1
   * character past the end of the current token.
   * @param startIndex The token start index. This value may be passed to
   * {@link IntStream//seek} to set the {@code input} position to the beginning
   * of the token.
   */
  execute(lexer, input, startIndex) {
    let requiresSeek = false;
    const stopIndex = input.index;
    try {
      for (let i2 = 0; i2 < this.lexerActions.length; i2++) {
        let lexerAction = this.lexerActions[i2];
        if (lexerAction instanceof LexerIndexedCustomAction) {
          const offset3 = lexerAction.offset;
          input.seek(startIndex + offset3);
          lexerAction = lexerAction.action;
          requiresSeek = startIndex + offset3 !== stopIndex;
        } else if (lexerAction.isPositionDependent) {
          input.seek(stopIndex);
          requiresSeek = false;
        }
        lexerAction.execute(lexer);
      }
    } finally {
      if (requiresSeek) {
        input.seek(stopIndex);
      }
    }
  }
  hashCode() {
    return this.cachedHashCode;
  }
  updateHashCode(hash4) {
    hash4.update(this.cachedHashCode);
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof _LexerActionExecutor)) {
      return false;
    } else if (this.cachedHashCode != other.cachedHashCode) {
      return false;
    } else if (this.lexerActions.length != other.lexerActions.length) {
      return false;
    } else {
      const numActions = this.lexerActions.length;
      for (let idx = 0; idx < numActions; ++idx) {
        if (!this.lexerActions[idx].equals(other.lexerActions[idx])) {
          return false;
        }
      }
      return true;
    }
  }
  /**
   * Creates a {@link LexerActionExecutor} which executes the actions for
   * the input {@code lexerActionExecutor} followed by a specified
   * {@code lexerAction}.
   *
   * @param lexerActionExecutor The executor for actions already traversed by
   * the lexer while matching a token within a particular
   * {@link LexerATNConfig}. If this is {@code null}, the method behaves as
   * though it were an empty executor.
   * @param lexerAction The lexer action to execute after the actions
   * specified in {@code lexerActionExecutor}.
   *
   * @return {LexerActionExecutor} A {@link LexerActionExecutor} for executing the combine actions
   * of {@code lexerActionExecutor} and {@code lexerAction}.
   */
  static append(lexerActionExecutor, lexerAction) {
    if (lexerActionExecutor === null) {
      return new _LexerActionExecutor([lexerAction]);
    }
    const lexerActions = lexerActionExecutor.lexerActions.concat([lexerAction]);
    return new _LexerActionExecutor(lexerActions);
  }
};

// node_modules/antlr4/src/antlr4/atn/LexerATNSimulator.js
function resetSimState(sim) {
  sim.index = -1;
  sim.line = 0;
  sim.column = -1;
  sim.dfaState = null;
}
var SimState = class {
  constructor() {
    resetSimState(this);
  }
  reset() {
    resetSimState(this);
  }
};
var LexerATNSimulator = class _LexerATNSimulator extends ATNSimulator {
  /**
   * When we hit an accept state in either the DFA or the ATN, we
   * have to notify the character stream to start buffering characters
   * via {@link IntStream//mark} and record the current state. The current sim state
   * includes the current index into the input, the current line,
   * and current character position in that line. Note that the Lexer is
   * tracking the starting line and characterization of the token. These
   * variables track the "state" of the simulator when it hits an accept state.
   *
   * <p>We track these variables separately for the DFA and ATN simulation
   * because the DFA simulation often has to fail over to the ATN
   * simulation. If the ATN simulation fails, we need the DFA to fall
   * back to its previously accepted state, if any. If the ATN succeeds,
   * then the ATN does the accept and the DFA simulator that invoked it
   * can simply return the predicted token type.</p>
   */
  constructor(recog, atn3, decisionToDFA, sharedContextCache2) {
    super(atn3, sharedContextCache2);
    this.decisionToDFA = decisionToDFA;
    this.recog = recog;
    this.startIndex = -1;
    this.line = 1;
    this.column = 0;
    this.mode = Lexer.DEFAULT_MODE;
    this.prevAccept = new SimState();
  }
  copyState(simulator) {
    this.column = simulator.column;
    this.line = simulator.line;
    this.mode = simulator.mode;
    this.startIndex = simulator.startIndex;
  }
  match(input, mode) {
    this.mode = mode;
    const mark = input.mark();
    try {
      this.startIndex = input.index;
      this.prevAccept.reset();
      const dfa = this.decisionToDFA[mode];
      if (dfa.s0 === null) {
        return this.matchATN(input);
      } else {
        return this.execATN(input, dfa.s0);
      }
    } finally {
      input.release(mark);
    }
  }
  reset() {
    this.prevAccept.reset();
    this.startIndex = -1;
    this.line = 1;
    this.column = 0;
    this.mode = Lexer.DEFAULT_MODE;
  }
  matchATN(input) {
    const startState = this.atn.modeToStartState[this.mode];
    if (_LexerATNSimulator.debug) {
      console.log("matchATN mode " + this.mode + " start: " + startState);
    }
    const old_mode = this.mode;
    const s0_closure = this.computeStartState(input, startState);
    const suppressEdge = s0_closure.hasSemanticContext;
    s0_closure.hasSemanticContext = false;
    const next2 = this.addDFAState(s0_closure);
    if (!suppressEdge) {
      this.decisionToDFA[this.mode].s0 = next2;
    }
    const predict = this.execATN(input, next2);
    if (_LexerATNSimulator.debug) {
      console.log("DFA after matchATN: " + this.decisionToDFA[old_mode].toLexerString());
    }
    return predict;
  }
  execATN(input, ds0) {
    if (_LexerATNSimulator.debug) {
      console.log("start state closure=" + ds0.configs);
    }
    if (ds0.isAcceptState) {
      this.captureSimState(this.prevAccept, input, ds0);
    }
    let t4 = input.LA(1);
    let s3 = ds0;
    for (; ; ) {
      if (_LexerATNSimulator.debug) {
        console.log("execATN loop starting closure: " + s3.configs);
      }
      let target = this.getExistingTargetState(s3, t4);
      if (target === null) {
        target = this.computeTargetState(input, s3, t4);
      }
      if (target === ATNSimulator.ERROR) {
        break;
      }
      if (t4 !== Token.EOF) {
        this.consume(input);
      }
      if (target.isAcceptState) {
        this.captureSimState(this.prevAccept, input, target);
        if (t4 === Token.EOF) {
          break;
        }
      }
      t4 = input.LA(1);
      s3 = target;
    }
    return this.failOrAccept(this.prevAccept, input, s3.configs, t4);
  }
  /**
   * Get an existing target state for an edge in the DFA. If the target state
   * for the edge has not yet been computed or is otherwise not available,
   * this method returns {@code null}.
   *
   * @param s The current DFA state
   * @param t The next input symbol
   * @return The existing target DFA state for the given input symbol
   * {@code t}, or {@code null} if the target state for this edge is not
   * already cached
   */
  getExistingTargetState(s3, t4) {
    if (s3.edges === null || t4 < _LexerATNSimulator.MIN_DFA_EDGE || t4 > _LexerATNSimulator.MAX_DFA_EDGE) {
      return null;
    }
    let target = s3.edges[t4 - _LexerATNSimulator.MIN_DFA_EDGE];
    if (target === void 0) {
      target = null;
    }
    if (_LexerATNSimulator.debug && target !== null) {
      console.log("reuse state " + s3.stateNumber + " edge to " + target.stateNumber);
    }
    return target;
  }
  /**
   * Compute a target state for an edge in the DFA, and attempt to add the
   * computed state and corresponding edge to the DFA.
   *
   * @param input The input stream
   * @param s The current DFA state
   * @param t The next input symbol
   *
   * @return The computed target DFA state for the given input symbol
   * {@code t}. If {@code t} does not lead to a valid DFA state, this method
   * returns {@link //ERROR}.
   */
  computeTargetState(input, s3, t4) {
    const reach = new OrderedATNConfigSet();
    this.getReachableConfigSet(input, s3.configs, reach, t4);
    if (reach.items.length === 0) {
      if (!reach.hasSemanticContext) {
        this.addDFAEdge(s3, t4, ATNSimulator.ERROR);
      }
      return ATNSimulator.ERROR;
    }
    return this.addDFAEdge(s3, t4, null, reach);
  }
  failOrAccept(prevAccept, input, reach, t4) {
    if (this.prevAccept.dfaState !== null) {
      const lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;
      this.accept(
        input,
        lexerActionExecutor,
        this.startIndex,
        prevAccept.index,
        prevAccept.line,
        prevAccept.column
      );
      return prevAccept.dfaState.prediction;
    } else {
      if (t4 === Token.EOF && input.index === this.startIndex) {
        return Token.EOF;
      }
      throw new LexerNoViableAltException(this.recog, input, this.startIndex, reach);
    }
  }
  /**
   * Given a starting configuration set, figure out all ATN configurations
   * we can reach upon input {@code t}. Parameter {@code reach} is a return
   * parameter.
   */
  getReachableConfigSet(input, closure, reach, t4) {
    let skipAlt = ATN.INVALID_ALT_NUMBER;
    for (let i2 = 0; i2 < closure.items.length; i2++) {
      const cfg = closure.items[i2];
      const currentAltReachedAcceptState = cfg.alt === skipAlt;
      if (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) {
        continue;
      }
      if (_LexerATNSimulator.debug) {
        console.log("testing %s at %s\n", this.getTokenName(t4), cfg.toString(this.recog, true));
      }
      for (let j = 0; j < cfg.state.transitions.length; j++) {
        const trans = cfg.state.transitions[j];
        const target = this.getReachableTarget(trans, t4);
        if (target !== null) {
          let lexerActionExecutor = cfg.lexerActionExecutor;
          if (lexerActionExecutor !== null) {
            lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);
          }
          const treatEofAsEpsilon = t4 === Token.EOF;
          const config2 = new LexerATNConfig({ state: target, lexerActionExecutor }, cfg);
          if (this.closure(
            input,
            config2,
            reach,
            currentAltReachedAcceptState,
            true,
            treatEofAsEpsilon
          )) {
            skipAlt = cfg.alt;
          }
        }
      }
    }
  }
  accept(input, lexerActionExecutor, startIndex, index4, line2, charPos) {
    if (_LexerATNSimulator.debug) {
      console.log("ACTION %s\n", lexerActionExecutor);
    }
    input.seek(index4);
    this.line = line2;
    this.column = charPos;
    if (lexerActionExecutor !== null && this.recog !== null) {
      lexerActionExecutor.execute(this.recog, input, startIndex);
    }
  }
  getReachableTarget(trans, t4) {
    if (trans.matches(t4, 0, Lexer.MAX_CHAR_VALUE)) {
      return trans.target;
    } else {
      return null;
    }
  }
  computeStartState(input, p) {
    const initialContext = PredictionContext.EMPTY;
    const configs = new OrderedATNConfigSet();
    for (let i2 = 0; i2 < p.transitions.length; i2++) {
      const target = p.transitions[i2].target;
      const cfg = new LexerATNConfig({ state: target, alt: i2 + 1, context: initialContext }, null);
      this.closure(input, cfg, configs, false, false, false);
    }
    return configs;
  }
  /**
   * Since the alternatives within any lexer decision are ordered by
   * preference, this method stops pursuing the closure as soon as an accept
   * state is reached. After the first accept state is reached by depth-first
   * search from {@code config}, all other (potentially reachable) states for
   * this rule would have a lower priority.
   *
   * @return {Boolean} {@code true} if an accept state is reached, otherwise
   * {@code false}.
   */
  closure(input, config2, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {
    let cfg = null;
    if (_LexerATNSimulator.debug) {
      console.log("closure(" + config2.toString(this.recog, true) + ")");
    }
    if (config2.state instanceof RuleStopState) {
      if (_LexerATNSimulator.debug) {
        if (this.recog !== null) {
          console.log("closure at %s rule stop %s\n", this.recog.ruleNames[config2.state.ruleIndex], config2);
        } else {
          console.log("closure at rule stop %s\n", config2);
        }
      }
      if (config2.context === null || config2.context.hasEmptyPath()) {
        if (config2.context === null || config2.context.isEmpty()) {
          configs.add(config2);
          return true;
        } else {
          configs.add(new LexerATNConfig({ state: config2.state, context: PredictionContext.EMPTY }, config2));
          currentAltReachedAcceptState = true;
        }
      }
      if (config2.context !== null && !config2.context.isEmpty()) {
        for (let i2 = 0; i2 < config2.context.length; i2++) {
          if (config2.context.getReturnState(i2) !== PredictionContext.EMPTY_RETURN_STATE) {
            const newContext = config2.context.getParent(i2);
            const returnState = this.atn.states[config2.context.getReturnState(i2)];
            cfg = new LexerATNConfig({ state: returnState, context: newContext }, config2);
            currentAltReachedAcceptState = this.closure(
              input,
              cfg,
              configs,
              currentAltReachedAcceptState,
              speculative,
              treatEofAsEpsilon
            );
          }
        }
      }
      return currentAltReachedAcceptState;
    }
    if (!config2.state.epsilonOnlyTransitions) {
      if (!currentAltReachedAcceptState || !config2.passedThroughNonGreedyDecision) {
        configs.add(config2);
      }
    }
    for (let j = 0; j < config2.state.transitions.length; j++) {
      const trans = config2.state.transitions[j];
      cfg = this.getEpsilonTarget(input, config2, trans, configs, speculative, treatEofAsEpsilon);
      if (cfg !== null) {
        currentAltReachedAcceptState = this.closure(
          input,
          cfg,
          configs,
          currentAltReachedAcceptState,
          speculative,
          treatEofAsEpsilon
        );
      }
    }
    return currentAltReachedAcceptState;
  }
  // side-effect: can alter configs.hasSemanticContext
  getEpsilonTarget(input, config2, trans, configs, speculative, treatEofAsEpsilon) {
    let cfg = null;
    if (trans.serializationType === Transition.RULE) {
      const newContext = SingletonPredictionContext.create(config2.context, trans.followState.stateNumber);
      cfg = new LexerATNConfig({ state: trans.target, context: newContext }, config2);
    } else if (trans.serializationType === Transition.PRECEDENCE) {
      throw "Precedence predicates are not supported in lexers.";
    } else if (trans.serializationType === Transition.PREDICATE) {
      if (_LexerATNSimulator.debug) {
        console.log("EVAL rule " + trans.ruleIndex + ":" + trans.predIndex);
      }
      configs.hasSemanticContext = true;
      if (this.evaluatePredicate(input, trans.ruleIndex, trans.predIndex, speculative)) {
        cfg = new LexerATNConfig({ state: trans.target }, config2);
      }
    } else if (trans.serializationType === Transition.ACTION) {
      if (config2.context === null || config2.context.hasEmptyPath()) {
        const lexerActionExecutor = LexerActionExecutor.append(
          config2.lexerActionExecutor,
          this.atn.lexerActions[trans.actionIndex]
        );
        cfg = new LexerATNConfig({ state: trans.target, lexerActionExecutor }, config2);
      } else {
        cfg = new LexerATNConfig({ state: trans.target }, config2);
      }
    } else if (trans.serializationType === Transition.EPSILON) {
      cfg = new LexerATNConfig({ state: trans.target }, config2);
    } else if (trans.serializationType === Transition.ATOM || trans.serializationType === Transition.RANGE || trans.serializationType === Transition.SET) {
      if (treatEofAsEpsilon) {
        if (trans.matches(Token.EOF, 0, Lexer.MAX_CHAR_VALUE)) {
          cfg = new LexerATNConfig({ state: trans.target }, config2);
        }
      }
    }
    return cfg;
  }
  /**
   * Evaluate a predicate specified in the lexer.
   *
   * <p>If {@code speculative} is {@code true}, this method was called before
   * {@link //consume} for the matched character. This method should call
   * {@link //consume} before evaluating the predicate to ensure position
   * sensitive values, including {@link Lexer//getText}, {@link Lexer//getLine},
   * and {@link Lexer//getcolumn}, properly reflect the current
   * lexer state. This method should restore {@code input} and the simulator
   * to the original state before returning (i.e. undo the actions made by the
   * call to {@link //consume}.</p>
   *
   * @param input The input stream.
   * @param ruleIndex The rule containing the predicate.
   * @param predIndex The index of the predicate within the rule.
   * @param speculative {@code true} if the current index in {@code input} is
   * one character before the predicate's location.
   *
   * @return {@code true} if the specified predicate evaluates to
   * {@code true}.
   */
  evaluatePredicate(input, ruleIndex, predIndex, speculative) {
    if (this.recog === null) {
      return true;
    }
    if (!speculative) {
      return this.recog.sempred(null, ruleIndex, predIndex);
    }
    const savedcolumn = this.column;
    const savedLine = this.line;
    const index4 = input.index;
    const marker = input.mark();
    try {
      this.consume(input);
      return this.recog.sempred(null, ruleIndex, predIndex);
    } finally {
      this.column = savedcolumn;
      this.line = savedLine;
      input.seek(index4);
      input.release(marker);
    }
  }
  captureSimState(settings, input, dfaState) {
    settings.index = input.index;
    settings.line = this.line;
    settings.column = this.column;
    settings.dfaState = dfaState;
  }
  addDFAEdge(from_, tk, to, cfgs) {
    if (to === void 0) {
      to = null;
    }
    if (cfgs === void 0) {
      cfgs = null;
    }
    if (to === null && cfgs !== null) {
      const suppressEdge = cfgs.hasSemanticContext;
      cfgs.hasSemanticContext = false;
      to = this.addDFAState(cfgs);
      if (suppressEdge) {
        return to;
      }
    }
    if (tk < _LexerATNSimulator.MIN_DFA_EDGE || tk > _LexerATNSimulator.MAX_DFA_EDGE) {
      return to;
    }
    if (_LexerATNSimulator.debug) {
      console.log("EDGE " + from_ + " -> " + to + " upon " + tk);
    }
    if (from_.edges === null) {
      from_.edges = [];
    }
    from_.edges[tk - _LexerATNSimulator.MIN_DFA_EDGE] = to;
    return to;
  }
  /**
   * Add a new DFA state if there isn't one with this set of
   * configurations already. This method also detects the first
   * configuration containing an ATN rule stop state. Later, when
   * traversing the DFA, we will know which rule to accept.
   */
  addDFAState(configs) {
    const proposed = new DFAState(null, configs);
    let firstConfigWithRuleStopState = null;
    for (let i2 = 0; i2 < configs.items.length; i2++) {
      const cfg = configs.items[i2];
      if (cfg.state instanceof RuleStopState) {
        firstConfigWithRuleStopState = cfg;
        break;
      }
    }
    if (firstConfigWithRuleStopState !== null) {
      proposed.isAcceptState = true;
      proposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;
      proposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];
    }
    const dfa = this.decisionToDFA[this.mode];
    const existing = dfa.states.get(proposed);
    if (existing !== null) {
      return existing;
    }
    const newState = proposed;
    newState.stateNumber = dfa.states.length;
    configs.setReadonly(true);
    newState.configs = configs;
    dfa.states.add(newState);
    return newState;
  }
  getDFA(mode) {
    return this.decisionToDFA[mode];
  }
  // Get the text matched so far for the current token.
  getText(input) {
    return input.getText(this.startIndex, input.index - 1);
  }
  consume(input) {
    const curChar = input.LA(1);
    if (curChar === "\n".charCodeAt(0)) {
      this.line += 1;
      this.column = 0;
    } else {
      this.column += 1;
    }
    input.consume();
  }
  getTokenName(tt2) {
    if (tt2 === -1) {
      return "EOF";
    } else {
      return "'" + String.fromCharCode(tt2) + "'";
    }
  }
};
LexerATNSimulator.debug = false;
LexerATNSimulator.dfa_debug = false;
LexerATNSimulator.MIN_DFA_EDGE = 0;
LexerATNSimulator.MAX_DFA_EDGE = 127;

// node_modules/antlr4/src/antlr4/dfa/PredPrediction.js
var PredPrediction = class {
  constructor(pred, alt) {
    this.alt = alt;
    this.pred = pred;
  }
  toString() {
    return "(" + this.pred + ", " + this.alt + ")";
  }
};

// node_modules/antlr4/src/antlr4/misc/AltDict.js
var AltDict = class {
  constructor() {
    this.data = {};
  }
  get(key) {
    return this.data["k-" + key] || null;
  }
  set(key, value) {
    this.data["k-" + key] = value;
  }
  values() {
    return Object.keys(this.data).filter((key) => key.startsWith("k-")).map((key) => this.data[key], this);
  }
};

// node_modules/antlr4/src/antlr4/atn/PredictionMode.js
var PredictionMode = {
  /**
   * The SLL(*) prediction mode. This prediction mode ignores the current
   * parser context when making predictions. This is the fastest prediction
   * mode, and provides correct results for many grammars. This prediction
   * mode is more powerful than the prediction mode provided by ANTLR 3, but
   * may result in syntax errors for grammar and input combinations which are
   * not SLL.
   *
   * <p>
   * When using this prediction mode, the parser will either return a correct
   * parse tree (i.e. the same parse tree that would be returned with the
   * {@link //LL} prediction mode), or it will report a syntax error. If a
   * syntax error is encountered when using the {@link //SLL} prediction mode,
   * it may be due to either an actual syntax error in the input or indicate
   * that the particular combination of grammar and input requires the more
   * powerful {@link //LL} prediction abilities to complete successfully.</p>
   *
   * <p>
   * This prediction mode does not provide any guarantees for prediction
   * behavior for syntactically-incorrect inputs.</p>
   */
  SLL: 0,
  /**
   * The LL(*) prediction mode. This prediction mode allows the current parser
   * context to be used for resolving SLL conflicts that occur during
   * prediction. This is the fastest prediction mode that guarantees correct
   * parse results for all combinations of grammars with syntactically correct
   * inputs.
   *
   * <p>
   * When using this prediction mode, the parser will make correct decisions
   * for all syntactically-correct grammar and input combinations. However, in
   * cases where the grammar is truly ambiguous this prediction mode might not
   * report a precise answer for <em>exactly which</em> alternatives are
   * ambiguous.</p>
   *
   * <p>
   * This prediction mode does not provide any guarantees for prediction
   * behavior for syntactically-incorrect inputs.</p>
   */
  LL: 1,
  /**
   *
   * The LL(*) prediction mode with exact ambiguity detection. In addition to
   * the correctness guarantees provided by the {@link //LL} prediction mode,
   * this prediction mode instructs the prediction algorithm to determine the
   * complete and exact set of ambiguous alternatives for every ambiguous
   * decision encountered while parsing.
   *
   * <p>
   * This prediction mode may be used for diagnosing ambiguities during
   * grammar development. Due to the performance overhead of calculating sets
   * of ambiguous alternatives, this prediction mode should be avoided when
   * the exact results are not necessary.</p>
   *
   * <p>
   * This prediction mode does not provide any guarantees for prediction
   * behavior for syntactically-incorrect inputs.</p>
   */
  LL_EXACT_AMBIG_DETECTION: 2,
  /**
   *
   * Computes the SLL prediction termination condition.
   *
   * <p>
   * This method computes the SLL prediction termination condition for both of
   * the following cases.</p>
   *
   * <ul>
   * <li>The usual SLL+LL fallback upon SLL conflict</li>
   * <li>Pure SLL without LL fallback</li>
   * </ul>
   *
   * <p><strong>COMBINED SLL+LL PARSING</strong></p>
   *
   * <p>When LL-fallback is enabled upon SLL conflict, correct predictions are
   * ensured regardless of how the termination condition is computed by this
   * method. Due to the substantially higher cost of LL prediction, the
   * prediction should only fall back to LL when the additional lookahead
   * cannot lead to a unique SLL prediction.</p>
   *
   * <p>Assuming combined SLL+LL parsing, an SLL configuration set with only
   * conflicting subsets should fall back to full LL, even if the
   * configuration sets don't resolve to the same alternative (e.g.
   * {@code {1,2}} and {@code {3,4}}. If there is at least one non-conflicting
   * configuration, SLL could continue with the hopes that more lookahead will
   * resolve via one of those non-conflicting configurations.</p>
   *
   * <p>Here's the prediction termination rule them: SLL (for SLL+LL parsing)
   * stops when it sees only conflicting configuration subsets. In contrast,
   * full LL keeps going when there is uncertainty.</p>
   *
   * <p><strong>HEURISTIC</strong></p>
   *
   * <p>As a heuristic, we stop prediction when we see any conflicting subset
   * unless we see a state that only has one alternative associated with it.
   * The single-alt-state thing lets prediction continue upon rules like
   * (otherwise, it would admit defeat too soon):</p>
   *
   * <p>{@code [12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;}</p>
   *
   * <p>When the ATN simulation reaches the state before {@code ';'}, it has a
   * DFA state that looks like: {@code [12|1|[], 6|2|[], 12|2|[]]}. Naturally
   * {@code 12|1|[]} and {@code 12|2|[]} conflict, but we cannot stop
   * processing this node because alternative to has another way to continue,
   * via {@code [6|2|[]]}.</p>
   *
   * <p>It also let's us continue for this rule:</p>
   *
   * <p>{@code [1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;}</p>
   *
   * <p>After matching input A, we reach the stop state for rule A, state 1.
   * State 8 is the state right before B. Clearly alternatives 1 and 2
   * conflict and no amount of further lookahead will separate the two.
   * However, alternative 3 will be able to continue and so we do not stop
   * working on this state. In the previous example, we're concerned with
   * states associated with the conflicting alternatives. Here alt 3 is not
   * associated with the conflicting configs, but since we can continue
   * looking for input reasonably, don't declare the state done.</p>
   *
   * <p><strong>PURE SLL PARSING</strong></p>
   *
   * <p>To handle pure SLL parsing, all we have to do is make sure that we
   * combine stack contexts for configurations that differ only by semantic
   * predicate. From there, we can do the usual SLL termination heuristic.</p>
   *
   * <p><strong>PREDICATES IN SLL+LL PARSING</strong></p>
   *
   * <p>SLL decisions don't evaluate predicates until after they reach DFA stop
   * states because they need to create the DFA cache that works in all
   * semantic situations. In contrast, full LL evaluates predicates collected
   * during start state computation so it can ignore predicates thereafter.
   * This means that SLL termination detection can totally ignore semantic
   * predicates.</p>
   *
   * <p>Implementation-wise, {@link ATNConfigSet} combines stack contexts but not
   * semantic predicate contexts so we might see two configurations like the
   * following.</p>
   *
   * <p>{@code (s, 1, x, {}), (s, 1, x', {p})}</p>
   *
   * <p>Before testing these configurations against others, we have to merge
   * {@code x} and {@code x'} (without modifying the existing configurations).
   * For example, we test {@code (x+x')==x''} when looking for conflicts in
   * the following configurations.</p>
   *
   * <p>{@code (s, 1, x, {}), (s, 1, x', {p}), (s, 2, x'', {})}</p>
   *
   * <p>If the configuration set has predicates (as indicated by
   * {@link ATNConfigSet//hasSemanticContext}), this algorithm makes a copy of
   * the configurations to strip out all of the predicates so that a standard
   * {@link ATNConfigSet} will merge everything ignoring predicates.</p>
   */
  hasSLLConflictTerminatingPrediction: function(mode, configs) {
    if (PredictionMode.allConfigsInRuleStopStates(configs)) {
      return true;
    }
    if (mode === PredictionMode.SLL) {
      if (configs.hasSemanticContext) {
        const dup = new ATNConfigSet();
        for (let i2 = 0; i2 < configs.items.length; i2++) {
          let c2 = configs.items[i2];
          c2 = new ATNConfig({ semanticContext: SemanticContext.NONE }, c2);
          dup.add(c2);
        }
        configs = dup;
      }
    }
    const altsets = PredictionMode.getConflictingAltSubsets(configs);
    return PredictionMode.hasConflictingAltSet(altsets) && !PredictionMode.hasStateAssociatedWithOneAlt(configs);
  },
  /**
   * Checks if any configuration in {@code configs} is in a
   * {@link RuleStopState}. Configurations meeting this condition have reached
   * the end of the decision rule (local context) or end of start rule (full
   * context).
   *
   * @param configs the configuration set to test
   * @return {@code true} if any configuration in {@code configs} is in a
   * {@link RuleStopState}, otherwise {@code false}
   */
  hasConfigInRuleStopState: function(configs) {
    for (let i2 = 0; i2 < configs.items.length; i2++) {
      const c2 = configs.items[i2];
      if (c2.state instanceof RuleStopState) {
        return true;
      }
    }
    return false;
  },
  /**
   * Checks if all configurations in {@code configs} are in a
   * {@link RuleStopState}. Configurations meeting this condition have reached
   * the end of the decision rule (local context) or end of start rule (full
   * context).
   *
   * @param configs the configuration set to test
   * @return {@code true} if all configurations in {@code configs} are in a
   * {@link RuleStopState}, otherwise {@code false}
   */
  allConfigsInRuleStopStates: function(configs) {
    for (let i2 = 0; i2 < configs.items.length; i2++) {
      const c2 = configs.items[i2];
      if (!(c2.state instanceof RuleStopState)) {
        return false;
      }
    }
    return true;
  },
  /**
   *
   * Full LL prediction termination.
   *
   * <p>Can we stop looking ahead during ATN simulation or is there some
   * uncertainty as to which alternative we will ultimately pick, after
   * consuming more input? Even if there are partial conflicts, we might know
   * that everything is going to resolve to the same minimum alternative. That
   * means we can stop since no more lookahead will change that fact. On the
   * other hand, there might be multiple conflicts that resolve to different
   * minimums. That means we need more look ahead to decide which of those
   * alternatives we should predict.</p>
   *
   * <p>The basic idea is to split the set of configurations {@code C}, into
   * conflicting subsets {@code (s, _, ctx, _)} and singleton subsets with
   * non-conflicting configurations. Two configurations conflict if they have
   * identical {@link ATNConfig//state} and {@link ATNConfig//context} values
   * but different {@link ATNConfig//alt} value, e.g. {@code (s, i, ctx, _)}
   * and {@code (s, j, ctx, _)} for {@code i!=j}.</p>
   *
   * <p>Reduce these configuration subsets to the set of possible alternatives.
   * You can compute the alternative subsets in one pass as follows:</p>
   *
   * <p>{@code A_s,ctx = {i | (s, i, ctx, _)}} for each configuration in
   * {@code C} holding {@code s} and {@code ctx} fixed.</p>
   *
   * <p>Or in pseudo-code, for each configuration {@code c} in {@code C}:</p>
   *
   * <pre>
   * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not
   * alt and not pred
   * </pre>
   *
   * <p>The values in {@code map} are the set of {@code A_s,ctx} sets.</p>
   *
   * <p>If {@code |A_s,ctx|=1} then there is no conflict associated with
   * {@code s} and {@code ctx}.</p>
   *
   * <p>Reduce the subsets to singletons by choosing a minimum of each subset. If
   * the union of these alternative subsets is a singleton, then no amount of
   * more lookahead will help us. We will always pick that alternative. If,
   * however, there is more than one alternative, then we are uncertain which
   * alternative to predict and must continue looking for resolution. We may
   * or may not discover an ambiguity in the future, even if there are no
   * conflicting subsets this round.</p>
   *
   * <p>The biggest sin is to terminate early because it means we've made a
   * decision but were uncertain as to the eventual outcome. We haven't used
   * enough lookahead. On the other hand, announcing a conflict too late is no
   * big deal; you will still have the conflict. It's just inefficient. It
   * might even look until the end of file.</p>
   *
   * <p>No special consideration for semantic predicates is required because
   * predicates are evaluated on-the-fly for full LL prediction, ensuring that
   * no configuration contains a semantic context during the termination
   * check.</p>
   *
   * <p><strong>CONFLICTING CONFIGS</strong></p>
   *
   * <p>Two configurations {@code (s, i, x)} and {@code (s, j, x')}, conflict
   * when {@code i!=j} but {@code x=x'}. Because we merge all
   * {@code (s, i, _)} configurations together, that means that there are at
   * most {@code n} configurations associated with state {@code s} for
   * {@code n} possible alternatives in the decision. The merged stacks
   * complicate the comparison of configuration contexts {@code x} and
   * {@code x'}. Sam checks to see if one is a subset of the other by calling
   * merge and checking to see if the merged result is either {@code x} or
   * {@code x'}. If the {@code x} associated with lowest alternative {@code i}
   * is the superset, then {@code i} is the only possible prediction since the
   * others resolve to {@code min(i)} as well. However, if {@code x} is
   * associated with {@code j>i} then at least one stack configuration for
   * {@code j} is not in conflict with alternative {@code i}. The algorithm
   * should keep going, looking for more lookahead due to the uncertainty.</p>
   *
   * <p>For simplicity, I'm doing a equality check between {@code x} and
   * {@code x'} that lets the algorithm continue to consume lookahead longer
   * than necessary. The reason I like the equality is of course the
   * simplicity but also because that is the test you need to detect the
   * alternatives that are actually in conflict.</p>
   *
   * <p><strong>CONTINUE/STOP RULE</strong></p>
   *
   * <p>Continue if union of resolved alternative sets from non-conflicting and
   * conflicting alternative subsets has more than one alternative. We are
   * uncertain about which alternative to predict.</p>
   *
   * <p>The complete set of alternatives, {@code [i for (_,i,_)]}, tells us which
   * alternatives are still in the running for the amount of input we've
   * consumed at this point. The conflicting sets let us to strip away
   * configurations that won't lead to more states because we resolve
   * conflicts to the configuration with a minimum alternate for the
   * conflicting set.</p>
   *
   * <p><strong>CASES</strong></p>
   *
   * <ul>
   *
   * <li>no conflicts and more than 1 alternative in set =&gt; continue</li>
   *
   * <li> {@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s, 3, z)},
   * {@code (s', 1, y)}, {@code (s', 2, y)} yields non-conflicting set
   * {@code {3}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =
   * {@code {1,3}} =&gt; continue
   * </li>
   *
   * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},
   * {@code (s', 2, y)}, {@code (s'', 1, z)} yields non-conflicting set
   * {@code {1}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =
   * {@code {1}} =&gt; stop and predict 1</li>
   *
   * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},
   * {@code (s', 2, y)} yields conflicting, reduced sets {@code {1}} U
   * {@code {1}} = {@code {1}} =&gt; stop and predict 1, can announce
   * ambiguity {@code {1,2}}</li>
   *
   * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 2, y)},
   * {@code (s', 3, y)} yields conflicting, reduced sets {@code {1}} U
   * {@code {2}} = {@code {1,2}} =&gt; continue</li>
   *
   * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 3, y)},
   * {@code (s', 4, y)} yields conflicting, reduced sets {@code {1}} U
   * {@code {3}} = {@code {1,3}} =&gt; continue</li>
   *
   * </ul>
   *
   * <p><strong>EXACT AMBIGUITY DETECTION</strong></p>
   *
   * <p>If all states report the same conflicting set of alternatives, then we
   * know we have the exact ambiguity set.</p>
   *
   * <p><code>|A_<em>i</em>|&gt;1</code> and
   * <code>A_<em>i</em> = A_<em>j</em></code> for all <em>i</em>, <em>j</em>.</p>
   *
   * <p>In other words, we continue examining lookahead until all {@code A_i}
   * have more than one alternative and all {@code A_i} are the same. If
   * {@code A={{1,2}, {1,3}}}, then regular LL prediction would terminate
   * because the resolved set is {@code {1}}. To determine what the real
   * ambiguity is, we have to know whether the ambiguity is between one and
   * two or one and three so we keep going. We can only stop prediction when
   * we need exact ambiguity detection when the sets look like
   * {@code A={{1,2}}} or {@code {{1,2},{1,2}}}, etc...</p>
   */
  resolvesToJustOneViableAlt: function(altsets) {
    return PredictionMode.getSingleViableAlt(altsets);
  },
  /**
   * Determines if every alternative subset in {@code altsets} contains more
   * than one alternative.
   *
   * @param altsets a collection of alternative subsets
   * @return {@code true} if every {@link BitSet} in {@code altsets} has
   * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}
   */
  allSubsetsConflict: function(altsets) {
    return !PredictionMode.hasNonConflictingAltSet(altsets);
  },
  /**
   * Determines if any single alternative subset in {@code altsets} contains
   * exactly one alternative.
   *
   * @param altsets a collection of alternative subsets
   * @return {@code true} if {@code altsets} contains a {@link BitSet} with
   * {@link BitSet//cardinality cardinality} 1, otherwise {@code false}
   */
  hasNonConflictingAltSet: function(altsets) {
    for (let i2 = 0; i2 < altsets.length; i2++) {
      const alts = altsets[i2];
      if (alts.length === 1) {
        return true;
      }
    }
    return false;
  },
  /**
   * Determines if any single alternative subset in {@code altsets} contains
   * more than one alternative.
   *
   * @param altsets a collection of alternative subsets
   * @return {@code true} if {@code altsets} contains a {@link BitSet} with
   * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}
   */
  hasConflictingAltSet: function(altsets) {
    for (let i2 = 0; i2 < altsets.length; i2++) {
      const alts = altsets[i2];
      if (alts.length > 1) {
        return true;
      }
    }
    return false;
  },
  /**
   * Determines if every alternative subset in {@code altsets} is equivalent.
   *
   * @param altsets a collection of alternative subsets
   * @return {@code true} if every member of {@code altsets} is equal to the
   * others, otherwise {@code false}
   */
  allSubsetsEqual: function(altsets) {
    let first = null;
    for (let i2 = 0; i2 < altsets.length; i2++) {
      const alts = altsets[i2];
      if (first === null) {
        first = alts;
      } else if (alts !== first) {
        return false;
      }
    }
    return true;
  },
  /**
   * Returns the unique alternative predicted by all alternative subsets in
   * {@code altsets}. If no such alternative exists, this method returns
   * {@link ATN//INVALID_ALT_NUMBER}.
   *
   * @param altsets a collection of alternative subsets
   */
  getUniqueAlt: function(altsets) {
    const all = PredictionMode.getAlts(altsets);
    if (all.length === 1) {
      return all.minValue();
    } else {
      return ATN.INVALID_ALT_NUMBER;
    }
  },
  /**
   * Gets the complete set of represented alternatives for a collection of
   * alternative subsets. This method returns the union of each {@link BitSet}
   * in {@code altsets}.
   *
   * @param altsets a collection of alternative subsets
   * @return the set of represented alternatives in {@code altsets}
   */
  getAlts: function(altsets) {
    const all = new BitSet();
    altsets.map(function(alts) {
      all.or(alts);
    });
    return all;
  },
  /**
   * This function gets the conflicting alt subsets from a configuration set.
   * For each configuration {@code c} in {@code configs}:
   *
   * <pre>
   * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not
   * alt and not pred
   * </pre>
   */
  getConflictingAltSubsets: function(configs) {
    const configToAlts = new HashMap();
    configToAlts.hashFunction = function(cfg) {
      HashCode.hashStuff(cfg.state.stateNumber, cfg.context);
    };
    configToAlts.equalsFunction = function(c1, c2) {
      return c1.state.stateNumber === c2.state.stateNumber && c1.context.equals(c2.context);
    };
    configs.items.map(function(cfg) {
      let alts = configToAlts.get(cfg);
      if (alts === null) {
        alts = new BitSet();
        configToAlts.set(cfg, alts);
      }
      alts.add(cfg.alt);
    });
    return configToAlts.getValues();
  },
  /**
   * Get a map from state to alt subset from a configuration set. For each
   * configuration {@code c} in {@code configs}:
   *
   * <pre>
   * map[c.{@link ATNConfig//state state}] U= c.{@link ATNConfig//alt alt}
   * </pre>
   */
  getStateToAltMap: function(configs) {
    const m3 = new AltDict();
    configs.items.map(function(c2) {
      let alts = m3.get(c2.state);
      if (alts === null) {
        alts = new BitSet();
        m3.set(c2.state, alts);
      }
      alts.add(c2.alt);
    });
    return m3;
  },
  hasStateAssociatedWithOneAlt: function(configs) {
    const values = PredictionMode.getStateToAltMap(configs).values();
    for (let i2 = 0; i2 < values.length; i2++) {
      if (values[i2].length === 1) {
        return true;
      }
    }
    return false;
  },
  getSingleViableAlt: function(altsets) {
    let result = null;
    for (let i2 = 0; i2 < altsets.length; i2++) {
      const alts = altsets[i2];
      const minAlt = alts.minValue();
      if (result === null) {
        result = minAlt;
      } else if (result !== minAlt) {
        return ATN.INVALID_ALT_NUMBER;
      }
    }
    return result;
  }
};
var PredictionMode_default = PredictionMode;

// node_modules/antlr4/src/antlr4/error/NoViableAltException.js
var NoViableAltException = class extends RecognitionException {
  constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {
    ctx = ctx || recognizer._ctx;
    offendingToken = offendingToken || recognizer.getCurrentToken();
    startToken = startToken || recognizer.getCurrentToken();
    input = input || recognizer.getInputStream();
    super({ message: "", recognizer, input, ctx });
    this.deadEndConfigs = deadEndConfigs;
    this.startToken = startToken;
    this.offendingToken = offendingToken;
  }
};

// node_modules/antlr4/src/antlr4/utils/DoubleDict.js
var DoubleDict = class {
  constructor(defaultMapCtor) {
    this.defaultMapCtor = defaultMapCtor || HashMap;
    this.cacheMap = new this.defaultMapCtor();
  }
  get(a3, b2) {
    const d3 = this.cacheMap.get(a3) || null;
    return d3 === null ? null : d3.get(b2) || null;
  }
  set(a3, b2, o) {
    let d3 = this.cacheMap.get(a3) || null;
    if (d3 === null) {
      d3 = new this.defaultMapCtor();
      this.cacheMap.set(a3, d3);
    }
    d3.set(b2, o);
  }
};

// node_modules/antlr4/src/antlr4/atn/ParserATNSimulator.js
var ParserATNSimulator = class extends ATNSimulator {
  constructor(parser, atn3, decisionToDFA, sharedContextCache2) {
    super(atn3, sharedContextCache2);
    this.parser = parser;
    this.decisionToDFA = decisionToDFA;
    this.predictionMode = PredictionMode_default.LL;
    this._input = null;
    this._startIndex = 0;
    this._outerContext = null;
    this._dfa = null;
    this.mergeCache = null;
    this.debug = false;
    this.debug_closure = false;
    this.debug_add = false;
    this.debug_list_atn_decisions = false;
    this.dfa_debug = false;
    this.retry_debug = false;
  }
  reset() {
  }
  adaptivePredict(input, decision, outerContext) {
    if (this.debug || this.debug_list_atn_decisions) {
      console.log("adaptivePredict decision " + decision + " exec LA(1)==" + this.getLookaheadName(input) + " line " + input.LT(1).line + ":" + input.LT(1).column);
    }
    this._input = input;
    this._startIndex = input.index;
    this._outerContext = outerContext;
    const dfa = this.decisionToDFA[decision];
    this._dfa = dfa;
    const m3 = input.mark();
    const index4 = input.index;
    try {
      let s0;
      if (dfa.precedenceDfa) {
        s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());
      } else {
        s0 = dfa.s0;
      }
      if (s0 === null) {
        if (outerContext === null) {
          outerContext = RuleContext.EMPTY;
        }
        if (this.debug || this.debug_list_atn_decisions) {
          console.log("predictATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this.parser.ruleNames));
        }
        const fullCtx = false;
        let s0_closure = this.computeStartState(dfa.atnStartState, RuleContext.EMPTY, fullCtx);
        if (dfa.precedenceDfa) {
          dfa.s0.configs = s0_closure;
          s0_closure = this.applyPrecedenceFilter(s0_closure);
          s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));
          dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);
        } else {
          s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));
          dfa.s0 = s0;
        }
      }
      const alt = this.execATN(dfa, s0, input, index4, outerContext);
      if (this.debug) {
        console.log("DFA after predictATN: " + dfa.toString(this.parser.literalNames, this.parser.symbolicNames));
      }
      return alt;
    } finally {
      this._dfa = null;
      this.mergeCache = null;
      input.seek(index4);
      input.release(m3);
    }
  }
  /**
   * Performs ATN simulation to compute a predicted alternative based
   *  upon the remaining input, but also updates the DFA cache to avoid
   *  having to traverse the ATN again for the same input sequence.
   *
   * There are some key conditions we're looking for after computing a new
   * set of ATN configs (proposed DFA state):
   *       if the set is empty, there is no viable alternative for current symbol
   *       does the state uniquely predict an alternative?
   *       does the state have a conflict that would prevent us from
   *         putting it on the work list?
   *
   * We also have some key operations to do:
   *       add an edge from previous DFA state to potentially new DFA state, D,
   *         upon current symbol but only if adding to work list, which means in all
   *         cases except no viable alternative (and possibly non-greedy decisions?)
   *       collecting predicates and adding semantic context to DFA accept states
   *       adding rule context to context-sensitive DFA accept states
   *       consuming an input symbol
   *       reporting a conflict
   *       reporting an ambiguity
   *       reporting a context sensitivity
   *       reporting insufficient predicates
   *
   * cover these cases:
   *    dead end
   *    single alt
   *    single alt + preds
   *    conflict
   *    conflict + preds
   *
   */
  execATN(dfa, s0, input, startIndex, outerContext) {
    if (this.debug || this.debug_list_atn_decisions) {
      console.log("execATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + " line " + input.LT(1).line + ":" + input.LT(1).column);
    }
    let alt;
    let previousD = s0;
    if (this.debug) {
      console.log("s0 = " + s0);
    }
    let t4 = input.LA(1);
    for (; ; ) {
      let D2 = this.getExistingTargetState(previousD, t4);
      if (D2 === null) {
        D2 = this.computeTargetState(dfa, previousD, t4);
      }
      if (D2 === ATNSimulator.ERROR) {
        const e4 = this.noViableAlt(input, outerContext, previousD.configs, startIndex);
        input.seek(startIndex);
        alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousD.configs, outerContext);
        if (alt !== ATN.INVALID_ALT_NUMBER) {
          return alt;
        } else {
          throw e4;
        }
      }
      if (D2.requiresFullContext && this.predictionMode !== PredictionMode_default.SLL) {
        let conflictingAlts = null;
        if (D2.predicates !== null) {
          if (this.debug) {
            console.log("DFA state has preds in DFA sim LL failover");
          }
          const conflictIndex = input.index;
          if (conflictIndex !== startIndex) {
            input.seek(startIndex);
          }
          conflictingAlts = this.evalSemanticContext(D2.predicates, outerContext, true);
          if (conflictingAlts.length === 1) {
            if (this.debug) {
              console.log("Full LL avoided");
            }
            return conflictingAlts.minValue();
          }
          if (conflictIndex !== startIndex) {
            input.seek(conflictIndex);
          }
        }
        if (this.dfa_debug) {
          console.log("ctx sensitive state " + outerContext + " in " + D2);
        }
        const fullCtx = true;
        const s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);
        this.reportAttemptingFullContext(dfa, conflictingAlts, D2.configs, startIndex, input.index);
        alt = this.execATNWithFullContext(dfa, D2, s0_closure, input, startIndex, outerContext);
        return alt;
      }
      if (D2.isAcceptState) {
        if (D2.predicates === null) {
          return D2.prediction;
        }
        const stopIndex = input.index;
        input.seek(startIndex);
        const alts = this.evalSemanticContext(D2.predicates, outerContext, true);
        if (alts.length === 0) {
          throw this.noViableAlt(input, outerContext, D2.configs, startIndex);
        } else if (alts.length === 1) {
          return alts.minValue();
        } else {
          this.reportAmbiguity(dfa, D2, startIndex, stopIndex, false, alts, D2.configs);
          return alts.minValue();
        }
      }
      previousD = D2;
      if (t4 !== Token.EOF) {
        input.consume();
        t4 = input.LA(1);
      }
    }
  }
  /**
   * Get an existing target state for an edge in the DFA. If the target state
   * for the edge has not yet been computed or is otherwise not available,
   * this method returns {@code null}.
   *
   * @param previousD The current DFA state
   * @param t The next input symbol
   * @return The existing target DFA state for the given input symbol
   * {@code t}, or {@code null} if the target state for this edge is not
   * already cached
   */
  getExistingTargetState(previousD, t4) {
    const edges = previousD.edges;
    if (edges === null) {
      return null;
    } else {
      return edges[t4 + 1] || null;
    }
  }
  /**
   * Compute a target state for an edge in the DFA, and attempt to add the
   * computed state and corresponding edge to the DFA.
   *
   * @param dfa The DFA
   * @param previousD The current DFA state
   * @param t The next input symbol
   *
   * @return The computed target DFA state for the given input symbol
   * {@code t}. If {@code t} does not lead to a valid DFA state, this method
   * returns {@link //ERROR
   */
  computeTargetState(dfa, previousD, t4) {
    const reach = this.computeReachSet(previousD.configs, t4, false);
    if (reach === null) {
      this.addDFAEdge(dfa, previousD, t4, ATNSimulator.ERROR);
      return ATNSimulator.ERROR;
    }
    let D2 = new DFAState(null, reach);
    const predictedAlt = this.getUniqueAlt(reach);
    if (this.debug) {
      const altSubSets = PredictionMode_default.getConflictingAltSubsets(reach);
      console.log("SLL altSubSets=" + arrayToString(altSubSets) + /*", previous=" + previousD.configs + */
      ", configs=" + reach + ", predict=" + predictedAlt + ", allSubsetsConflict=" + PredictionMode_default.allSubsetsConflict(altSubSets) + ", conflictingAlts=" + this.getConflictingAlts(reach));
    }
    if (predictedAlt !== ATN.INVALID_ALT_NUMBER) {
      D2.isAcceptState = true;
      D2.configs.uniqueAlt = predictedAlt;
      D2.prediction = predictedAlt;
    } else if (PredictionMode_default.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {
      D2.configs.conflictingAlts = this.getConflictingAlts(reach);
      D2.requiresFullContext = true;
      D2.isAcceptState = true;
      D2.prediction = D2.configs.conflictingAlts.minValue();
    }
    if (D2.isAcceptState && D2.configs.hasSemanticContext) {
      this.predicateDFAState(D2, this.atn.getDecisionState(dfa.decision));
      if (D2.predicates !== null) {
        D2.prediction = ATN.INVALID_ALT_NUMBER;
      }
    }
    D2 = this.addDFAEdge(dfa, previousD, t4, D2);
    return D2;
  }
  predicateDFAState(dfaState, decisionState) {
    const nalts = decisionState.transitions.length;
    const altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);
    const altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, nalts);
    if (altToPred !== null) {
      dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);
      dfaState.prediction = ATN.INVALID_ALT_NUMBER;
    } else {
      dfaState.prediction = altsToCollectPredsFrom.minValue();
    }
  }
  // comes back with reach.uniqueAlt set to a valid alt
  execATNWithFullContext(dfa, D2, s0, input, startIndex, outerContext) {
    if (this.debug || this.debug_list_atn_decisions) {
      console.log("execATNWithFullContext " + s0);
    }
    const fullCtx = true;
    let foundExactAmbig = false;
    let reach;
    let previous = s0;
    input.seek(startIndex);
    let t4 = input.LA(1);
    let predictedAlt = -1;
    for (; ; ) {
      reach = this.computeReachSet(previous, t4, fullCtx);
      if (reach === null) {
        const e4 = this.noViableAlt(input, outerContext, previous, startIndex);
        input.seek(startIndex);
        const alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);
        if (alt !== ATN.INVALID_ALT_NUMBER) {
          return alt;
        } else {
          throw e4;
        }
      }
      const altSubSets = PredictionMode_default.getConflictingAltSubsets(reach);
      if (this.debug) {
        console.log("LL altSubSets=" + altSubSets + ", predict=" + PredictionMode_default.getUniqueAlt(altSubSets) + ", resolvesToJustOneViableAlt=" + PredictionMode_default.resolvesToJustOneViableAlt(altSubSets));
      }
      reach.uniqueAlt = this.getUniqueAlt(reach);
      if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {
        predictedAlt = reach.uniqueAlt;
        break;
      } else if (this.predictionMode !== PredictionMode_default.LL_EXACT_AMBIG_DETECTION) {
        predictedAlt = PredictionMode_default.resolvesToJustOneViableAlt(altSubSets);
        if (predictedAlt !== ATN.INVALID_ALT_NUMBER) {
          break;
        }
      } else {
        if (PredictionMode_default.allSubsetsConflict(altSubSets) && PredictionMode_default.allSubsetsEqual(altSubSets)) {
          foundExactAmbig = true;
          predictedAlt = PredictionMode_default.getSingleViableAlt(altSubSets);
          break;
        }
      }
      previous = reach;
      if (t4 !== Token.EOF) {
        input.consume();
        t4 = input.LA(1);
      }
    }
    if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {
      this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);
      return predictedAlt;
    }
    this.reportAmbiguity(dfa, D2, startIndex, input.index, foundExactAmbig, null, reach);
    return predictedAlt;
  }
  computeReachSet(closure, t4, fullCtx) {
    if (this.debug) {
      console.log("in computeReachSet, starting closure: " + closure);
    }
    if (this.mergeCache === null) {
      this.mergeCache = new DoubleDict();
    }
    const intermediate = new ATNConfigSet(fullCtx);
    let skippedStopStates = null;
    for (let i2 = 0; i2 < closure.items.length; i2++) {
      const c2 = closure.items[i2];
      if (this.debug) {
        console.log("testing " + this.getTokenName(t4) + " at " + c2);
      }
      if (c2.state instanceof RuleStopState) {
        if (fullCtx || t4 === Token.EOF) {
          if (skippedStopStates === null) {
            skippedStopStates = [];
          }
          skippedStopStates.push(c2);
          if (this.debug_add) {
            console.log("added " + c2 + " to skippedStopStates");
          }
        }
        continue;
      }
      for (let j = 0; j < c2.state.transitions.length; j++) {
        const trans = c2.state.transitions[j];
        const target = this.getReachableTarget(trans, t4);
        if (target !== null) {
          const cfg = new ATNConfig({ state: target }, c2);
          intermediate.add(cfg, this.mergeCache);
          if (this.debug_add) {
            console.log("added " + cfg + " to intermediate");
          }
        }
      }
    }
    let reach = null;
    if (skippedStopStates === null && t4 !== Token.EOF) {
      if (intermediate.items.length === 1) {
        reach = intermediate;
      } else if (this.getUniqueAlt(intermediate) !== ATN.INVALID_ALT_NUMBER) {
        reach = intermediate;
      }
    }
    if (reach === null) {
      reach = new ATNConfigSet(fullCtx);
      const closureBusy = new HashSet();
      const treatEofAsEpsilon = t4 === Token.EOF;
      for (let k2 = 0; k2 < intermediate.items.length; k2++) {
        this.closure(intermediate.items[k2], reach, closureBusy, false, fullCtx, treatEofAsEpsilon);
      }
    }
    if (t4 === Token.EOF) {
      reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);
    }
    if (skippedStopStates !== null && (!fullCtx || !PredictionMode_default.hasConfigInRuleStopState(reach))) {
      for (let l = 0; l < skippedStopStates.length; l++) {
        reach.add(skippedStopStates[l], this.mergeCache);
      }
    }
    if (reach.items.length === 0) {
      return null;
    } else {
      return reach;
    }
  }
  /**
   * Return a configuration set containing only the configurations from
   * {@code configs} which are in a {@link RuleStopState}. If all
   * configurations in {@code configs} are already in a rule stop state, this
   * method simply returns {@code configs}.
   *
   * <p>When {@code lookToEndOfRule} is true, this method uses
   * {@link ATN//nextTokens} for each configuration in {@code configs} which is
   * not already in a rule stop state to see if a rule stop state is reachable
   * from the configuration via epsilon-only transitions.</p>
   *
   * @param configs the configuration set to update
   * @param lookToEndOfRule when true, this method checks for rule stop states
   * reachable by epsilon-only transitions from each configuration in
   * {@code configs}.
   *
   * @return {@code configs} if all configurations in {@code configs} are in a
   * rule stop state, otherwise return a new configuration set containing only
   * the configurations from {@code configs} which are in a rule stop state
   */
  removeAllConfigsNotInRuleStopState(configs, lookToEndOfRule) {
    if (PredictionMode_default.allConfigsInRuleStopStates(configs)) {
      return configs;
    }
    const result = new ATNConfigSet(configs.fullCtx);
    for (let i2 = 0; i2 < configs.items.length; i2++) {
      const config2 = configs.items[i2];
      if (config2.state instanceof RuleStopState) {
        result.add(config2, this.mergeCache);
        continue;
      }
      if (lookToEndOfRule && config2.state.epsilonOnlyTransitions) {
        const nextTokens = this.atn.nextTokens(config2.state);
        if (nextTokens.contains(Token.EPSILON)) {
          const endOfRuleState = this.atn.ruleToStopState[config2.state.ruleIndex];
          result.add(new ATNConfig({ state: endOfRuleState }, config2), this.mergeCache);
        }
      }
    }
    return result;
  }
  computeStartState(p, ctx, fullCtx) {
    const initialContext = predictionContextFromRuleContext(this.atn, ctx);
    const configs = new ATNConfigSet(fullCtx);
    for (let i2 = 0; i2 < p.transitions.length; i2++) {
      const target = p.transitions[i2].target;
      const c2 = new ATNConfig({ state: target, alt: i2 + 1, context: initialContext }, null);
      const closureBusy = new HashSet();
      this.closure(c2, configs, closureBusy, true, fullCtx, false);
    }
    return configs;
  }
  /**
   * This method transforms the start state computed by
   * {@link //computeStartState} to the special start state used by a
   * precedence DFA for a particular precedence value. The transformation
   * process applies the following changes to the start state's configuration
   * set.
   *
   * <ol>
   * <li>Evaluate the precedence predicates for each configuration using
   * {@link SemanticContext//evalPrecedence}.</li>
   * <li>Remove all configurations which predict an alternative greater than
   * 1, for which another configuration that predicts alternative 1 is in the
   * same ATN state with the same prediction context. This transformation is
   * valid for the following reasons:
   * <ul>
   * <li>The closure block cannot contain any epsilon transitions which bypass
   * the body of the closure, so all states reachable via alternative 1 are
   * part of the precedence alternatives of the transformed left-recursive
   * rule.</li>
   * <li>The "primary" portion of a left recursive rule cannot contain an
   * epsilon transition, so the only way an alternative other than 1 can exist
   * in a state that is also reachable via alternative 1 is by nesting calls
   * to the left-recursive rule, with the outer calls not being at the
   * preferred precedence level.</li>
   * </ul>
   * </li>
   * </ol>
   *
   * <p>
   * The prediction context must be considered by this filter to address
   * situations like the following.
   * </p>
   * <code>
   * <pre>
   * grammar TA;
   * prog: statement* EOF;
   * statement: letterA | statement letterA 'b' ;
   * letterA: 'a';
   * </pre>
   * </code>
   * <p>
   * If the above grammar, the ATN state immediately before the token
   * reference {@code 'a'} in {@code letterA} is reachable from the left edge
   * of both the primary and closure blocks of the left-recursive rule
   * {@code statement}. The prediction context associated with each of these
   * configurations distinguishes between them, and prevents the alternative
   * which stepped out to {@code prog} (and then back in to {@code statement}
   * from being eliminated by the filter.
   * </p>
   *
   * @param configs The configuration set computed by
   * {@link //computeStartState} as the start state for the DFA.
   * @return The transformed configuration set representing the start state
   * for a precedence DFA at a particular precedence level (determined by
   * calling {@link Parser//getPrecedence})
   */
  applyPrecedenceFilter(configs) {
    let config2;
    const statesFromAlt1 = [];
    const configSet = new ATNConfigSet(configs.fullCtx);
    for (let i2 = 0; i2 < configs.items.length; i2++) {
      config2 = configs.items[i2];
      if (config2.alt !== 1) {
        continue;
      }
      const updatedContext = config2.semanticContext.evalPrecedence(this.parser, this._outerContext);
      if (updatedContext === null) {
        continue;
      }
      statesFromAlt1[config2.state.stateNumber] = config2.context;
      if (updatedContext !== config2.semanticContext) {
        configSet.add(new ATNConfig({ semanticContext: updatedContext }, config2), this.mergeCache);
      } else {
        configSet.add(config2, this.mergeCache);
      }
    }
    for (let i2 = 0; i2 < configs.items.length; i2++) {
      config2 = configs.items[i2];
      if (config2.alt === 1) {
        continue;
      }
      if (!config2.precedenceFilterSuppressed) {
        const context = statesFromAlt1[config2.state.stateNumber] || null;
        if (context !== null && context.equals(config2.context)) {
          continue;
        }
      }
      configSet.add(config2, this.mergeCache);
    }
    return configSet;
  }
  getReachableTarget(trans, ttype) {
    if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
      return trans.target;
    } else {
      return null;
    }
  }
  getPredsForAmbigAlts(ambigAlts, configs, nalts) {
    let altToPred = [];
    for (let i2 = 0; i2 < configs.items.length; i2++) {
      const c2 = configs.items[i2];
      if (ambigAlts.has(c2.alt)) {
        altToPred[c2.alt] = SemanticContext.orContext(altToPred[c2.alt] || null, c2.semanticContext);
      }
    }
    let nPredAlts = 0;
    for (let i2 = 1; i2 < nalts + 1; i2++) {
      const pred = altToPred[i2] || null;
      if (pred === null) {
        altToPred[i2] = SemanticContext.NONE;
      } else if (pred !== SemanticContext.NONE) {
        nPredAlts += 1;
      }
    }
    if (nPredAlts === 0) {
      altToPred = null;
    }
    if (this.debug) {
      console.log("getPredsForAmbigAlts result " + arrayToString(altToPred));
    }
    return altToPred;
  }
  getPredicatePredictions(ambigAlts, altToPred) {
    const pairs = [];
    let containsPredicate = false;
    for (let i2 = 1; i2 < altToPred.length; i2++) {
      const pred = altToPred[i2];
      if (ambigAlts !== null && ambigAlts.has(i2)) {
        pairs.push(new PredPrediction(pred, i2));
      }
      if (pred !== SemanticContext.NONE) {
        containsPredicate = true;
      }
    }
    if (!containsPredicate) {
      return null;
    }
    return pairs;
  }
  /**
   * This method is used to improve the localization of error messages by
   * choosing an alternative rather than throwing a
   * {@link NoViableAltException} in particular prediction scenarios where the
   * {@link //ERROR} state was reached during ATN simulation.
   *
   * <p>
   * The default implementation of this method uses the following
   * algorithm to identify an ATN configuration which successfully parsed the
   * decision entry rule. Choosing such an alternative ensures that the
   * {@link ParserRuleContext} returned by the calling rule will be complete
   * and valid, and the syntax error will be reported later at a more
   * localized location.</p>
   *
   * <ul>
   * <li>If a syntactically valid path or paths reach the end of the decision rule and
   * they are semantically valid if predicated, return the min associated alt.</li>
   * <li>Else, if a semantically invalid but syntactically valid path exist
   * or paths exist, return the minimum associated alt.
   * </li>
   * <li>Otherwise, return {@link ATN//INVALID_ALT_NUMBER}.</li>
   * </ul>
   *
   * <p>
   * In some scenarios, the algorithm described above could predict an
   * alternative which will result in a {@link FailedPredicateException} in
   * the parser. Specifically, this could occur if the <em>only</em> configuration
   * capable of successfully parsing to the end of the decision rule is
   * blocked by a semantic predicate. By choosing this alternative within
   * {@link //adaptivePredict} instead of throwing a
   * {@link NoViableAltException}, the resulting
   * {@link FailedPredicateException} in the parser will identify the specific
   * predicate which is preventing the parser from successfully parsing the
   * decision rule, which helps developers identify and correct logic errors
   * in semantic predicates.
   * </p>
   *
   * @param configs The ATN configurations which were valid immediately before
   * the {@link //ERROR} state was reached
   * @param outerContext The is the \gamma_0 initial parser context from the paper
   * or the parser stack at the instant before prediction commences.
   *
   * @return The value to return from {@link //adaptivePredict}, or
   * {@link ATN//INVALID_ALT_NUMBER} if a suitable alternative was not
   * identified and {@link //adaptivePredict} should report an error instead
   */
  getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(configs, outerContext) {
    const cfgs = this.splitAccordingToSemanticValidity(configs, outerContext);
    const semValidConfigs = cfgs[0];
    const semInvalidConfigs = cfgs[1];
    let alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);
    if (alt !== ATN.INVALID_ALT_NUMBER) {
      return alt;
    }
    if (semInvalidConfigs.items.length > 0) {
      alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);
      if (alt !== ATN.INVALID_ALT_NUMBER) {
        return alt;
      }
    }
    return ATN.INVALID_ALT_NUMBER;
  }
  getAltThatFinishedDecisionEntryRule(configs) {
    const alts = [];
    for (let i2 = 0; i2 < configs.items.length; i2++) {
      const c2 = configs.items[i2];
      if (c2.reachesIntoOuterContext > 0 || c2.state instanceof RuleStopState && c2.context.hasEmptyPath()) {
        if (alts.indexOf(c2.alt) < 0) {
          alts.push(c2.alt);
        }
      }
    }
    if (alts.length === 0) {
      return ATN.INVALID_ALT_NUMBER;
    } else {
      return Math.min.apply(null, alts);
    }
  }
  /**
   * Walk the list of configurations and split them according to
   * those that have preds evaluating to true/false.  If no pred, assume
   * true pred and include in succeeded set.  Returns Pair of sets.
   *
   * Create a new set so as not to alter the incoming parameter.
   *
   * Assumption: the input stream has been restored to the starting point
   * prediction, which is where predicates need to evaluate.*/
  splitAccordingToSemanticValidity(configs, outerContext) {
    const succeeded = new ATNConfigSet(configs.fullCtx);
    const failed = new ATNConfigSet(configs.fullCtx);
    for (let i2 = 0; i2 < configs.items.length; i2++) {
      const c2 = configs.items[i2];
      if (c2.semanticContext !== SemanticContext.NONE) {
        const predicateEvaluationResult = c2.semanticContext.evaluate(this.parser, outerContext);
        if (predicateEvaluationResult) {
          succeeded.add(c2);
        } else {
          failed.add(c2);
        }
      } else {
        succeeded.add(c2);
      }
    }
    return [succeeded, failed];
  }
  /**
   * Look through a list of predicate/alt pairs, returning alts for the
   * pairs that win. A {@code NONE} predicate indicates an alt containing an
   * unpredicated config which behaves as "always true." If !complete
   * then we stop at the first predicate that evaluates to true. This
   * includes pairs with null predicates.
   */
  evalSemanticContext(predPredictions, outerContext, complete) {
    const predictions = new BitSet();
    for (let i2 = 0; i2 < predPredictions.length; i2++) {
      const pair = predPredictions[i2];
      if (pair.pred === SemanticContext.NONE) {
        predictions.add(pair.alt);
        if (!complete) {
          break;
        }
        continue;
      }
      const predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);
      if (this.debug || this.dfa_debug) {
        console.log("eval pred " + pair + "=" + predicateEvaluationResult);
      }
      if (predicateEvaluationResult) {
        if (this.debug || this.dfa_debug) {
          console.log("PREDICT " + pair.alt);
        }
        predictions.add(pair.alt);
        if (!complete) {
          break;
        }
      }
    }
    return predictions;
  }
  // TODO: If we are doing predicates, there is no point in pursuing
  //     closure operations if we reach a DFA state that uniquely predicts
  //     alternative. We will not be caching that DFA state and it is a
  //     waste to pursue the closure. Might have to advance when we do
  //     ambig detection thought :(
  //
  closure(config2, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {
    const initialDepth = 0;
    this.closureCheckingStopState(
      config2,
      configs,
      closureBusy,
      collectPredicates,
      fullCtx,
      initialDepth,
      treatEofAsEpsilon
    );
  }
  closureCheckingStopState(config2, configs, closureBusy, collectPredicates, fullCtx, depth2, treatEofAsEpsilon) {
    if (this.debug || this.debug_closure) {
      console.log("closure(" + config2.toString(this.parser, true) + ")");
      if (config2.reachesIntoOuterContext > 50) {
        throw "problem";
      }
    }
    if (config2.state instanceof RuleStopState) {
      if (!config2.context.isEmpty()) {
        for (let i2 = 0; i2 < config2.context.length; i2++) {
          if (config2.context.getReturnState(i2) === PredictionContext.EMPTY_RETURN_STATE) {
            if (fullCtx) {
              configs.add(new ATNConfig({ state: config2.state, context: PredictionContext.EMPTY }, config2), this.mergeCache);
              continue;
            } else {
              if (this.debug) {
                console.log("FALLING off rule " + this.getRuleName(config2.state.ruleIndex));
              }
              this.closure_(
                config2,
                configs,
                closureBusy,
                collectPredicates,
                fullCtx,
                depth2,
                treatEofAsEpsilon
              );
            }
            continue;
          }
          const returnState = this.atn.states[config2.context.getReturnState(i2)];
          const newContext = config2.context.getParent(i2);
          const parms = { state: returnState, alt: config2.alt, context: newContext, semanticContext: config2.semanticContext };
          const c2 = new ATNConfig(parms, null);
          c2.reachesIntoOuterContext = config2.reachesIntoOuterContext;
          this.closureCheckingStopState(c2, configs, closureBusy, collectPredicates, fullCtx, depth2 - 1, treatEofAsEpsilon);
        }
        return;
      } else if (fullCtx) {
        configs.add(config2, this.mergeCache);
        return;
      } else {
        if (this.debug) {
          console.log("FALLING off rule " + this.getRuleName(config2.state.ruleIndex));
        }
      }
    }
    this.closure_(config2, configs, closureBusy, collectPredicates, fullCtx, depth2, treatEofAsEpsilon);
  }
  // Do the actual work of walking epsilon edges//
  closure_(config2, configs, closureBusy, collectPredicates, fullCtx, depth2, treatEofAsEpsilon) {
    const p = config2.state;
    if (!p.epsilonOnlyTransitions) {
      configs.add(config2, this.mergeCache);
    }
    for (let i2 = 0; i2 < p.transitions.length; i2++) {
      if (i2 === 0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config2))
        continue;
      const t4 = p.transitions[i2];
      const continueCollecting = collectPredicates && !(t4 instanceof ActionTransition);
      const c2 = this.getEpsilonTarget(config2, t4, continueCollecting, depth2 === 0, fullCtx, treatEofAsEpsilon);
      if (c2 !== null) {
        let newDepth = depth2;
        if (config2.state instanceof RuleStopState) {
          if (this._dfa !== null && this._dfa.precedenceDfa) {
            if (t4.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex) {
              c2.precedenceFilterSuppressed = true;
            }
          }
          c2.reachesIntoOuterContext += 1;
          if (closureBusy.add(c2) !== c2) {
            continue;
          }
          configs.dipsIntoOuterContext = true;
          newDepth -= 1;
          if (this.debug) {
            console.log("dips into outer ctx: " + c2);
          }
        } else {
          if (!t4.isEpsilon && closureBusy.add(c2) !== c2) {
            continue;
          }
          if (t4 instanceof RuleTransition) {
            if (newDepth >= 0) {
              newDepth += 1;
            }
          }
        }
        this.closureCheckingStopState(c2, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);
      }
    }
  }
  canDropLoopEntryEdgeInLeftRecursiveRule(config2) {
    const p = config2.state;
    if (p.stateType !== ATNState.STAR_LOOP_ENTRY)
      return false;
    if (p.stateType !== ATNState.STAR_LOOP_ENTRY || !p.isPrecedenceDecision || config2.context.isEmpty() || config2.context.hasEmptyPath())
      return false;
    const numCtxs = config2.context.length;
    for (let i2 = 0; i2 < numCtxs; i2++) {
      const returnState = this.atn.states[config2.context.getReturnState(i2)];
      if (returnState.ruleIndex !== p.ruleIndex)
        return false;
    }
    const decisionStartState = p.transitions[0].target;
    const blockEndStateNum = decisionStartState.endState.stateNumber;
    const blockEndState = this.atn.states[blockEndStateNum];
    for (let i2 = 0; i2 < numCtxs; i2++) {
      const returnStateNumber = config2.context.getReturnState(i2);
      const returnState = this.atn.states[returnStateNumber];
      if (returnState.transitions.length !== 1 || !returnState.transitions[0].isEpsilon)
        return false;
      const returnStateTarget = returnState.transitions[0].target;
      if (returnState.stateType === ATNState.BLOCK_END && returnStateTarget === p)
        continue;
      if (returnState === blockEndState)
        continue;
      if (returnStateTarget === blockEndState)
        continue;
      if (returnStateTarget.stateType === ATNState.BLOCK_END && returnStateTarget.transitions.length === 1 && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target === p)
        continue;
      return false;
    }
    return true;
  }
  getRuleName(index4) {
    if (this.parser !== null && index4 >= 0) {
      return this.parser.ruleNames[index4];
    } else {
      return "<rule " + index4 + ">";
    }
  }
  getEpsilonTarget(config2, t4, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {
    switch (t4.serializationType) {
      case Transition.RULE:
        return this.ruleTransition(config2, t4);
      case Transition.PRECEDENCE:
        return this.precedenceTransition(config2, t4, collectPredicates, inContext, fullCtx);
      case Transition.PREDICATE:
        return this.predTransition(config2, t4, collectPredicates, inContext, fullCtx);
      case Transition.ACTION:
        return this.actionTransition(config2, t4);
      case Transition.EPSILON:
        return new ATNConfig({ state: t4.target }, config2);
      case Transition.ATOM:
      case Transition.RANGE:
      case Transition.SET:
        if (treatEofAsEpsilon) {
          if (t4.matches(Token.EOF, 0, 1)) {
            return new ATNConfig({ state: t4.target }, config2);
          }
        }
        return null;
      default:
        return null;
    }
  }
  actionTransition(config2, t4) {
    if (this.debug) {
      const index4 = t4.actionIndex === -1 ? 65535 : t4.actionIndex;
      console.log("ACTION edge " + t4.ruleIndex + ":" + index4);
    }
    return new ATNConfig({ state: t4.target }, config2);
  }
  precedenceTransition(config2, pt2, collectPredicates, inContext, fullCtx) {
    if (this.debug) {
      console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt2.precedence + ">=_p, ctx dependent=true");
      if (this.parser !== null) {
        console.log("context surrounding pred is " + arrayToString(this.parser.getRuleInvocationStack()));
      }
    }
    let c2 = null;
    if (collectPredicates && inContext) {
      if (fullCtx) {
        const currentPosition = this._input.index;
        this._input.seek(this._startIndex);
        const predSucceeds = pt2.getPredicate().evaluate(this.parser, this._outerContext);
        this._input.seek(currentPosition);
        if (predSucceeds) {
          c2 = new ATNConfig({ state: pt2.target }, config2);
        }
      } else {
        const newSemCtx = SemanticContext.andContext(config2.semanticContext, pt2.getPredicate());
        c2 = new ATNConfig({ state: pt2.target, semanticContext: newSemCtx }, config2);
      }
    } else {
      c2 = new ATNConfig({ state: pt2.target }, config2);
    }
    if (this.debug) {
      console.log("config from pred transition=" + c2);
    }
    return c2;
  }
  predTransition(config2, pt2, collectPredicates, inContext, fullCtx) {
    if (this.debug) {
      console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt2.ruleIndex + ":" + pt2.predIndex + ", ctx dependent=" + pt2.isCtxDependent);
      if (this.parser !== null) {
        console.log("context surrounding pred is " + arrayToString(this.parser.getRuleInvocationStack()));
      }
    }
    let c2 = null;
    if (collectPredicates && (pt2.isCtxDependent && inContext || !pt2.isCtxDependent)) {
      if (fullCtx) {
        const currentPosition = this._input.index;
        this._input.seek(this._startIndex);
        const predSucceeds = pt2.getPredicate().evaluate(this.parser, this._outerContext);
        this._input.seek(currentPosition);
        if (predSucceeds) {
          c2 = new ATNConfig({ state: pt2.target }, config2);
        }
      } else {
        const newSemCtx = SemanticContext.andContext(config2.semanticContext, pt2.getPredicate());
        c2 = new ATNConfig({ state: pt2.target, semanticContext: newSemCtx }, config2);
      }
    } else {
      c2 = new ATNConfig({ state: pt2.target }, config2);
    }
    if (this.debug) {
      console.log("config from pred transition=" + c2);
    }
    return c2;
  }
  ruleTransition(config2, t4) {
    if (this.debug) {
      console.log("CALL rule " + this.getRuleName(t4.target.ruleIndex) + ", ctx=" + config2.context);
    }
    const returnState = t4.followState;
    const newContext = SingletonPredictionContext.create(config2.context, returnState.stateNumber);
    return new ATNConfig({ state: t4.target, context: newContext }, config2);
  }
  getConflictingAlts(configs) {
    const altsets = PredictionMode_default.getConflictingAltSubsets(configs);
    return PredictionMode_default.getAlts(altsets);
  }
  /**
   * Sam pointed out a problem with the previous definition, v3, of
   * ambiguous states. If we have another state associated with conflicting
   * alternatives, we should keep going. For example, the following grammar
   *
   * s : (ID | ID ID?) ';' ;
   *
   * When the ATN simulation reaches the state before ';', it has a DFA
   * state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally
   * 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node
   * because alternative to has another way to continue, via [6|2|[]].
   * The key is that we have a single state that has config's only associated
   * with a single alternative, 2, and crucially the state transitions
   * among the configurations are all non-epsilon transitions. That means
   * we don't consider any conflicts that include alternative 2. So, we
   * ignore the conflict between alts 1 and 2. We ignore a set of
   * conflicting alts when there is an intersection with an alternative
   * associated with a single alt state in the state&rarr;config-list map.
   *
   * It's also the case that we might have two conflicting configurations but
   * also a 3rd nonconflicting configuration for a different alternative:
   * [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:
   *
   * a : A | A | A B ;
   *
   * After matching input A, we reach the stop state for rule A, state 1.
   * State 8 is the state right before B. Clearly alternatives 1 and 2
   * conflict and no amount of further lookahead will separate the two.
   * However, alternative 3 will be able to continue and so we do not
   * stop working on this state. In the previous example, we're concerned
   * with states associated with the conflicting alternatives. Here alt
   * 3 is not associated with the conflicting configs, but since we can continue
   * looking for input reasonably, I don't declare the state done. We
   * ignore a set of conflicting alts when we have an alternative
   * that we still need to pursue
   */
  getConflictingAltsOrUniqueAlt(configs) {
    let conflictingAlts = null;
    if (configs.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {
      conflictingAlts = new BitSet();
      conflictingAlts.add(configs.uniqueAlt);
    } else {
      conflictingAlts = configs.conflictingAlts;
    }
    return conflictingAlts;
  }
  getTokenName(t4) {
    if (t4 === Token.EOF) {
      return "EOF";
    }
    if (this.parser !== null && this.parser.literalNames !== null) {
      if (t4 >= this.parser.literalNames.length && t4 >= this.parser.symbolicNames.length) {
        console.log("" + t4 + " ttype out of range: " + this.parser.literalNames);
        console.log("" + this.parser.getInputStream().getTokens());
      } else {
        const name2 = this.parser.literalNames[t4] || this.parser.symbolicNames[t4];
        return name2 + "<" + t4 + ">";
      }
    }
    return "" + t4;
  }
  getLookaheadName(input) {
    return this.getTokenName(input.LA(1));
  }
  /**
   * Used for debugging in adaptivePredict around execATN but I cut
   * it out for clarity now that alg. works well. We can leave this
   * "dead" code for a bit
   */
  dumpDeadEndConfigs(nvae) {
    console.log("dead end configs: ");
    const decs = nvae.getDeadEndConfigs();
    for (let i2 = 0; i2 < decs.length; i2++) {
      const c2 = decs[i2];
      let trans = "no edges";
      if (c2.state.transitions.length > 0) {
        const t4 = c2.state.transitions[0];
        if (t4 instanceof AtomTransition) {
          trans = "Atom " + this.getTokenName(t4.label);
        } else if (t4 instanceof SetTransition) {
          const neg = t4 instanceof NotSetTransition;
          trans = (neg ? "~" : "") + "Set " + t4.set;
        }
      }
      console.error(c2.toString(this.parser, true) + ":" + trans);
    }
  }
  noViableAlt(input, outerContext, configs, startIndex) {
    return new NoViableAltException(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
  }
  getUniqueAlt(configs) {
    let alt = ATN.INVALID_ALT_NUMBER;
    for (let i2 = 0; i2 < configs.items.length; i2++) {
      const c2 = configs.items[i2];
      if (alt === ATN.INVALID_ALT_NUMBER) {
        alt = c2.alt;
      } else if (c2.alt !== alt) {
        return ATN.INVALID_ALT_NUMBER;
      }
    }
    return alt;
  }
  /**
   * Add an edge to the DFA, if possible. This method calls
   * {@link //addDFAState} to ensure the {@code to} state is present in the
   * DFA. If {@code from} is {@code null}, or if {@code t} is outside the
   * range of edges that can be represented in the DFA tables, this method
   * returns without adding the edge to the DFA.
   *
   * <p>If {@code to} is {@code null}, this method returns {@code null}.
   * Otherwise, this method returns the {@link DFAState} returned by calling
   * {@link //addDFAState} for the {@code to} state.</p>
   *
   * @param dfa The DFA
   * @param from_ The source state for the edge
   * @param t The input symbol
   * @param to The target state for the edge
   *
   * @return If {@code to} is {@code null}, this method returns {@code null};
   * otherwise this method returns the result of calling {@link //addDFAState}
   * on {@code to}
   */
  addDFAEdge(dfa, from_, t4, to) {
    if (this.debug) {
      console.log("EDGE " + from_ + " -> " + to + " upon " + this.getTokenName(t4));
    }
    if (to === null) {
      return null;
    }
    to = this.addDFAState(dfa, to);
    if (from_ === null || t4 < -1 || t4 > this.atn.maxTokenType) {
      return to;
    }
    if (from_.edges === null) {
      from_.edges = [];
    }
    from_.edges[t4 + 1] = to;
    if (this.debug) {
      const literalNames = this.parser === null ? null : this.parser.literalNames;
      const symbolicNames = this.parser === null ? null : this.parser.symbolicNames;
      console.log("DFA=\n" + dfa.toString(literalNames, symbolicNames));
    }
    return to;
  }
  /**
   * Add state {@code D} to the DFA if it is not already present, and return
   * the actual instance stored in the DFA. If a state equivalent to {@code D}
   * is already in the DFA, the existing state is returned. Otherwise this
   * method returns {@code D} after adding it to the DFA.
   *
   * <p>If {@code D} is {@link //ERROR}, this method returns {@link //ERROR} and
   * does not change the DFA.</p>
   *
   * @param dfa The dfa
   * @param D The DFA state to add
   * @return The state stored in the DFA. This will be either the existing
   * state if {@code D} is already in the DFA, or {@code D} itself if the
   * state was not already present
   */
  addDFAState(dfa, D2) {
    if (D2 === ATNSimulator.ERROR) {
      return D2;
    }
    const existing = dfa.states.get(D2);
    if (existing !== null) {
      return existing;
    }
    D2.stateNumber = dfa.states.length;
    if (!D2.configs.readOnly) {
      D2.configs.optimizeConfigs(this);
      D2.configs.setReadonly(true);
    }
    dfa.states.add(D2);
    if (this.debug) {
      console.log("adding new DFA state: " + D2);
    }
    return D2;
  }
  reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {
    if (this.debug || this.retry_debug) {
      const interval = new Interval(startIndex, stopIndex + 1);
      console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + configs + ", input=" + this.parser.getTokenStream().getText(interval));
    }
    if (this.parser !== null) {
      this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, dfa, startIndex, stopIndex, conflictingAlts, configs);
    }
  }
  reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {
    if (this.debug || this.retry_debug) {
      const interval = new Interval(startIndex, stopIndex + 1);
      console.log("reportContextSensitivity decision=" + dfa.decision + ":" + configs + ", input=" + this.parser.getTokenStream().getText(interval));
    }
    if (this.parser !== null) {
      this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, dfa, startIndex, stopIndex, prediction, configs);
    }
  }
  // If context sensitive parsing, we know it's ambiguity not conflict//
  reportAmbiguity(dfa, D2, startIndex, stopIndex, exact, ambigAlts, configs) {
    if (this.debug || this.retry_debug) {
      const interval = new Interval(startIndex, stopIndex + 1);
      console.log("reportAmbiguity " + ambigAlts + ":" + configs + ", input=" + this.parser.getTokenStream().getText(interval));
    }
    if (this.parser !== null) {
      this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
    }
  }
};

// node_modules/antlr4/src/antlr4/atn/index.js
var atn_default = { ATN, ATNDeserializer, LexerATNSimulator, ParserATNSimulator, PredictionMode: PredictionMode_default };

// node_modules/antlr4/src/antlr4/dfa/DFASerializer.js
var DFASerializer = class {
  constructor(dfa, literalNames, symbolicNames) {
    this.dfa = dfa;
    this.literalNames = literalNames || [];
    this.symbolicNames = symbolicNames || [];
  }
  toString() {
    if (this.dfa.s0 === null) {
      return null;
    }
    let buf = "";
    const states = this.dfa.sortedStates();
    for (let i2 = 0; i2 < states.length; i2++) {
      const s3 = states[i2];
      if (s3.edges !== null) {
        const n = s3.edges.length;
        for (let j = 0; j < n; j++) {
          const t4 = s3.edges[j] || null;
          if (t4 !== null && t4.stateNumber !== 2147483647) {
            buf = buf.concat(this.getStateString(s3));
            buf = buf.concat("-");
            buf = buf.concat(this.getEdgeLabel(j));
            buf = buf.concat("->");
            buf = buf.concat(this.getStateString(t4));
            buf = buf.concat("\n");
          }
        }
      }
    }
    return buf.length === 0 ? null : buf;
  }
  getEdgeLabel(i2) {
    if (i2 === 0) {
      return "EOF";
    } else if (this.literalNames !== null || this.symbolicNames !== null) {
      return this.literalNames[i2 - 1] || this.symbolicNames[i2 - 1];
    } else {
      return String.fromCharCode(i2 - 1);
    }
  }
  getStateString(s3) {
    const baseStateStr = (s3.isAcceptState ? ":" : "") + "s" + s3.stateNumber + (s3.requiresFullContext ? "^" : "");
    if (s3.isAcceptState) {
      if (s3.predicates !== null) {
        return baseStateStr + "=>" + arrayToString(s3.predicates);
      } else {
        return baseStateStr + "=>" + s3.prediction.toString();
      }
    } else {
      return baseStateStr;
    }
  }
};

// node_modules/antlr4/src/antlr4/dfa/LexerDFASerializer.js
var LexerDFASerializer = class extends DFASerializer {
  constructor(dfa) {
    super(dfa, null);
  }
  getEdgeLabel(i2) {
    return "'" + String.fromCharCode(i2) + "'";
  }
};

// node_modules/antlr4/src/antlr4/dfa/DFA.js
var DFA = class {
  constructor(atnStartState, decision) {
    if (decision === void 0) {
      decision = 0;
    }
    this.atnStartState = atnStartState;
    this.decision = decision;
    this._states = new HashSet();
    this.s0 = null;
    this.precedenceDfa = false;
    if (atnStartState instanceof StarLoopEntryState) {
      if (atnStartState.isPrecedenceDecision) {
        this.precedenceDfa = true;
        const precedenceState = new DFAState(null, new ATNConfigSet());
        precedenceState.edges = [];
        precedenceState.isAcceptState = false;
        precedenceState.requiresFullContext = false;
        this.s0 = precedenceState;
      }
    }
  }
  /**
   * Get the start state for a specific precedence value.
   *
   * @param precedence The current precedence.
   * @return The start state corresponding to the specified precedence, or
   * {@code null} if no start state exists for the specified precedence.
   *
   * @throws IllegalStateException if this is not a precedence DFA.
   * @see //isPrecedenceDfa()
   */
  getPrecedenceStartState(precedence) {
    if (!this.precedenceDfa) {
      throw "Only precedence DFAs may contain a precedence start state.";
    }
    if (precedence < 0 || precedence >= this.s0.edges.length) {
      return null;
    }
    return this.s0.edges[precedence] || null;
  }
  /**
   * Set the start state for a specific precedence value.
   *
   * @param precedence The current precedence.
   * @param startState The start state corresponding to the specified
   * precedence.
   *
   * @throws IllegalStateException if this is not a precedence DFA.
   * @see //isPrecedenceDfa()
   */
  setPrecedenceStartState(precedence, startState) {
    if (!this.precedenceDfa) {
      throw "Only precedence DFAs may contain a precedence start state.";
    }
    if (precedence < 0) {
      return;
    }
    this.s0.edges[precedence] = startState;
  }
  /**
   * Sets whether this is a precedence DFA. If the specified value differs
   * from the current DFA configuration, the following actions are taken;
   * otherwise no changes are made to the current DFA.
   *
   * <ul>
   * <li>The {@link //states} map is cleared</li>
   * <li>If {@code precedenceDfa} is {@code false}, the initial state
   * {@link //s0} is set to {@code null}; otherwise, it is initialized to a new
   * {@link DFAState} with an empty outgoing {@link DFAState//edges} array to
   * store the start states for individual precedence values.</li>
   * <li>The {@link //precedenceDfa} field is updated</li>
   * </ul>
   *
   * @param precedenceDfa {@code true} if this is a precedence DFA; otherwise,
   * {@code false}
   */
  setPrecedenceDfa(precedenceDfa) {
    if (this.precedenceDfa !== precedenceDfa) {
      this._states = new HashSet();
      if (precedenceDfa) {
        const precedenceState = new DFAState(null, new ATNConfigSet());
        precedenceState.edges = [];
        precedenceState.isAcceptState = false;
        precedenceState.requiresFullContext = false;
        this.s0 = precedenceState;
      } else {
        this.s0 = null;
      }
      this.precedenceDfa = precedenceDfa;
    }
  }
  /**
   * Return a list of all states in this DFA, ordered by state number.
   */
  sortedStates() {
    const list = this._states.values();
    return list.sort(function(a3, b2) {
      return a3.stateNumber - b2.stateNumber;
    });
  }
  toString(literalNames, symbolicNames) {
    literalNames = literalNames || null;
    symbolicNames = symbolicNames || null;
    if (this.s0 === null) {
      return "";
    }
    const serializer = new DFASerializer(this, literalNames, symbolicNames);
    return serializer.toString();
  }
  toLexerString() {
    if (this.s0 === null) {
      return "";
    }
    const serializer = new LexerDFASerializer(this);
    return serializer.toString();
  }
  get states() {
    return this._states;
  }
};

// node_modules/antlr4/src/antlr4/dfa/index.js
var dfa_default = { DFA, DFASerializer, LexerDFASerializer, PredPrediction };

// node_modules/antlr4/src/antlr4/tree/ParseTreeListener.js
var ParseTreeListener = class {
  visitTerminal(node3) {
  }
  visitErrorNode(node3) {
  }
  enterEveryRule(node3) {
  }
  exitEveryRule(node3) {
  }
};

// node_modules/antlr4/src/antlr4/tree/ParseTreeVisitor.js
var ParseTreeVisitor = class {
  visit(ctx) {
    if (Array.isArray(ctx)) {
      return ctx.map(function(child) {
        return child.accept(this);
      }, this);
    } else {
      return ctx.accept(this);
    }
  }
  visitChildren(ctx) {
    if (ctx.children) {
      return this.visit(ctx.children);
    } else {
      return null;
    }
  }
  visitTerminal(node3) {
  }
  visitErrorNode(node3) {
  }
};

// node_modules/antlr4/src/antlr4/tree/ParseTreeWalker.js
var ParseTreeWalker = class {
  /**
   * Performs a walk on the given parse tree starting at the root and going down recursively
   * with depth-first search. On each node, {@link ParseTreeWalker//enterRule} is called before
   * recursively walking down into child nodes, then
   * {@link ParseTreeWalker//exitRule} is called after the recursive call to wind up.
   * @param listener The listener used by the walker to process grammar rules
   * @param t The parse tree to be walked on
   */
  walk(listener, t4) {
    const errorNode = t4 instanceof ErrorNode || t4.isErrorNode !== void 0 && t4.isErrorNode();
    if (errorNode) {
      listener.visitErrorNode(t4);
    } else if (t4 instanceof TerminalNode) {
      listener.visitTerminal(t4);
    } else {
      this.enterRule(listener, t4);
      for (let i2 = 0; i2 < t4.getChildCount(); i2++) {
        const child = t4.getChild(i2);
        this.walk(listener, child);
      }
      this.exitRule(listener, t4);
    }
  }
  /**
   * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener//enterEveryRule}
   * then by triggering the event specific to the given parse tree node
   * @param listener The listener responding to the trigger events
   * @param r The grammar rule containing the rule context
   */
  enterRule(listener, r2) {
    const ctx = r2.getRuleContext();
    listener.enterEveryRule(ctx);
    ctx.enterRule(listener);
  }
  /**
   * Exits a grammar rule by first triggering the event specific to the given parse tree node
   * then by triggering the generic event {@link ParseTreeListener//exitEveryRule}
   * @param listener The listener responding to the trigger events
   * @param r The grammar rule containing the rule context
   */
  exitRule(listener, r2) {
    const ctx = r2.getRuleContext();
    ctx.exitRule(listener);
    listener.exitEveryRule(ctx);
  }
};
ParseTreeWalker.DEFAULT = new ParseTreeWalker();

// node_modules/antlr4/src/antlr4/tree/index.js
var tree_default = { Trees: Trees_default, RuleNode, ErrorNode, TerminalNode, ParseTreeListener, ParseTreeVisitor, ParseTreeWalker };

// node_modules/antlr4/src/antlr4/error/InputMismatchException.js
var InputMismatchException = class extends RecognitionException {
  constructor(recognizer) {
    super({ message: "", recognizer, input: recognizer.getInputStream(), ctx: recognizer._ctx });
    this.offendingToken = recognizer.getCurrentToken();
  }
};

// node_modules/antlr4/src/antlr4/error/FailedPredicateException.js
var FailedPredicateException = class extends RecognitionException {
  constructor(recognizer, predicate, message) {
    super({
      message: formatMessage(predicate, message || null),
      recognizer,
      input: recognizer.getInputStream(),
      ctx: recognizer._ctx
    });
    const s3 = recognizer._interp.atn.states[recognizer.state];
    const trans = s3.transitions[0];
    if (trans instanceof PredicateTransition) {
      this.ruleIndex = trans.ruleIndex;
      this.predicateIndex = trans.predIndex;
    } else {
      this.ruleIndex = 0;
      this.predicateIndex = 0;
    }
    this.predicate = predicate;
    this.offendingToken = recognizer.getCurrentToken();
  }
};
function formatMessage(predicate, message) {
  if (message !== null) {
    return message;
  } else {
    return "failed predicate: {" + predicate + "}?";
  }
}

// node_modules/antlr4/src/antlr4/error/DiagnosticErrorListener.js
var DiagnosticErrorListener = class extends ErrorListener {
  constructor(exactOnly) {
    super();
    exactOnly = exactOnly || true;
    this.exactOnly = exactOnly;
  }
  reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
    if (this.exactOnly && !exact) {
      return;
    }
    const msg = "reportAmbiguity d=" + this.getDecisionDescription(recognizer, dfa) + ": ambigAlts=" + this.getConflictingAlts(ambigAlts, configs) + ", input='" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
    recognizer.notifyErrorListeners(msg);
  }
  reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
    const msg = "reportAttemptingFullContext d=" + this.getDecisionDescription(recognizer, dfa) + ", input='" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
    recognizer.notifyErrorListeners(msg);
  }
  reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
    const msg = "reportContextSensitivity d=" + this.getDecisionDescription(recognizer, dfa) + ", input='" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
    recognizer.notifyErrorListeners(msg);
  }
  getDecisionDescription(recognizer, dfa) {
    const decision = dfa.decision;
    const ruleIndex = dfa.atnStartState.ruleIndex;
    const ruleNames = recognizer.ruleNames;
    if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {
      return "" + decision;
    }
    const ruleName = ruleNames[ruleIndex] || null;
    if (ruleName === null || ruleName.length === 0) {
      return "" + decision;
    }
    return `${decision} (${ruleName})`;
  }
  /**
   * Computes the set of conflicting or ambiguous alternatives from a
   * configuration set, if that information was not already provided by the
   * parser.
   *
   * @param reportedAlts The set of conflicting or ambiguous alternatives, as
   * reported by the parser.
   * @param configs The conflicting or ambiguous configuration set.
   * @return Returns {@code reportedAlts} if it is not {@code null}, otherwise
   * returns the set of alternatives represented in {@code configs}.
      */
  getConflictingAlts(reportedAlts, configs) {
    if (reportedAlts !== null) {
      return reportedAlts;
    }
    const result = new BitSet();
    for (let i2 = 0; i2 < configs.items.length; i2++) {
      result.add(configs.items[i2].alt);
    }
    return `{${result.values().join(", ")}}`;
  }
};

// node_modules/antlr4/src/antlr4/error/ParseCancellationException.js
var ParseCancellationException = class _ParseCancellationException extends Error {
  constructor() {
    super();
    Error.captureStackTrace(this, _ParseCancellationException);
  }
};

// node_modules/antlr4/src/antlr4/error/ErrorStrategy.js
var ErrorStrategy = class {
  reset(recognizer) {
  }
  recoverInline(recognizer) {
  }
  recover(recognizer, e4) {
  }
  sync(recognizer) {
  }
  inErrorRecoveryMode(recognizer) {
  }
  reportError(recognizer) {
  }
};

// node_modules/antlr4/src/antlr4/error/DefaultErrorStrategy.js
var DefaultErrorStrategy = class extends ErrorStrategy {
  constructor() {
    super();
    this.errorRecoveryMode = false;
    this.lastErrorIndex = -1;
    this.lastErrorStates = null;
    this.nextTokensContext = null;
    this.nextTokenState = 0;
  }
  /**
   * <p>The default implementation simply calls {@link //endErrorCondition} to
   * ensure that the handler is not in error recovery mode.</p>
   */
  reset(recognizer) {
    this.endErrorCondition(recognizer);
  }
  /**
   * This method is called to enter error recovery mode when a recognition
   * exception is reported.
   *
   * @param recognizer the parser instance
   */
  beginErrorCondition(recognizer) {
    this.errorRecoveryMode = true;
  }
  inErrorRecoveryMode(recognizer) {
    return this.errorRecoveryMode;
  }
  /**
   * This method is called to leave error recovery mode after recovering from
   * a recognition exception.
   * @param recognizer
   */
  endErrorCondition(recognizer) {
    this.errorRecoveryMode = false;
    this.lastErrorStates = null;
    this.lastErrorIndex = -1;
  }
  /**
   * {@inheritDoc}
   * <p>The default implementation simply calls {@link //endErrorCondition}.</p>
   */
  reportMatch(recognizer) {
    this.endErrorCondition(recognizer);
  }
  /**
   * {@inheritDoc}
   *
   * <p>The default implementation returns immediately if the handler is already
   * in error recovery mode. Otherwise, it calls {@link //beginErrorCondition}
   * and dispatches the reporting task based on the runtime type of {@code e}
   * according to the following table.</p>
   *
   * <ul>
   * <li>{@link NoViableAltException}: Dispatches the call to
   * {@link //reportNoViableAlternative}</li>
   * <li>{@link InputMismatchException}: Dispatches the call to
   * {@link //reportInputMismatch}</li>
   * <li>{@link FailedPredicateException}: Dispatches the call to
   * {@link //reportFailedPredicate}</li>
   * <li>All other types: calls {@link Parser//notifyErrorListeners} to report
   * the exception</li>
   * </ul>
   */
  reportError(recognizer, e4) {
    if (this.inErrorRecoveryMode(recognizer)) {
      return;
    }
    this.beginErrorCondition(recognizer);
    if (e4 instanceof NoViableAltException) {
      this.reportNoViableAlternative(recognizer, e4);
    } else if (e4 instanceof InputMismatchException) {
      this.reportInputMismatch(recognizer, e4);
    } else if (e4 instanceof FailedPredicateException) {
      this.reportFailedPredicate(recognizer, e4);
    } else {
      console.log("unknown recognition error type: " + e4.constructor.name);
      console.log(e4.stack);
      recognizer.notifyErrorListeners(e4.getOffendingToken(), e4.getMessage(), e4);
    }
  }
  /**
   *
   * {@inheritDoc}
   *
   * <p>The default implementation resynchronizes the parser by consuming tokens
   * until we find one in the resynchronization set--loosely the set of tokens
   * that can follow the current rule.</p>
   *
   */
  recover(recognizer, e4) {
    if (this.lastErrorIndex === recognizer.getInputStream().index && this.lastErrorStates !== null && this.lastErrorStates.indexOf(recognizer.state) >= 0) {
      recognizer.consume();
    }
    this.lastErrorIndex = recognizer._input.index;
    if (this.lastErrorStates === null) {
      this.lastErrorStates = [];
    }
    this.lastErrorStates.push(recognizer.state);
    const followSet = this.getErrorRecoverySet(recognizer);
    this.consumeUntil(recognizer, followSet);
  }
  /**
   * The default implementation of {@link ANTLRErrorStrategy//sync} makes sure
   * that the current lookahead symbol is consistent with what were expecting
   * at this point in the ATN. You can call this anytime but ANTLR only
   * generates code to check before subrules/loops and each iteration.
   *
   * <p>Implements Jim Idle's magic sync mechanism in closures and optional
   * subrules. E.g.,</p>
   *
   * <pre>
   * a : sync ( stuff sync )* ;
   * sync : {consume to what can follow sync} ;
   * </pre>
   *
   * At the start of a sub rule upon error, {@link //sync} performs single
   * token deletion, if possible. If it can't do that, it bails on the current
   * rule and uses the default error recovery, which consumes until the
   * resynchronization set of the current rule.
   *
   * <p>If the sub rule is optional ({@code (...)?}, {@code (...)*}, or block
   * with an empty alternative), then the expected set includes what follows
   * the subrule.</p>
   *
   * <p>During loop iteration, it consumes until it sees a token that can start a
   * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
   * stay in the loop as long as possible.</p>
   *
   * <p><strong>ORIGINS</strong></p>
   *
   * <p>Previous versions of ANTLR did a poor job of their recovery within loops.
   * A single mismatch token or missing token would force the parser to bail
   * out of the entire rules surrounding the loop. So, for rule</p>
   *
   * <pre>
   * classDef : 'class' ID '{' member* '}'
   * </pre>
   *
   * input with an extra token between members would force the parser to
   * consume until it found the next class definition rather than the next
   * member definition of the current class.
   *
   * <p>This functionality cost a little bit of effort because the parser has to
   * compare token set at the start of the loop and at each iteration. If for
   * some reason speed is suffering for you, you can turn off this
   * functionality by simply overriding this method as a blank { }.</p>
   *
   */
  sync(recognizer) {
    if (this.inErrorRecoveryMode(recognizer)) {
      return;
    }
    const s3 = recognizer._interp.atn.states[recognizer.state];
    const la = recognizer.getTokenStream().LA(1);
    const nextTokens = recognizer.atn.nextTokens(s3);
    if (nextTokens.contains(la)) {
      this.nextTokensContext = null;
      this.nextTokenState = ATNState.INVALID_STATE_NUMBER;
      return;
    } else if (nextTokens.contains(Token.EPSILON)) {
      if (this.nextTokensContext === null) {
        this.nextTokensContext = recognizer._ctx;
        this.nextTokensState = recognizer._stateNumber;
      }
      return;
    }
    switch (s3.stateType) {
      case ATNState.BLOCK_START:
      case ATNState.STAR_BLOCK_START:
      case ATNState.PLUS_BLOCK_START:
      case ATNState.STAR_LOOP_ENTRY:
        if (this.singleTokenDeletion(recognizer) !== null) {
          return;
        } else {
          throw new InputMismatchException(recognizer);
        }
      case ATNState.PLUS_LOOP_BACK:
      case ATNState.STAR_LOOP_BACK:
        {
          this.reportUnwantedToken(recognizer);
          const expecting = new IntervalSet();
          expecting.addSet(recognizer.getExpectedTokens());
          const whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer));
          this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
        }
        break;
      default:
    }
  }
  /**
   * This is called by {@link //reportError} when the exception is a
   * {@link NoViableAltException}.
   *
   * @see //reportError
   *
   * @param recognizer the parser instance
   * @param e the recognition exception
   */
  reportNoViableAlternative(recognizer, e4) {
    const tokens2 = recognizer.getTokenStream();
    let input;
    if (tokens2 !== null) {
      if (e4.startToken.type === Token.EOF) {
        input = "<EOF>";
      } else {
        input = tokens2.getText(new Interval(e4.startToken.tokenIndex, e4.offendingToken.tokenIndex));
      }
    } else {
      input = "<unknown input>";
    }
    const msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
    recognizer.notifyErrorListeners(msg, e4.offendingToken, e4);
  }
  /**
   * This is called by {@link //reportError} when the exception is an
   * {@link InputMismatchException}.
   *
   * @see //reportError
   *
   * @param recognizer the parser instance
   * @param e the recognition exception
   */
  reportInputMismatch(recognizer, e4) {
    const msg = "mismatched input " + this.getTokenErrorDisplay(e4.offendingToken) + " expecting " + e4.getExpectedTokens().toString(recognizer.literalNames, recognizer.symbolicNames);
    recognizer.notifyErrorListeners(msg, e4.offendingToken, e4);
  }
  /**
   * This is called by {@link //reportError} when the exception is a
   * {@link FailedPredicateException}.
   *
   * @see //reportError
   *
   * @param recognizer the parser instance
   * @param e the recognition exception
   */
  reportFailedPredicate(recognizer, e4) {
    const ruleName = recognizer.ruleNames[recognizer._ctx.ruleIndex];
    const msg = "rule " + ruleName + " " + e4.message;
    recognizer.notifyErrorListeners(msg, e4.offendingToken, e4);
  }
  /**
   * This method is called to report a syntax error which requires the removal
   * of a token from the input stream. At the time this method is called, the
   * erroneous symbol is current {@code LT(1)} symbol and has not yet been
   * removed from the input stream. When this method returns,
   * {@code recognizer} is in error recovery mode.
   *
   * <p>This method is called when {@link //singleTokenDeletion} identifies
   * single-token deletion as a viable recovery strategy for a mismatched
   * input error.</p>
   *
   * <p>The default implementation simply returns if the handler is already in
   * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to
   * enter error recovery mode, followed by calling
   * {@link Parser//notifyErrorListeners}.</p>
   *
   * @param recognizer the parser instance
   *
   */
  reportUnwantedToken(recognizer) {
    if (this.inErrorRecoveryMode(recognizer)) {
      return;
    }
    this.beginErrorCondition(recognizer);
    const t4 = recognizer.getCurrentToken();
    const tokenName = this.getTokenErrorDisplay(t4);
    const expecting = this.getExpectedTokens(recognizer);
    const msg = "extraneous input " + tokenName + " expecting " + expecting.toString(recognizer.literalNames, recognizer.symbolicNames);
    recognizer.notifyErrorListeners(msg, t4, null);
  }
  /**
   * This method is called to report a syntax error which requires the
   * insertion of a missing token into the input stream. At the time this
   * method is called, the missing token has not yet been inserted. When this
   * method returns, {@code recognizer} is in error recovery mode.
   *
   * <p>This method is called when {@link //singleTokenInsertion} identifies
   * single-token insertion as a viable recovery strategy for a mismatched
   * input error.</p>
   *
   * <p>The default implementation simply returns if the handler is already in
   * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to
   * enter error recovery mode, followed by calling
   * {@link Parser//notifyErrorListeners}.</p>
   *
   * @param recognizer the parser instance
   */
  reportMissingToken(recognizer) {
    if (this.inErrorRecoveryMode(recognizer)) {
      return;
    }
    this.beginErrorCondition(recognizer);
    const t4 = recognizer.getCurrentToken();
    const expecting = this.getExpectedTokens(recognizer);
    const msg = "missing " + expecting.toString(recognizer.literalNames, recognizer.symbolicNames) + " at " + this.getTokenErrorDisplay(t4);
    recognizer.notifyErrorListeners(msg, t4, null);
  }
  /**
   * <p>The default implementation attempts to recover from the mismatched input
   * by using single token insertion and deletion as described below. If the
   * recovery attempt fails, this method throws an
   * {@link InputMismatchException}.</p>
   *
   * <p><strong>EXTRA TOKEN</strong> (single token deletion)</p>
   *
   * <p>{@code LA(1)} is not what we are looking for. If {@code LA(2)} has the
   * right token, however, then assume {@code LA(1)} is some extra spurious
   * token and delete it. Then consume and return the next token (which was
   * the {@code LA(2)} token) as the successful result of the match operation.</p>
   *
   * <p>This recovery strategy is implemented by {@link
      * //singleTokenDeletion}.</p>
   *
   * <p><strong>MISSING TOKEN</strong> (single token insertion)</p>
   *
   * <p>If current token (at {@code LA(1)}) is consistent with what could come
   * after the expected {@code LA(1)} token, then assume the token is missing
   * and use the parser's {@link TokenFactory} to create it on the fly. The
   * "insertion" is performed by returning the created token as the successful
   * result of the match operation.</p>
   *
   * <p>This recovery strategy is implemented by {@link
      * //singleTokenInsertion}.</p>
   *
   * <p><strong>EXAMPLE</strong></p>
   *
   * <p>For example, Input {@code i=(3;} is clearly missing the {@code ')'}. When
   * the parser returns from the nested call to {@code expr}, it will have
   * call chain:</p>
   *
   * <pre>
   * stat &rarr; expr &rarr; atom
   * </pre>
   *
   * and it will be trying to match the {@code ')'} at this point in the
   * derivation:
   *
   * <pre>
   * =&gt; ID '=' '(' INT ')' ('+' atom)* ';'
   * ^
   * </pre>
   *
   * The attempt to match {@code ')'} will fail when it sees {@code ';'} and
   * call {@link //recoverInline}. To recover, it sees that {@code LA(1)==';'}
   * is in the set of tokens that can follow the {@code ')'} token reference
   * in rule {@code atom}. It can assume that you forgot the {@code ')'}.
   */
  recoverInline(recognizer) {
    const matchedSymbol = this.singleTokenDeletion(recognizer);
    if (matchedSymbol !== null) {
      recognizer.consume();
      return matchedSymbol;
    }
    if (this.singleTokenInsertion(recognizer)) {
      return this.getMissingSymbol(recognizer);
    }
    throw new InputMismatchException(recognizer);
  }
  /**
   * This method implements the single-token insertion inline error recovery
   * strategy. It is called by {@link //recoverInline} if the single-token
   * deletion strategy fails to recover from the mismatched input. If this
   * method returns {@code true}, {@code recognizer} will be in error recovery
   * mode.
   *
   * <p>This method determines whether or not single-token insertion is viable by
   * checking if the {@code LA(1)} input symbol could be successfully matched
   * if it were instead the {@code LA(2)} symbol. If this method returns
   * {@code true}, the caller is responsible for creating and inserting a
   * token with the correct type to produce this behavior.</p>
   *
   * @param recognizer the parser instance
   * @return {@code true} if single-token insertion is a viable recovery
   * strategy for the current mismatched input, otherwise {@code false}
   */
  singleTokenInsertion(recognizer) {
    const currentSymbolType = recognizer.getTokenStream().LA(1);
    const atn3 = recognizer._interp.atn;
    const currentState = atn3.states[recognizer.state];
    const next2 = currentState.transitions[0].target;
    const expectingAtLL2 = atn3.nextTokens(next2, recognizer._ctx);
    if (expectingAtLL2.contains(currentSymbolType)) {
      this.reportMissingToken(recognizer);
      return true;
    } else {
      return false;
    }
  }
  /**
   * This method implements the single-token deletion inline error recovery
   * strategy. It is called by {@link //recoverInline} to attempt to recover
   * from mismatched input. If this method returns null, the parser and error
   * handler state will not have changed. If this method returns non-null,
   * {@code recognizer} will <em>not</em> be in error recovery mode since the
   * returned token was a successful match.
   *
   * <p>If the single-token deletion is successful, this method calls
   * {@link //reportUnwantedToken} to report the error, followed by
   * {@link Parser//consume} to actually "delete" the extraneous token. Then,
   * before returning {@link //reportMatch} is called to signal a successful
   * match.</p>
   *
   * @param recognizer the parser instance
   * @return the successfully matched {@link Token} instance if single-token
   * deletion successfully recovers from the mismatched input, otherwise
   * {@code null}
   */
  singleTokenDeletion(recognizer) {
    const nextTokenType = recognizer.getTokenStream().LA(2);
    const expecting = this.getExpectedTokens(recognizer);
    if (expecting.contains(nextTokenType)) {
      this.reportUnwantedToken(recognizer);
      recognizer.consume();
      const matchedSymbol = recognizer.getCurrentToken();
      this.reportMatch(recognizer);
      return matchedSymbol;
    } else {
      return null;
    }
  }
  /**
   * Conjure up a missing token during error recovery.
   *
   * The recognizer attempts to recover from single missing
   * symbols. But, actions might refer to that missing symbol.
   * For example, x=ID {f($x);}. The action clearly assumes
   * that there has been an identifier matched previously and that
   * $x points at that token. If that token is missing, but
   * the next token in the stream is what we want we assume that
   * this token is missing and we keep going. Because we
   * have to return some token to replace the missing token,
   * we have to conjure one up. This method gives the user control
   * over the tokens returned for missing tokens. Mostly,
   * you will want to create something special for identifier
   * tokens. For literals such as '{' and ',', the default
   * action in the parser or tree parser works. It simply creates
   * a CommonToken of the appropriate type. The text will be the token.
   * If you change what tokens must be created by the lexer,
   * override this method to create the appropriate tokens.
   *
   */
  getMissingSymbol(recognizer) {
    const currentSymbol = recognizer.getCurrentToken();
    const expecting = this.getExpectedTokens(recognizer);
    const expectedTokenType = expecting.first();
    let tokenText;
    if (expectedTokenType === Token.EOF) {
      tokenText = "<missing EOF>";
    } else {
      tokenText = "<missing " + recognizer.literalNames[expectedTokenType] + ">";
    }
    let current = currentSymbol;
    const lookback = recognizer.getTokenStream().LT(-1);
    if (current.type === Token.EOF && lookback !== null) {
      current = lookback;
    }
    return recognizer.getTokenFactory().create(
      current.source,
      expectedTokenType,
      tokenText,
      Token.DEFAULT_CHANNEL,
      -1,
      -1,
      current.line,
      current.column
    );
  }
  getExpectedTokens(recognizer) {
    return recognizer.getExpectedTokens();
  }
  /**
   * How should a token be displayed in an error message? The default
   * is to display just the text, but during development you might
   * want to have a lot of information spit out. Override in that case
   * to use t.toString() (which, for CommonToken, dumps everything about
   * the token). This is better than forcing you to override a method in
   * your token objects because you don't have to go modify your lexer
   * so that it creates a new Java type.
   */
  getTokenErrorDisplay(t4) {
    if (t4 === null) {
      return "<no token>";
    }
    let s3 = t4.text;
    if (s3 === null) {
      if (t4.type === Token.EOF) {
        s3 = "<EOF>";
      } else {
        s3 = "<" + t4.type + ">";
      }
    }
    return this.escapeWSAndQuote(s3);
  }
  escapeWSAndQuote(s3) {
    s3 = s3.replace(/\n/g, "\\n");
    s3 = s3.replace(/\r/g, "\\r");
    s3 = s3.replace(/\t/g, "\\t");
    return "'" + s3 + "'";
  }
  /**
   * Compute the error recovery set for the current rule. During
   * rule invocation, the parser pushes the set of tokens that can
   * follow that rule reference on the stack; this amounts to
   * computing FIRST of what follows the rule reference in the
   * enclosing rule. See LinearApproximator.FIRST().
   * This local follow set only includes tokens
   * from within the rule; i.e., the FIRST computation done by
   * ANTLR stops at the end of a rule.
   *
   * EXAMPLE
   *
   * When you find a "no viable alt exception", the input is not
   * consistent with any of the alternatives for rule r. The best
   * thing to do is to consume tokens until you see something that
   * can legally follow a call to r//or* any rule that called r.
   * You don't want the exact set of viable next tokens because the
   * input might just be missing a token--you might consume the
   * rest of the input looking for one of the missing tokens.
   *
   * Consider grammar:
   *
   * a : '[' b ']'
   * | '(' b ')'
   * ;
   * b : c '^' INT ;
   * c : ID
   * | INT
   * ;
   *
   * At each rule invocation, the set of tokens that could follow
   * that rule is pushed on a stack. Here are the various
   * context-sensitive follow sets:
   *
   * FOLLOW(b1_in_a) = FIRST(']') = ']'
   * FOLLOW(b2_in_a) = FIRST(')') = ')'
   * FOLLOW(c_in_b) = FIRST('^') = '^'
   *
   * Upon erroneous input "[]", the call chain is
   *
   * a -> b -> c
   *
   * and, hence, the follow context stack is:
   *
   * depth follow set start of rule execution
   * 0 <EOF> a (from main())
   * 1 ']' b
   * 2 '^' c
   *
   * Notice that ')' is not included, because b would have to have
   * been called from a different context in rule a for ')' to be
   * included.
   *
   * For error recovery, we cannot consider FOLLOW(c)
   * (context-sensitive or otherwise). We need the combined set of
   * all context-sensitive FOLLOW sets--the set of all tokens that
   * could follow any reference in the call chain. We need to
   * resync to one of those tokens. Note that FOLLOW(c)='^' and if
   * we resync'd to that token, we'd consume until EOF. We need to
   * sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
   * In this case, for input "[]", LA(1) is ']' and in the set, so we would
   * not consume anything. After printing an error, rule c would
   * return normally. Rule b would not find the required '^' though.
   * At this point, it gets a mismatched token error and throws an
   * exception (since LA(1) is not in the viable following token
   * set). The rule exception handler tries to recover, but finds
   * the same recovery set and doesn't consume anything. Rule b
   * exits normally returning to rule a. Now it finds the ']' (and
   * with the successful match exits errorRecovery mode).
   *
   * So, you can see that the parser walks up the call chain looking
   * for the token that was a member of the recovery set.
   *
   * Errors are not generated in errorRecovery mode.
   *
   * ANTLR's error recovery mechanism is based upon original ideas:
   *
   * "Algorithms + Data Structures = Programs" by Niklaus Wirth
   *
   * and
   *
   * "A note on error recovery in recursive descent parsers":
   * http://portal.acm.org/citation.cfm?id=947902.947905
   *
   * Later, Josef Grosch had some good ideas:
   *
   * "Efficient and Comfortable Error Recovery in Recursive Descent
   * Parsers":
   * ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
   *
   * Like Grosch I implement context-sensitive FOLLOW sets that are combined
   * at run-time upon error to avoid overhead during parsing.
   */
  getErrorRecoverySet(recognizer) {
    const atn3 = recognizer._interp.atn;
    let ctx = recognizer._ctx;
    const recoverSet = new IntervalSet();
    while (ctx !== null && ctx.invokingState >= 0) {
      const invokingState = atn3.states[ctx.invokingState];
      const rt2 = invokingState.transitions[0];
      const follow = atn3.nextTokens(rt2.followState);
      recoverSet.addSet(follow);
      ctx = ctx.parentCtx;
    }
    recoverSet.removeOne(Token.EPSILON);
    return recoverSet;
  }
  // Consume tokens until one matches the given token set.//
  consumeUntil(recognizer, set2) {
    let ttype = recognizer.getTokenStream().LA(1);
    while (ttype !== Token.EOF && !set2.contains(ttype)) {
      recognizer.consume();
      ttype = recognizer.getTokenStream().LA(1);
    }
  }
};

// node_modules/antlr4/src/antlr4/error/BailErrorStrategy.js
var BailErrorStrategy = class extends DefaultErrorStrategy {
  constructor() {
    super();
  }
  /**
   * Instead of recovering from exception {@code e}, re-throw it wrapped
   * in a {@link ParseCancellationException} so it is not caught by the
   * rule function catches. Use {@link Exception//getCause()} to get the
   * original {@link RecognitionException}.
   */
  recover(recognizer, e4) {
    let context = recognizer._ctx;
    while (context !== null) {
      context.exception = e4;
      context = context.parentCtx;
    }
    throw new ParseCancellationException(e4);
  }
  /**
   * Make sure we don't attempt to recover inline; if the parser
   * successfully recovers, it won't throw an exception.
   */
  recoverInline(recognizer) {
    this.recover(recognizer, new InputMismatchException(recognizer));
  }
  // Make sure we don't attempt to recover from problems in subrules.//
  sync(recognizer) {
  }
};

// node_modules/antlr4/src/antlr4/error/index.js
var error_default = {
  RecognitionException,
  NoViableAltException,
  LexerNoViableAltException,
  InputMismatchException,
  FailedPredicateException,
  DiagnosticErrorListener,
  BailErrorStrategy,
  DefaultErrorStrategy,
  ErrorListener
};

// node_modules/antlr4/src/antlr4/InputStream.js
var InputStream = class {
  constructor(data, decodeToUnicodeCodePoints) {
    this.name = "<empty>";
    this.strdata = data;
    this.decodeToUnicodeCodePoints = decodeToUnicodeCodePoints || false;
    this._index = 0;
    this.data = [];
    if (this.decodeToUnicodeCodePoints) {
      for (let i2 = 0; i2 < this.strdata.length; ) {
        const codePoint = this.strdata.codePointAt(i2);
        this.data.push(codePoint);
        i2 += codePoint <= 65535 ? 1 : 2;
      }
    } else {
      this.data = new Array(this.strdata.length);
      for (let i2 = 0; i2 < this.strdata.length; i2++) {
        const codeUnit = this.strdata.charCodeAt(i2);
        this.data[i2] = codeUnit;
      }
    }
    this._size = this.data.length;
  }
  /**
   * Reset the stream so that it's in the same state it was
   * when the object was created *except* the data array is not
   * touched.
   */
  reset() {
    this._index = 0;
  }
  consume() {
    if (this._index >= this._size) {
      throw "cannot consume EOF";
    }
    this._index += 1;
  }
  LA(offset3) {
    if (offset3 === 0) {
      return 0;
    }
    if (offset3 < 0) {
      offset3 += 1;
    }
    const pos = this._index + offset3 - 1;
    if (pos < 0 || pos >= this._size) {
      return Token.EOF;
    }
    return this.data[pos];
  }
  LT(offset3) {
    return this.LA(offset3);
  }
  // mark/release do nothing; we have entire buffer
  mark() {
    return -1;
  }
  release(marker) {
  }
  /**
   * consume() ahead until p==_index; can't just set p=_index as we must
   * update line and column. If we seek backwards, just set p
   */
  seek(_index) {
    if (_index <= this._index) {
      this._index = _index;
      return;
    }
    this._index = Math.min(_index, this._size);
  }
  getText(start2, stop) {
    if (stop >= this._size) {
      stop = this._size - 1;
    }
    if (start2 >= this._size) {
      return "";
    } else {
      if (this.decodeToUnicodeCodePoints) {
        let result = "";
        for (let i2 = start2; i2 <= stop; i2++) {
          result += String.fromCodePoint(this.data[i2]);
        }
        return result;
      } else {
        return this.strdata.slice(start2, stop + 1);
      }
    }
  }
  toString() {
    return this.strdata;
  }
  get index() {
    return this._index;
  }
  get size() {
    return this._size;
  }
};

// node_modules/antlr4/src/antlr4/TokenStream.js
var TokenStream = class {
};

// node_modules/antlr4/src/antlr4/BufferedTokenStream.js
var BufferedTokenStream = class extends TokenStream {
  constructor(tokenSource) {
    super();
    this.tokenSource = tokenSource;
    this.tokens = [];
    this.index = -1;
    this.fetchedEOF = false;
  }
  mark() {
    return 0;
  }
  release(marker) {
  }
  reset() {
    this.seek(0);
  }
  seek(index4) {
    this.lazyInit();
    this.index = this.adjustSeekIndex(index4);
  }
  get(index4) {
    this.lazyInit();
    return this.tokens[index4];
  }
  consume() {
    let skipEofCheck = false;
    if (this.index >= 0) {
      if (this.fetchedEOF) {
        skipEofCheck = this.index < this.tokens.length - 1;
      } else {
        skipEofCheck = this.index < this.tokens.length;
      }
    } else {
      skipEofCheck = false;
    }
    if (!skipEofCheck && this.LA(1) === Token.EOF) {
      throw "cannot consume EOF";
    }
    if (this.sync(this.index + 1)) {
      this.index = this.adjustSeekIndex(this.index + 1);
    }
  }
  /**
   * Make sure index {@code i} in tokens has a token.
   *
   * @return {Boolean} {@code true} if a token is located at index {@code i}, otherwise
   * {@code false}.
   * @see //get(int i)
   */
  sync(i2) {
    const n = i2 - this.tokens.length + 1;
    if (n > 0) {
      const fetched = this.fetch(n);
      return fetched >= n;
    }
    return true;
  }
  /**
   * Add {@code n} elements to buffer.
   *
   * @return {Number} The actual number of elements added to the buffer.
   */
  fetch(n) {
    if (this.fetchedEOF) {
      return 0;
    }
    for (let i2 = 0; i2 < n; i2++) {
      const t4 = this.tokenSource.nextToken();
      t4.tokenIndex = this.tokens.length;
      this.tokens.push(t4);
      if (t4.type === Token.EOF) {
        this.fetchedEOF = true;
        return i2 + 1;
      }
    }
    return n;
  }
  // Get all tokens from start..stop inclusively///
  getTokens(start2, stop, types2) {
    if (types2 === void 0) {
      types2 = null;
    }
    if (start2 < 0 || stop < 0) {
      return null;
    }
    this.lazyInit();
    const subset = [];
    if (stop >= this.tokens.length) {
      stop = this.tokens.length - 1;
    }
    for (let i2 = start2; i2 < stop; i2++) {
      const t4 = this.tokens[i2];
      if (t4.type === Token.EOF) {
        break;
      }
      if (types2 === null || types2.contains(t4.type)) {
        subset.push(t4);
      }
    }
    return subset;
  }
  LA(i2) {
    return this.LT(i2).type;
  }
  LB(k2) {
    if (this.index - k2 < 0) {
      return null;
    }
    return this.tokens[this.index - k2];
  }
  LT(k2) {
    this.lazyInit();
    if (k2 === 0) {
      return null;
    }
    if (k2 < 0) {
      return this.LB(-k2);
    }
    const i2 = this.index + k2 - 1;
    this.sync(i2);
    if (i2 >= this.tokens.length) {
      return this.tokens[this.tokens.length - 1];
    }
    return this.tokens[i2];
  }
  /**
   * Allowed derived classes to modify the behavior of operations which change
   * the current stream position by adjusting the target token index of a seek
   * operation. The default implementation simply returns {@code i}. If an
   * exception is thrown in this method, the current stream index should not be
   * changed.
   *
   * <p>For example, {@link CommonTokenStream} overrides this method to ensure
   * that
   * the seek target is always an on-channel token.</p>
   *
   * @param {Number} i The target token index.
   * @return {Number} The adjusted target token index.
   */
  adjustSeekIndex(i2) {
    return i2;
  }
  lazyInit() {
    if (this.index === -1) {
      this.setup();
    }
  }
  setup() {
    this.sync(0);
    this.index = this.adjustSeekIndex(0);
  }
  // Reset this token stream by setting its token source.///
  setTokenSource(tokenSource) {
    this.tokenSource = tokenSource;
    this.tokens = [];
    this.index = -1;
    this.fetchedEOF = false;
  }
  /**
   * Given a starting index, return the index of the next token on channel.
   * Return i if tokens[i] is on channel. Return -1 if there are no tokens
   * on channel between i and EOF.
   */
  nextTokenOnChannel(i2, channel) {
    this.sync(i2);
    if (i2 >= this.tokens.length) {
      return -1;
    }
    let token2 = this.tokens[i2];
    while (token2.channel !== this.channel) {
      if (token2.type === Token.EOF) {
        return -1;
      }
      i2 += 1;
      this.sync(i2);
      token2 = this.tokens[i2];
    }
    return i2;
  }
  /**
   * Given a starting index, return the index of the previous token on channel.
   * Return i if tokens[i] is on channel. Return -1 if there are no tokens
   * on channel between i and 0.
   */
  previousTokenOnChannel(i2, channel) {
    while (i2 >= 0 && this.tokens[i2].channel !== channel) {
      i2 -= 1;
    }
    return i2;
  }
  /**
   * Collect all tokens on specified channel to the right of
   * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or
   * EOF. If channel is -1, find any non default channel token.
   */
  getHiddenTokensToRight(tokenIndex, channel) {
    if (channel === void 0) {
      channel = -1;
    }
    this.lazyInit();
    if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
      throw "" + tokenIndex + " not in 0.." + this.tokens.length - 1;
    }
    const nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer.DEFAULT_TOKEN_CHANNEL);
    const from_ = tokenIndex + 1;
    const to = nextOnChannel === -1 ? this.tokens.length - 1 : nextOnChannel;
    return this.filterForChannel(from_, to, channel);
  }
  /**
   * Collect all tokens on specified channel to the left of
   * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL.
   * If channel is -1, find any non default channel token.
   */
  getHiddenTokensToLeft(tokenIndex, channel) {
    if (channel === void 0) {
      channel = -1;
    }
    this.lazyInit();
    if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
      throw "" + tokenIndex + " not in 0.." + this.tokens.length - 1;
    }
    const prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer.DEFAULT_TOKEN_CHANNEL);
    if (prevOnChannel === tokenIndex - 1) {
      return null;
    }
    const from_ = prevOnChannel + 1;
    const to = tokenIndex - 1;
    return this.filterForChannel(from_, to, channel);
  }
  filterForChannel(left2, right2, channel) {
    const hidden = [];
    for (let i2 = left2; i2 < right2 + 1; i2++) {
      const t4 = this.tokens[i2];
      if (channel === -1) {
        if (t4.channel !== Lexer.DEFAULT_TOKEN_CHANNEL) {
          hidden.push(t4);
        }
      } else if (t4.channel === channel) {
        hidden.push(t4);
      }
    }
    if (hidden.length === 0) {
      return null;
    }
    return hidden;
  }
  getSourceName() {
    return this.tokenSource.getSourceName();
  }
  // Get the text of all tokens in this buffer.///
  getText(interval) {
    this.lazyInit();
    this.fill();
    if (interval === void 0 || interval === null) {
      interval = new Interval(0, this.tokens.length - 1);
    }
    let start2 = interval.start;
    if (start2 instanceof Token) {
      start2 = start2.tokenIndex;
    }
    let stop = interval.stop;
    if (stop instanceof Token) {
      stop = stop.tokenIndex;
    }
    if (start2 === null || stop === null || start2 < 0 || stop < 0) {
      return "";
    }
    if (stop >= this.tokens.length) {
      stop = this.tokens.length - 1;
    }
    let s3 = "";
    for (let i2 = start2; i2 < stop + 1; i2++) {
      const t4 = this.tokens[i2];
      if (t4.type === Token.EOF) {
        break;
      }
      s3 = s3 + t4.text;
    }
    return s3;
  }
  // Get all tokens from lexer until EOF///
  fill() {
    this.lazyInit();
    while (this.fetch(1e3) === 1e3) {
      continue;
    }
  }
};

// node_modules/antlr4/src/antlr4/CommonTokenStream.js
var CommonTokenStream = class extends BufferedTokenStream {
  constructor(lexer, channel) {
    super(lexer);
    this.channel = channel === void 0 ? Token.DEFAULT_CHANNEL : channel;
  }
  adjustSeekIndex(i2) {
    return this.nextTokenOnChannel(i2, this.channel);
  }
  LB(k2) {
    if (k2 === 0 || this.index - k2 < 0) {
      return null;
    }
    let i2 = this.index;
    let n = 1;
    while (n <= k2) {
      i2 = this.previousTokenOnChannel(i2 - 1, this.channel);
      n += 1;
    }
    if (i2 < 0) {
      return null;
    }
    return this.tokens[i2];
  }
  LT(k2) {
    this.lazyInit();
    if (k2 === 0) {
      return null;
    }
    if (k2 < 0) {
      return this.LB(-k2);
    }
    let i2 = this.index;
    let n = 1;
    while (n < k2) {
      if (this.sync(i2 + 1)) {
        i2 = this.nextTokenOnChannel(i2 + 1, this.channel);
      }
      n += 1;
    }
    return this.tokens[i2];
  }
  // Count EOF just once.
  getNumberOfOnChannelTokens() {
    let n = 0;
    this.fill();
    for (let i2 = 0; i2 < this.tokens.length; i2++) {
      const t4 = this.tokens[i2];
      if (t4.channel === this.channel) {
        n += 1;
      }
      if (t4.type === Token.EOF) {
        break;
      }
    }
    return n;
  }
};

// node_modules/antlr4/src/antlr4/TraceListener.js
var TraceListener = class extends ParseTreeListener {
  constructor(parser) {
    super();
    this.parser = parser;
  }
  enterEveryRule(ctx) {
    console.log("enter   " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
  }
  visitTerminal(node3) {
    console.log("consume " + node3.symbol + " rule " + this.parser.ruleNames[this.parser._ctx.ruleIndex]);
  }
  exitEveryRule(ctx) {
    console.log("exit    " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
  }
};

// node_modules/antlr4/src/antlr4/Parser.js
var Parser3 = class extends Recognizer {
  /**
   * this is all the parsing support code essentially; most of it is error
   * recovery stuff.
   */
  constructor(input) {
    super();
    this._input = null;
    this._errHandler = new DefaultErrorStrategy();
    this._precedenceStack = [];
    this._precedenceStack.push(0);
    this._ctx = null;
    this.buildParseTrees = true;
    this._tracer = null;
    this._parseListeners = null;
    this._syntaxErrors = 0;
    this.setInputStream(input);
  }
  // reset the parser's state
  reset() {
    if (this._input !== null) {
      this._input.seek(0);
    }
    this._errHandler.reset(this);
    this._ctx = null;
    this._syntaxErrors = 0;
    this.setTrace(false);
    this._precedenceStack = [];
    this._precedenceStack.push(0);
    if (this._interp !== null) {
      this._interp.reset();
    }
  }
  /**
   * Match current input symbol against {@code ttype}. If the symbol type
   * matches, {@link ANTLRErrorStrategy//reportMatch} and {@link //consume} are
   * called to complete the match process.
   *
   * <p>If the symbol type does not match,
   * {@link ANTLRErrorStrategy//recoverInline} is called on the current error
   * strategy to attempt recovery. If {@link //getBuildParseTree} is
   * {@code true} and the token index of the symbol returned by
   * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
   * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>
   *
   * @param ttype the token type to match
   * @return the matched symbol
   * @throws RecognitionException if the current input symbol did not match
   * {@code ttype} and the error strategy could not recover from the
   * mismatched symbol
   */
  match(ttype) {
    let t4 = this.getCurrentToken();
    if (t4.type === ttype) {
      this._errHandler.reportMatch(this);
      this.consume();
    } else {
      t4 = this._errHandler.recoverInline(this);
      if (this.buildParseTrees && t4.tokenIndex === -1) {
        this._ctx.addErrorNode(t4);
      }
    }
    return t4;
  }
  /**
   * Match current input symbol as a wildcard. If the symbol type matches
   * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy//reportMatch}
   * and {@link //consume} are called to complete the match process.
   *
   * <p>If the symbol type does not match,
   * {@link ANTLRErrorStrategy//recoverInline} is called on the current error
   * strategy to attempt recovery. If {@link //getBuildParseTree} is
   * {@code true} and the token index of the symbol returned by
   * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
   * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>
   *
   * @return the matched symbol
   * @throws RecognitionException if the current input symbol did not match
   * a wildcard and the error strategy could not recover from the mismatched
   * symbol
   */
  matchWildcard() {
    let t4 = this.getCurrentToken();
    if (t4.type > 0) {
      this._errHandler.reportMatch(this);
      this.consume();
    } else {
      t4 = this._errHandler.recoverInline(this);
      if (this._buildParseTrees && t4.tokenIndex === -1) {
        this._ctx.addErrorNode(t4);
      }
    }
    return t4;
  }
  getParseListeners() {
    return this._parseListeners || [];
  }
  /**
   * Registers {@code listener} to receive events during the parsing process.
   *
   * <p>To support output-preserving grammar transformations (including but not
   * limited to left-recursion removal, automated left-factoring, and
   * optimized code generation), calls to listener methods during the parse
   * may differ substantially from calls made by
   * {@link ParseTreeWalker//DEFAULT} used after the parse is complete. In
   * particular, rule entry and exit events may occur in a different order
   * during the parse than after the parser. In addition, calls to certain
   * rule entry methods may be omitted.</p>
   *
   * <p>With the following specific exceptions, calls to listener events are
   * <em>deterministic</em>, i.e. for identical input the calls to listener
   * methods will be the same.</p>
   *
   * <ul>
   * <li>Alterations to the grammar used to generate code may change the
   * behavior of the listener calls.</li>
   * <li>Alterations to the command line options passed to ANTLR 4 when
   * generating the parser may change the behavior of the listener calls.</li>
   * <li>Changing the version of the ANTLR Tool used to generate the parser
   * may change the behavior of the listener calls.</li>
   * </ul>
   *
   * @param listener the listener to add
   *
   * @throws NullPointerException if {@code} listener is {@code null}
   */
  addParseListener(listener) {
    if (listener === null) {
      throw "listener";
    }
    if (this._parseListeners === null) {
      this._parseListeners = [];
    }
    this._parseListeners.push(listener);
  }
  /**
   * Remove {@code listener} from the list of parse listeners.
   *
   * <p>If {@code listener} is {@code null} or has not been added as a parse
   * listener, this method does nothing.</p>
   * @param listener the listener to remove
   */
  removeParseListener(listener) {
    if (this._parseListeners !== null) {
      const idx = this._parseListeners.indexOf(listener);
      if (idx >= 0) {
        this._parseListeners.splice(idx, 1);
      }
      if (this._parseListeners.length === 0) {
        this._parseListeners = null;
      }
    }
  }
  // Remove all parse listeners.
  removeParseListeners() {
    this._parseListeners = null;
  }
  // Notify any parse listeners of an enter rule event.
  triggerEnterRuleEvent() {
    if (this._parseListeners !== null) {
      const ctx = this._ctx;
      this._parseListeners.forEach(function(listener) {
        listener.enterEveryRule(ctx);
        ctx.enterRule(listener);
      });
    }
  }
  /**
   * Notify any parse listeners of an exit rule event.
   * @see //addParseListener
   */
  triggerExitRuleEvent() {
    if (this._parseListeners !== null) {
      const ctx = this._ctx;
      this._parseListeners.slice(0).reverse().forEach(function(listener) {
        ctx.exitRule(listener);
        listener.exitEveryRule(ctx);
      });
    }
  }
  getTokenFactory() {
    return this._input.tokenSource._factory;
  }
  // Tell our token source and error strategy about a new way to create tokens.
  setTokenFactory(factory) {
    this._input.tokenSource._factory = factory;
  }
  /**
   * The ATN with bypass alternatives is expensive to create so we create it
   * lazily.
   *
   * @throws UnsupportedOperationException if the current parser does not
   * implement the {@link //getSerializedATN()} method.
   */
  getATNWithBypassAlts() {
    const serializedAtn = this.getSerializedATN();
    if (serializedAtn === null) {
      throw "The current parser does not support an ATN with bypass alternatives.";
    }
    let result = this.bypassAltsAtnCache[serializedAtn];
    if (result === null) {
      const deserializationOptions = new ATNDeserializationOptions();
      deserializationOptions.generateRuleBypassTransitions = true;
      result = new ATNDeserializer(deserializationOptions).deserialize(serializedAtn);
      this.bypassAltsAtnCache[serializedAtn] = result;
    }
    return result;
  }
  getInputStream() {
    return this.getTokenStream();
  }
  setInputStream(input) {
    this.setTokenStream(input);
  }
  getTokenStream() {
    return this._input;
  }
  // Set the token stream and reset the parser.
  setTokenStream(input) {
    this._input = null;
    this.reset();
    this._input = input;
  }
  /**
   * Match needs to return the current input symbol, which gets put
   * into the label for the associated token ref; e.g., x=ID.
   */
  getCurrentToken() {
    return this._input.LT(1);
  }
  notifyErrorListeners(msg, offendingToken, err) {
    offendingToken = offendingToken || null;
    err = err || null;
    if (offendingToken === null) {
      offendingToken = this.getCurrentToken();
    }
    this._syntaxErrors += 1;
    const line2 = offendingToken.line;
    const column2 = offendingToken.column;
    const listener = this.getErrorListenerDispatch();
    listener.syntaxError(this, offendingToken, line2, column2, msg, err);
  }
  /**
   * Consume and return the {@linkplain //getCurrentToken current symbol}.
   *
   * <p>E.g., given the following input with {@code A} being the current
   * lookahead symbol, this function moves the cursor to {@code B} and returns
   * {@code A}.</p>
   *
   * <pre>
   * A B
   * ^
   * </pre>
   *
   * If the parser is not in error recovery mode, the consumed symbol is added
   * to the parse tree using {@link ParserRuleContext//addChild(Token)}, and
   * {@link ParseTreeListener//visitTerminal} is called on any parse listeners.
   * If the parser <em>is</em> in error recovery mode, the consumed symbol is
   * added to the parse tree using
   * {@link ParserRuleContext//addErrorNode(Token)}, and
   * {@link ParseTreeListener//visitErrorNode} is called on any parse
   * listeners.
   */
  consume() {
    const o = this.getCurrentToken();
    if (o.type !== Token.EOF) {
      this.getInputStream().consume();
    }
    const hasListener = this._parseListeners !== null && this._parseListeners.length > 0;
    if (this.buildParseTrees || hasListener) {
      let node3;
      if (this._errHandler.inErrorRecoveryMode(this)) {
        node3 = this._ctx.addErrorNode(o);
      } else {
        node3 = this._ctx.addTokenNode(o);
      }
      node3.invokingState = this.state;
      if (hasListener) {
        this._parseListeners.forEach(function(listener) {
          if (node3 instanceof ErrorNode || node3.isErrorNode !== void 0 && node3.isErrorNode()) {
            listener.visitErrorNode(node3);
          } else if (node3 instanceof TerminalNode) {
            listener.visitTerminal(node3);
          }
        });
      }
    }
    return o;
  }
  addContextToParseTree() {
    if (this._ctx.parentCtx !== null) {
      this._ctx.parentCtx.addChild(this._ctx);
    }
  }
  /**
   * Always called by generated parsers upon entry to a rule. Access field
   * {@link //_ctx} get the current context.
   */
  enterRule(localctx, state, ruleIndex) {
    this.state = state;
    this._ctx = localctx;
    this._ctx.start = this._input.LT(1);
    if (this.buildParseTrees) {
      this.addContextToParseTree();
    }
    this.triggerEnterRuleEvent();
  }
  exitRule() {
    this._ctx.stop = this._input.LT(-1);
    this.triggerExitRuleEvent();
    this.state = this._ctx.invokingState;
    this._ctx = this._ctx.parentCtx;
  }
  enterOuterAlt(localctx, altNum) {
    localctx.setAltNumber(altNum);
    if (this.buildParseTrees && this._ctx !== localctx) {
      if (this._ctx.parentCtx !== null) {
        this._ctx.parentCtx.removeLastChild();
        this._ctx.parentCtx.addChild(localctx);
      }
    }
    this._ctx = localctx;
  }
  /**
   * Get the precedence level for the top-most precedence rule.
   *
   * @return The precedence level for the top-most precedence rule, or -1 if
   * the parser context is not nested within a precedence rule.
   */
  getPrecedence() {
    if (this._precedenceStack.length === 0) {
      return -1;
    } else {
      return this._precedenceStack[this._precedenceStack.length - 1];
    }
  }
  enterRecursionRule(localctx, state, ruleIndex, precedence) {
    this.state = state;
    this._precedenceStack.push(precedence);
    this._ctx = localctx;
    this._ctx.start = this._input.LT(1);
    this.triggerEnterRuleEvent();
  }
  // Like {@link //enterRule} but for recursive rules.
  pushNewRecursionContext(localctx, state, ruleIndex) {
    const previous = this._ctx;
    previous.parentCtx = localctx;
    previous.invokingState = state;
    previous.stop = this._input.LT(-1);
    this._ctx = localctx;
    this._ctx.start = previous.start;
    if (this.buildParseTrees) {
      this._ctx.addChild(previous);
    }
    this.triggerEnterRuleEvent();
  }
  unrollRecursionContexts(parentCtx) {
    this._precedenceStack.pop();
    this._ctx.stop = this._input.LT(-1);
    const retCtx = this._ctx;
    const parseListeners = this.getParseListeners();
    if (parseListeners !== null && parseListeners.length > 0) {
      while (this._ctx !== parentCtx) {
        this.triggerExitRuleEvent();
        this._ctx = this._ctx.parentCtx;
      }
    } else {
      this._ctx = parentCtx;
    }
    retCtx.parentCtx = parentCtx;
    if (this.buildParseTrees && parentCtx !== null) {
      parentCtx.addChild(retCtx);
    }
  }
  getInvokingContext(ruleIndex) {
    let ctx = this._ctx;
    while (ctx !== null) {
      if (ctx.ruleIndex === ruleIndex) {
        return ctx;
      }
      ctx = ctx.parentCtx;
    }
    return null;
  }
  precpred(localctx, precedence) {
    return precedence >= this._precedenceStack[this._precedenceStack.length - 1];
  }
  inContext(context) {
    return false;
  }
  /**
   * Checks whether or not {@code symbol} can follow the current state in the
   * ATN. The behavior of this method is equivalent to the following, but is
   * implemented such that the complete context-sensitive follow set does not
   * need to be explicitly constructed.
   *
   * <pre>
   * return getExpectedTokens().contains(symbol);
   * </pre>
   *
   * @param symbol the symbol type to check
   * @return {@code true} if {@code symbol} can follow the current state in
   * the ATN, otherwise {@code false}.
   */
  isExpectedToken(symbol) {
    const atn3 = this._interp.atn;
    let ctx = this._ctx;
    const s3 = atn3.states[this.state];
    let following = atn3.nextTokens(s3);
    if (following.contains(symbol)) {
      return true;
    }
    if (!following.contains(Token.EPSILON)) {
      return false;
    }
    while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
      const invokingState = atn3.states[ctx.invokingState];
      const rt2 = invokingState.transitions[0];
      following = atn3.nextTokens(rt2.followState);
      if (following.contains(symbol)) {
        return true;
      }
      ctx = ctx.parentCtx;
    }
    if (following.contains(Token.EPSILON) && symbol === Token.EOF) {
      return true;
    } else {
      return false;
    }
  }
  /**
   * Computes the set of input symbols which could follow the current parser
   * state and context, as given by {@link //getState} and {@link //getContext},
   * respectively.
   *
   * @see ATN//getExpectedTokens(int, RuleContext)
   */
  getExpectedTokens() {
    return this._interp.atn.getExpectedTokens(this.state, this._ctx);
  }
  getExpectedTokensWithinCurrentRule() {
    const atn3 = this._interp.atn;
    const s3 = atn3.states[this.state];
    return atn3.nextTokens(s3);
  }
  // Get a rule's index (i.e., {@code RULE_ruleName} field) or -1 if not found.
  getRuleIndex(ruleName) {
    const ruleIndex = this.getRuleIndexMap()[ruleName];
    if (ruleIndex !== null) {
      return ruleIndex;
    } else {
      return -1;
    }
  }
  /**
   * Return List&lt;String&gt; of the rule names in your parser instance
   * leading up to a call to the current rule. You could override if
   * you want more details such as the file/line info of where
   * in the ATN a rule is invoked.
   *
   * this is very useful for error messages.
   */
  getRuleInvocationStack(p) {
    p = p || null;
    if (p === null) {
      p = this._ctx;
    }
    const stack = [];
    while (p !== null) {
      const ruleIndex = p.ruleIndex;
      if (ruleIndex < 0) {
        stack.push("n/a");
      } else {
        stack.push(this.ruleNames[ruleIndex]);
      }
      p = p.parentCtx;
    }
    return stack;
  }
  // For debugging and other purposes.
  getDFAStrings() {
    return this._interp.decisionToDFA.toString();
  }
  // For debugging and other purposes.
  dumpDFA() {
    let seenOne = false;
    for (let i2 = 0; i2 < this._interp.decisionToDFA.length; i2++) {
      const dfa = this._interp.decisionToDFA[i2];
      if (dfa.states.length > 0) {
        if (seenOne) {
          console.log();
        }
        this.printer.println("Decision " + dfa.decision + ":");
        this.printer.print(dfa.toString(this.literalNames, this.symbolicNames));
        seenOne = true;
      }
    }
  }
  /*
      "			printer = function() {\r\n" +
      "				this.println = function(s) { document.getElementById('output') += s + '\\n'; }\r\n" +
      "				this.print = function(s) { document.getElementById('output') += s; }\r\n" +
      "			};\r\n" +
      */
  getSourceName() {
    return this._input.sourceName;
  }
  /**
   * During a parse is sometimes useful to listen in on the rule entry and exit
   * events as well as token matches. this is for quick and dirty debugging.
   */
  setTrace(trace) {
    if (!trace) {
      this.removeParseListener(this._tracer);
      this._tracer = null;
    } else {
      if (this._tracer !== null) {
        this.removeParseListener(this._tracer);
      }
      this._tracer = new TraceListener(this);
      this.addParseListener(this._tracer);
    }
  }
};
Parser3.bypassAltsAtnCache = {};

// node_modules/antlr4/src/antlr4/atn/PredictionContextCache.js
var PredictionContextCache = class {
  constructor() {
    this.cache = new HashMap();
  }
  /**
   * Add a context to the cache and return it. If the context already exists,
   * return that one instead and do not add a new context to the cache.
   * Protect shared cache from unsafe thread access.
   */
  add(ctx) {
    if (ctx === PredictionContext.EMPTY) {
      return PredictionContext.EMPTY;
    }
    const existing = this.cache.get(ctx) || null;
    if (existing !== null) {
      return existing;
    }
    this.cache.set(ctx, ctx);
    return ctx;
  }
  get(ctx) {
    return this.cache.get(ctx) || null;
  }
  get length() {
    return this.cache.length;
  }
};

// node_modules/antlr4/src/antlr4/tree/TerminalNodeImpl.js
var TerminalNodeImpl = class extends TerminalNode {
  constructor(symbol) {
    super();
    this.parentCtx = null;
    this.symbol = symbol;
  }
  getChild(i2) {
    return null;
  }
  getSymbol() {
    return this.symbol;
  }
  getParent() {
    return this.parentCtx;
  }
  getPayload() {
    return this.symbol;
  }
  getSourceInterval() {
    if (this.symbol === null) {
      return Interval.INVALID_INTERVAL;
    }
    const tokenIndex = this.symbol.tokenIndex;
    return new Interval(tokenIndex, tokenIndex);
  }
  getChildCount() {
    return 0;
  }
  accept(visitor) {
    return visitor.visitTerminal(this);
  }
  getText() {
    return this.symbol.text;
  }
  toString() {
    if (this.symbol.type === Token.EOF) {
      return "<EOF>";
    } else {
      return this.symbol.text;
    }
  }
};

// node_modules/antlr4/src/antlr4/tree/ErrorNodeImpl.js
var ErrorNodeImpl = class extends TerminalNodeImpl {
  constructor(token2) {
    super(token2);
  }
  isErrorNode() {
    return true;
  }
  accept(visitor) {
    return visitor.visitErrorNode(this);
  }
};

// node_modules/antlr4/src/antlr4/context/ParserRuleContext.js
var ParserRuleContext = class extends RuleContext {
  constructor(parent, invokingStateNumber) {
    parent = parent || null;
    invokingStateNumber = invokingStateNumber || null;
    super(parent, invokingStateNumber);
    this.ruleIndex = -1;
    this.children = null;
    this.start = null;
    this.stop = null;
    this.exception = null;
  }
  // COPY a ctx (I'm deliberately not using copy constructor)
  copyFrom(ctx) {
    this.parentCtx = ctx.parentCtx;
    this.invokingState = ctx.invokingState;
    this.children = null;
    this.start = ctx.start;
    this.stop = ctx.stop;
    if (ctx.children) {
      this.children = [];
      ctx.children.map(function(child) {
        if (child instanceof ErrorNodeImpl) {
          this.children.push(child);
          child.parentCtx = this;
        }
      }, this);
    }
  }
  // Double dispatch methods for listeners
  enterRule(listener) {
  }
  exitRule(listener) {
  }
  // Does not set parent link; other add methods do that
  addChild(child) {
    if (this.children === null) {
      this.children = [];
    }
    this.children.push(child);
    return child;
  }
  /** Used by enterOuterAlt to toss out a RuleContext previously added as
   * we entered a rule. If we have // label, we will need to remove
   * generic ruleContext object.
   */
  removeLastChild() {
    if (this.children !== null) {
      this.children.pop();
    }
  }
  addTokenNode(token2) {
    const node3 = new TerminalNodeImpl(token2);
    this.addChild(node3);
    node3.parentCtx = this;
    return node3;
  }
  addErrorNode(badToken) {
    const node3 = new ErrorNodeImpl(badToken);
    this.addChild(node3);
    node3.parentCtx = this;
    return node3;
  }
  getChild(i2, type) {
    type = type || null;
    if (this.children === null || i2 < 0 || i2 >= this.children.length) {
      return null;
    }
    if (type === null) {
      return this.children[i2];
    } else {
      for (let j = 0; j < this.children.length; j++) {
        const child = this.children[j];
        if (child instanceof type) {
          if (i2 === 0) {
            return child;
          } else {
            i2 -= 1;
          }
        }
      }
      return null;
    }
  }
  getToken(ttype, i2) {
    if (this.children === null || i2 < 0 || i2 >= this.children.length) {
      return null;
    }
    for (let j = 0; j < this.children.length; j++) {
      const child = this.children[j];
      if (child instanceof TerminalNode) {
        if (child.symbol.type === ttype) {
          if (i2 === 0) {
            return child;
          } else {
            i2 -= 1;
          }
        }
      }
    }
    return null;
  }
  getTokens(ttype) {
    if (this.children === null) {
      return [];
    } else {
      const tokens2 = [];
      for (let j = 0; j < this.children.length; j++) {
        const child = this.children[j];
        if (child instanceof TerminalNode) {
          if (child.symbol.type === ttype) {
            tokens2.push(child);
          }
        }
      }
      return tokens2;
    }
  }
  getTypedRuleContext(ctxType, i2) {
    return this.getChild(i2, ctxType);
  }
  getTypedRuleContexts(ctxType) {
    if (this.children === null) {
      return [];
    } else {
      const contexts = [];
      for (let j = 0; j < this.children.length; j++) {
        const child = this.children[j];
        if (child instanceof ctxType) {
          contexts.push(child);
        }
      }
      return contexts;
    }
  }
  getChildCount() {
    if (this.children === null) {
      return 0;
    } else {
      return this.children.length;
    }
  }
  getSourceInterval() {
    if (this.start === null || this.stop === null) {
      return Interval.INVALID_INTERVAL;
    } else {
      return new Interval(this.start.tokenIndex, this.stop.tokenIndex);
    }
  }
};
RuleContext.EMPTY = new ParserRuleContext();

// node_modules/antlr4/src/antlr4/utils/index.js
var utils_default = { arrayToString };

// node_modules/@neo4j-cypher/antlr4-browser/es/index.js
var antlr4 = {
  atn: atn_default,
  dfa: dfa_default,
  tree: tree_default,
  error: error_default,
  Token,
  CommonToken,
  /* CharStreams, */
  InputStream,
  /* FileStream, */
  CommonTokenStream,
  Lexer,
  Parser: Parser3,
  PredictionContextCache,
  ParserRuleContext,
  Interval,
  IntervalSet,
  LL1Analyzer,
  Utils: utils_default
};
var es_default = antlr4;

// node_modules/@neo4j-cypher/antlr4/es/CypherLexer.js
var serializedATN = [4, 0, 221, 1915, 6, -1, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7, 99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2, 104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7, 108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2, 113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7, 117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2, 122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7, 126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2, 131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7, 135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2, 140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7, 144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2, 149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7, 153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2, 158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7, 162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2, 167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7, 171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2, 176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7, 180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2, 185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7, 189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2, 194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7, 198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2, 203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7, 207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2, 212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7, 216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2, 221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7, 225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2, 230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7, 234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2, 239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7, 243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2, 248, 7, 248, 2, 249, 7, 249, 2, 250, 7, 250, 2, 251, 7, 251, 2, 252, 7, 252, 2, 253, 7, 253, 2, 254, 7, 254, 2, 255, 7, 255, 2, 256, 7, 256, 2, 257, 7, 257, 2, 258, 7, 258, 2, 259, 7, 259, 1, 0, 1, 0, 1, 1, 1, 1, 1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 6, 1, 6, 1, 7, 1, 7, 1, 8, 1, 8, 1, 9, 1, 9, 1, 10, 1, 10, 1, 11, 1, 11, 1, 12, 1, 12, 1, 13, 1, 13, 1, 14, 1, 14, 1, 15, 1, 15, 1, 16, 1, 16, 1, 17, 1, 17, 1, 18, 1, 18, 1, 19, 1, 19, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 24, 1, 24, 1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 1, 29, 1, 29, 1, 30, 1, 30, 1, 31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 1, 34, 1, 34, 1, 35, 1, 35, 1, 36, 1, 36, 1, 37, 1, 37, 1, 38, 1, 38, 1, 39, 1, 39, 1, 40, 1, 40, 1, 41, 1, 41, 1, 42, 1, 42, 1, 43, 1, 43, 1, 44, 1, 44, 1, 45, 1, 45, 1, 46, 1, 46, 1, 47, 1, 47, 1, 48, 1, 48, 1, 49, 1, 49, 1, 50, 1, 50, 1, 51, 1, 51, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 1, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 64, 1, 64, 1, 64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 67, 1, 67, 1, 67, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 71, 1, 71, 1, 71, 1, 71, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 75, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 86, 1, 86, 1, 86, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 90, 1, 90, 1, 90, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 94, 1, 94, 1, 94, 1, 94, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 102, 1, 102, 1, 102, 1, 102, 1, 103, 1, 103, 1, 103, 1, 103, 1, 103, 1, 103, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 106, 1, 106, 1, 106, 1, 107, 1, 107, 1, 107, 1, 107, 1, 108, 1, 108, 1, 108, 1, 108, 1, 109, 1, 109, 1, 109, 1, 109, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 115, 1, 115, 1, 115, 1, 115, 1, 115, 1, 115, 1, 115, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 117, 1, 117, 1, 117, 1, 117, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 125, 1, 125, 1, 125, 1, 125, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 130, 1, 130, 1, 130, 1, 130, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 138, 1, 138, 1, 138, 1, 138, 1, 138, 1, 138, 1, 138, 1, 139, 1, 139, 1, 139, 1, 139, 1, 139, 1, 139, 1, 139, 1, 139, 1, 140, 1, 140, 1, 140, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 143, 1, 143, 1, 143, 1, 143, 1, 143, 1, 143, 1, 144, 1, 144, 1, 144, 1, 144, 1, 144, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 150, 1, 150, 1, 150, 1, 150, 1, 150, 1, 150, 1, 150, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 155, 1, 155, 1, 155, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 158, 1, 158, 1, 158, 1, 158, 1, 158, 1, 159, 1, 159, 1, 159, 1, 159, 1, 159, 1, 159, 1, 159, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 164, 1, 164, 1, 164, 1, 164, 1, 164, 1, 165, 1, 165, 1, 165, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 172, 1, 172, 1, 172, 1, 172, 1, 173, 1, 173, 1, 173, 1, 173, 1, 173, 1, 173, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 177, 1, 177, 1, 177, 1, 177, 1, 177, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 181, 1, 181, 1, 181, 1, 181, 1, 181, 1, 181, 1, 181, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 184, 1, 184, 1, 184, 1, 184, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 197, 1, 197, 1, 197, 1, 197, 1, 197, 1, 197, 1, 197, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 3, 198, 1627, 8, 198, 5, 198, 1629, 8, 198, 10, 198, 12, 198, 1632, 9, 198, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 3, 198, 1640, 8, 198, 5, 198, 1642, 8, 198, 10, 198, 12, 198, 1645, 9, 198, 1, 198, 3, 198, 1648, 8, 198, 1, 199, 1, 199, 1, 199, 4, 199, 1653, 8, 199, 11, 199, 12, 199, 1654, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 3, 200, 1675, 8, 200, 1, 201, 1, 201, 1, 201, 1, 201, 4, 201, 1681, 8, 201, 11, 201, 12, 201, 1682, 1, 202, 1, 202, 1, 202, 5, 202, 1688, 8, 202, 10, 202, 12, 202, 1691, 9, 202, 3, 202, 1693, 8, 202, 1, 203, 1, 203, 4, 203, 1697, 8, 203, 11, 203, 12, 203, 1698, 1, 204, 3, 204, 1702, 8, 204, 1, 205, 1, 205, 3, 205, 1706, 8, 205, 1, 206, 1, 206, 3, 206, 1710, 8, 206, 1, 207, 1, 207, 3, 207, 1714, 8, 207, 1, 208, 1, 208, 1, 209, 1, 209, 3, 209, 1720, 8, 209, 1, 210, 1, 210, 1, 211, 4, 211, 1725, 8, 211, 11, 211, 12, 211, 1726, 1, 211, 4, 211, 1730, 8, 211, 11, 211, 12, 211, 1731, 1, 211, 1, 211, 4, 211, 1736, 8, 211, 11, 211, 12, 211, 1737, 1, 211, 1, 211, 4, 211, 1742, 8, 211, 11, 211, 12, 211, 1743, 3, 211, 1746, 8, 211, 1, 211, 1, 211, 3, 211, 1750, 8, 211, 1, 211, 4, 211, 1753, 8, 211, 11, 211, 12, 211, 1754, 1, 212, 5, 212, 1758, 8, 212, 10, 212, 12, 212, 1761, 9, 212, 1, 212, 1, 212, 4, 212, 1765, 8, 212, 11, 212, 12, 212, 1766, 1, 213, 1, 213, 5, 213, 1771, 8, 213, 10, 213, 12, 213, 1774, 9, 213, 1, 214, 1, 214, 3, 214, 1778, 8, 214, 1, 215, 1, 215, 3, 215, 1782, 8, 215, 1, 216, 1, 216, 1, 216, 1, 216, 5, 216, 1788, 8, 216, 10, 216, 12, 216, 1791, 9, 216, 1, 216, 1, 216, 1, 217, 4, 217, 1796, 8, 217, 11, 217, 12, 217, 1797, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 3, 218, 1812, 8, 218, 1, 219, 1, 219, 1, 219, 1, 219, 5, 219, 1818, 8, 219, 10, 219, 12, 219, 1821, 9, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 5, 219, 1829, 8, 219, 10, 219, 12, 219, 1832, 9, 219, 3, 219, 1834, 8, 219, 1, 220, 1, 220, 1, 221, 1, 221, 1, 222, 1, 222, 1, 223, 1, 223, 1, 224, 1, 224, 1, 225, 1, 225, 1, 226, 1, 226, 1, 227, 1, 227, 1, 228, 1, 228, 1, 229, 1, 229, 1, 230, 1, 230, 1, 231, 1, 231, 1, 232, 1, 232, 1, 233, 1, 233, 1, 234, 1, 234, 1, 235, 1, 235, 1, 236, 1, 236, 1, 237, 1, 237, 1, 238, 1, 238, 1, 239, 1, 239, 1, 240, 1, 240, 1, 241, 1, 241, 1, 242, 1, 242, 1, 243, 1, 243, 1, 244, 1, 244, 1, 245, 1, 245, 1, 246, 1, 246, 1, 247, 1, 247, 1, 248, 1, 248, 1, 249, 1, 249, 1, 250, 1, 250, 1, 251, 1, 251, 1, 252, 1, 252, 1, 253, 1, 253, 1, 254, 1, 254, 1, 255, 1, 255, 1, 256, 1, 256, 1, 257, 1, 257, 1, 258, 1, 258, 1, 259, 1, 259, 1, 1819, 0, 260, 1, 1, 3, 2, 5, 3, 7, 4, 9, 5, 11, 6, 13, 7, 15, 8, 17, 9, 19, 10, 21, 11, 23, 12, 25, 13, 27, 14, 29, 15, 31, 16, 33, 17, 35, 18, 37, 19, 39, 20, 41, 21, 43, 22, 45, 23, 47, 24, 49, 25, 51, 26, 53, 27, 55, 28, 57, 29, 59, 30, 61, 31, 63, 32, 65, 33, 67, 34, 69, 35, 71, 36, 73, 37, 75, 38, 77, 39, 79, 40, 81, 41, 83, 42, 85, 43, 87, 44, 89, 45, 91, 46, 93, 47, 95, 48, 97, 49, 99, 50, 101, 51, 103, 52, 105, 53, 107, 54, 109, 55, 111, 56, 113, 57, 115, 58, 117, 59, 119, 60, 121, 61, 123, 62, 125, 63, 127, 64, 129, 65, 131, 66, 133, 67, 135, 68, 137, 69, 139, 70, 141, 71, 143, 72, 145, 73, 147, 74, 149, 75, 151, 76, 153, 77, 155, 78, 157, 79, 159, 80, 161, 81, 163, 82, 165, 83, 167, 84, 169, 85, 171, 86, 173, 87, 175, 88, 177, 89, 179, 90, 181, 91, 183, 92, 185, 93, 187, 94, 189, 95, 191, 96, 193, 97, 195, 98, 197, 99, 199, 100, 201, 101, 203, 102, 205, 103, 207, 104, 209, 105, 211, 106, 213, 107, 215, 108, 217, 109, 219, 110, 221, 111, 223, 112, 225, 113, 227, 114, 229, 115, 231, 116, 233, 117, 235, 118, 237, 119, 239, 120, 241, 121, 243, 122, 245, 123, 247, 124, 249, 125, 251, 126, 253, 127, 255, 128, 257, 129, 259, 130, 261, 131, 263, 132, 265, 133, 267, 134, 269, 135, 271, 136, 273, 137, 275, 138, 277, 139, 279, 140, 281, 141, 283, 142, 285, 143, 287, 144, 289, 145, 291, 146, 293, 147, 295, 148, 297, 149, 299, 150, 301, 151, 303, 152, 305, 153, 307, 154, 309, 155, 311, 156, 313, 157, 315, 158, 317, 159, 319, 160, 321, 161, 323, 162, 325, 163, 327, 164, 329, 165, 331, 166, 333, 167, 335, 168, 337, 169, 339, 170, 341, 171, 343, 172, 345, 173, 347, 174, 349, 175, 351, 176, 353, 177, 355, 178, 357, 179, 359, 180, 361, 181, 363, 182, 365, 183, 367, 184, 369, 185, 371, 186, 373, 187, 375, 188, 377, 189, 379, 190, 381, 191, 383, 192, 385, 193, 387, 194, 389, 195, 391, 196, 393, 197, 395, 198, 397, 199, 399, 200, 401, 201, 403, 202, 405, 203, 407, 204, 409, 205, 411, 206, 413, 207, 415, 208, 417, 209, 419, 210, 421, 211, 423, 212, 425, 213, 427, 214, 429, 215, 431, 216, 433, 217, 435, 218, 437, 219, 439, 220, 441, 221, 443, 0, 445, 0, 447, 0, 449, 0, 451, 0, 453, 0, 455, 0, 457, 0, 459, 0, 461, 0, 463, 0, 465, 0, 467, 0, 469, 0, 471, 0, 473, 0, 475, 0, 477, 0, 479, 0, 481, 0, 483, 0, 485, 0, 487, 0, 489, 0, 491, 0, 493, 0, 495, 0, 497, 0, 499, 0, 501, 0, 503, 0, 505, 0, 507, 0, 509, 0, 511, 0, 513, 0, 515, 0, 517, 0, 519, 0, 1, 0, 48, 2, 0, 34, 34, 92, 92, 2, 0, 39, 39, 92, 92, 3, 0, 48, 57, 65, 70, 97, 102, 13, 0, 34, 34, 39, 39, 66, 66, 70, 70, 78, 78, 82, 82, 84, 84, 92, 92, 98, 98, 102, 102, 110, 110, 114, 114, 116, 116, 2, 0, 85, 85, 117, 117, 2, 0, 65, 70, 97, 102, 2, 0, 69, 69, 101, 101, 6, 0, 95, 95, 8255, 8256, 8276, 8276, 65075, 65076, 65101, 65103, 65343, 65343, 1, 0, 96, 96, 8, 0, 160, 160, 5760, 5760, 6158, 6158, 8192, 8202, 8232, 8233, 8239, 8239, 8287, 8287, 12288, 12288, 2, 0, 10, 10, 13, 13, 1, 0, 12, 12, 1, 0, 30, 30, 429, 0, 48, 57, 65, 90, 95, 95, 97, 122, 170, 170, 181, 181, 183, 183, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112, 2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423, 2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4969, 4977, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6e3, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6618, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8472, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43e3, 43047, 43072, 43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 1, 0, 29, 29, 1, 0, 28, 28, 1, 0, 13, 13, 17, 0, 36, 36, 162, 165, 1423, 1423, 1547, 1547, 2546, 2547, 2555, 2555, 2801, 2801, 3065, 3065, 3647, 3647, 6107, 6107, 8352, 8378, 43064, 43064, 65020, 65020, 65129, 65129, 65284, 65284, 65504, 65505, 65509, 65510, 1, 0, 32, 32, 1, 0, 9, 9, 1, 0, 10, 10, 1, 0, 11, 11, 1, 0, 31, 31, 370, 0, 65, 90, 97, 122, 170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6e3, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8472, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12443, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43e3, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 2, 0, 65, 65, 97, 97, 2, 0, 66, 66, 98, 98, 2, 0, 67, 67, 99, 99, 2, 0, 68, 68, 100, 100, 2, 0, 70, 70, 102, 102, 2, 0, 71, 71, 103, 103, 2, 0, 72, 72, 104, 104, 2, 0, 73, 73, 105, 105, 2, 0, 74, 74, 106, 106, 2, 0, 75, 75, 107, 107, 2, 0, 76, 76, 108, 108, 2, 0, 77, 77, 109, 109, 2, 0, 78, 78, 110, 110, 2, 0, 79, 79, 111, 111, 2, 0, 80, 80, 112, 112, 2, 0, 81, 81, 113, 113, 2, 0, 82, 82, 114, 114, 2, 0, 83, 83, 115, 115, 2, 0, 84, 84, 116, 116, 2, 0, 86, 86, 118, 118, 2, 0, 87, 87, 119, 119, 2, 0, 88, 88, 120, 120, 2, 0, 89, 89, 121, 121, 2, 0, 90, 90, 122, 122, 1923, 0, 1, 1, 0, 0, 0, 0, 3, 1, 0, 0, 0, 0, 5, 1, 0, 0, 0, 0, 7, 1, 0, 0, 0, 0, 9, 1, 0, 0, 0, 0, 11, 1, 0, 0, 0, 0, 13, 1, 0, 0, 0, 0, 15, 1, 0, 0, 0, 0, 17, 1, 0, 0, 0, 0, 19, 1, 0, 0, 0, 0, 21, 1, 0, 0, 0, 0, 23, 1, 0, 0, 0, 0, 25, 1, 0, 0, 0, 0, 27, 1, 0, 0, 0, 0, 29, 1, 0, 0, 0, 0, 31, 1, 0, 0, 0, 0, 33, 1, 0, 0, 0, 0, 35, 1, 0, 0, 0, 0, 37, 1, 0, 0, 0, 0, 39, 1, 0, 0, 0, 0, 41, 1, 0, 0, 0, 0, 43, 1, 0, 0, 0, 0, 45, 1, 0, 0, 0, 0, 47, 1, 0, 0, 0, 0, 49, 1, 0, 0, 0, 0, 51, 1, 0, 0, 0, 0, 53, 1, 0, 0, 0, 0, 55, 1, 0, 0, 0, 0, 57, 1, 0, 0, 0, 0, 59, 1, 0, 0, 0, 0, 61, 1, 0, 0, 0, 0, 63, 1, 0, 0, 0, 0, 65, 1, 0, 0, 0, 0, 67, 1, 0, 0, 0, 0, 69, 1, 0, 0, 0, 0, 71, 1, 0, 0, 0, 0, 73, 1, 0, 0, 0, 0, 75, 1, 0, 0, 0, 0, 77, 1, 0, 0, 0, 0, 79, 1, 0, 0, 0, 0, 81, 1, 0, 0, 0, 0, 83, 1, 0, 0, 0, 0, 85, 1, 0, 0, 0, 0, 87, 1, 0, 0, 0, 0, 89, 1, 0, 0, 0, 0, 91, 1, 0, 0, 0, 0, 93, 1, 0, 0, 0, 0, 95, 1, 0, 0, 0, 0, 97, 1, 0, 0, 0, 0, 99, 1, 0, 0, 0, 0, 101, 1, 0, 0, 0, 0, 103, 1, 0, 0, 0, 0, 105, 1, 0, 0, 0, 0, 107, 1, 0, 0, 0, 0, 109, 1, 0, 0, 0, 0, 111, 1, 0, 0, 0, 0, 113, 1, 0, 0, 0, 0, 115, 1, 0, 0, 0, 0, 117, 1, 0, 0, 0, 0, 119, 1, 0, 0, 0, 0, 121, 1, 0, 0, 0, 0, 123, 1, 0, 0, 0, 0, 125, 1, 0, 0, 0, 0, 127, 1, 0, 0, 0, 0, 129, 1, 0, 0, 0, 0, 131, 1, 0, 0, 0, 0, 133, 1, 0, 0, 0, 0, 135, 1, 0, 0, 0, 0, 137, 1, 0, 0, 0, 0, 139, 1, 0, 0, 0, 0, 141, 1, 0, 0, 0, 0, 143, 1, 0, 0, 0, 0, 145, 1, 0, 0, 0, 0, 147, 1, 0, 0, 0, 0, 149, 1, 0, 0, 0, 0, 151, 1, 0, 0, 0, 0, 153, 1, 0, 0, 0, 0, 155, 1, 0, 0, 0, 0, 157, 1, 0, 0, 0, 0, 159, 1, 0, 0, 0, 0, 161, 1, 0, 0, 0, 0, 163, 1, 0, 0, 0, 0, 165, 1, 0, 0, 0, 0, 167, 1, 0, 0, 0, 0, 169, 1, 0, 0, 0, 0, 171, 1, 0, 0, 0, 0, 173, 1, 0, 0, 0, 0, 175, 1, 0, 0, 0, 0, 177, 1, 0, 0, 0, 0, 179, 1, 0, 0, 0, 0, 181, 1, 0, 0, 0, 0, 183, 1, 0, 0, 0, 0, 185, 1, 0, 0, 0, 0, 187, 1, 0, 0, 0, 0, 189, 1, 0, 0, 0, 0, 191, 1, 0, 0, 0, 0, 193, 1, 0, 0, 0, 0, 195, 1, 0, 0, 0, 0, 197, 1, 0, 0, 0, 0, 199, 1, 0, 0, 0, 0, 201, 1, 0, 0, 0, 0, 203, 1, 0, 0, 0, 0, 205, 1, 0, 0, 0, 0, 207, 1, 0, 0, 0, 0, 209, 1, 0, 0, 0, 0, 211, 1, 0, 0, 0, 0, 213, 1, 0, 0, 0, 0, 215, 1, 0, 0, 0, 0, 217, 1, 0, 0, 0, 0, 219, 1, 0, 0, 0, 0, 221, 1, 0, 0, 0, 0, 223, 1, 0, 0, 0, 0, 225, 1, 0, 0, 0, 0, 227, 1, 0, 0, 0, 0, 229, 1, 0, 0, 0, 0, 231, 1, 0, 0, 0, 0, 233, 1, 0, 0, 0, 0, 235, 1, 0, 0, 0, 0, 237, 1, 0, 0, 0, 0, 239, 1, 0, 0, 0, 0, 241, 1, 0, 0, 0, 0, 243, 1, 0, 0, 0, 0, 245, 1, 0, 0, 0, 0, 247, 1, 0, 0, 0, 0, 249, 1, 0, 0, 0, 0, 251, 1, 0, 0, 0, 0, 253, 1, 0, 0, 0, 0, 255, 1, 0, 0, 0, 0, 257, 1, 0, 0, 0, 0, 259, 1, 0, 0, 0, 0, 261, 1, 0, 0, 0, 0, 263, 1, 0, 0, 0, 0, 265, 1, 0, 0, 0, 0, 267, 1, 0, 0, 0, 0, 269, 1, 0, 0, 0, 0, 271, 1, 0, 0, 0, 0, 273, 1, 0, 0, 0, 0, 275, 1, 0, 0, 0, 0, 277, 1, 0, 0, 0, 0, 279, 1, 0, 0, 0, 0, 281, 1, 0, 0, 0, 0, 283, 1, 0, 0, 0, 0, 285, 1, 0, 0, 0, 0, 287, 1, 0, 0, 0, 0, 289, 1, 0, 0, 0, 0, 291, 1, 0, 0, 0, 0, 293, 1, 0, 0, 0, 0, 295, 1, 0, 0, 0, 0, 297, 1, 0, 0, 0, 0, 299, 1, 0, 0, 0, 0, 301, 1, 0, 0, 0, 0, 303, 1, 0, 0, 0, 0, 305, 1, 0, 0, 0, 0, 307, 1, 0, 0, 0, 0, 309, 1, 0, 0, 0, 0, 311, 1, 0, 0, 0, 0, 313, 1, 0, 0, 0, 0, 315, 1, 0, 0, 0, 0, 317, 1, 0, 0, 0, 0, 319, 1, 0, 0, 0, 0, 321, 1, 0, 0, 0, 0, 323, 1, 0, 0, 0, 0, 325, 1, 0, 0, 0, 0, 327, 1, 0, 0, 0, 0, 329, 1, 0, 0, 0, 0, 331, 1, 0, 0, 0, 0, 333, 1, 0, 0, 0, 0, 335, 1, 0, 0, 0, 0, 337, 1, 0, 0, 0, 0, 339, 1, 0, 0, 0, 0, 341, 1, 0, 0, 0, 0, 343, 1, 0, 0, 0, 0, 345, 1, 0, 0, 0, 0, 347, 1, 0, 0, 0, 0, 349, 1, 0, 0, 0, 0, 351, 1, 0, 0, 0, 0, 353, 1, 0, 0, 0, 0, 355, 1, 0, 0, 0, 0, 357, 1, 0, 0, 0, 0, 359, 1, 0, 0, 0, 0, 361, 1, 0, 0, 0, 0, 363, 1, 0, 0, 0, 0, 365, 1, 0, 0, 0, 0, 367, 1, 0, 0, 0, 0, 369, 1, 0, 0, 0, 0, 371, 1, 0, 0, 0, 0, 373, 1, 0, 0, 0, 0, 375, 1, 0, 0, 0, 0, 377, 1, 0, 0, 0, 0, 379, 1, 0, 0, 0, 0, 381, 1, 0, 0, 0, 0, 383, 1, 0, 0, 0, 0, 385, 1, 0, 0, 0, 0, 387, 1, 0, 0, 0, 0, 389, 1, 0, 0, 0, 0, 391, 1, 0, 0, 0, 0, 393, 1, 0, 0, 0, 0, 395, 1, 0, 0, 0, 0, 397, 1, 0, 0, 0, 0, 399, 1, 0, 0, 0, 0, 401, 1, 0, 0, 0, 0, 403, 1, 0, 0, 0, 0, 405, 1, 0, 0, 0, 0, 407, 1, 0, 0, 0, 0, 409, 1, 0, 0, 0, 0, 411, 1, 0, 0, 0, 0, 413, 1, 0, 0, 0, 0, 415, 1, 0, 0, 0, 0, 417, 1, 0, 0, 0, 0, 419, 1, 0, 0, 0, 0, 421, 1, 0, 0, 0, 0, 423, 1, 0, 0, 0, 0, 425, 1, 0, 0, 0, 0, 427, 1, 0, 0, 0, 0, 429, 1, 0, 0, 0, 0, 431, 1, 0, 0, 0, 0, 433, 1, 0, 0, 0, 0, 435, 1, 0, 0, 0, 0, 437, 1, 0, 0, 0, 0, 439, 1, 0, 0, 0, 0, 441, 1, 0, 0, 0, 1, 521, 1, 0, 0, 0, 3, 523, 1, 0, 0, 0, 5, 525, 1, 0, 0, 0, 7, 527, 1, 0, 0, 0, 9, 530, 1, 0, 0, 0, 11, 534, 1, 0, 0, 0, 13, 536, 1, 0, 0, 0, 15, 538, 1, 0, 0, 0, 17, 540, 1, 0, 0, 0, 19, 542, 1, 0, 0, 0, 21, 544, 1, 0, 0, 0, 23, 546, 1, 0, 0, 0, 25, 548, 1, 0, 0, 0, 27, 550, 1, 0, 0, 0, 29, 552, 1, 0, 0, 0, 31, 554, 1, 0, 0, 0, 33, 556, 1, 0, 0, 0, 35, 558, 1, 0, 0, 0, 37, 560, 1, 0, 0, 0, 39, 562, 1, 0, 0, 0, 41, 564, 1, 0, 0, 0, 43, 566, 1, 0, 0, 0, 45, 569, 1, 0, 0, 0, 47, 571, 1, 0, 0, 0, 49, 574, 1, 0, 0, 0, 51, 576, 1, 0, 0, 0, 53, 578, 1, 0, 0, 0, 55, 581, 1, 0, 0, 0, 57, 584, 1, 0, 0, 0, 59, 587, 1, 0, 0, 0, 61, 589, 1, 0, 0, 0, 63, 591, 1, 0, 0, 0, 65, 594, 1, 0, 0, 0, 67, 597, 1, 0, 0, 0, 69, 599, 1, 0, 0, 0, 71, 601, 1, 0, 0, 0, 73, 603, 1, 0, 0, 0, 75, 605, 1, 0, 0, 0, 77, 607, 1, 0, 0, 0, 79, 609, 1, 0, 0, 0, 81, 611, 1, 0, 0, 0, 83, 613, 1, 0, 0, 0, 85, 615, 1, 0, 0, 0, 87, 617, 1, 0, 0, 0, 89, 619, 1, 0, 0, 0, 91, 621, 1, 0, 0, 0, 93, 623, 1, 0, 0, 0, 95, 625, 1, 0, 0, 0, 97, 627, 1, 0, 0, 0, 99, 629, 1, 0, 0, 0, 101, 631, 1, 0, 0, 0, 103, 633, 1, 0, 0, 0, 105, 635, 1, 0, 0, 0, 107, 637, 1, 0, 0, 0, 109, 644, 1, 0, 0, 0, 111, 652, 1, 0, 0, 0, 113, 660, 1, 0, 0, 0, 115, 666, 1, 0, 0, 0, 117, 675, 1, 0, 0, 0, 119, 682, 1, 0, 0, 0, 121, 688, 1, 0, 0, 0, 123, 692, 1, 0, 0, 0, 125, 699, 1, 0, 0, 0, 127, 704, 1, 0, 0, 0, 129, 710, 1, 0, 0, 0, 131, 713, 1, 0, 0, 0, 133, 724, 1, 0, 0, 0, 135, 731, 1, 0, 0, 0, 137, 734, 1, 0, 0, 0, 139, 741, 1, 0, 0, 0, 141, 748, 1, 0, 0, 0, 143, 753, 1, 0, 0, 0, 145, 757, 1, 0, 0, 0, 147, 762, 1, 0, 0, 0, 149, 770, 1, 0, 0, 0, 151, 775, 1, 0, 0, 0, 153, 778, 1, 0, 0, 0, 155, 794, 1, 0, 0, 0, 157, 803, 1, 0, 0, 0, 159, 809, 1, 0, 0, 0, 161, 816, 1, 0, 0, 0, 163, 822, 1, 0, 0, 0, 165, 826, 1, 0, 0, 0, 167, 833, 1, 0, 0, 0, 169, 840, 1, 0, 0, 0, 171, 847, 1, 0, 0, 0, 173, 855, 1, 0, 0, 0, 175, 858, 1, 0, 0, 0, 177, 867, 1, 0, 0, 0, 179, 874, 1, 0, 0, 0, 181, 880, 1, 0, 0, 0, 183, 883, 1, 0, 0, 0, 185, 888, 1, 0, 0, 0, 187, 894, 1, 0, 0, 0, 189, 904, 1, 0, 0, 0, 191, 908, 1, 0, 0, 0, 193, 919, 1, 0, 0, 0, 195, 924, 1, 0, 0, 0, 197, 929, 1, 0, 0, 0, 199, 934, 1, 0, 0, 0, 201, 940, 1, 0, 0, 0, 203, 945, 1, 0, 0, 0, 205, 958, 1, 0, 0, 0, 207, 962, 1, 0, 0, 0, 209, 968, 1, 0, 0, 0, 211, 981, 1, 0, 0, 0, 213, 998, 1, 0, 0, 0, 215, 1001, 1, 0, 0, 0, 217, 1005, 1, 0, 0, 0, 219, 1009, 1, 0, 0, 0, 221, 1013, 1, 0, 0, 0, 223, 1020, 1, 0, 0, 0, 225, 1025, 1, 0, 0, 0, 227, 1034, 1, 0, 0, 0, 229, 1039, 1, 0, 0, 0, 231, 1045, 1, 0, 0, 0, 233, 1052, 1, 0, 0, 0, 235, 1060, 1, 0, 0, 0, 237, 1064, 1, 0, 0, 0, 239, 1069, 1, 0, 0, 0, 241, 1076, 1, 0, 0, 0, 243, 1081, 1, 0, 0, 0, 245, 1087, 1, 0, 0, 0, 247, 1094, 1, 0, 0, 0, 249, 1099, 1, 0, 0, 0, 251, 1104, 1, 0, 0, 0, 253, 1108, 1, 0, 0, 0, 255, 1113, 1, 0, 0, 0, 257, 1118, 1, 0, 0, 0, 259, 1123, 1, 0, 0, 0, 261, 1129, 1, 0, 0, 0, 263, 1133, 1, 0, 0, 0, 265, 1141, 1, 0, 0, 0, 267, 1146, 1, 0, 0, 0, 269, 1154, 1, 0, 0, 0, 271, 1159, 1, 0, 0, 0, 273, 1168, 1, 0, 0, 0, 275, 1178, 1, 0, 0, 0, 277, 1184, 1, 0, 0, 0, 279, 1191, 1, 0, 0, 0, 281, 1199, 1, 0, 0, 0, 283, 1202, 1, 0, 0, 0, 285, 1207, 1, 0, 0, 0, 287, 1212, 1, 0, 0, 0, 289, 1218, 1, 0, 0, 0, 291, 1223, 1, 0, 0, 0, 293, 1229, 1, 0, 0, 0, 295, 1239, 1, 0, 0, 0, 297, 1248, 1, 0, 0, 0, 299, 1255, 1, 0, 0, 0, 301, 1264, 1, 0, 0, 0, 303, 1271, 1, 0, 0, 0, 305, 1278, 1, 0, 0, 0, 307, 1288, 1, 0, 0, 0, 309, 1294, 1, 0, 0, 0, 311, 1302, 1, 0, 0, 0, 313, 1305, 1, 0, 0, 0, 315, 1316, 1, 0, 0, 0, 317, 1322, 1, 0, 0, 0, 319, 1327, 1, 0, 0, 0, 321, 1334, 1, 0, 0, 0, 323, 1348, 1, 0, 0, 0, 325, 1354, 1, 0, 0, 0, 327, 1362, 1, 0, 0, 0, 329, 1371, 1, 0, 0, 0, 331, 1376, 1, 0, 0, 0, 333, 1379, 1, 0, 0, 0, 335, 1388, 1, 0, 0, 0, 337, 1393, 1, 0, 0, 0, 339, 1399, 1, 0, 0, 0, 341, 1406, 1, 0, 0, 0, 343, 1414, 1, 0, 0, 0, 345, 1425, 1, 0, 0, 0, 347, 1429, 1, 0, 0, 0, 349, 1435, 1, 0, 0, 0, 351, 1442, 1, 0, 0, 0, 353, 1447, 1, 0, 0, 0, 355, 1453, 1, 0, 0, 0, 357, 1458, 1, 0, 0, 0, 359, 1464, 1, 0, 0, 0, 361, 1473, 1, 0, 0, 0, 363, 1485, 1, 0, 0, 0, 365, 1492, 1, 0, 0, 0, 367, 1498, 1, 0, 0, 0, 369, 1504, 1, 0, 0, 0, 371, 1508, 1, 0, 0, 0, 373, 1516, 1, 0, 0, 0, 375, 1524, 1, 0, 0, 0, 377, 1532, 1, 0, 0, 0, 379, 1541, 1, 0, 0, 0, 381, 1551, 1, 0, 0, 0, 383, 1559, 1, 0, 0, 0, 385, 1569, 1, 0, 0, 0, 387, 1580, 1, 0, 0, 0, 389, 1586, 1, 0, 0, 0, 391, 1600, 1, 0, 0, 0, 393, 1606, 1, 0, 0, 0, 395, 1614, 1, 0, 0, 0, 397, 1647, 1, 0, 0, 0, 399, 1652, 1, 0, 0, 0, 401, 1656, 1, 0, 0, 0, 403, 1676, 1, 0, 0, 0, 405, 1692, 1, 0, 0, 0, 407, 1694, 1, 0, 0, 0, 409, 1701, 1, 0, 0, 0, 411, 1705, 1, 0, 0, 0, 413, 1709, 1, 0, 0, 0, 415, 1713, 1, 0, 0, 0, 417, 1715, 1, 0, 0, 0, 419, 1719, 1, 0, 0, 0, 421, 1721, 1, 0, 0, 0, 423, 1745, 1, 0, 0, 0, 425, 1759, 1, 0, 0, 0, 427, 1768, 1, 0, 0, 0, 429, 1777, 1, 0, 0, 0, 431, 1781, 1, 0, 0, 0, 433, 1783, 1, 0, 0, 0, 435, 1795, 1, 0, 0, 0, 437, 1811, 1, 0, 0, 0, 439, 1833, 1, 0, 0, 0, 441, 1835, 1, 0, 0, 0, 443, 1837, 1, 0, 0, 0, 445, 1839, 1, 0, 0, 0, 447, 1841, 1, 0, 0, 0, 449, 1843, 1, 0, 0, 0, 451, 1845, 1, 0, 0, 0, 453, 1847, 1, 0, 0, 0, 455, 1849, 1, 0, 0, 0, 457, 1851, 1, 0, 0, 0, 459, 1853, 1, 0, 0, 0, 461, 1855, 1, 0, 0, 0, 463, 1857, 1, 0, 0, 0, 465, 1859, 1, 0, 0, 0, 467, 1861, 1, 0, 0, 0, 469, 1863, 1, 0, 0, 0, 471, 1865, 1, 0, 0, 0, 473, 1867, 1, 0, 0, 0, 475, 1869, 1, 0, 0, 0, 477, 1871, 1, 0, 0, 0, 479, 1873, 1, 0, 0, 0, 481, 1875, 1, 0, 0, 0, 483, 1877, 1, 0, 0, 0, 485, 1879, 1, 0, 0, 0, 487, 1881, 1, 0, 0, 0, 489, 1883, 1, 0, 0, 0, 491, 1885, 1, 0, 0, 0, 493, 1887, 1, 0, 0, 0, 495, 1889, 1, 0, 0, 0, 497, 1891, 1, 0, 0, 0, 499, 1893, 1, 0, 0, 0, 501, 1895, 1, 0, 0, 0, 503, 1897, 1, 0, 0, 0, 505, 1899, 1, 0, 0, 0, 507, 1901, 1, 0, 0, 0, 509, 1903, 1, 0, 0, 0, 511, 1905, 1, 0, 0, 0, 513, 1907, 1, 0, 0, 0, 515, 1909, 1, 0, 0, 0, 517, 1911, 1, 0, 0, 0, 519, 1913, 1, 0, 0, 0, 521, 522, 5, 59, 0, 0, 522, 2, 1, 0, 0, 0, 523, 524, 5, 58, 0, 0, 524, 4, 1, 0, 0, 0, 525, 526, 5, 45, 0, 0, 526, 6, 1, 0, 0, 0, 527, 528, 5, 61, 0, 0, 528, 529, 5, 62, 0, 0, 529, 8, 1, 0, 0, 0, 530, 531, 5, 58, 0, 0, 531, 532, 5, 47, 0, 0, 532, 533, 5, 47, 0, 0, 533, 10, 1, 0, 0, 0, 534, 535, 5, 47, 0, 0, 535, 12, 1, 0, 0, 0, 536, 537, 5, 46, 0, 0, 537, 14, 1, 0, 0, 0, 538, 539, 5, 64, 0, 0, 539, 16, 1, 0, 0, 0, 540, 541, 5, 35, 0, 0, 541, 18, 1, 0, 0, 0, 542, 543, 5, 63, 0, 0, 543, 20, 1, 0, 0, 0, 544, 545, 5, 38, 0, 0, 545, 22, 1, 0, 0, 0, 546, 547, 5, 61, 0, 0, 547, 24, 1, 0, 0, 0, 548, 549, 5, 43, 0, 0, 549, 26, 1, 0, 0, 0, 550, 551, 5, 123, 0, 0, 551, 28, 1, 0, 0, 0, 552, 553, 5, 44, 0, 0, 553, 30, 1, 0, 0, 0, 554, 555, 5, 125, 0, 0, 555, 32, 1, 0, 0, 0, 556, 557, 5, 91, 0, 0, 557, 34, 1, 0, 0, 0, 558, 559, 5, 93, 0, 0, 559, 36, 1, 0, 0, 0, 560, 561, 5, 42, 0, 0, 561, 38, 1, 0, 0, 0, 562, 563, 5, 40, 0, 0, 563, 40, 1, 0, 0, 0, 564, 565, 5, 41, 0, 0, 565, 42, 1, 0, 0, 0, 566, 567, 5, 43, 0, 0, 567, 568, 5, 61, 0, 0, 568, 44, 1, 0, 0, 0, 569, 570, 5, 124, 0, 0, 570, 46, 1, 0, 0, 0, 571, 572, 5, 46, 0, 0, 572, 573, 5, 46, 0, 0, 573, 48, 1, 0, 0, 0, 574, 575, 5, 37, 0, 0, 575, 50, 1, 0, 0, 0, 576, 577, 5, 94, 0, 0, 577, 52, 1, 0, 0, 0, 578, 579, 5, 61, 0, 0, 579, 580, 5, 126, 0, 0, 580, 54, 1, 0, 0, 0, 581, 582, 5, 60, 0, 0, 582, 583, 5, 62, 0, 0, 583, 56, 1, 0, 0, 0, 584, 585, 5, 33, 0, 0, 585, 586, 5, 61, 0, 0, 586, 58, 1, 0, 0, 0, 587, 588, 5, 60, 0, 0, 588, 60, 1, 0, 0, 0, 589, 590, 5, 62, 0, 0, 590, 62, 1, 0, 0, 0, 591, 592, 5, 60, 0, 0, 592, 593, 5, 61, 0, 0, 593, 64, 1, 0, 0, 0, 594, 595, 5, 62, 0, 0, 595, 596, 5, 61, 0, 0, 596, 66, 1, 0, 0, 0, 597, 598, 5, 36, 0, 0, 598, 68, 1, 0, 0, 0, 599, 600, 5, 10216, 0, 0, 600, 70, 1, 0, 0, 0, 601, 602, 5, 12296, 0, 0, 602, 72, 1, 0, 0, 0, 603, 604, 5, 65124, 0, 0, 604, 74, 1, 0, 0, 0, 605, 606, 5, 65308, 0, 0, 606, 76, 1, 0, 0, 0, 607, 608, 5, 10217, 0, 0, 608, 78, 1, 0, 0, 0, 609, 610, 5, 12297, 0, 0, 610, 80, 1, 0, 0, 0, 611, 612, 5, 65125, 0, 0, 612, 82, 1, 0, 0, 0, 613, 614, 5, 65310, 0, 0, 614, 84, 1, 0, 0, 0, 615, 616, 5, 173, 0, 0, 616, 86, 1, 0, 0, 0, 617, 618, 5, 8208, 0, 0, 618, 88, 1, 0, 0, 0, 619, 620, 5, 8209, 0, 0, 620, 90, 1, 0, 0, 0, 621, 622, 5, 8210, 0, 0, 622, 92, 1, 0, 0, 0, 623, 624, 5, 8211, 0, 0, 624, 94, 1, 0, 0, 0, 625, 626, 5, 8212, 0, 0, 626, 96, 1, 0, 0, 0, 627, 628, 5, 8213, 0, 0, 628, 98, 1, 0, 0, 0, 629, 630, 5, 8722, 0, 0, 630, 100, 1, 0, 0, 0, 631, 632, 5, 65112, 0, 0, 632, 102, 1, 0, 0, 0, 633, 634, 5, 65123, 0, 0, 634, 104, 1, 0, 0, 0, 635, 636, 5, 65293, 0, 0, 636, 106, 1, 0, 0, 0, 637, 638, 3, 473, 236, 0, 638, 639, 3, 517, 258, 0, 639, 640, 3, 499, 249, 0, 640, 641, 3, 483, 241, 0, 641, 642, 3, 477, 238, 0, 642, 643, 3, 503, 251, 0, 643, 108, 1, 0, 0, 0, 644, 645, 3, 477, 238, 0, 645, 646, 3, 515, 257, 0, 646, 647, 3, 499, 249, 0, 647, 648, 3, 491, 245, 0, 648, 649, 3, 469, 234, 0, 649, 650, 3, 485, 242, 0, 650, 651, 3, 495, 247, 0, 651, 110, 1, 0, 0, 0, 652, 653, 3, 499, 249, 0, 653, 654, 3, 503, 251, 0, 654, 655, 3, 497, 248, 0, 655, 656, 3, 479, 239, 0, 656, 657, 3, 485, 242, 0, 657, 658, 3, 491, 245, 0, 658, 659, 3, 477, 238, 0, 659, 112, 1, 0, 0, 0, 660, 661, 3, 509, 254, 0, 661, 662, 3, 505, 252, 0, 662, 663, 3, 485, 242, 0, 663, 664, 3, 495, 247, 0, 664, 665, 3, 481, 240, 0, 665, 114, 1, 0, 0, 0, 666, 667, 3, 499, 249, 0, 667, 668, 3, 477, 238, 0, 668, 669, 3, 503, 251, 0, 669, 670, 3, 485, 242, 0, 670, 671, 3, 497, 248, 0, 671, 672, 3, 475, 237, 0, 672, 673, 3, 485, 242, 0, 673, 674, 3, 473, 236, 0, 674, 116, 1, 0, 0, 0, 675, 676, 3, 473, 236, 0, 676, 677, 3, 497, 248, 0, 677, 678, 3, 493, 246, 0, 678, 679, 3, 493, 246, 0, 679, 680, 3, 485, 242, 0, 680, 681, 3, 507, 253, 0, 681, 118, 1, 0, 0, 0, 682, 683, 3, 509, 254, 0, 683, 684, 3, 495, 247, 0, 684, 685, 3, 485, 242, 0, 685, 686, 3, 497, 248, 0, 686, 687, 3, 495, 247, 0, 687, 120, 1, 0, 0, 0, 688, 689, 3, 469, 234, 0, 689, 690, 3, 491, 245, 0, 690, 691, 3, 491, 245, 0, 691, 122, 1, 0, 0, 0, 692, 693, 3, 473, 236, 0, 693, 694, 3, 503, 251, 0, 694, 695, 3, 477, 238, 0, 695, 696, 3, 469, 234, 0, 696, 697, 3, 507, 253, 0, 697, 698, 3, 477, 238, 0, 698, 124, 1, 0, 0, 0, 699, 700, 3, 475, 237, 0, 700, 701, 3, 503, 251, 0, 701, 702, 3, 497, 248, 0, 702, 703, 3, 499, 249, 0, 703, 126, 1, 0, 0, 0, 704, 705, 3, 485, 242, 0, 705, 706, 3, 495, 247, 0, 706, 707, 3, 475, 237, 0, 707, 708, 3, 477, 238, 0, 708, 709, 3, 515, 257, 0, 709, 128, 1, 0, 0, 0, 710, 711, 3, 497, 248, 0, 711, 712, 3, 495, 247, 0, 712, 130, 1, 0, 0, 0, 713, 714, 3, 473, 236, 0, 714, 715, 3, 497, 248, 0, 715, 716, 3, 495, 247, 0, 716, 717, 3, 505, 252, 0, 717, 718, 3, 507, 253, 0, 718, 719, 3, 503, 251, 0, 719, 720, 3, 469, 234, 0, 720, 721, 3, 485, 242, 0, 721, 722, 3, 495, 247, 0, 722, 723, 3, 507, 253, 0, 723, 132, 1, 0, 0, 0, 724, 725, 3, 469, 234, 0, 725, 726, 3, 505, 252, 0, 726, 727, 3, 505, 252, 0, 727, 728, 3, 477, 238, 0, 728, 729, 3, 503, 251, 0, 729, 730, 3, 507, 253, 0, 730, 134, 1, 0, 0, 0, 731, 732, 3, 485, 242, 0, 732, 733, 3, 505, 252, 0, 733, 136, 1, 0, 0, 0, 734, 735, 3, 509, 254, 0, 735, 736, 3, 495, 247, 0, 736, 737, 3, 485, 242, 0, 737, 738, 3, 501, 250, 0, 738, 739, 3, 509, 254, 0, 739, 740, 3, 477, 238, 0, 740, 138, 1, 0, 0, 0, 741, 742, 3, 477, 238, 0, 742, 743, 3, 515, 257, 0, 743, 744, 3, 485, 242, 0, 744, 745, 3, 505, 252, 0, 745, 746, 3, 507, 253, 0, 746, 747, 3, 505, 252, 0, 747, 140, 1, 0, 0, 0, 748, 749, 3, 491, 245, 0, 749, 750, 3, 497, 248, 0, 750, 751, 3, 469, 234, 0, 751, 752, 3, 475, 237, 0, 752, 142, 1, 0, 0, 0, 753, 754, 3, 473, 236, 0, 754, 755, 3, 505, 252, 0, 755, 756, 3, 511, 255, 0, 756, 144, 1, 0, 0, 0, 757, 758, 3, 513, 256, 0, 758, 759, 3, 485, 242, 0, 759, 760, 3, 507, 253, 0, 760, 761, 3, 483, 241, 0, 761, 146, 1, 0, 0, 0, 762, 763, 3, 483, 241, 0, 763, 764, 3, 477, 238, 0, 764, 765, 3, 469, 234, 0, 765, 766, 3, 475, 237, 0, 766, 767, 3, 477, 238, 0, 767, 768, 3, 503, 251, 0, 768, 769, 3, 505, 252, 0, 769, 148, 1, 0, 0, 0, 770, 771, 3, 479, 239, 0, 771, 772, 3, 503, 251, 0, 772, 773, 3, 497, 248, 0, 773, 774, 3, 493, 246, 0, 774, 150, 1, 0, 0, 0, 775, 776, 3, 469, 234, 0, 776, 777, 3, 505, 252, 0, 777, 152, 1, 0, 0, 0, 778, 779, 3, 479, 239, 0, 779, 780, 3, 485, 242, 0, 780, 781, 3, 477, 238, 0, 781, 782, 3, 491, 245, 0, 782, 783, 3, 475, 237, 0, 783, 784, 3, 507, 253, 0, 784, 785, 3, 477, 238, 0, 785, 786, 3, 503, 251, 0, 786, 787, 3, 493, 246, 0, 787, 788, 3, 485, 242, 0, 788, 789, 3, 495, 247, 0, 789, 790, 3, 469, 234, 0, 790, 791, 3, 507, 253, 0, 791, 792, 3, 497, 248, 0, 792, 793, 3, 503, 251, 0, 793, 154, 1, 0, 0, 0, 794, 795, 3, 497, 248, 0, 795, 796, 3, 499, 249, 0, 796, 797, 3, 507, 253, 0, 797, 798, 3, 485, 242, 0, 798, 799, 3, 497, 248, 0, 799, 800, 3, 495, 247, 0, 800, 801, 3, 469, 234, 0, 801, 802, 3, 491, 245, 0, 802, 156, 1, 0, 0, 0, 803, 804, 3, 493, 246, 0, 804, 805, 3, 469, 234, 0, 805, 806, 3, 507, 253, 0, 806, 807, 3, 473, 236, 0, 807, 808, 3, 483, 241, 0, 808, 158, 1, 0, 0, 0, 809, 810, 3, 509, 254, 0, 810, 811, 3, 495, 247, 0, 811, 812, 3, 513, 256, 0, 812, 813, 3, 485, 242, 0, 813, 814, 3, 495, 247, 0, 814, 815, 3, 475, 237, 0, 815, 160, 1, 0, 0, 0, 816, 817, 3, 493, 246, 0, 817, 818, 3, 477, 238, 0, 818, 819, 3, 503, 251, 0, 819, 820, 3, 481, 240, 0, 820, 821, 3, 477, 238, 0, 821, 162, 1, 0, 0, 0, 822, 823, 3, 505, 252, 0, 823, 824, 3, 477, 238, 0, 824, 825, 3, 507, 253, 0, 825, 164, 1, 0, 0, 0, 826, 827, 3, 475, 237, 0, 827, 828, 3, 477, 238, 0, 828, 829, 3, 507, 253, 0, 829, 830, 3, 469, 234, 0, 830, 831, 3, 473, 236, 0, 831, 832, 3, 483, 241, 0, 832, 166, 1, 0, 0, 0, 833, 834, 3, 475, 237, 0, 834, 835, 3, 477, 238, 0, 835, 836, 3, 491, 245, 0, 836, 837, 3, 477, 238, 0, 837, 838, 3, 507, 253, 0, 838, 839, 3, 477, 238, 0, 839, 168, 1, 0, 0, 0, 840, 841, 3, 503, 251, 0, 841, 842, 3, 477, 238, 0, 842, 843, 3, 493, 246, 0, 843, 844, 3, 497, 248, 0, 844, 845, 3, 511, 255, 0, 845, 846, 3, 477, 238, 0, 846, 170, 1, 0, 0, 0, 847, 848, 3, 479, 239, 0, 848, 849, 3, 497, 248, 0, 849, 850, 3, 503, 251, 0, 850, 851, 3, 477, 238, 0, 851, 852, 3, 469, 234, 0, 852, 853, 3, 473, 236, 0, 853, 854, 3, 483, 241, 0, 854, 172, 1, 0, 0, 0, 855, 856, 3, 485, 242, 0, 856, 857, 3, 495, 247, 0, 857, 174, 1, 0, 0, 0, 858, 859, 3, 475, 237, 0, 859, 860, 3, 485, 242, 0, 860, 861, 3, 505, 252, 0, 861, 862, 3, 507, 253, 0, 862, 863, 3, 485, 242, 0, 863, 864, 3, 495, 247, 0, 864, 865, 3, 473, 236, 0, 865, 866, 3, 507, 253, 0, 866, 176, 1, 0, 0, 0, 867, 868, 3, 503, 251, 0, 868, 869, 3, 477, 238, 0, 869, 870, 3, 507, 253, 0, 870, 871, 3, 509, 254, 0, 871, 872, 3, 503, 251, 0, 872, 873, 3, 495, 247, 0, 873, 178, 1, 0, 0, 0, 874, 875, 3, 497, 248, 0, 875, 876, 3, 503, 251, 0, 876, 877, 3, 475, 237, 0, 877, 878, 3, 477, 238, 0, 878, 879, 3, 503, 251, 0, 879, 180, 1, 0, 0, 0, 880, 881, 3, 471, 235, 0, 881, 882, 3, 517, 258, 0, 882, 182, 1, 0, 0, 0, 883, 884, 3, 505, 252, 0, 884, 885, 3, 489, 244, 0, 885, 886, 3, 485, 242, 0, 886, 887, 3, 499, 249, 0, 887, 184, 1, 0, 0, 0, 888, 889, 3, 491, 245, 0, 889, 890, 3, 485, 242, 0, 890, 891, 3, 493, 246, 0, 891, 892, 3, 485, 242, 0, 892, 893, 3, 507, 253, 0, 893, 186, 1, 0, 0, 0, 894, 895, 3, 469, 234, 0, 895, 896, 3, 505, 252, 0, 896, 897, 3, 473, 236, 0, 897, 898, 3, 477, 238, 0, 898, 899, 3, 495, 247, 0, 899, 900, 3, 475, 237, 0, 900, 901, 3, 485, 242, 0, 901, 902, 3, 495, 247, 0, 902, 903, 3, 481, 240, 0, 903, 188, 1, 0, 0, 0, 904, 905, 3, 469, 234, 0, 905, 906, 3, 505, 252, 0, 906, 907, 3, 473, 236, 0, 907, 190, 1, 0, 0, 0, 908, 909, 3, 475, 237, 0, 909, 910, 3, 477, 238, 0, 910, 911, 3, 505, 252, 0, 911, 912, 3, 473, 236, 0, 912, 913, 3, 477, 238, 0, 913, 914, 3, 495, 247, 0, 914, 915, 3, 475, 237, 0, 915, 916, 3, 485, 242, 0, 916, 917, 3, 495, 247, 0, 917, 918, 3, 481, 240, 0, 918, 192, 1, 0, 0, 0, 919, 920, 3, 475, 237, 0, 920, 921, 3, 477, 238, 0, 921, 922, 3, 505, 252, 0, 922, 923, 3, 473, 236, 0, 923, 194, 1, 0, 0, 0, 924, 925, 3, 487, 243, 0, 925, 926, 3, 497, 248, 0, 926, 927, 3, 485, 242, 0, 927, 928, 3, 495, 247, 0, 928, 196, 1, 0, 0, 0, 929, 930, 3, 505, 252, 0, 930, 931, 3, 473, 236, 0, 931, 932, 3, 469, 234, 0, 932, 933, 3, 495, 247, 0, 933, 198, 1, 0, 0, 0, 934, 935, 3, 505, 252, 0, 935, 936, 3, 507, 253, 0, 936, 937, 3, 469, 234, 0, 937, 938, 3, 503, 251, 0, 938, 939, 3, 507, 253, 0, 939, 200, 1, 0, 0, 0, 940, 941, 3, 495, 247, 0, 941, 942, 3, 497, 248, 0, 942, 943, 3, 475, 237, 0, 943, 944, 3, 477, 238, 0, 944, 202, 1, 0, 0, 0, 945, 946, 3, 503, 251, 0, 946, 947, 3, 477, 238, 0, 947, 948, 3, 491, 245, 0, 948, 949, 3, 469, 234, 0, 949, 950, 3, 507, 253, 0, 950, 951, 3, 485, 242, 0, 951, 952, 3, 497, 248, 0, 952, 953, 3, 495, 247, 0, 953, 954, 3, 505, 252, 0, 954, 955, 3, 483, 241, 0, 955, 956, 3, 485, 242, 0, 956, 957, 3, 499, 249, 0, 957, 204, 1, 0, 0, 0, 958, 959, 3, 503, 251, 0, 959, 960, 3, 477, 238, 0, 960, 961, 3, 491, 245, 0, 961, 206, 1, 0, 0, 0, 962, 963, 3, 513, 256, 0, 963, 964, 3, 483, 241, 0, 964, 965, 3, 477, 238, 0, 965, 966, 3, 503, 251, 0, 966, 967, 3, 477, 238, 0, 967, 208, 1, 0, 0, 0, 968, 969, 3, 505, 252, 0, 969, 970, 3, 483, 241, 0, 970, 971, 3, 497, 248, 0, 971, 972, 3, 503, 251, 0, 972, 973, 3, 507, 253, 0, 973, 974, 3, 477, 238, 0, 974, 975, 3, 505, 252, 0, 975, 976, 3, 507, 253, 0, 976, 977, 3, 499, 249, 0, 977, 978, 3, 469, 234, 0, 978, 979, 3, 507, 253, 0, 979, 980, 3, 483, 241, 0, 980, 210, 1, 0, 0, 0, 981, 982, 3, 469, 234, 0, 982, 983, 3, 491, 245, 0, 983, 984, 3, 491, 245, 0, 984, 985, 3, 505, 252, 0, 985, 986, 3, 483, 241, 0, 986, 987, 3, 497, 248, 0, 987, 988, 3, 503, 251, 0, 988, 989, 3, 507, 253, 0, 989, 990, 3, 477, 238, 0, 990, 991, 3, 505, 252, 0, 991, 992, 3, 507, 253, 0, 992, 993, 3, 499, 249, 0, 993, 994, 3, 469, 234, 0, 994, 995, 3, 507, 253, 0, 995, 996, 3, 483, 241, 0, 996, 997, 3, 505, 252, 0, 997, 212, 1, 0, 0, 0, 998, 999, 3, 497, 248, 0, 999, 1e3, 3, 503, 251, 0, 1e3, 214, 1, 0, 0, 0, 1001, 1002, 3, 515, 257, 0, 1002, 1003, 3, 497, 248, 0, 1003, 1004, 3, 503, 251, 0, 1004, 216, 1, 0, 0, 0, 1005, 1006, 3, 469, 234, 0, 1006, 1007, 3, 495, 247, 0, 1007, 1008, 3, 475, 237, 0, 1008, 218, 1, 0, 0, 0, 1009, 1010, 3, 495, 247, 0, 1010, 1011, 3, 497, 248, 0, 1011, 1012, 3, 507, 253, 0, 1012, 220, 1, 0, 0, 0, 1013, 1014, 3, 505, 252, 0, 1014, 1015, 3, 507, 253, 0, 1015, 1016, 3, 469, 234, 0, 1016, 1017, 3, 503, 251, 0, 1017, 1018, 3, 507, 253, 0, 1018, 1019, 3, 505, 252, 0, 1019, 222, 1, 0, 0, 0, 1020, 1021, 3, 477, 238, 0, 1021, 1022, 3, 495, 247, 0, 1022, 1023, 3, 475, 237, 0, 1023, 1024, 3, 505, 252, 0, 1024, 224, 1, 0, 0, 0, 1025, 1026, 3, 473, 236, 0, 1026, 1027, 3, 497, 248, 0, 1027, 1028, 3, 495, 247, 0, 1028, 1029, 3, 507, 253, 0, 1029, 1030, 3, 469, 234, 0, 1030, 1031, 3, 485, 242, 0, 1031, 1032, 3, 495, 247, 0, 1032, 1033, 3, 505, 252, 0, 1033, 226, 1, 0, 0, 0, 1034, 1035, 3, 495, 247, 0, 1035, 1036, 3, 509, 254, 0, 1036, 1037, 3, 491, 245, 0, 1037, 1038, 3, 491, 245, 0, 1038, 228, 1, 0, 0, 0, 1039, 1040, 3, 473, 236, 0, 1040, 1041, 3, 497, 248, 0, 1041, 1042, 3, 509, 254, 0, 1042, 1043, 3, 495, 247, 0, 1043, 1044, 3, 507, 253, 0, 1044, 230, 1, 0, 0, 0, 1045, 1046, 3, 479, 239, 0, 1046, 1047, 3, 485, 242, 0, 1047, 1048, 3, 491, 245, 0, 1048, 1049, 3, 507, 253, 0, 1049, 1050, 3, 477, 238, 0, 1050, 1051, 3, 503, 251, 0, 1051, 232, 1, 0, 0, 0, 1052, 1053, 3, 477, 238, 0, 1053, 1054, 3, 515, 257, 0, 1054, 1055, 3, 507, 253, 0, 1055, 1056, 3, 503, 251, 0, 1056, 1057, 3, 469, 234, 0, 1057, 1058, 3, 473, 236, 0, 1058, 1059, 3, 507, 253, 0, 1059, 234, 1, 0, 0, 0, 1060, 1061, 3, 469, 234, 0, 1061, 1062, 3, 495, 247, 0, 1062, 1063, 3, 517, 258, 0, 1063, 236, 1, 0, 0, 0, 1064, 1065, 3, 495, 247, 0, 1065, 1066, 3, 497, 248, 0, 1066, 1067, 3, 495, 247, 0, 1067, 1068, 3, 477, 238, 0, 1068, 238, 1, 0, 0, 0, 1069, 1070, 3, 505, 252, 0, 1070, 1071, 3, 485, 242, 0, 1071, 1072, 3, 495, 247, 0, 1072, 1073, 3, 481, 240, 0, 1073, 1074, 3, 491, 245, 0, 1074, 1075, 3, 477, 238, 0, 1075, 240, 1, 0, 0, 0, 1076, 1077, 3, 507, 253, 0, 1077, 1078, 3, 503, 251, 0, 1078, 1079, 3, 509, 254, 0, 1079, 1080, 3, 477, 238, 0, 1080, 242, 1, 0, 0, 0, 1081, 1082, 3, 479, 239, 0, 1082, 1083, 3, 469, 234, 0, 1083, 1084, 3, 491, 245, 0, 1084, 1085, 3, 505, 252, 0, 1085, 1086, 3, 477, 238, 0, 1086, 244, 1, 0, 0, 0, 1087, 1088, 3, 503, 251, 0, 1088, 1089, 3, 477, 238, 0, 1089, 1090, 3, 475, 237, 0, 1090, 1091, 3, 509, 254, 0, 1091, 1092, 3, 473, 236, 0, 1092, 1093, 3, 477, 238, 0, 1093, 246, 1, 0, 0, 0, 1094, 1095, 3, 473, 236, 0, 1095, 1096, 3, 469, 234, 0, 1096, 1097, 3, 505, 252, 0, 1097, 1098, 3, 477, 238, 0, 1098, 248, 1, 0, 0, 0, 1099, 1100, 3, 477, 238, 0, 1100, 1101, 3, 491, 245, 0, 1101, 1102, 3, 505, 252, 0, 1102, 1103, 3, 477, 238, 0, 1103, 250, 1, 0, 0, 0, 1104, 1105, 3, 477, 238, 0, 1105, 1106, 3, 495, 247, 0, 1106, 1107, 3, 475, 237, 0, 1107, 252, 1, 0, 0, 0, 1108, 1109, 3, 513, 256, 0, 1109, 1110, 3, 483, 241, 0, 1110, 1111, 3, 477, 238, 0, 1111, 1112, 3, 495, 247, 0, 1112, 254, 1, 0, 0, 0, 1113, 1114, 3, 507, 253, 0, 1114, 1115, 3, 483, 241, 0, 1115, 1116, 3, 477, 238, 0, 1116, 1117, 3, 495, 247, 0, 1117, 256, 1, 0, 0, 0, 1118, 1119, 3, 473, 236, 0, 1119, 1120, 3, 469, 234, 0, 1120, 1121, 3, 491, 245, 0, 1121, 1122, 3, 491, 245, 0, 1122, 258, 1, 0, 0, 0, 1123, 1124, 3, 517, 258, 0, 1124, 1125, 3, 485, 242, 0, 1125, 1126, 3, 477, 238, 0, 1126, 1127, 3, 491, 245, 0, 1127, 1128, 3, 475, 237, 0, 1128, 260, 1, 0, 0, 0, 1129, 1130, 3, 489, 244, 0, 1130, 1131, 3, 477, 238, 0, 1131, 1132, 3, 517, 258, 0, 1132, 262, 1, 0, 0, 0, 1133, 1134, 3, 473, 236, 0, 1134, 1135, 3, 469, 234, 0, 1135, 1136, 3, 507, 253, 0, 1136, 1137, 3, 469, 234, 0, 1137, 1138, 3, 491, 245, 0, 1138, 1139, 3, 497, 248, 0, 1139, 1140, 3, 481, 240, 0, 1140, 264, 1, 0, 0, 0, 1141, 1142, 3, 505, 252, 0, 1142, 1143, 3, 483, 241, 0, 1143, 1144, 3, 497, 248, 0, 1144, 1145, 3, 513, 256, 0, 1145, 266, 1, 0, 0, 0, 1146, 1147, 3, 475, 237, 0, 1147, 1148, 3, 477, 238, 0, 1148, 1149, 3, 479, 239, 0, 1149, 1150, 3, 469, 234, 0, 1150, 1151, 3, 509, 254, 0, 1151, 1152, 3, 491, 245, 0, 1152, 1153, 3, 507, 253, 0, 1153, 268, 1, 0, 0, 0, 1154, 1155, 3, 475, 237, 0, 1155, 1156, 3, 471, 235, 0, 1156, 1157, 3, 493, 246, 0, 1157, 1158, 3, 505, 252, 0, 1158, 270, 1, 0, 0, 0, 1159, 1160, 3, 475, 237, 0, 1160, 1161, 3, 469, 234, 0, 1161, 1162, 3, 507, 253, 0, 1162, 1163, 3, 469, 234, 0, 1163, 1164, 3, 471, 235, 0, 1164, 1165, 3, 469, 234, 0, 1165, 1166, 3, 505, 252, 0, 1166, 1167, 3, 477, 238, 0, 1167, 272, 1, 0, 0, 0, 1168, 1169, 3, 475, 237, 0, 1169, 1170, 3, 469, 234, 0, 1170, 1171, 3, 507, 253, 0, 1171, 1172, 3, 469, 234, 0, 1172, 1173, 3, 471, 235, 0, 1173, 1174, 3, 469, 234, 0, 1174, 1175, 3, 505, 252, 0, 1175, 1176, 3, 477, 238, 0, 1176, 1177, 3, 505, 252, 0, 1177, 274, 1, 0, 0, 0, 1178, 1179, 3, 481, 240, 0, 1179, 1180, 3, 503, 251, 0, 1180, 1181, 3, 469, 234, 0, 1181, 1182, 3, 499, 249, 0, 1182, 1183, 3, 483, 241, 0, 1183, 276, 1, 0, 0, 0, 1184, 1185, 3, 481, 240, 0, 1185, 1186, 3, 503, 251, 0, 1186, 1187, 3, 469, 234, 0, 1187, 1188, 3, 499, 249, 0, 1188, 1189, 3, 483, 241, 0, 1189, 1190, 3, 505, 252, 0, 1190, 278, 1, 0, 0, 0, 1191, 1192, 3, 503, 251, 0, 1192, 1193, 3, 477, 238, 0, 1193, 1194, 3, 499, 249, 0, 1194, 1195, 3, 491, 245, 0, 1195, 1196, 3, 469, 234, 0, 1196, 1197, 3, 473, 236, 0, 1197, 1198, 3, 477, 238, 0, 1198, 280, 1, 0, 0, 0, 1199, 1200, 3, 485, 242, 0, 1200, 1201, 3, 479, 239, 0, 1201, 282, 1, 0, 0, 0, 1202, 1203, 3, 505, 252, 0, 1203, 1204, 3, 507, 253, 0, 1204, 1205, 3, 497, 248, 0, 1205, 1206, 3, 499, 249, 0, 1206, 284, 1, 0, 0, 0, 1207, 1208, 3, 503, 251, 0, 1208, 1209, 3, 497, 248, 0, 1209, 1210, 3, 491, 245, 0, 1210, 1211, 3, 477, 238, 0, 1211, 286, 1, 0, 0, 0, 1212, 1213, 3, 503, 251, 0, 1213, 1214, 3, 497, 248, 0, 1214, 1215, 3, 491, 245, 0, 1215, 1216, 3, 477, 238, 0, 1216, 1217, 3, 505, 252, 0, 1217, 288, 1, 0, 0, 0, 1218, 1219, 3, 509, 254, 0, 1219, 1220, 3, 505, 252, 0, 1220, 1221, 3, 477, 238, 0, 1221, 1222, 3, 503, 251, 0, 1222, 290, 1, 0, 0, 0, 1223, 1224, 3, 509, 254, 0, 1224, 1225, 3, 505, 252, 0, 1225, 1226, 3, 477, 238, 0, 1226, 1227, 3, 503, 251, 0, 1227, 1228, 3, 505, 252, 0, 1228, 292, 1, 0, 0, 0, 1229, 1230, 3, 499, 249, 0, 1230, 1231, 3, 497, 248, 0, 1231, 1232, 3, 499, 249, 0, 1232, 1233, 3, 509, 254, 0, 1233, 1234, 3, 491, 245, 0, 1234, 1235, 3, 469, 234, 0, 1235, 1236, 3, 507, 253, 0, 1236, 1237, 3, 477, 238, 0, 1237, 1238, 3, 475, 237, 0, 1238, 294, 1, 0, 0, 0, 1239, 1240, 3, 499, 249, 0, 1240, 1241, 3, 469, 234, 0, 1241, 1242, 3, 505, 252, 0, 1242, 1243, 3, 505, 252, 0, 1243, 1244, 3, 513, 256, 0, 1244, 1245, 3, 497, 248, 0, 1245, 1246, 3, 503, 251, 0, 1246, 1247, 3, 475, 237, 0, 1247, 296, 1, 0, 0, 0, 1248, 1249, 3, 473, 236, 0, 1249, 1250, 3, 483, 241, 0, 1250, 1251, 3, 469, 234, 0, 1251, 1252, 3, 495, 247, 0, 1252, 1253, 3, 481, 240, 0, 1253, 1254, 3, 477, 238, 0, 1254, 298, 1, 0, 0, 0, 1255, 1256, 3, 503, 251, 0, 1256, 1257, 3, 477, 238, 0, 1257, 1258, 3, 501, 250, 0, 1258, 1259, 3, 509, 254, 0, 1259, 1260, 3, 485, 242, 0, 1260, 1261, 3, 503, 251, 0, 1261, 1262, 3, 477, 238, 0, 1262, 1263, 3, 475, 237, 0, 1263, 300, 1, 0, 0, 0, 1264, 1265, 3, 505, 252, 0, 1265, 1266, 3, 507, 253, 0, 1266, 1267, 3, 469, 234, 0, 1267, 1268, 3, 507, 253, 0, 1268, 1269, 3, 509, 254, 0, 1269, 1270, 3, 505, 252, 0, 1270, 302, 1, 0, 0, 0, 1271, 1272, 3, 469, 234, 0, 1272, 1273, 3, 473, 236, 0, 1273, 1274, 3, 507, 253, 0, 1274, 1275, 3, 485, 242, 0, 1275, 1276, 3, 511, 255, 0, 1276, 1277, 3, 477, 238, 0, 1277, 304, 1, 0, 0, 0, 1278, 1279, 3, 505, 252, 0, 1279, 1280, 3, 509, 254, 0, 1280, 1281, 3, 505, 252, 0, 1281, 1282, 3, 499, 249, 0, 1282, 1283, 3, 477, 238, 0, 1283, 1284, 3, 495, 247, 0, 1284, 1285, 3, 475, 237, 0, 1285, 1286, 3, 477, 238, 0, 1286, 1287, 3, 475, 237, 0, 1287, 306, 1, 0, 0, 0, 1288, 1289, 3, 469, 234, 0, 1289, 1290, 3, 491, 245, 0, 1290, 1291, 3, 507, 253, 0, 1291, 1292, 3, 477, 238, 0, 1292, 1293, 3, 503, 251, 0, 1293, 308, 1, 0, 0, 0, 1294, 1295, 3, 473, 236, 0, 1295, 1296, 3, 509, 254, 0, 1296, 1297, 3, 503, 251, 0, 1297, 1298, 3, 503, 251, 0, 1298, 1299, 3, 477, 238, 0, 1299, 1300, 3, 495, 247, 0, 1300, 1301, 3, 507, 253, 0, 1301, 310, 1, 0, 0, 0, 1302, 1303, 3, 507, 253, 0, 1303, 1304, 3, 497, 248, 0, 1304, 312, 1, 0, 0, 0, 1305, 1306, 3, 499, 249, 0, 1306, 1307, 3, 503, 251, 0, 1307, 1308, 3, 485, 242, 0, 1308, 1309, 3, 511, 255, 0, 1309, 1310, 3, 485, 242, 0, 1310, 1311, 3, 491, 245, 0, 1311, 1312, 3, 477, 238, 0, 1312, 1313, 3, 481, 240, 0, 1313, 1314, 3, 477, 238, 0, 1314, 1315, 3, 505, 252, 0, 1315, 314, 1, 0, 0, 0, 1316, 1317, 3, 481, 240, 0, 1317, 1318, 3, 503, 251, 0, 1318, 1319, 3, 469, 234, 0, 1319, 1320, 3, 495, 247, 0, 1320, 1321, 3, 507, 253, 0, 1321, 316, 1, 0, 0, 0, 1322, 1323, 3, 475, 237, 0, 1323, 1324, 3, 477, 238, 0, 1324, 1325, 3, 495, 247, 0, 1325, 1326, 3, 517, 258, 0, 1326, 318, 1, 0, 0, 0, 1327, 1328, 3, 503, 251, 0, 1328, 1329, 3, 477, 238, 0, 1329, 1330, 3, 511, 255, 0, 1330, 1331, 3, 497, 248, 0, 1331, 1332, 3, 489, 244, 0, 1332, 1333, 3, 477, 238, 0, 1333, 320, 1, 0, 0, 0, 1334, 1335, 3, 503, 251, 0, 1335, 1336, 3, 477, 238, 0, 1336, 1337, 3, 491, 245, 0, 1337, 1338, 3, 469, 234, 0, 1338, 1339, 3, 507, 253, 0, 1339, 1340, 3, 485, 242, 0, 1340, 1341, 3, 497, 248, 0, 1341, 1342, 3, 495, 247, 0, 1342, 1343, 3, 505, 252, 0, 1343, 1344, 3, 483, 241, 0, 1344, 1345, 3, 485, 242, 0, 1345, 1346, 3, 499, 249, 0, 1346, 1347, 3, 505, 252, 0, 1347, 322, 1, 0, 0, 0, 1348, 1349, 3, 495, 247, 0, 1349, 1350, 3, 497, 248, 0, 1350, 1351, 3, 475, 237, 0, 1351, 1352, 3, 477, 238, 0, 1352, 1353, 3, 505, 252, 0, 1353, 324, 1, 0, 0, 0, 1354, 1355, 3, 477, 238, 0, 1355, 1356, 3, 491, 245, 0, 1356, 1357, 3, 477, 238, 0, 1357, 1358, 3, 493, 246, 0, 1358, 1359, 3, 477, 238, 0, 1359, 1360, 3, 495, 247, 0, 1360, 1361, 3, 507, 253, 0, 1361, 326, 1, 0, 0, 0, 1362, 1363, 3, 477, 238, 0, 1363, 1364, 3, 491, 245, 0, 1364, 1365, 3, 477, 238, 0, 1365, 1366, 3, 493, 246, 0, 1366, 1367, 3, 477, 238, 0, 1367, 1368, 3, 495, 247, 0, 1368, 1369, 3, 507, 253, 0, 1369, 1370, 3, 505, 252, 0, 1370, 328, 1, 0, 0, 0, 1371, 1372, 3, 473, 236, 0, 1372, 1373, 3, 497, 248, 0, 1373, 1374, 3, 499, 249, 0, 1374, 1375, 3, 517, 258, 0, 1375, 330, 1, 0, 0, 0, 1376, 1377, 3, 497, 248, 0, 1377, 1378, 3, 479, 239, 0, 1378, 332, 1, 0, 0, 0, 1379, 1380, 3, 507, 253, 0, 1380, 1381, 3, 503, 251, 0, 1381, 1382, 3, 469, 234, 0, 1382, 1383, 3, 511, 255, 0, 1383, 1384, 3, 477, 238, 0, 1384, 1385, 3, 503, 251, 0, 1385, 1386, 3, 505, 252, 0, 1386, 1387, 3, 477, 238, 0, 1387, 334, 1, 0, 0, 0, 1388, 1389, 3, 503, 251, 0, 1389, 1390, 3, 477, 238, 0, 1390, 1391, 3, 469, 234, 0, 1391, 1392, 3, 475, 237, 0, 1392, 336, 1, 0, 0, 0, 1393, 1394, 3, 513, 256, 0, 1394, 1395, 3, 503, 251, 0, 1395, 1396, 3, 485, 242, 0, 1396, 1397, 3, 507, 253, 0, 1397, 1398, 3, 477, 238, 0, 1398, 338, 1, 0, 0, 0, 1399, 1400, 3, 469, 234, 0, 1400, 1401, 3, 473, 236, 0, 1401, 1402, 3, 473, 236, 0, 1402, 1403, 3, 477, 238, 0, 1403, 1404, 3, 505, 252, 0, 1404, 1405, 3, 505, 252, 0, 1405, 340, 1, 0, 0, 0, 1406, 1407, 3, 485, 242, 0, 1407, 1408, 3, 495, 247, 0, 1408, 1409, 3, 475, 237, 0, 1409, 1410, 3, 477, 238, 0, 1410, 1411, 3, 515, 257, 0, 1411, 1412, 3, 477, 238, 0, 1412, 1413, 3, 505, 252, 0, 1413, 342, 1, 0, 0, 0, 1414, 1415, 3, 493, 246, 0, 1415, 1416, 3, 469, 234, 0, 1416, 1417, 3, 495, 247, 0, 1417, 1418, 3, 469, 234, 0, 1418, 1419, 3, 481, 240, 0, 1419, 1420, 3, 477, 238, 0, 1420, 1421, 3, 493, 246, 0, 1421, 1422, 3, 477, 238, 0, 1422, 1423, 3, 495, 247, 0, 1423, 1424, 3, 507, 253, 0, 1424, 344, 1, 0, 0, 0, 1425, 1426, 3, 495, 247, 0, 1426, 1427, 3, 477, 238, 0, 1427, 1428, 3, 513, 256, 0, 1428, 346, 1, 0, 0, 0, 1429, 1430, 3, 491, 245, 0, 1430, 1431, 3, 469, 234, 0, 1431, 1432, 3, 471, 235, 0, 1432, 1433, 3, 477, 238, 0, 1433, 1434, 3, 491, 245, 0, 1434, 348, 1, 0, 0, 0, 1435, 1436, 3, 491, 245, 0, 1436, 1437, 3, 469, 234, 0, 1437, 1438, 3, 471, 235, 0, 1438, 1439, 3, 477, 238, 0, 1439, 1440, 3, 491, 245, 0, 1440, 1441, 3, 505, 252, 0, 1441, 350, 1, 0, 0, 0, 1442, 1443, 3, 495, 247, 0, 1443, 1444, 3, 469, 234, 0, 1444, 1445, 3, 493, 246, 0, 1445, 1446, 3, 477, 238, 0, 1446, 352, 1, 0, 0, 0, 1447, 1448, 3, 495, 247, 0, 1448, 1449, 3, 469, 234, 0, 1449, 1450, 3, 493, 246, 0, 1450, 1451, 3, 477, 238, 0, 1451, 1452, 3, 505, 252, 0, 1452, 354, 1, 0, 0, 0, 1453, 1454, 3, 507, 253, 0, 1454, 1455, 3, 517, 258, 0, 1455, 1456, 3, 499, 249, 0, 1456, 1457, 3, 477, 238, 0, 1457, 356, 1, 0, 0, 0, 1458, 1459, 3, 507, 253, 0, 1459, 1460, 3, 517, 258, 0, 1460, 1461, 3, 499, 249, 0, 1461, 1462, 3, 477, 238, 0, 1462, 1463, 3, 505, 252, 0, 1463, 358, 1, 0, 0, 0, 1464, 1465, 3, 499, 249, 0, 1465, 1466, 3, 503, 251, 0, 1466, 1467, 3, 497, 248, 0, 1467, 1468, 3, 499, 249, 0, 1468, 1469, 3, 477, 238, 0, 1469, 1470, 3, 503, 251, 0, 1470, 1471, 3, 507, 253, 0, 1471, 1472, 3, 517, 258, 0, 1472, 360, 1, 0, 0, 0, 1473, 1474, 3, 473, 236, 0, 1474, 1475, 3, 497, 248, 0, 1475, 1476, 3, 495, 247, 0, 1476, 1477, 3, 505, 252, 0, 1477, 1478, 3, 507, 253, 0, 1478, 1479, 3, 503, 251, 0, 1479, 1480, 3, 469, 234, 0, 1480, 1481, 3, 485, 242, 0, 1481, 1482, 3, 495, 247, 0, 1482, 1483, 3, 507, 253, 0, 1483, 1484, 3, 505, 252, 0, 1484, 362, 1, 0, 0, 0, 1485, 1486, 3, 469, 234, 0, 1486, 1487, 3, 505, 252, 0, 1487, 1488, 3, 505, 252, 0, 1488, 1489, 3, 485, 242, 0, 1489, 1490, 3, 481, 240, 0, 1490, 1491, 3, 495, 247, 0, 1491, 364, 1, 0, 0, 0, 1492, 1493, 3, 471, 235, 0, 1493, 1494, 3, 507, 253, 0, 1494, 1495, 3, 503, 251, 0, 1495, 1496, 3, 477, 238, 0, 1496, 1497, 3, 477, 238, 0, 1497, 366, 1, 0, 0, 0, 1498, 1499, 3, 477, 238, 0, 1499, 1500, 3, 515, 257, 0, 1500, 1501, 3, 485, 242, 0, 1501, 1502, 3, 505, 252, 0, 1502, 1503, 3, 507, 253, 0, 1503, 368, 1, 0, 0, 0, 1504, 1505, 3, 479, 239, 0, 1505, 1506, 3, 497, 248, 0, 1506, 1507, 3, 503, 251, 0, 1507, 370, 1, 0, 0, 0, 1508, 1509, 3, 497, 248, 0, 1509, 1510, 3, 499, 249, 0, 1510, 1511, 3, 507, 253, 0, 1511, 1512, 3, 485, 242, 0, 1512, 1513, 3, 497, 248, 0, 1513, 1514, 3, 495, 247, 0, 1514, 1515, 3, 505, 252, 0, 1515, 372, 1, 0, 0, 0, 1516, 1517, 3, 477, 238, 0, 1517, 1518, 3, 515, 257, 0, 1518, 1519, 3, 477, 238, 0, 1519, 1520, 3, 473, 236, 0, 1520, 1521, 3, 509, 254, 0, 1521, 1522, 3, 507, 253, 0, 1522, 1523, 3, 477, 238, 0, 1523, 374, 1, 0, 0, 0, 1524, 1525, 3, 475, 237, 0, 1525, 1526, 3, 477, 238, 0, 1526, 1527, 3, 479, 239, 0, 1527, 1528, 3, 485, 242, 0, 1528, 1529, 3, 495, 247, 0, 1529, 1530, 3, 477, 238, 0, 1530, 1531, 3, 475, 237, 0, 1531, 376, 1, 0, 0, 0, 1532, 1533, 3, 479, 239, 0, 1533, 1534, 3, 509, 254, 0, 1534, 1535, 3, 495, 247, 0, 1535, 1536, 3, 473, 236, 0, 1536, 1537, 3, 507, 253, 0, 1537, 1538, 3, 485, 242, 0, 1538, 1539, 3, 497, 248, 0, 1539, 1540, 3, 495, 247, 0, 1540, 378, 1, 0, 0, 0, 1541, 1542, 3, 479, 239, 0, 1542, 1543, 3, 509, 254, 0, 1543, 1544, 3, 495, 247, 0, 1544, 1545, 3, 473, 236, 0, 1545, 1546, 3, 507, 253, 0, 1546, 1547, 3, 485, 242, 0, 1547, 1548, 3, 497, 248, 0, 1548, 1549, 3, 495, 247, 0, 1549, 1550, 3, 505, 252, 0, 1550, 380, 1, 0, 0, 0, 1551, 1552, 3, 471, 235, 0, 1552, 1553, 3, 497, 248, 0, 1553, 1554, 3, 497, 248, 0, 1554, 1555, 3, 505, 252, 0, 1555, 1556, 3, 507, 253, 0, 1556, 1557, 3, 477, 238, 0, 1557, 1558, 3, 475, 237, 0, 1558, 382, 1, 0, 0, 0, 1559, 1560, 3, 499, 249, 0, 1560, 1561, 3, 503, 251, 0, 1561, 1562, 3, 497, 248, 0, 1562, 1563, 3, 473, 236, 0, 1563, 1564, 3, 477, 238, 0, 1564, 1565, 3, 475, 237, 0, 1565, 1566, 3, 509, 254, 0, 1566, 1567, 3, 503, 251, 0, 1567, 1568, 3, 477, 238, 0, 1568, 384, 1, 0, 0, 0, 1569, 1570, 3, 499, 249, 0, 1570, 1571, 3, 503, 251, 0, 1571, 1572, 3, 497, 248, 0, 1572, 1573, 3, 473, 236, 0, 1573, 1574, 3, 477, 238, 0, 1574, 1575, 3, 475, 237, 0, 1575, 1576, 3, 509, 254, 0, 1576, 1577, 3, 503, 251, 0, 1577, 1578, 3, 477, 238, 0, 1578, 1579, 3, 505, 252, 0, 1579, 386, 1, 0, 0, 0, 1580, 1581, 3, 469, 234, 0, 1581, 1582, 3, 475, 237, 0, 1582, 1583, 3, 493, 246, 0, 1583, 1584, 3, 485, 242, 0, 1584, 1585, 3, 495, 247, 0, 1585, 388, 1, 0, 0, 0, 1586, 1587, 3, 469, 234, 0, 1587, 1588, 3, 475, 237, 0, 1588, 1589, 3, 493, 246, 0, 1589, 1590, 3, 485, 242, 0, 1590, 1591, 3, 495, 247, 0, 1591, 1592, 3, 485, 242, 0, 1592, 1593, 3, 505, 252, 0, 1593, 1594, 3, 507, 253, 0, 1594, 1595, 3, 503, 251, 0, 1595, 1596, 3, 469, 234, 0, 1596, 1597, 3, 507, 253, 0, 1597, 1598, 3, 497, 248, 0, 1598, 1599, 3, 503, 251, 0, 1599, 390, 1, 0, 0, 0, 1600, 1601, 3, 471, 235, 0, 1601, 1602, 3, 503, 251, 0, 1602, 1603, 3, 485, 242, 0, 1603, 1604, 3, 477, 238, 0, 1604, 1605, 3, 479, 239, 0, 1605, 392, 1, 0, 0, 0, 1606, 1607, 3, 511, 255, 0, 1607, 1608, 3, 477, 238, 0, 1608, 1609, 3, 503, 251, 0, 1609, 1610, 3, 471, 235, 0, 1610, 1611, 3, 497, 248, 0, 1611, 1612, 3, 505, 252, 0, 1612, 1613, 3, 477, 238, 0, 1613, 394, 1, 0, 0, 0, 1614, 1615, 3, 497, 248, 0, 1615, 1616, 3, 509, 254, 0, 1616, 1617, 3, 507, 253, 0, 1617, 1618, 3, 499, 249, 0, 1618, 1619, 3, 509, 254, 0, 1619, 1620, 3, 507, 253, 0, 1620, 396, 1, 0, 0, 0, 1621, 1630, 5, 34, 0, 0, 1622, 1629, 8, 0, 0, 0, 1623, 1626, 5, 92, 0, 0, 1624, 1627, 9, 0, 0, 0, 1625, 1627, 5, 0, 0, 1, 1626, 1624, 1, 0, 0, 0, 1626, 1625, 1, 0, 0, 0, 1627, 1629, 1, 0, 0, 0, 1628, 1622, 1, 0, 0, 0, 1628, 1623, 1, 0, 0, 0, 1629, 1632, 1, 0, 0, 0, 1630, 1628, 1, 0, 0, 0, 1630, 1631, 1, 0, 0, 0, 1631, 1633, 1, 0, 0, 0, 1632, 1630, 1, 0, 0, 0, 1633, 1648, 5, 34, 0, 0, 1634, 1643, 5, 39, 0, 0, 1635, 1642, 8, 1, 0, 0, 1636, 1639, 5, 92, 0, 0, 1637, 1640, 9, 0, 0, 0, 1638, 1640, 5, 0, 0, 1, 1639, 1637, 1, 0, 0, 0, 1639, 1638, 1, 0, 0, 0, 1640, 1642, 1, 0, 0, 0, 1641, 1635, 1, 0, 0, 0, 1641, 1636, 1, 0, 0, 0, 1642, 1645, 1, 0, 0, 0, 1643, 1641, 1, 0, 0, 0, 1643, 1644, 1, 0, 0, 0, 1644, 1646, 1, 0, 0, 0, 1645, 1643, 1, 0, 0, 0, 1646, 1648, 5, 39, 0, 0, 1647, 1621, 1, 0, 0, 0, 1647, 1634, 1, 0, 0, 0, 1648, 398, 1, 0, 0, 0, 1649, 1650, 5, 37, 0, 0, 1650, 1651, 7, 2, 0, 0, 1651, 1653, 7, 2, 0, 0, 1652, 1649, 1, 0, 0, 0, 1653, 1654, 1, 0, 0, 0, 1654, 1652, 1, 0, 0, 0, 1654, 1655, 1, 0, 0, 0, 1655, 400, 1, 0, 0, 0, 1656, 1674, 5, 92, 0, 0, 1657, 1675, 7, 3, 0, 0, 1658, 1659, 7, 4, 0, 0, 1659, 1660, 3, 411, 205, 0, 1660, 1661, 3, 411, 205, 0, 1661, 1662, 3, 411, 205, 0, 1662, 1663, 3, 411, 205, 0, 1663, 1675, 1, 0, 0, 0, 1664, 1665, 7, 4, 0, 0, 1665, 1666, 3, 411, 205, 0, 1666, 1667, 3, 411, 205, 0, 1667, 1668, 3, 411, 205, 0, 1668, 1669, 3, 411, 205, 0, 1669, 1670, 3, 411, 205, 0, 1670, 1671, 3, 411, 205, 0, 1671, 1672, 3, 411, 205, 0, 1672, 1673, 3, 411, 205, 0, 1673, 1675, 1, 0, 0, 0, 1674, 1657, 1, 0, 0, 0, 1674, 1658, 1, 0, 0, 0, 1674, 1664, 1, 0, 0, 0, 1675, 402, 1, 0, 0, 0, 1676, 1677, 5, 48, 0, 0, 1677, 1678, 5, 120, 0, 0, 1678, 1680, 1, 0, 0, 0, 1679, 1681, 3, 411, 205, 0, 1680, 1679, 1, 0, 0, 0, 1681, 1682, 1, 0, 0, 0, 1682, 1680, 1, 0, 0, 0, 1682, 1683, 1, 0, 0, 0, 1683, 404, 1, 0, 0, 0, 1684, 1693, 3, 421, 210, 0, 1685, 1689, 3, 415, 207, 0, 1686, 1688, 3, 413, 206, 0, 1687, 1686, 1, 0, 0, 0, 1688, 1691, 1, 0, 0, 0, 1689, 1687, 1, 0, 0, 0, 1689, 1690, 1, 0, 0, 0, 1690, 1693, 1, 0, 0, 0, 1691, 1689, 1, 0, 0, 0, 1692, 1684, 1, 0, 0, 0, 1692, 1685, 1, 0, 0, 0, 1693, 406, 1, 0, 0, 0, 1694, 1696, 3, 421, 210, 0, 1695, 1697, 3, 419, 209, 0, 1696, 1695, 1, 0, 0, 0, 1697, 1698, 1, 0, 0, 0, 1698, 1696, 1, 0, 0, 0, 1698, 1699, 1, 0, 0, 0, 1699, 408, 1, 0, 0, 0, 1700, 1702, 7, 5, 0, 0, 1701, 1700, 1, 0, 0, 0, 1702, 410, 1, 0, 0, 0, 1703, 1706, 3, 413, 206, 0, 1704, 1706, 3, 409, 204, 0, 1705, 1703, 1, 0, 0, 0, 1705, 1704, 1, 0, 0, 0, 1706, 412, 1, 0, 0, 0, 1707, 1710, 3, 421, 210, 0, 1708, 1710, 3, 415, 207, 0, 1709, 1707, 1, 0, 0, 0, 1709, 1708, 1, 0, 0, 0, 1710, 414, 1, 0, 0, 0, 1711, 1714, 3, 417, 208, 0, 1712, 1714, 2, 56, 57, 0, 1713, 1711, 1, 0, 0, 0, 1713, 1712, 1, 0, 0, 0, 1714, 416, 1, 0, 0, 0, 1715, 1716, 2, 49, 55, 0, 1716, 418, 1, 0, 0, 0, 1717, 1720, 3, 421, 210, 0, 1718, 1720, 3, 417, 208, 0, 1719, 1717, 1, 0, 0, 0, 1719, 1718, 1, 0, 0, 0, 1720, 420, 1, 0, 0, 0, 1721, 1722, 5, 48, 0, 0, 1722, 422, 1, 0, 0, 0, 1723, 1725, 3, 413, 206, 0, 1724, 1723, 1, 0, 0, 0, 1725, 1726, 1, 0, 0, 0, 1726, 1724, 1, 0, 0, 0, 1726, 1727, 1, 0, 0, 0, 1727, 1746, 1, 0, 0, 0, 1728, 1730, 3, 413, 206, 0, 1729, 1728, 1, 0, 0, 0, 1730, 1731, 1, 0, 0, 0, 1731, 1729, 1, 0, 0, 0, 1731, 1732, 1, 0, 0, 0, 1732, 1733, 1, 0, 0, 0, 1733, 1735, 5, 46, 0, 0, 1734, 1736, 3, 413, 206, 0, 1735, 1734, 1, 0, 0, 0, 1736, 1737, 1, 0, 0, 0, 1737, 1735, 1, 0, 0, 0, 1737, 1738, 1, 0, 0, 0, 1738, 1746, 1, 0, 0, 0, 1739, 1741, 5, 46, 0, 0, 1740, 1742, 3, 413, 206, 0, 1741, 1740, 1, 0, 0, 0, 1742, 1743, 1, 0, 0, 0, 1743, 1741, 1, 0, 0, 0, 1743, 1744, 1, 0, 0, 0, 1744, 1746, 1, 0, 0, 0, 1745, 1724, 1, 0, 0, 0, 1745, 1729, 1, 0, 0, 0, 1745, 1739, 1, 0, 0, 0, 1746, 1747, 1, 0, 0, 0, 1747, 1749, 7, 6, 0, 0, 1748, 1750, 5, 45, 0, 0, 1749, 1748, 1, 0, 0, 0, 1749, 1750, 1, 0, 0, 0, 1750, 1752, 1, 0, 0, 0, 1751, 1753, 3, 413, 206, 0, 1752, 1751, 1, 0, 0, 0, 1753, 1754, 1, 0, 0, 0, 1754, 1752, 1, 0, 0, 0, 1754, 1755, 1, 0, 0, 0, 1755, 424, 1, 0, 0, 0, 1756, 1758, 3, 413, 206, 0, 1757, 1756, 1, 0, 0, 0, 1758, 1761, 1, 0, 0, 0, 1759, 1757, 1, 0, 0, 0, 1759, 1760, 1, 0, 0, 0, 1760, 1762, 1, 0, 0, 0, 1761, 1759, 1, 0, 0, 0, 1762, 1764, 5, 46, 0, 0, 1763, 1765, 3, 413, 206, 0, 1764, 1763, 1, 0, 0, 0, 1765, 1766, 1, 0, 0, 0, 1766, 1764, 1, 0, 0, 0, 1766, 1767, 1, 0, 0, 0, 1767, 426, 1, 0, 0, 0, 1768, 1772, 3, 429, 214, 0, 1769, 1771, 3, 431, 215, 0, 1770, 1769, 1, 0, 0, 0, 1771, 1774, 1, 0, 0, 0, 1772, 1770, 1, 0, 0, 0, 1772, 1773, 1, 0, 0, 0, 1773, 428, 1, 0, 0, 0, 1774, 1772, 1, 0, 0, 0, 1775, 1778, 3, 467, 233, 0, 1776, 1778, 7, 7, 0, 0, 1777, 1775, 1, 0, 0, 0, 1777, 1776, 1, 0, 0, 0, 1778, 430, 1, 0, 0, 0, 1779, 1782, 3, 447, 223, 0, 1780, 1782, 3, 455, 227, 0, 1781, 1779, 1, 0, 0, 0, 1781, 1780, 1, 0, 0, 0, 1782, 432, 1, 0, 0, 0, 1783, 1789, 5, 96, 0, 0, 1784, 1788, 8, 8, 0, 0, 1785, 1786, 5, 96, 0, 0, 1786, 1788, 5, 96, 0, 0, 1787, 1784, 1, 0, 0, 0, 1787, 1785, 1, 0, 0, 0, 1788, 1791, 1, 0, 0, 0, 1789, 1787, 1, 0, 0, 0, 1789, 1790, 1, 0, 0, 0, 1790, 1792, 1, 0, 0, 0, 1791, 1789, 1, 0, 0, 0, 1792, 1793, 5, 96, 0, 0, 1793, 434, 1, 0, 0, 0, 1794, 1796, 3, 437, 218, 0, 1795, 1794, 1, 0, 0, 0, 1796, 1797, 1, 0, 0, 0, 1797, 1795, 1, 0, 0, 0, 1797, 1798, 1, 0, 0, 0, 1798, 436, 1, 0, 0, 0, 1799, 1812, 3, 457, 228, 0, 1800, 1812, 3, 459, 229, 0, 1801, 1812, 3, 461, 230, 0, 1802, 1812, 3, 463, 231, 0, 1803, 1812, 3, 443, 221, 0, 1804, 1812, 3, 453, 226, 0, 1805, 1812, 3, 451, 225, 0, 1806, 1812, 3, 449, 224, 0, 1807, 1812, 3, 445, 222, 0, 1808, 1812, 3, 465, 232, 0, 1809, 1812, 7, 9, 0, 0, 1810, 1812, 3, 439, 219, 0, 1811, 1799, 1, 0, 0, 0, 1811, 1800, 1, 0, 0, 0, 1811, 1801, 1, 0, 0, 0, 1811, 1802, 1, 0, 0, 0, 1811, 1803, 1, 0, 0, 0, 1811, 1804, 1, 0, 0, 0, 1811, 1805, 1, 0, 0, 0, 1811, 1806, 1, 0, 0, 0, 1811, 1807, 1, 0, 0, 0, 1811, 1808, 1, 0, 0, 0, 1811, 1809, 1, 0, 0, 0, 1811, 1810, 1, 0, 0, 0, 1812, 438, 1, 0, 0, 0, 1813, 1814, 5, 47, 0, 0, 1814, 1815, 5, 42, 0, 0, 1815, 1819, 1, 0, 0, 0, 1816, 1818, 9, 0, 0, 0, 1817, 1816, 1, 0, 0, 0, 1818, 1821, 1, 0, 0, 0, 1819, 1820, 1, 0, 0, 0, 1819, 1817, 1, 0, 0, 0, 1820, 1822, 1, 0, 0, 0, 1821, 1819, 1, 0, 0, 0, 1822, 1823, 5, 42, 0, 0, 1823, 1834, 5, 47, 0, 0, 1824, 1825, 5, 47, 0, 0, 1825, 1826, 5, 47, 0, 0, 1826, 1830, 1, 0, 0, 0, 1827, 1829, 8, 10, 0, 0, 1828, 1827, 1, 0, 0, 0, 1829, 1832, 1, 0, 0, 0, 1830, 1828, 1, 0, 0, 0, 1830, 1831, 1, 0, 0, 0, 1831, 1834, 1, 0, 0, 0, 1832, 1830, 1, 0, 0, 0, 1833, 1813, 1, 0, 0, 0, 1833, 1824, 1, 0, 0, 0, 1834, 440, 1, 0, 0, 0, 1835, 1836, 9, 0, 0, 0, 1836, 442, 1, 0, 0, 0, 1837, 1838, 7, 11, 0, 0, 1838, 444, 1, 0, 0, 0, 1839, 1840, 7, 12, 0, 0, 1840, 446, 1, 0, 0, 0, 1841, 1842, 7, 13, 0, 0, 1842, 448, 1, 0, 0, 0, 1843, 1844, 7, 14, 0, 0, 1844, 450, 1, 0, 0, 0, 1845, 1846, 7, 15, 0, 0, 1846, 452, 1, 0, 0, 0, 1847, 1848, 7, 16, 0, 0, 1848, 454, 1, 0, 0, 0, 1849, 1850, 7, 17, 0, 0, 1850, 456, 1, 0, 0, 0, 1851, 1852, 7, 18, 0, 0, 1852, 458, 1, 0, 0, 0, 1853, 1854, 7, 19, 0, 0, 1854, 460, 1, 0, 0, 0, 1855, 1856, 7, 20, 0, 0, 1856, 462, 1, 0, 0, 0, 1857, 1858, 7, 21, 0, 0, 1858, 464, 1, 0, 0, 0, 1859, 1860, 7, 22, 0, 0, 1860, 466, 1, 0, 0, 0, 1861, 1862, 7, 23, 0, 0, 1862, 468, 1, 0, 0, 0, 1863, 1864, 7, 24, 0, 0, 1864, 470, 1, 0, 0, 0, 1865, 1866, 7, 25, 0, 0, 1866, 472, 1, 0, 0, 0, 1867, 1868, 7, 26, 0, 0, 1868, 474, 1, 0, 0, 0, 1869, 1870, 7, 27, 0, 0, 1870, 476, 1, 0, 0, 0, 1871, 1872, 7, 6, 0, 0, 1872, 478, 1, 0, 0, 0, 1873, 1874, 7, 28, 0, 0, 1874, 480, 1, 0, 0, 0, 1875, 1876, 7, 29, 0, 0, 1876, 482, 1, 0, 0, 0, 1877, 1878, 7, 30, 0, 0, 1878, 484, 1, 0, 0, 0, 1879, 1880, 7, 31, 0, 0, 1880, 486, 1, 0, 0, 0, 1881, 1882, 7, 32, 0, 0, 1882, 488, 1, 0, 0, 0, 1883, 1884, 7, 33, 0, 0, 1884, 490, 1, 0, 0, 0, 1885, 1886, 7, 34, 0, 0, 1886, 492, 1, 0, 0, 0, 1887, 1888, 7, 35, 0, 0, 1888, 494, 1, 0, 0, 0, 1889, 1890, 7, 36, 0, 0, 1890, 496, 1, 0, 0, 0, 1891, 1892, 7, 37, 0, 0, 1892, 498, 1, 0, 0, 0, 1893, 1894, 7, 38, 0, 0, 1894, 500, 1, 0, 0, 0, 1895, 1896, 7, 39, 0, 0, 1896, 502, 1, 0, 0, 0, 1897, 1898, 7, 40, 0, 0, 1898, 504, 1, 0, 0, 0, 1899, 1900, 7, 41, 0, 0, 1900, 506, 1, 0, 0, 0, 1901, 1902, 7, 42, 0, 0, 1902, 508, 1, 0, 0, 0, 1903, 1904, 7, 4, 0, 0, 1904, 510, 1, 0, 0, 0, 1905, 1906, 7, 43, 0, 0, 1906, 512, 1, 0, 0, 0, 1907, 1908, 7, 44, 0, 0, 1908, 514, 1, 0, 0, 0, 1909, 1910, 7, 45, 0, 0, 1910, 516, 1, 0, 0, 0, 1911, 1912, 7, 46, 0, 0, 1912, 518, 1, 0, 0, 0, 1913, 1914, 7, 47, 0, 0, 1914, 520, 1, 0, 0, 0, 38, 0, 1626, 1628, 1630, 1639, 1641, 1643, 1647, 1654, 1674, 1682, 1689, 1692, 1698, 1701, 1705, 1709, 1713, 1719, 1726, 1731, 1737, 1743, 1745, 1749, 1754, 1759, 1766, 1772, 1777, 1781, 1787, 1789, 1797, 1811, 1819, 1830, 1833, 0];
var atn = new es_default.atn.ATNDeserializer().deserialize(serializedATN);
var decisionsToDFA = atn.decisionToState.map((ds, index4) => new es_default.dfa.DFA(ds, index4));
var CypherLexer = class extends es_default.Lexer {
  constructor(input) {
    super(input);
    this._interp = new es_default.atn.LexerATNSimulator(this, atn, decisionsToDFA, new es_default.PredictionContextCache());
  }
  get atn() {
    return atn;
  }
};
_defineProperty(CypherLexer, "grammarFileName", "Cypher.g4");
_defineProperty(CypherLexer, "channelNames", ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"]);
_defineProperty(CypherLexer, "modeNames", ["DEFAULT_MODE"]);
_defineProperty(CypherLexer, "literalNames", [null, "';'", "':'", "'-'", "'=>'", "'://'", "'/'", "'.'", "'@'", "'#'", "'?'", "'&'", "'='", "'+'", "'{'", "','", "'}'", "'['", "']'", "'*'", "'('", "')'", "'+='", "'|'", "'..'", "'%'", "'^'", "'=~'", "'<>'", "'!='", "'<'", "'>'", "'<='", "'>='", "'$'", "'\\u27E8'", "'\\u3008'", "'\\uFE64'", "'\\uFF1C'", "'\\u27E9'", "'\\u3009'", "'\\uFE65'", "'\\uFF1E'", "'\\u00AD'", "'\\u2010'", "'\\u2011'", "'\\u2012'", "'\\u2013'", "'\\u2014'", "'\\u2015'", "'\\u2212'", "'\\uFE58'", "'\\uFE63'", "'\\uFF0D'", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "'0'"]);
_defineProperty(CypherLexer, "symbolicNames", [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "CYPHER", "EXPLAIN", "PROFILE", "USING", "PERIODIC", "COMMIT", "UNION", "ALL", "CREATE", "DROP", "INDEX", "ON", "CONSTRAINT", "ASSERT", "IS", "UNIQUE", "EXISTS", "LOAD", "CSV", "WITH", "HEADERS", "FROM", "AS", "FIELDTERMINATOR", "OPTIONAL", "MATCH", "UNWIND", "MERGE", "SET", "DETACH", "DELETE", "REMOVE", "FOREACH", "IN", "DISTINCT", "RETURN", "ORDER", "BY", "L_SKIP", "LIMIT", "ASCENDING", "ASC", "DESCENDING", "DESC", "JOIN", "SCAN", "START", "NODE", "RELATIONSHIP", "REL", "WHERE", "SHORTESTPATH", "ALLSHORTESTPATHS", "OR", "XOR", "AND", "NOT", "STARTS", "ENDS", "CONTAINS", "NULL", "COUNT", "FILTER", "EXTRACT", "ANY", "NONE", "SINGLE", "TRUE", "FALSE", "REDUCE", "CASE", "ELSE", "END", "WHEN", "THEN", "CALL", "YIELD", "KEY", "CATALOG", "SHOW", "DEFAULT", "DBMS", "DATABASE", "DATABASES", "GRAPH", "GRAPHS", "REPLACE", "IF", "STOP", "ROLE", "ROLES", "USER", "USERS", "POPULATED", "PASSWORD", "CHANGE", "REQUIRED", "STATUS", "ACTIVE", "SUSPENDED", "ALTER", "CURRENT", "TO", "PRIVILEGES", "GRANT", "DENY", "REVOKE", "RELATIONSHIPS", "NODES", "ELEMENT", "ELEMENTS", "COPY", "OF", "TRAVERSE", "READ", "WRITE", "ACCESS", "INDEXES", "MANAGEMENT", "NEW", "LABEL", "LABELS", "NAME", "NAMES", "TYPE", "TYPES", "PROPERTY", "CONSTRAINTS", "ASSIGN", "BTREE", "EXIST", "FOR", "OPTIONS", "EXECUTE", "DEFINED", "FUNCTION", "FUNCTIONS", "BOOSTED", "PROCEDURE", "PROCEDURES", "ADMIN", "ADMINISTRATOR", "BRIEF", "VERBOSE", "OUTPUT", "StringLiteral", "UrlHex", "EscapedChar", "HexInteger", "DecimalInteger", "OctalInteger", "HexLetter", "HexDigit", "Digit", "NonZeroDigit", "NonZeroOctDigit", "OctDigit", "ZeroDigit", "ExponentDecimalReal", "RegularDecimalReal", "UnescapedSymbolicName", "IdentifierStart", "IdentifierPart", "EscapedSymbolicName", "SP", "WHITESPACE", "Comment", "ERROR_TOKEN"]);
_defineProperty(CypherLexer, "ruleNames", ["T__0", "T__1", "T__2", "T__3", "T__4", "T__5", "T__6", "T__7", "T__8", "T__9", "T__10", "T__11", "T__12", "T__13", "T__14", "T__15", "T__16", "T__17", "T__18", "T__19", "T__20", "T__21", "T__22", "T__23", "T__24", "T__25", "T__26", "T__27", "T__28", "T__29", "T__30", "T__31", "T__32", "T__33", "T__34", "T__35", "T__36", "T__37", "T__38", "T__39", "T__40", "T__41", "T__42", "T__43", "T__44", "T__45", "T__46", "T__47", "T__48", "T__49", "T__50", "T__51", "T__52", "CYPHER", "EXPLAIN", "PROFILE", "USING", "PERIODIC", "COMMIT", "UNION", "ALL", "CREATE", "DROP", "INDEX", "ON", "CONSTRAINT", "ASSERT", "IS", "UNIQUE", "EXISTS", "LOAD", "CSV", "WITH", "HEADERS", "FROM", "AS", "FIELDTERMINATOR", "OPTIONAL", "MATCH", "UNWIND", "MERGE", "SET", "DETACH", "DELETE", "REMOVE", "FOREACH", "IN", "DISTINCT", "RETURN", "ORDER", "BY", "L_SKIP", "LIMIT", "ASCENDING", "ASC", "DESCENDING", "DESC", "JOIN", "SCAN", "START", "NODE", "RELATIONSHIP", "REL", "WHERE", "SHORTESTPATH", "ALLSHORTESTPATHS", "OR", "XOR", "AND", "NOT", "STARTS", "ENDS", "CONTAINS", "NULL", "COUNT", "FILTER", "EXTRACT", "ANY", "NONE", "SINGLE", "TRUE", "FALSE", "REDUCE", "CASE", "ELSE", "END", "WHEN", "THEN", "CALL", "YIELD", "KEY", "CATALOG", "SHOW", "DEFAULT", "DBMS", "DATABASE", "DATABASES", "GRAPH", "GRAPHS", "REPLACE", "IF", "STOP", "ROLE", "ROLES", "USER", "USERS", "POPULATED", "PASSWORD", "CHANGE", "REQUIRED", "STATUS", "ACTIVE", "SUSPENDED", "ALTER", "CURRENT", "TO", "PRIVILEGES", "GRANT", "DENY", "REVOKE", "RELATIONSHIPS", "NODES", "ELEMENT", "ELEMENTS", "COPY", "OF", "TRAVERSE", "READ", "WRITE", "ACCESS", "INDEXES", "MANAGEMENT", "NEW", "LABEL", "LABELS", "NAME", "NAMES", "TYPE", "TYPES", "PROPERTY", "CONSTRAINTS", "ASSIGN", "BTREE", "EXIST", "FOR", "OPTIONS", "EXECUTE", "DEFINED", "FUNCTION", "FUNCTIONS", "BOOSTED", "PROCEDURE", "PROCEDURES", "ADMIN", "ADMINISTRATOR", "BRIEF", "VERBOSE", "OUTPUT", "StringLiteral", "UrlHex", "EscapedChar", "HexInteger", "DecimalInteger", "OctalInteger", "HexLetter", "HexDigit", "Digit", "NonZeroDigit", "NonZeroOctDigit", "OctDigit", "ZeroDigit", "ExponentDecimalReal", "RegularDecimalReal", "UnescapedSymbolicName", "IdentifierStart", "IdentifierPart", "EscapedSymbolicName", "SP", "WHITESPACE", "Comment", "ERROR_TOKEN", "FF", "RS", "ID_Continue", "GS", "FS", "CR", "Sc", "SPACE", "TAB", "LF", "VT", "US", "ID_Start", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]);
CypherLexer.EOF = es_default.Token.EOF;
CypherLexer.T__0 = 1;
CypherLexer.T__1 = 2;
CypherLexer.T__2 = 3;
CypherLexer.T__3 = 4;
CypherLexer.T__4 = 5;
CypherLexer.T__5 = 6;
CypherLexer.T__6 = 7;
CypherLexer.T__7 = 8;
CypherLexer.T__8 = 9;
CypherLexer.T__9 = 10;
CypherLexer.T__10 = 11;
CypherLexer.T__11 = 12;
CypherLexer.T__12 = 13;
CypherLexer.T__13 = 14;
CypherLexer.T__14 = 15;
CypherLexer.T__15 = 16;
CypherLexer.T__16 = 17;
CypherLexer.T__17 = 18;
CypherLexer.T__18 = 19;
CypherLexer.T__19 = 20;
CypherLexer.T__20 = 21;
CypherLexer.T__21 = 22;
CypherLexer.T__22 = 23;
CypherLexer.T__23 = 24;
CypherLexer.T__24 = 25;
CypherLexer.T__25 = 26;
CypherLexer.T__26 = 27;
CypherLexer.T__27 = 28;
CypherLexer.T__28 = 29;
CypherLexer.T__29 = 30;
CypherLexer.T__30 = 31;
CypherLexer.T__31 = 32;
CypherLexer.T__32 = 33;
CypherLexer.T__33 = 34;
CypherLexer.T__34 = 35;
CypherLexer.T__35 = 36;
CypherLexer.T__36 = 37;
CypherLexer.T__37 = 38;
CypherLexer.T__38 = 39;
CypherLexer.T__39 = 40;
CypherLexer.T__40 = 41;
CypherLexer.T__41 = 42;
CypherLexer.T__42 = 43;
CypherLexer.T__43 = 44;
CypherLexer.T__44 = 45;
CypherLexer.T__45 = 46;
CypherLexer.T__46 = 47;
CypherLexer.T__47 = 48;
CypherLexer.T__48 = 49;
CypherLexer.T__49 = 50;
CypherLexer.T__50 = 51;
CypherLexer.T__51 = 52;
CypherLexer.T__52 = 53;
CypherLexer.CYPHER = 54;
CypherLexer.EXPLAIN = 55;
CypherLexer.PROFILE = 56;
CypherLexer.USING = 57;
CypherLexer.PERIODIC = 58;
CypherLexer.COMMIT = 59;
CypherLexer.UNION = 60;
CypherLexer.ALL = 61;
CypherLexer.CREATE = 62;
CypherLexer.DROP = 63;
CypherLexer.INDEX = 64;
CypherLexer.ON = 65;
CypherLexer.CONSTRAINT = 66;
CypherLexer.ASSERT = 67;
CypherLexer.IS = 68;
CypherLexer.UNIQUE = 69;
CypherLexer.EXISTS = 70;
CypherLexer.LOAD = 71;
CypherLexer.CSV = 72;
CypherLexer.WITH = 73;
CypherLexer.HEADERS = 74;
CypherLexer.FROM = 75;
CypherLexer.AS = 76;
CypherLexer.FIELDTERMINATOR = 77;
CypherLexer.OPTIONAL = 78;
CypherLexer.MATCH = 79;
CypherLexer.UNWIND = 80;
CypherLexer.MERGE = 81;
CypherLexer.SET = 82;
CypherLexer.DETACH = 83;
CypherLexer.DELETE = 84;
CypherLexer.REMOVE = 85;
CypherLexer.FOREACH = 86;
CypherLexer.IN = 87;
CypherLexer.DISTINCT = 88;
CypherLexer.RETURN = 89;
CypherLexer.ORDER = 90;
CypherLexer.BY = 91;
CypherLexer.L_SKIP = 92;
CypherLexer.LIMIT = 93;
CypherLexer.ASCENDING = 94;
CypherLexer.ASC = 95;
CypherLexer.DESCENDING = 96;
CypherLexer.DESC = 97;
CypherLexer.JOIN = 98;
CypherLexer.SCAN = 99;
CypherLexer.START = 100;
CypherLexer.NODE = 101;
CypherLexer.RELATIONSHIP = 102;
CypherLexer.REL = 103;
CypherLexer.WHERE = 104;
CypherLexer.SHORTESTPATH = 105;
CypherLexer.ALLSHORTESTPATHS = 106;
CypherLexer.OR = 107;
CypherLexer.XOR = 108;
CypherLexer.AND = 109;
CypherLexer.NOT = 110;
CypherLexer.STARTS = 111;
CypherLexer.ENDS = 112;
CypherLexer.CONTAINS = 113;
CypherLexer.NULL = 114;
CypherLexer.COUNT = 115;
CypherLexer.FILTER = 116;
CypherLexer.EXTRACT = 117;
CypherLexer.ANY = 118;
CypherLexer.NONE = 119;
CypherLexer.SINGLE = 120;
CypherLexer.TRUE = 121;
CypherLexer.FALSE = 122;
CypherLexer.REDUCE = 123;
CypherLexer.CASE = 124;
CypherLexer.ELSE = 125;
CypherLexer.END = 126;
CypherLexer.WHEN = 127;
CypherLexer.THEN = 128;
CypherLexer.CALL = 129;
CypherLexer.YIELD = 130;
CypherLexer.KEY = 131;
CypherLexer.CATALOG = 132;
CypherLexer.SHOW = 133;
CypherLexer.DEFAULT = 134;
CypherLexer.DBMS = 135;
CypherLexer.DATABASE = 136;
CypherLexer.DATABASES = 137;
CypherLexer.GRAPH = 138;
CypherLexer.GRAPHS = 139;
CypherLexer.REPLACE = 140;
CypherLexer.IF = 141;
CypherLexer.STOP = 142;
CypherLexer.ROLE = 143;
CypherLexer.ROLES = 144;
CypherLexer.USER = 145;
CypherLexer.USERS = 146;
CypherLexer.POPULATED = 147;
CypherLexer.PASSWORD = 148;
CypherLexer.CHANGE = 149;
CypherLexer.REQUIRED = 150;
CypherLexer.STATUS = 151;
CypherLexer.ACTIVE = 152;
CypherLexer.SUSPENDED = 153;
CypherLexer.ALTER = 154;
CypherLexer.CURRENT = 155;
CypherLexer.TO = 156;
CypherLexer.PRIVILEGES = 157;
CypherLexer.GRANT = 158;
CypherLexer.DENY = 159;
CypherLexer.REVOKE = 160;
CypherLexer.RELATIONSHIPS = 161;
CypherLexer.NODES = 162;
CypherLexer.ELEMENT = 163;
CypherLexer.ELEMENTS = 164;
CypherLexer.COPY = 165;
CypherLexer.OF = 166;
CypherLexer.TRAVERSE = 167;
CypherLexer.READ = 168;
CypherLexer.WRITE = 169;
CypherLexer.ACCESS = 170;
CypherLexer.INDEXES = 171;
CypherLexer.MANAGEMENT = 172;
CypherLexer.NEW = 173;
CypherLexer.LABEL = 174;
CypherLexer.LABELS = 175;
CypherLexer.NAME = 176;
CypherLexer.NAMES = 177;
CypherLexer.TYPE = 178;
CypherLexer.TYPES = 179;
CypherLexer.PROPERTY = 180;
CypherLexer.CONSTRAINTS = 181;
CypherLexer.ASSIGN = 182;
CypherLexer.BTREE = 183;
CypherLexer.EXIST = 184;
CypherLexer.FOR = 185;
CypherLexer.OPTIONS = 186;
CypherLexer.EXECUTE = 187;
CypherLexer.DEFINED = 188;
CypherLexer.FUNCTION = 189;
CypherLexer.FUNCTIONS = 190;
CypherLexer.BOOSTED = 191;
CypherLexer.PROCEDURE = 192;
CypherLexer.PROCEDURES = 193;
CypherLexer.ADMIN = 194;
CypherLexer.ADMINISTRATOR = 195;
CypherLexer.BRIEF = 196;
CypherLexer.VERBOSE = 197;
CypherLexer.OUTPUT = 198;
CypherLexer.StringLiteral = 199;
CypherLexer.UrlHex = 200;
CypherLexer.EscapedChar = 201;
CypherLexer.HexInteger = 202;
CypherLexer.DecimalInteger = 203;
CypherLexer.OctalInteger = 204;
CypherLexer.HexLetter = 205;
CypherLexer.HexDigit = 206;
CypherLexer.Digit = 207;
CypherLexer.NonZeroDigit = 208;
CypherLexer.NonZeroOctDigit = 209;
CypherLexer.OctDigit = 210;
CypherLexer.ZeroDigit = 211;
CypherLexer.ExponentDecimalReal = 212;
CypherLexer.RegularDecimalReal = 213;
CypherLexer.UnescapedSymbolicName = 214;
CypherLexer.IdentifierStart = 215;
CypherLexer.IdentifierPart = 216;
CypherLexer.EscapedSymbolicName = 217;
CypherLexer.SP = 218;
CypherLexer.WHITESPACE = 219;
CypherLexer.Comment = 220;
CypherLexer.ERROR_TOKEN = 221;

// node_modules/@neo4j-cypher/antlr4/es/CypherListener.js
var CypherListener = class extends es_default.tree.ParseTreeListener {
  // Enter a parse tree produced by CypherParser#cypher.
  enterCypher(ctx) {
  }
  // Exit a parse tree produced by CypherParser#cypher.
  exitCypher(ctx) {
  }
  // Enter a parse tree produced by CypherParser#cypherPart.
  enterCypherPart(ctx) {
  }
  // Exit a parse tree produced by CypherParser#cypherPart.
  exitCypherPart(ctx) {
  }
  // Enter a parse tree produced by CypherParser#cypherConsoleCommand.
  enterCypherConsoleCommand(ctx) {
  }
  // Exit a parse tree produced by CypherParser#cypherConsoleCommand.
  exitCypherConsoleCommand(ctx) {
  }
  // Enter a parse tree produced by CypherParser#cypherConsoleCommandName.
  enterCypherConsoleCommandName(ctx) {
  }
  // Exit a parse tree produced by CypherParser#cypherConsoleCommandName.
  exitCypherConsoleCommandName(ctx) {
  }
  // Enter a parse tree produced by CypherParser#cypherConsoleCommandParameters.
  enterCypherConsoleCommandParameters(ctx) {
  }
  // Exit a parse tree produced by CypherParser#cypherConsoleCommandParameters.
  exitCypherConsoleCommandParameters(ctx) {
  }
  // Enter a parse tree produced by CypherParser#cypherConsoleCommandParameter.
  enterCypherConsoleCommandParameter(ctx) {
  }
  // Exit a parse tree produced by CypherParser#cypherConsoleCommandParameter.
  exitCypherConsoleCommandParameter(ctx) {
  }
  // Enter a parse tree produced by CypherParser#arrowExpression.
  enterArrowExpression(ctx) {
  }
  // Exit a parse tree produced by CypherParser#arrowExpression.
  exitArrowExpression(ctx) {
  }
  // Enter a parse tree produced by CypherParser#url.
  enterUrl(ctx) {
  }
  // Exit a parse tree produced by CypherParser#url.
  exitUrl(ctx) {
  }
  // Enter a parse tree produced by CypherParser#uri.
  enterUri(ctx) {
  }
  // Exit a parse tree produced by CypherParser#uri.
  exitUri(ctx) {
  }
  // Enter a parse tree produced by CypherParser#scheme.
  enterScheme(ctx) {
  }
  // Exit a parse tree produced by CypherParser#scheme.
  exitScheme(ctx) {
  }
  // Enter a parse tree produced by CypherParser#host.
  enterHost(ctx) {
  }
  // Exit a parse tree produced by CypherParser#host.
  exitHost(ctx) {
  }
  // Enter a parse tree produced by CypherParser#hostname.
  enterHostname(ctx) {
  }
  // Exit a parse tree produced by CypherParser#hostname.
  exitHostname(ctx) {
  }
  // Enter a parse tree produced by CypherParser#hostnumber.
  enterHostnumber(ctx) {
  }
  // Exit a parse tree produced by CypherParser#hostnumber.
  exitHostnumber(ctx) {
  }
  // Enter a parse tree produced by CypherParser#port.
  enterPort(ctx) {
  }
  // Exit a parse tree produced by CypherParser#port.
  exitPort(ctx) {
  }
  // Enter a parse tree produced by CypherParser#path.
  enterPath(ctx) {
  }
  // Exit a parse tree produced by CypherParser#path.
  exitPath(ctx) {
  }
  // Enter a parse tree produced by CypherParser#user.
  enterUser(ctx) {
  }
  // Exit a parse tree produced by CypherParser#user.
  exitUser(ctx) {
  }
  // Enter a parse tree produced by CypherParser#login.
  enterLogin(ctx) {
  }
  // Exit a parse tree produced by CypherParser#login.
  exitLogin(ctx) {
  }
  // Enter a parse tree produced by CypherParser#password.
  enterPassword(ctx) {
  }
  // Exit a parse tree produced by CypherParser#password.
  exitPassword(ctx) {
  }
  // Enter a parse tree produced by CypherParser#frag.
  enterFrag(ctx) {
  }
  // Exit a parse tree produced by CypherParser#frag.
  exitFrag(ctx) {
  }
  // Enter a parse tree produced by CypherParser#urlQuery.
  enterUrlQuery(ctx) {
  }
  // Exit a parse tree produced by CypherParser#urlQuery.
  exitUrlQuery(ctx) {
  }
  // Enter a parse tree produced by CypherParser#search.
  enterSearch(ctx) {
  }
  // Exit a parse tree produced by CypherParser#search.
  exitSearch(ctx) {
  }
  // Enter a parse tree produced by CypherParser#searchparameter.
  enterSearchparameter(ctx) {
  }
  // Exit a parse tree produced by CypherParser#searchparameter.
  exitSearchparameter(ctx) {
  }
  // Enter a parse tree produced by CypherParser#string.
  enterString(ctx) {
  }
  // Exit a parse tree produced by CypherParser#string.
  exitString(ctx) {
  }
  // Enter a parse tree produced by CypherParser#urlDigits.
  enterUrlDigits(ctx) {
  }
  // Exit a parse tree produced by CypherParser#urlDigits.
  exitUrlDigits(ctx) {
  }
  // Enter a parse tree produced by CypherParser#json.
  enterJson(ctx) {
  }
  // Exit a parse tree produced by CypherParser#json.
  exitJson(ctx) {
  }
  // Enter a parse tree produced by CypherParser#obj.
  enterObj(ctx) {
  }
  // Exit a parse tree produced by CypherParser#obj.
  exitObj(ctx) {
  }
  // Enter a parse tree produced by CypherParser#pair.
  enterPair(ctx) {
  }
  // Exit a parse tree produced by CypherParser#pair.
  exitPair(ctx) {
  }
  // Enter a parse tree produced by CypherParser#array.
  enterArray(ctx) {
  }
  // Exit a parse tree produced by CypherParser#array.
  exitArray(ctx) {
  }
  // Enter a parse tree produced by CypherParser#value.
  enterValue(ctx) {
  }
  // Exit a parse tree produced by CypherParser#value.
  exitValue(ctx) {
  }
  // Enter a parse tree produced by CypherParser#keyValueLiteral.
  enterKeyValueLiteral(ctx) {
  }
  // Exit a parse tree produced by CypherParser#keyValueLiteral.
  exitKeyValueLiteral(ctx) {
  }
  // Enter a parse tree produced by CypherParser#commandPath.
  enterCommandPath(ctx) {
  }
  // Exit a parse tree produced by CypherParser#commandPath.
  exitCommandPath(ctx) {
  }
  // Enter a parse tree produced by CypherParser#subCommand.
  enterSubCommand(ctx) {
  }
  // Exit a parse tree produced by CypherParser#subCommand.
  exitSubCommand(ctx) {
  }
  // Enter a parse tree produced by CypherParser#cypherQuery.
  enterCypherQuery(ctx) {
  }
  // Exit a parse tree produced by CypherParser#cypherQuery.
  exitCypherQuery(ctx) {
  }
  // Enter a parse tree produced by CypherParser#queryOptions.
  enterQueryOptions(ctx) {
  }
  // Exit a parse tree produced by CypherParser#queryOptions.
  exitQueryOptions(ctx) {
  }
  // Enter a parse tree produced by CypherParser#anyCypherOption.
  enterAnyCypherOption(ctx) {
  }
  // Exit a parse tree produced by CypherParser#anyCypherOption.
  exitAnyCypherOption(ctx) {
  }
  // Enter a parse tree produced by CypherParser#cypherOption.
  enterCypherOption(ctx) {
  }
  // Exit a parse tree produced by CypherParser#cypherOption.
  exitCypherOption(ctx) {
  }
  // Enter a parse tree produced by CypherParser#versionNumber.
  enterVersionNumber(ctx) {
  }
  // Exit a parse tree produced by CypherParser#versionNumber.
  exitVersionNumber(ctx) {
  }
  // Enter a parse tree produced by CypherParser#explain.
  enterExplain(ctx) {
  }
  // Exit a parse tree produced by CypherParser#explain.
  exitExplain(ctx) {
  }
  // Enter a parse tree produced by CypherParser#profile.
  enterProfile(ctx) {
  }
  // Exit a parse tree produced by CypherParser#profile.
  exitProfile(ctx) {
  }
  // Enter a parse tree produced by CypherParser#configurationOption.
  enterConfigurationOption(ctx) {
  }
  // Exit a parse tree produced by CypherParser#configurationOption.
  exitConfigurationOption(ctx) {
  }
  // Enter a parse tree produced by CypherParser#statement.
  enterStatement(ctx) {
  }
  // Exit a parse tree produced by CypherParser#statement.
  exitStatement(ctx) {
  }
  // Enter a parse tree produced by CypherParser#query.
  enterQuery(ctx) {
  }
  // Exit a parse tree produced by CypherParser#query.
  exitQuery(ctx) {
  }
  // Enter a parse tree produced by CypherParser#regularQuery.
  enterRegularQuery(ctx) {
  }
  // Exit a parse tree produced by CypherParser#regularQuery.
  exitRegularQuery(ctx) {
  }
  // Enter a parse tree produced by CypherParser#bulkImportQuery.
  enterBulkImportQuery(ctx) {
  }
  // Exit a parse tree produced by CypherParser#bulkImportQuery.
  exitBulkImportQuery(ctx) {
  }
  // Enter a parse tree produced by CypherParser#singleQuery.
  enterSingleQuery(ctx) {
  }
  // Exit a parse tree produced by CypherParser#singleQuery.
  exitSingleQuery(ctx) {
  }
  // Enter a parse tree produced by CypherParser#periodicCommitHint.
  enterPeriodicCommitHint(ctx) {
  }
  // Exit a parse tree produced by CypherParser#periodicCommitHint.
  exitPeriodicCommitHint(ctx) {
  }
  // Enter a parse tree produced by CypherParser#loadCSVQuery.
  enterLoadCSVQuery(ctx) {
  }
  // Exit a parse tree produced by CypherParser#loadCSVQuery.
  exitLoadCSVQuery(ctx) {
  }
  // Enter a parse tree produced by CypherParser#union.
  enterUnion(ctx) {
  }
  // Exit a parse tree produced by CypherParser#union.
  exitUnion(ctx) {
  }
  // Enter a parse tree produced by CypherParser#clause.
  enterClause(ctx) {
  }
  // Exit a parse tree produced by CypherParser#clause.
  exitClause(ctx) {
  }
  // Enter a parse tree produced by CypherParser#command.
  enterCommand(ctx) {
  }
  // Exit a parse tree produced by CypherParser#command.
  exitCommand(ctx) {
  }
  // Enter a parse tree produced by CypherParser#systemCommand.
  enterSystemCommand(ctx) {
  }
  // Exit a parse tree produced by CypherParser#systemCommand.
  exitSystemCommand(ctx) {
  }
  // Enter a parse tree produced by CypherParser#multidatabaseCommand.
  enterMultidatabaseCommand(ctx) {
  }
  // Exit a parse tree produced by CypherParser#multidatabaseCommand.
  exitMultidatabaseCommand(ctx) {
  }
  // Enter a parse tree produced by CypherParser#userCommand.
  enterUserCommand(ctx) {
  }
  // Exit a parse tree produced by CypherParser#userCommand.
  exitUserCommand(ctx) {
  }
  // Enter a parse tree produced by CypherParser#privilegeCommand.
  enterPrivilegeCommand(ctx) {
  }
  // Exit a parse tree produced by CypherParser#privilegeCommand.
  exitPrivilegeCommand(ctx) {
  }
  // Enter a parse tree produced by CypherParser#showRoles.
  enterShowRoles(ctx) {
  }
  // Exit a parse tree produced by CypherParser#showRoles.
  exitShowRoles(ctx) {
  }
  // Enter a parse tree produced by CypherParser#createRole.
  enterCreateRole(ctx) {
  }
  // Exit a parse tree produced by CypherParser#createRole.
  exitCreateRole(ctx) {
  }
  // Enter a parse tree produced by CypherParser#copyRole.
  enterCopyRole(ctx) {
  }
  // Exit a parse tree produced by CypherParser#copyRole.
  exitCopyRole(ctx) {
  }
  // Enter a parse tree produced by CypherParser#dropRole.
  enterDropRole(ctx) {
  }
  // Exit a parse tree produced by CypherParser#dropRole.
  exitDropRole(ctx) {
  }
  // Enter a parse tree produced by CypherParser#showUsers.
  enterShowUsers(ctx) {
  }
  // Exit a parse tree produced by CypherParser#showUsers.
  exitShowUsers(ctx) {
  }
  // Enter a parse tree produced by CypherParser#createUser.
  enterCreateUser(ctx) {
  }
  // Exit a parse tree produced by CypherParser#createUser.
  exitCreateUser(ctx) {
  }
  // Enter a parse tree produced by CypherParser#dropUser.
  enterDropUser(ctx) {
  }
  // Exit a parse tree produced by CypherParser#dropUser.
  exitDropUser(ctx) {
  }
  // Enter a parse tree produced by CypherParser#alterUser.
  enterAlterUser(ctx) {
  }
  // Exit a parse tree produced by CypherParser#alterUser.
  exitAlterUser(ctx) {
  }
  // Enter a parse tree produced by CypherParser#showPrivileges.
  enterShowPrivileges(ctx) {
  }
  // Exit a parse tree produced by CypherParser#showPrivileges.
  exitShowPrivileges(ctx) {
  }
  // Enter a parse tree produced by CypherParser#grantPrivilege.
  enterGrantPrivilege(ctx) {
  }
  // Exit a parse tree produced by CypherParser#grantPrivilege.
  exitGrantPrivilege(ctx) {
  }
  // Enter a parse tree produced by CypherParser#denyPrivilege.
  enterDenyPrivilege(ctx) {
  }
  // Exit a parse tree produced by CypherParser#denyPrivilege.
  exitDenyPrivilege(ctx) {
  }
  // Enter a parse tree produced by CypherParser#revokePrivilege.
  enterRevokePrivilege(ctx) {
  }
  // Exit a parse tree produced by CypherParser#revokePrivilege.
  exitRevokePrivilege(ctx) {
  }
  // Enter a parse tree produced by CypherParser#revokePart.
  enterRevokePart(ctx) {
  }
  // Exit a parse tree produced by CypherParser#revokePart.
  exitRevokePart(ctx) {
  }
  // Enter a parse tree produced by CypherParser#databaseScope.
  enterDatabaseScope(ctx) {
  }
  // Exit a parse tree produced by CypherParser#databaseScope.
  exitDatabaseScope(ctx) {
  }
  // Enter a parse tree produced by CypherParser#graphScope.
  enterGraphScope(ctx) {
  }
  // Exit a parse tree produced by CypherParser#graphScope.
  exitGraphScope(ctx) {
  }
  // Enter a parse tree produced by CypherParser#roles.
  enterRoles(ctx) {
  }
  // Exit a parse tree produced by CypherParser#roles.
  exitRoles(ctx) {
  }
  // Enter a parse tree produced by CypherParser#grantableGraphPrivileges.
  enterGrantableGraphPrivileges(ctx) {
  }
  // Exit a parse tree produced by CypherParser#grantableGraphPrivileges.
  exitGrantableGraphPrivileges(ctx) {
  }
  // Enter a parse tree produced by CypherParser#revokeableGraphPrivileges.
  enterRevokeableGraphPrivileges(ctx) {
  }
  // Exit a parse tree produced by CypherParser#revokeableGraphPrivileges.
  exitRevokeableGraphPrivileges(ctx) {
  }
  // Enter a parse tree produced by CypherParser#datasbasePrivilege.
  enterDatasbasePrivilege(ctx) {
  }
  // Exit a parse tree produced by CypherParser#datasbasePrivilege.
  exitDatasbasePrivilege(ctx) {
  }
  // Enter a parse tree produced by CypherParser#dbmsPrivilege.
  enterDbmsPrivilege(ctx) {
  }
  // Exit a parse tree produced by CypherParser#dbmsPrivilege.
  exitDbmsPrivilege(ctx) {
  }
  // Enter a parse tree produced by CypherParser#elementScope.
  enterElementScope(ctx) {
  }
  // Exit a parse tree produced by CypherParser#elementScope.
  exitElementScope(ctx) {
  }
  // Enter a parse tree produced by CypherParser#propertiesList.
  enterPropertiesList(ctx) {
  }
  // Exit a parse tree produced by CypherParser#propertiesList.
  exitPropertiesList(ctx) {
  }
  // Enter a parse tree produced by CypherParser#propertyScope.
  enterPropertyScope(ctx) {
  }
  // Exit a parse tree produced by CypherParser#propertyScope.
  exitPropertyScope(ctx) {
  }
  // Enter a parse tree produced by CypherParser#showDatabase.
  enterShowDatabase(ctx) {
  }
  // Exit a parse tree produced by CypherParser#showDatabase.
  exitShowDatabase(ctx) {
  }
  // Enter a parse tree produced by CypherParser#createDatabase.
  enterCreateDatabase(ctx) {
  }
  // Exit a parse tree produced by CypherParser#createDatabase.
  exitCreateDatabase(ctx) {
  }
  // Enter a parse tree produced by CypherParser#dropDatabase.
  enterDropDatabase(ctx) {
  }
  // Exit a parse tree produced by CypherParser#dropDatabase.
  exitDropDatabase(ctx) {
  }
  // Enter a parse tree produced by CypherParser#startDatabase.
  enterStartDatabase(ctx) {
  }
  // Exit a parse tree produced by CypherParser#startDatabase.
  exitStartDatabase(ctx) {
  }
  // Enter a parse tree produced by CypherParser#stopDatabase.
  enterStopDatabase(ctx) {
  }
  // Exit a parse tree produced by CypherParser#stopDatabase.
  exitStopDatabase(ctx) {
  }
  // Enter a parse tree produced by CypherParser#ifNotExists.
  enterIfNotExists(ctx) {
  }
  // Exit a parse tree produced by CypherParser#ifNotExists.
  exitIfNotExists(ctx) {
  }
  // Enter a parse tree produced by CypherParser#ifExists.
  enterIfExists(ctx) {
  }
  // Exit a parse tree produced by CypherParser#ifExists.
  exitIfExists(ctx) {
  }
  // Enter a parse tree produced by CypherParser#orReplace.
  enterOrReplace(ctx) {
  }
  // Exit a parse tree produced by CypherParser#orReplace.
  exitOrReplace(ctx) {
  }
  // Enter a parse tree produced by CypherParser#setPassword.
  enterSetPassword(ctx) {
  }
  // Exit a parse tree produced by CypherParser#setPassword.
  exitSetPassword(ctx) {
  }
  // Enter a parse tree produced by CypherParser#passwordStatus.
  enterPasswordStatus(ctx) {
  }
  // Exit a parse tree produced by CypherParser#passwordStatus.
  exitPasswordStatus(ctx) {
  }
  // Enter a parse tree produced by CypherParser#setStatus.
  enterSetStatus(ctx) {
  }
  // Exit a parse tree produced by CypherParser#setStatus.
  exitSetStatus(ctx) {
  }
  // Enter a parse tree produced by CypherParser#userStatus.
  enterUserStatus(ctx) {
  }
  // Exit a parse tree produced by CypherParser#userStatus.
  exitUserStatus(ctx) {
  }
  // Enter a parse tree produced by CypherParser#createUniqueConstraint.
  enterCreateUniqueConstraint(ctx) {
  }
  // Exit a parse tree produced by CypherParser#createUniqueConstraint.
  exitCreateUniqueConstraint(ctx) {
  }
  // Enter a parse tree produced by CypherParser#createNodeKeyConstraint.
  enterCreateNodeKeyConstraint(ctx) {
  }
  // Exit a parse tree produced by CypherParser#createNodeKeyConstraint.
  exitCreateNodeKeyConstraint(ctx) {
  }
  // Enter a parse tree produced by CypherParser#createNodePropertyExistenceConstraint.
  enterCreateNodePropertyExistenceConstraint(ctx) {
  }
  // Exit a parse tree produced by CypherParser#createNodePropertyExistenceConstraint.
  exitCreateNodePropertyExistenceConstraint(ctx) {
  }
  // Enter a parse tree produced by CypherParser#createRelationshipPropertyExistenceConstraint.
  enterCreateRelationshipPropertyExistenceConstraint(ctx) {
  }
  // Exit a parse tree produced by CypherParser#createRelationshipPropertyExistenceConstraint.
  exitCreateRelationshipPropertyExistenceConstraint(ctx) {
  }
  // Enter a parse tree produced by CypherParser#createIndex.
  enterCreateIndex(ctx) {
  }
  // Exit a parse tree produced by CypherParser#createIndex.
  exitCreateIndex(ctx) {
  }
  // Enter a parse tree produced by CypherParser#dropUniqueConstraint.
  enterDropUniqueConstraint(ctx) {
  }
  // Exit a parse tree produced by CypherParser#dropUniqueConstraint.
  exitDropUniqueConstraint(ctx) {
  }
  // Enter a parse tree produced by CypherParser#dropNodeKeyConstraint.
  enterDropNodeKeyConstraint(ctx) {
  }
  // Exit a parse tree produced by CypherParser#dropNodeKeyConstraint.
  exitDropNodeKeyConstraint(ctx) {
  }
  // Enter a parse tree produced by CypherParser#dropNodePropertyExistenceConstraint.
  enterDropNodePropertyExistenceConstraint(ctx) {
  }
  // Exit a parse tree produced by CypherParser#dropNodePropertyExistenceConstraint.
  exitDropNodePropertyExistenceConstraint(ctx) {
  }
  // Enter a parse tree produced by CypherParser#dropRelationshipPropertyExistenceConstraint.
  enterDropRelationshipPropertyExistenceConstraint(ctx) {
  }
  // Exit a parse tree produced by CypherParser#dropRelationshipPropertyExistenceConstraint.
  exitDropRelationshipPropertyExistenceConstraint(ctx) {
  }
  // Enter a parse tree produced by CypherParser#dropIndex.
  enterDropIndex(ctx) {
  }
  // Exit a parse tree produced by CypherParser#dropIndex.
  exitDropIndex(ctx) {
  }
  // Enter a parse tree produced by CypherParser#index.
  enterIndex(ctx) {
  }
  // Exit a parse tree produced by CypherParser#index.
  exitIndex(ctx) {
  }
  // Enter a parse tree produced by CypherParser#uniqueConstraint.
  enterUniqueConstraint(ctx) {
  }
  // Exit a parse tree produced by CypherParser#uniqueConstraint.
  exitUniqueConstraint(ctx) {
  }
  // Enter a parse tree produced by CypherParser#nodeKeyConstraint.
  enterNodeKeyConstraint(ctx) {
  }
  // Exit a parse tree produced by CypherParser#nodeKeyConstraint.
  exitNodeKeyConstraint(ctx) {
  }
  // Enter a parse tree produced by CypherParser#nodePropertyExistenceConstraint.
  enterNodePropertyExistenceConstraint(ctx) {
  }
  // Exit a parse tree produced by CypherParser#nodePropertyExistenceConstraint.
  exitNodePropertyExistenceConstraint(ctx) {
  }
  // Enter a parse tree produced by CypherParser#relationshipPropertyExistenceConstraint.
  enterRelationshipPropertyExistenceConstraint(ctx) {
  }
  // Exit a parse tree produced by CypherParser#relationshipPropertyExistenceConstraint.
  exitRelationshipPropertyExistenceConstraint(ctx) {
  }
  // Enter a parse tree produced by CypherParser#relationshipPatternSyntax.
  enterRelationshipPatternSyntax(ctx) {
  }
  // Exit a parse tree produced by CypherParser#relationshipPatternSyntax.
  exitRelationshipPatternSyntax(ctx) {
  }
  // Enter a parse tree produced by CypherParser#loadCSVClause.
  enterLoadCSVClause(ctx) {
  }
  // Exit a parse tree produced by CypherParser#loadCSVClause.
  exitLoadCSVClause(ctx) {
  }
  // Enter a parse tree produced by CypherParser#matchClause.
  enterMatchClause(ctx) {
  }
  // Exit a parse tree produced by CypherParser#matchClause.
  exitMatchClause(ctx) {
  }
  // Enter a parse tree produced by CypherParser#unwindClause.
  enterUnwindClause(ctx) {
  }
  // Exit a parse tree produced by CypherParser#unwindClause.
  exitUnwindClause(ctx) {
  }
  // Enter a parse tree produced by CypherParser#mergeClause.
  enterMergeClause(ctx) {
  }
  // Exit a parse tree produced by CypherParser#mergeClause.
  exitMergeClause(ctx) {
  }
  // Enter a parse tree produced by CypherParser#mergeAction.
  enterMergeAction(ctx) {
  }
  // Exit a parse tree produced by CypherParser#mergeAction.
  exitMergeAction(ctx) {
  }
  // Enter a parse tree produced by CypherParser#createClause.
  enterCreateClause(ctx) {
  }
  // Exit a parse tree produced by CypherParser#createClause.
  exitCreateClause(ctx) {
  }
  // Enter a parse tree produced by CypherParser#createUniqueClause.
  enterCreateUniqueClause(ctx) {
  }
  // Exit a parse tree produced by CypherParser#createUniqueClause.
  exitCreateUniqueClause(ctx) {
  }
  // Enter a parse tree produced by CypherParser#setClause.
  enterSetClause(ctx) {
  }
  // Exit a parse tree produced by CypherParser#setClause.
  exitSetClause(ctx) {
  }
  // Enter a parse tree produced by CypherParser#setItem.
  enterSetItem(ctx) {
  }
  // Exit a parse tree produced by CypherParser#setItem.
  exitSetItem(ctx) {
  }
  // Enter a parse tree produced by CypherParser#deleteClause.
  enterDeleteClause(ctx) {
  }
  // Exit a parse tree produced by CypherParser#deleteClause.
  exitDeleteClause(ctx) {
  }
  // Enter a parse tree produced by CypherParser#removeClause.
  enterRemoveClause(ctx) {
  }
  // Exit a parse tree produced by CypherParser#removeClause.
  exitRemoveClause(ctx) {
  }
  // Enter a parse tree produced by CypherParser#removeItem.
  enterRemoveItem(ctx) {
  }
  // Exit a parse tree produced by CypherParser#removeItem.
  exitRemoveItem(ctx) {
  }
  // Enter a parse tree produced by CypherParser#foreachClause.
  enterForeachClause(ctx) {
  }
  // Exit a parse tree produced by CypherParser#foreachClause.
  exitForeachClause(ctx) {
  }
  // Enter a parse tree produced by CypherParser#withClause.
  enterWithClause(ctx) {
  }
  // Exit a parse tree produced by CypherParser#withClause.
  exitWithClause(ctx) {
  }
  // Enter a parse tree produced by CypherParser#returnClause.
  enterReturnClause(ctx) {
  }
  // Exit a parse tree produced by CypherParser#returnClause.
  exitReturnClause(ctx) {
  }
  // Enter a parse tree produced by CypherParser#returnBody.
  enterReturnBody(ctx) {
  }
  // Exit a parse tree produced by CypherParser#returnBody.
  exitReturnBody(ctx) {
  }
  // Enter a parse tree produced by CypherParser#func.
  enterFunc(ctx) {
  }
  // Exit a parse tree produced by CypherParser#func.
  exitFunc(ctx) {
  }
  // Enter a parse tree produced by CypherParser#returnItems.
  enterReturnItems(ctx) {
  }
  // Exit a parse tree produced by CypherParser#returnItems.
  exitReturnItems(ctx) {
  }
  // Enter a parse tree produced by CypherParser#returnItem.
  enterReturnItem(ctx) {
  }
  // Exit a parse tree produced by CypherParser#returnItem.
  exitReturnItem(ctx) {
  }
  // Enter a parse tree produced by CypherParser#call.
  enterCall(ctx) {
  }
  // Exit a parse tree produced by CypherParser#call.
  exitCall(ctx) {
  }
  // Enter a parse tree produced by CypherParser#procedureInvocation.
  enterProcedureInvocation(ctx) {
  }
  // Exit a parse tree produced by CypherParser#procedureInvocation.
  exitProcedureInvocation(ctx) {
  }
  // Enter a parse tree produced by CypherParser#procedureInvocationBody.
  enterProcedureInvocationBody(ctx) {
  }
  // Exit a parse tree produced by CypherParser#procedureInvocationBody.
  exitProcedureInvocationBody(ctx) {
  }
  // Enter a parse tree produced by CypherParser#procedureArguments.
  enterProcedureArguments(ctx) {
  }
  // Exit a parse tree produced by CypherParser#procedureArguments.
  exitProcedureArguments(ctx) {
  }
  // Enter a parse tree produced by CypherParser#procedureResults.
  enterProcedureResults(ctx) {
  }
  // Exit a parse tree produced by CypherParser#procedureResults.
  exitProcedureResults(ctx) {
  }
  // Enter a parse tree produced by CypherParser#procedureResult.
  enterProcedureResult(ctx) {
  }
  // Exit a parse tree produced by CypherParser#procedureResult.
  exitProcedureResult(ctx) {
  }
  // Enter a parse tree produced by CypherParser#aliasedProcedureResult.
  enterAliasedProcedureResult(ctx) {
  }
  // Exit a parse tree produced by CypherParser#aliasedProcedureResult.
  exitAliasedProcedureResult(ctx) {
  }
  // Enter a parse tree produced by CypherParser#simpleProcedureResult.
  enterSimpleProcedureResult(ctx) {
  }
  // Exit a parse tree produced by CypherParser#simpleProcedureResult.
  exitSimpleProcedureResult(ctx) {
  }
  // Enter a parse tree produced by CypherParser#procedureOutput.
  enterProcedureOutput(ctx) {
  }
  // Exit a parse tree produced by CypherParser#procedureOutput.
  exitProcedureOutput(ctx) {
  }
  // Enter a parse tree produced by CypherParser#order.
  enterOrder(ctx) {
  }
  // Exit a parse tree produced by CypherParser#order.
  exitOrder(ctx) {
  }
  // Enter a parse tree produced by CypherParser#skip.
  enterSkip(ctx) {
  }
  // Exit a parse tree produced by CypherParser#skip.
  exitSkip(ctx) {
  }
  // Enter a parse tree produced by CypherParser#limit.
  enterLimit(ctx) {
  }
  // Exit a parse tree produced by CypherParser#limit.
  exitLimit(ctx) {
  }
  // Enter a parse tree produced by CypherParser#sortItem.
  enterSortItem(ctx) {
  }
  // Exit a parse tree produced by CypherParser#sortItem.
  exitSortItem(ctx) {
  }
  // Enter a parse tree produced by CypherParser#hint.
  enterHint(ctx) {
  }
  // Exit a parse tree produced by CypherParser#hint.
  exitHint(ctx) {
  }
  // Enter a parse tree produced by CypherParser#startClause.
  enterStartClause(ctx) {
  }
  // Exit a parse tree produced by CypherParser#startClause.
  exitStartClause(ctx) {
  }
  // Enter a parse tree produced by CypherParser#startPoint.
  enterStartPoint(ctx) {
  }
  // Exit a parse tree produced by CypherParser#startPoint.
  exitStartPoint(ctx) {
  }
  // Enter a parse tree produced by CypherParser#lookup.
  enterLookup(ctx) {
  }
  // Exit a parse tree produced by CypherParser#lookup.
  exitLookup(ctx) {
  }
  // Enter a parse tree produced by CypherParser#nodeLookup.
  enterNodeLookup(ctx) {
  }
  // Exit a parse tree produced by CypherParser#nodeLookup.
  exitNodeLookup(ctx) {
  }
  // Enter a parse tree produced by CypherParser#relationshipLookup.
  enterRelationshipLookup(ctx) {
  }
  // Exit a parse tree produced by CypherParser#relationshipLookup.
  exitRelationshipLookup(ctx) {
  }
  // Enter a parse tree produced by CypherParser#identifiedIndexLookup.
  enterIdentifiedIndexLookup(ctx) {
  }
  // Exit a parse tree produced by CypherParser#identifiedIndexLookup.
  exitIdentifiedIndexLookup(ctx) {
  }
  // Enter a parse tree produced by CypherParser#indexQuery.
  enterIndexQuery(ctx) {
  }
  // Exit a parse tree produced by CypherParser#indexQuery.
  exitIndexQuery(ctx) {
  }
  // Enter a parse tree produced by CypherParser#idLookup.
  enterIdLookup(ctx) {
  }
  // Exit a parse tree produced by CypherParser#idLookup.
  exitIdLookup(ctx) {
  }
  // Enter a parse tree produced by CypherParser#literalIds.
  enterLiteralIds(ctx) {
  }
  // Exit a parse tree produced by CypherParser#literalIds.
  exitLiteralIds(ctx) {
  }
  // Enter a parse tree produced by CypherParser#where.
  enterWhere(ctx) {
  }
  // Exit a parse tree produced by CypherParser#where.
  exitWhere(ctx) {
  }
  // Enter a parse tree produced by CypherParser#pattern.
  enterPattern(ctx) {
  }
  // Exit a parse tree produced by CypherParser#pattern.
  exitPattern(ctx) {
  }
  // Enter a parse tree produced by CypherParser#patternPart.
  enterPatternPart(ctx) {
  }
  // Exit a parse tree produced by CypherParser#patternPart.
  exitPatternPart(ctx) {
  }
  // Enter a parse tree produced by CypherParser#anonymousPatternPart.
  enterAnonymousPatternPart(ctx) {
  }
  // Exit a parse tree produced by CypherParser#anonymousPatternPart.
  exitAnonymousPatternPart(ctx) {
  }
  // Enter a parse tree produced by CypherParser#patternElement.
  enterPatternElement(ctx) {
  }
  // Exit a parse tree produced by CypherParser#patternElement.
  exitPatternElement(ctx) {
  }
  // Enter a parse tree produced by CypherParser#nodePattern.
  enterNodePattern(ctx) {
  }
  // Exit a parse tree produced by CypherParser#nodePattern.
  exitNodePattern(ctx) {
  }
  // Enter a parse tree produced by CypherParser#patternElementChain.
  enterPatternElementChain(ctx) {
  }
  // Exit a parse tree produced by CypherParser#patternElementChain.
  exitPatternElementChain(ctx) {
  }
  // Enter a parse tree produced by CypherParser#relationshipPattern.
  enterRelationshipPattern(ctx) {
  }
  // Exit a parse tree produced by CypherParser#relationshipPattern.
  exitRelationshipPattern(ctx) {
  }
  // Enter a parse tree produced by CypherParser#relationshipPatternStart.
  enterRelationshipPatternStart(ctx) {
  }
  // Exit a parse tree produced by CypherParser#relationshipPatternStart.
  exitRelationshipPatternStart(ctx) {
  }
  // Enter a parse tree produced by CypherParser#relationshipPatternEnd.
  enterRelationshipPatternEnd(ctx) {
  }
  // Exit a parse tree produced by CypherParser#relationshipPatternEnd.
  exitRelationshipPatternEnd(ctx) {
  }
  // Enter a parse tree produced by CypherParser#relationshipDetail.
  enterRelationshipDetail(ctx) {
  }
  // Exit a parse tree produced by CypherParser#relationshipDetail.
  exitRelationshipDetail(ctx) {
  }
  // Enter a parse tree produced by CypherParser#properties.
  enterProperties(ctx) {
  }
  // Exit a parse tree produced by CypherParser#properties.
  exitProperties(ctx) {
  }
  // Enter a parse tree produced by CypherParser#relType.
  enterRelType(ctx) {
  }
  // Exit a parse tree produced by CypherParser#relType.
  exitRelType(ctx) {
  }
  // Enter a parse tree produced by CypherParser#relationshipTypes.
  enterRelationshipTypes(ctx) {
  }
  // Exit a parse tree produced by CypherParser#relationshipTypes.
  exitRelationshipTypes(ctx) {
  }
  // Enter a parse tree produced by CypherParser#relationshipType.
  enterRelationshipType(ctx) {
  }
  // Exit a parse tree produced by CypherParser#relationshipType.
  exitRelationshipType(ctx) {
  }
  // Enter a parse tree produced by CypherParser#relationshipTypeOptionalColon.
  enterRelationshipTypeOptionalColon(ctx) {
  }
  // Exit a parse tree produced by CypherParser#relationshipTypeOptionalColon.
  exitRelationshipTypeOptionalColon(ctx) {
  }
  // Enter a parse tree produced by CypherParser#nodeLabels.
  enterNodeLabels(ctx) {
  }
  // Exit a parse tree produced by CypherParser#nodeLabels.
  exitNodeLabels(ctx) {
  }
  // Enter a parse tree produced by CypherParser#nodeLabel.
  enterNodeLabel(ctx) {
  }
  // Exit a parse tree produced by CypherParser#nodeLabel.
  exitNodeLabel(ctx) {
  }
  // Enter a parse tree produced by CypherParser#rangeLiteral.
  enterRangeLiteral(ctx) {
  }
  // Exit a parse tree produced by CypherParser#rangeLiteral.
  exitRangeLiteral(ctx) {
  }
  // Enter a parse tree produced by CypherParser#labelName.
  enterLabelName(ctx) {
  }
  // Exit a parse tree produced by CypherParser#labelName.
  exitLabelName(ctx) {
  }
  // Enter a parse tree produced by CypherParser#relTypeName.
  enterRelTypeName(ctx) {
  }
  // Exit a parse tree produced by CypherParser#relTypeName.
  exitRelTypeName(ctx) {
  }
  // Enter a parse tree produced by CypherParser#expression.
  enterExpression(ctx) {
  }
  // Exit a parse tree produced by CypherParser#expression.
  exitExpression(ctx) {
  }
  // Enter a parse tree produced by CypherParser#orExpression.
  enterOrExpression(ctx) {
  }
  // Exit a parse tree produced by CypherParser#orExpression.
  exitOrExpression(ctx) {
  }
  // Enter a parse tree produced by CypherParser#xorExpression.
  enterXorExpression(ctx) {
  }
  // Exit a parse tree produced by CypherParser#xorExpression.
  exitXorExpression(ctx) {
  }
  // Enter a parse tree produced by CypherParser#andExpression.
  enterAndExpression(ctx) {
  }
  // Exit a parse tree produced by CypherParser#andExpression.
  exitAndExpression(ctx) {
  }
  // Enter a parse tree produced by CypherParser#notExpression.
  enterNotExpression(ctx) {
  }
  // Exit a parse tree produced by CypherParser#notExpression.
  exitNotExpression(ctx) {
  }
  // Enter a parse tree produced by CypherParser#comparisonExpression.
  enterComparisonExpression(ctx) {
  }
  // Exit a parse tree produced by CypherParser#comparisonExpression.
  exitComparisonExpression(ctx) {
  }
  // Enter a parse tree produced by CypherParser#addOrSubtractExpression.
  enterAddOrSubtractExpression(ctx) {
  }
  // Exit a parse tree produced by CypherParser#addOrSubtractExpression.
  exitAddOrSubtractExpression(ctx) {
  }
  // Enter a parse tree produced by CypherParser#multiplyDivideModuloExpression.
  enterMultiplyDivideModuloExpression(ctx) {
  }
  // Exit a parse tree produced by CypherParser#multiplyDivideModuloExpression.
  exitMultiplyDivideModuloExpression(ctx) {
  }
  // Enter a parse tree produced by CypherParser#powerOfExpression.
  enterPowerOfExpression(ctx) {
  }
  // Exit a parse tree produced by CypherParser#powerOfExpression.
  exitPowerOfExpression(ctx) {
  }
  // Enter a parse tree produced by CypherParser#unaryAddOrSubtractExpression.
  enterUnaryAddOrSubtractExpression(ctx) {
  }
  // Exit a parse tree produced by CypherParser#unaryAddOrSubtractExpression.
  exitUnaryAddOrSubtractExpression(ctx) {
  }
  // Enter a parse tree produced by CypherParser#stringListNullOperatorExpression.
  enterStringListNullOperatorExpression(ctx) {
  }
  // Exit a parse tree produced by CypherParser#stringListNullOperatorExpression.
  exitStringListNullOperatorExpression(ctx) {
  }
  // Enter a parse tree produced by CypherParser#propertyOrLabelsExpression.
  enterPropertyOrLabelsExpression(ctx) {
  }
  // Exit a parse tree produced by CypherParser#propertyOrLabelsExpression.
  exitPropertyOrLabelsExpression(ctx) {
  }
  // Enter a parse tree produced by CypherParser#filterFunction.
  enterFilterFunction(ctx) {
  }
  // Exit a parse tree produced by CypherParser#filterFunction.
  exitFilterFunction(ctx) {
  }
  // Enter a parse tree produced by CypherParser#filterFunctionName.
  enterFilterFunctionName(ctx) {
  }
  // Exit a parse tree produced by CypherParser#filterFunctionName.
  exitFilterFunctionName(ctx) {
  }
  // Enter a parse tree produced by CypherParser#existsFunction.
  enterExistsFunction(ctx) {
  }
  // Exit a parse tree produced by CypherParser#existsFunction.
  exitExistsFunction(ctx) {
  }
  // Enter a parse tree produced by CypherParser#existsFunctionName.
  enterExistsFunctionName(ctx) {
  }
  // Exit a parse tree produced by CypherParser#existsFunctionName.
  exitExistsFunctionName(ctx) {
  }
  // Enter a parse tree produced by CypherParser#allFunction.
  enterAllFunction(ctx) {
  }
  // Exit a parse tree produced by CypherParser#allFunction.
  exitAllFunction(ctx) {
  }
  // Enter a parse tree produced by CypherParser#allFunctionName.
  enterAllFunctionName(ctx) {
  }
  // Exit a parse tree produced by CypherParser#allFunctionName.
  exitAllFunctionName(ctx) {
  }
  // Enter a parse tree produced by CypherParser#anyFunction.
  enterAnyFunction(ctx) {
  }
  // Exit a parse tree produced by CypherParser#anyFunction.
  exitAnyFunction(ctx) {
  }
  // Enter a parse tree produced by CypherParser#anyFunctionName.
  enterAnyFunctionName(ctx) {
  }
  // Exit a parse tree produced by CypherParser#anyFunctionName.
  exitAnyFunctionName(ctx) {
  }
  // Enter a parse tree produced by CypherParser#noneFunction.
  enterNoneFunction(ctx) {
  }
  // Exit a parse tree produced by CypherParser#noneFunction.
  exitNoneFunction(ctx) {
  }
  // Enter a parse tree produced by CypherParser#noneFunctionName.
  enterNoneFunctionName(ctx) {
  }
  // Exit a parse tree produced by CypherParser#noneFunctionName.
  exitNoneFunctionName(ctx) {
  }
  // Enter a parse tree produced by CypherParser#singleFunction.
  enterSingleFunction(ctx) {
  }
  // Exit a parse tree produced by CypherParser#singleFunction.
  exitSingleFunction(ctx) {
  }
  // Enter a parse tree produced by CypherParser#singleFunctionName.
  enterSingleFunctionName(ctx) {
  }
  // Exit a parse tree produced by CypherParser#singleFunctionName.
  exitSingleFunctionName(ctx) {
  }
  // Enter a parse tree produced by CypherParser#extractFunction.
  enterExtractFunction(ctx) {
  }
  // Exit a parse tree produced by CypherParser#extractFunction.
  exitExtractFunction(ctx) {
  }
  // Enter a parse tree produced by CypherParser#extractFunctionName.
  enterExtractFunctionName(ctx) {
  }
  // Exit a parse tree produced by CypherParser#extractFunctionName.
  exitExtractFunctionName(ctx) {
  }
  // Enter a parse tree produced by CypherParser#reduceFunction.
  enterReduceFunction(ctx) {
  }
  // Exit a parse tree produced by CypherParser#reduceFunction.
  exitReduceFunction(ctx) {
  }
  // Enter a parse tree produced by CypherParser#reduceFunctionName.
  enterReduceFunctionName(ctx) {
  }
  // Exit a parse tree produced by CypherParser#reduceFunctionName.
  exitReduceFunctionName(ctx) {
  }
  // Enter a parse tree produced by CypherParser#shortestPathPatternFunction.
  enterShortestPathPatternFunction(ctx) {
  }
  // Exit a parse tree produced by CypherParser#shortestPathPatternFunction.
  exitShortestPathPatternFunction(ctx) {
  }
  // Enter a parse tree produced by CypherParser#shortestPathFunctionName.
  enterShortestPathFunctionName(ctx) {
  }
  // Exit a parse tree produced by CypherParser#shortestPathFunctionName.
  exitShortestPathFunctionName(ctx) {
  }
  // Enter a parse tree produced by CypherParser#allShortestPathFunctionName.
  enterAllShortestPathFunctionName(ctx) {
  }
  // Exit a parse tree produced by CypherParser#allShortestPathFunctionName.
  exitAllShortestPathFunctionName(ctx) {
  }
  // Enter a parse tree produced by CypherParser#atom.
  enterAtom(ctx) {
  }
  // Exit a parse tree produced by CypherParser#atom.
  exitAtom(ctx) {
  }
  // Enter a parse tree produced by CypherParser#literal.
  enterLiteral(ctx) {
  }
  // Exit a parse tree produced by CypherParser#literal.
  exitLiteral(ctx) {
  }
  // Enter a parse tree produced by CypherParser#stringLiteral.
  enterStringLiteral(ctx) {
  }
  // Exit a parse tree produced by CypherParser#stringLiteral.
  exitStringLiteral(ctx) {
  }
  // Enter a parse tree produced by CypherParser#booleanLiteral.
  enterBooleanLiteral(ctx) {
  }
  // Exit a parse tree produced by CypherParser#booleanLiteral.
  exitBooleanLiteral(ctx) {
  }
  // Enter a parse tree produced by CypherParser#listLiteral.
  enterListLiteral(ctx) {
  }
  // Exit a parse tree produced by CypherParser#listLiteral.
  exitListLiteral(ctx) {
  }
  // Enter a parse tree produced by CypherParser#partialComparisonExpression.
  enterPartialComparisonExpression(ctx) {
  }
  // Exit a parse tree produced by CypherParser#partialComparisonExpression.
  exitPartialComparisonExpression(ctx) {
  }
  // Enter a parse tree produced by CypherParser#parenthesizedExpression.
  enterParenthesizedExpression(ctx) {
  }
  // Exit a parse tree produced by CypherParser#parenthesizedExpression.
  exitParenthesizedExpression(ctx) {
  }
  // Enter a parse tree produced by CypherParser#relationshipsPattern.
  enterRelationshipsPattern(ctx) {
  }
  // Exit a parse tree produced by CypherParser#relationshipsPattern.
  exitRelationshipsPattern(ctx) {
  }
  // Enter a parse tree produced by CypherParser#filterExpression.
  enterFilterExpression(ctx) {
  }
  // Exit a parse tree produced by CypherParser#filterExpression.
  exitFilterExpression(ctx) {
  }
  // Enter a parse tree produced by CypherParser#idInColl.
  enterIdInColl(ctx) {
  }
  // Exit a parse tree produced by CypherParser#idInColl.
  exitIdInColl(ctx) {
  }
  // Enter a parse tree produced by CypherParser#functionInvocation.
  enterFunctionInvocation(ctx) {
  }
  // Exit a parse tree produced by CypherParser#functionInvocation.
  exitFunctionInvocation(ctx) {
  }
  // Enter a parse tree produced by CypherParser#functionInvocationBody.
  enterFunctionInvocationBody(ctx) {
  }
  // Exit a parse tree produced by CypherParser#functionInvocationBody.
  exitFunctionInvocationBody(ctx) {
  }
  // Enter a parse tree produced by CypherParser#functionName.
  enterFunctionName(ctx) {
  }
  // Exit a parse tree produced by CypherParser#functionName.
  exitFunctionName(ctx) {
  }
  // Enter a parse tree produced by CypherParser#procedureName.
  enterProcedureName(ctx) {
  }
  // Exit a parse tree produced by CypherParser#procedureName.
  exitProcedureName(ctx) {
  }
  // Enter a parse tree produced by CypherParser#listComprehension.
  enterListComprehension(ctx) {
  }
  // Exit a parse tree produced by CypherParser#listComprehension.
  exitListComprehension(ctx) {
  }
  // Enter a parse tree produced by CypherParser#patternComprehension.
  enterPatternComprehension(ctx) {
  }
  // Exit a parse tree produced by CypherParser#patternComprehension.
  exitPatternComprehension(ctx) {
  }
  // Enter a parse tree produced by CypherParser#propertyLookup.
  enterPropertyLookup(ctx) {
  }
  // Exit a parse tree produced by CypherParser#propertyLookup.
  exitPropertyLookup(ctx) {
  }
  // Enter a parse tree produced by CypherParser#caseExpression.
  enterCaseExpression(ctx) {
  }
  // Exit a parse tree produced by CypherParser#caseExpression.
  exitCaseExpression(ctx) {
  }
  // Enter a parse tree produced by CypherParser#caseAlternatives.
  enterCaseAlternatives(ctx) {
  }
  // Exit a parse tree produced by CypherParser#caseAlternatives.
  exitCaseAlternatives(ctx) {
  }
  // Enter a parse tree produced by CypherParser#variable.
  enterVariable(ctx) {
  }
  // Exit a parse tree produced by CypherParser#variable.
  exitVariable(ctx) {
  }
  // Enter a parse tree produced by CypherParser#numberLiteral.
  enterNumberLiteral(ctx) {
  }
  // Exit a parse tree produced by CypherParser#numberLiteral.
  exitNumberLiteral(ctx) {
  }
  // Enter a parse tree produced by CypherParser#mapLiteral.
  enterMapLiteral(ctx) {
  }
  // Exit a parse tree produced by CypherParser#mapLiteral.
  exitMapLiteral(ctx) {
  }
  // Enter a parse tree produced by CypherParser#mapProjection.
  enterMapProjection(ctx) {
  }
  // Exit a parse tree produced by CypherParser#mapProjection.
  exitMapProjection(ctx) {
  }
  // Enter a parse tree produced by CypherParser#mapProjectionVariants.
  enterMapProjectionVariants(ctx) {
  }
  // Exit a parse tree produced by CypherParser#mapProjectionVariants.
  exitMapProjectionVariants(ctx) {
  }
  // Enter a parse tree produced by CypherParser#literalEntry.
  enterLiteralEntry(ctx) {
  }
  // Exit a parse tree produced by CypherParser#literalEntry.
  exitLiteralEntry(ctx) {
  }
  // Enter a parse tree produced by CypherParser#propertySelector.
  enterPropertySelector(ctx) {
  }
  // Exit a parse tree produced by CypherParser#propertySelector.
  exitPropertySelector(ctx) {
  }
  // Enter a parse tree produced by CypherParser#variableSelector.
  enterVariableSelector(ctx) {
  }
  // Exit a parse tree produced by CypherParser#variableSelector.
  exitVariableSelector(ctx) {
  }
  // Enter a parse tree produced by CypherParser#allPropertiesSelector.
  enterAllPropertiesSelector(ctx) {
  }
  // Exit a parse tree produced by CypherParser#allPropertiesSelector.
  exitAllPropertiesSelector(ctx) {
  }
  // Enter a parse tree produced by CypherParser#parameter.
  enterParameter(ctx) {
  }
  // Exit a parse tree produced by CypherParser#parameter.
  exitParameter(ctx) {
  }
  // Enter a parse tree produced by CypherParser#legacyParameter.
  enterLegacyParameter(ctx) {
  }
  // Exit a parse tree produced by CypherParser#legacyParameter.
  exitLegacyParameter(ctx) {
  }
  // Enter a parse tree produced by CypherParser#newParameter.
  enterNewParameter(ctx) {
  }
  // Exit a parse tree produced by CypherParser#newParameter.
  exitNewParameter(ctx) {
  }
  // Enter a parse tree produced by CypherParser#parameterName.
  enterParameterName(ctx) {
  }
  // Exit a parse tree produced by CypherParser#parameterName.
  exitParameterName(ctx) {
  }
  // Enter a parse tree produced by CypherParser#propertyExpressions.
  enterPropertyExpressions(ctx) {
  }
  // Exit a parse tree produced by CypherParser#propertyExpressions.
  exitPropertyExpressions(ctx) {
  }
  // Enter a parse tree produced by CypherParser#propertyExpression.
  enterPropertyExpression(ctx) {
  }
  // Exit a parse tree produced by CypherParser#propertyExpression.
  exitPropertyExpression(ctx) {
  }
  // Enter a parse tree produced by CypherParser#propertyKeys.
  enterPropertyKeys(ctx) {
  }
  // Exit a parse tree produced by CypherParser#propertyKeys.
  exitPropertyKeys(ctx) {
  }
  // Enter a parse tree produced by CypherParser#propertyKeyName.
  enterPropertyKeyName(ctx) {
  }
  // Exit a parse tree produced by CypherParser#propertyKeyName.
  exitPropertyKeyName(ctx) {
  }
  // Enter a parse tree produced by CypherParser#integerLiteral.
  enterIntegerLiteral(ctx) {
  }
  // Exit a parse tree produced by CypherParser#integerLiteral.
  exitIntegerLiteral(ctx) {
  }
  // Enter a parse tree produced by CypherParser#doubleLiteral.
  enterDoubleLiteral(ctx) {
  }
  // Exit a parse tree produced by CypherParser#doubleLiteral.
  exitDoubleLiteral(ctx) {
  }
  // Enter a parse tree produced by CypherParser#namespace.
  enterNamespace(ctx) {
  }
  // Exit a parse tree produced by CypherParser#namespace.
  exitNamespace(ctx) {
  }
  // Enter a parse tree produced by CypherParser#leftArrowHead.
  enterLeftArrowHead(ctx) {
  }
  // Exit a parse tree produced by CypherParser#leftArrowHead.
  exitLeftArrowHead(ctx) {
  }
  // Enter a parse tree produced by CypherParser#rightArrowHead.
  enterRightArrowHead(ctx) {
  }
  // Exit a parse tree produced by CypherParser#rightArrowHead.
  exitRightArrowHead(ctx) {
  }
  // Enter a parse tree produced by CypherParser#dash.
  enterDash(ctx) {
  }
  // Exit a parse tree produced by CypherParser#dash.
  exitDash(ctx) {
  }
  // Enter a parse tree produced by CypherParser#symbolicName.
  enterSymbolicName(ctx) {
  }
  // Exit a parse tree produced by CypherParser#symbolicName.
  exitSymbolicName(ctx) {
  }
  // Enter a parse tree produced by CypherParser#keyword.
  enterKeyword(ctx) {
  }
  // Exit a parse tree produced by CypherParser#keyword.
  exitKeyword(ctx) {
  }
};

// node_modules/@neo4j-cypher/antlr4/es/CypherParser.js
var serializedATN2 = [4, 1, 221, 3443, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7, 99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2, 104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7, 108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2, 113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7, 117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2, 122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7, 126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2, 131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7, 135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2, 140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7, 144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2, 149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7, 153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2, 158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7, 162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2, 167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7, 171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2, 176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7, 180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2, 185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7, 189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2, 194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7, 198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2, 203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7, 207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2, 212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7, 216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2, 221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7, 225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2, 230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7, 234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2, 239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 1, 0, 1, 0, 1, 0, 5, 0, 490, 8, 0, 10, 0, 12, 0, 493, 9, 0, 1, 0, 3, 0, 496, 8, 0, 1, 0, 1, 0, 1, 1, 3, 1, 501, 8, 1, 1, 1, 1, 1, 3, 1, 505, 8, 1, 1, 1, 3, 1, 508, 8, 1, 1, 2, 1, 2, 1, 2, 3, 2, 513, 8, 2, 1, 3, 1, 3, 1, 3, 1, 3, 5, 3, 519, 8, 3, 10, 3, 12, 3, 522, 9, 3, 1, 4, 1, 4, 1, 4, 5, 4, 527, 8, 4, 10, 4, 12, 4, 530, 9, 4, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 542, 8, 5, 1, 6, 1, 6, 3, 6, 546, 8, 6, 1, 6, 1, 6, 3, 6, 550, 8, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 3, 8, 559, 8, 8, 1, 8, 1, 8, 1, 8, 3, 8, 564, 8, 8, 1, 8, 1, 8, 3, 8, 568, 8, 8, 1, 8, 3, 8, 571, 8, 8, 1, 8, 3, 8, 574, 8, 8, 1, 9, 1, 9, 1, 10, 3, 10, 579, 8, 10, 1, 10, 1, 10, 3, 10, 583, 8, 10, 1, 11, 1, 11, 1, 11, 5, 11, 588, 8, 11, 10, 11, 12, 11, 591, 9, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 5, 14, 606, 8, 14, 10, 14, 12, 14, 609, 9, 14, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 1, 20, 1, 20, 1, 20, 5, 20, 629, 8, 20, 10, 20, 12, 20, 632, 9, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 639, 8, 21, 3, 21, 641, 8, 21, 1, 22, 1, 22, 3, 22, 645, 8, 22, 1, 22, 5, 22, 648, 8, 22, 10, 22, 12, 22, 651, 9, 22, 1, 23, 4, 23, 654, 8, 23, 11, 23, 12, 23, 655, 1, 24, 1, 24, 1, 25, 1, 25, 3, 25, 662, 8, 25, 1, 25, 1, 25, 3, 25, 666, 8, 25, 1, 25, 1, 25, 3, 25, 670, 8, 25, 1, 25, 1, 25, 3, 25, 674, 8, 25, 5, 25, 676, 8, 25, 10, 25, 12, 25, 679, 9, 25, 1, 25, 1, 25, 1, 25, 1, 25, 3, 25, 685, 8, 25, 1, 25, 3, 25, 688, 8, 25, 1, 26, 1, 26, 3, 26, 692, 8, 26, 1, 26, 1, 26, 3, 26, 696, 8, 26, 1, 26, 1, 26, 1, 27, 1, 27, 3, 27, 702, 8, 27, 1, 27, 1, 27, 3, 27, 706, 8, 27, 1, 27, 1, 27, 3, 27, 710, 8, 27, 1, 27, 1, 27, 3, 27, 714, 8, 27, 5, 27, 716, 8, 27, 10, 27, 12, 27, 719, 9, 27, 1, 27, 1, 27, 1, 27, 1, 27, 3, 27, 725, 8, 27, 1, 27, 3, 27, 728, 8, 27, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 736, 8, 28, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 745, 8, 29, 1, 30, 1, 30, 1, 30, 3, 30, 750, 8, 30, 4, 30, 752, 8, 30, 11, 30, 12, 30, 753, 1, 30, 3, 30, 757, 8, 30, 1, 31, 1, 31, 1, 31, 5, 31, 762, 8, 31, 10, 31, 12, 31, 765, 9, 31, 1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 3, 33, 772, 8, 33, 5, 33, 774, 8, 33, 10, 33, 12, 33, 777, 9, 33, 1, 34, 1, 34, 1, 34, 3, 34, 782, 8, 34, 1, 35, 1, 35, 1, 35, 3, 35, 787, 8, 35, 1, 35, 1, 35, 5, 35, 791, 8, 35, 10, 35, 12, 35, 794, 9, 35, 1, 36, 1, 36, 1, 37, 1, 37, 1, 38, 1, 38, 1, 39, 1, 39, 3, 39, 804, 8, 39, 1, 39, 1, 39, 3, 39, 808, 8, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 816, 8, 40, 1, 40, 3, 40, 819, 8, 40, 1, 41, 1, 41, 3, 41, 823, 8, 41, 1, 42, 1, 42, 3, 42, 827, 8, 42, 1, 42, 5, 42, 830, 8, 42, 10, 42, 12, 42, 833, 9, 42, 1, 43, 1, 43, 3, 43, 837, 8, 43, 1, 43, 1, 43, 1, 44, 1, 44, 3, 44, 843, 8, 44, 1, 44, 5, 44, 846, 8, 44, 10, 44, 12, 44, 849, 9, 44, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 858, 8, 45, 1, 46, 1, 46, 3, 46, 862, 8, 46, 1, 46, 5, 46, 865, 8, 46, 10, 46, 12, 46, 868, 9, 46, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 874, 8, 47, 1, 47, 1, 47, 1, 47, 3, 47, 879, 8, 47, 1, 47, 3, 47, 882, 8, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 898, 8, 48, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 910, 8, 49, 1, 50, 1, 50, 1, 50, 3, 50, 915, 8, 50, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 3, 51, 922, 8, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 931, 8, 52, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 937, 8, 53, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 943, 8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 950, 8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 956, 8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 963, 8, 54, 3, 54, 965, 8, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 974, 8, 55, 1, 55, 1, 55, 3, 55, 978, 8, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 985, 8, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 992, 8, 55, 3, 55, 994, 8, 55, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 1013, 8, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 1027, 8, 59, 1, 59, 1, 59, 1, 59, 3, 59, 1032, 8, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 1039, 8, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 1048, 8, 59, 3, 59, 1050, 8, 59, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 1059, 8, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 1075, 8, 61, 1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 1081, 8, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 1092, 8, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 1102, 8, 61, 1, 62, 1, 62, 1, 62, 1, 62, 3, 62, 1108, 8, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 3, 62, 1118, 8, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 3, 62, 1128, 8, 62, 1, 62, 3, 62, 1131, 8, 62, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 3, 63, 1178, 8, 63, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 3, 64, 1225, 8, 64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 1240, 8, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 1248, 8, 65, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66, 1268, 8, 66, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 1277, 8, 67, 1, 67, 1, 67, 3, 67, 1281, 8, 67, 1, 67, 5, 67, 1284, 8, 67, 10, 67, 12, 67, 1287, 9, 67, 3, 67, 1289, 8, 67, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 1298, 8, 68, 1, 68, 1, 68, 3, 68, 1302, 8, 68, 1, 68, 5, 68, 1305, 8, 68, 10, 68, 12, 68, 1308, 9, 68, 3, 68, 1310, 8, 68, 1, 69, 1, 69, 3, 69, 1314, 8, 69, 1, 69, 1, 69, 3, 69, 1318, 8, 69, 1, 69, 5, 69, 1321, 8, 69, 10, 69, 12, 69, 1324, 9, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 1331, 8, 70, 1, 70, 1, 70, 1, 70, 3, 70, 1336, 8, 70, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 1343, 8, 71, 1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 1349, 8, 71, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 1378, 8, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 1387, 8, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 1396, 8, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 1402, 8, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 1408, 8, 72, 1, 72, 3, 72, 1411, 8, 72, 3, 72, 1413, 8, 72, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 1433, 8, 73, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 1440, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 1447, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 1454, 8, 74, 3, 74, 1456, 8, 74, 1, 75, 1, 75, 1, 75, 3, 75, 1461, 8, 75, 1, 75, 1, 75, 3, 75, 1465, 8, 75, 1, 75, 5, 75, 1468, 8, 75, 10, 75, 12, 75, 1471, 9, 75, 3, 75, 1473, 8, 75, 1, 76, 1, 76, 3, 76, 1477, 8, 76, 1, 76, 1, 76, 3, 76, 1481, 8, 76, 1, 76, 1, 76, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 1489, 8, 77, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 1495, 8, 77, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 1504, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 1511, 8, 78, 1, 78, 1, 78, 1, 78, 3, 78, 1516, 8, 78, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 1525, 8, 79, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 83, 1, 83, 1, 83, 1, 83, 1, 84, 1, 84, 1, 84, 1, 84, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 3, 85, 1559, 8, 85, 1, 85, 1, 85, 3, 85, 1563, 8, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 3, 85, 1570, 8, 85, 1, 86, 1, 86, 1, 86, 1, 86, 3, 86, 1576, 8, 86, 1, 86, 1, 86, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 89, 1, 89, 1, 89, 1, 89, 1, 90, 1, 90, 1, 90, 1, 90, 1, 91, 1, 91, 1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93, 1, 93, 1, 94, 1, 94, 1, 94, 1, 94, 1, 95, 1, 95, 1, 95, 1, 95, 1, 96, 1, 96, 1, 96, 1, 96, 1, 97, 1, 97, 1, 97, 1, 97, 1, 98, 1, 98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1, 99, 3, 99, 1632, 8, 99, 1, 99, 1, 99, 3, 99, 1636, 8, 99, 1, 99, 1, 99, 3, 99, 1640, 8, 99, 1, 99, 1, 99, 3, 99, 1644, 8, 99, 1, 99, 1, 99, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 1652, 8, 100, 1, 100, 1, 100, 3, 100, 1656, 8, 100, 1, 100, 1, 100, 1, 100, 3, 100, 1661, 8, 100, 1, 100, 1, 100, 3, 100, 1665, 8, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 101, 1, 101, 1, 101, 1, 101, 3, 101, 1679, 8, 101, 1, 101, 1, 101, 3, 101, 1683, 8, 101, 1, 101, 1, 101, 1, 101, 3, 101, 1688, 8, 101, 1, 101, 1, 101, 3, 101, 1692, 8, 101, 1, 101, 1, 101, 1, 101, 1, 101, 3, 101, 1698, 8, 101, 1, 101, 1, 101, 3, 101, 1702, 8, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 102, 1, 102, 1, 102, 1, 102, 3, 102, 1716, 8, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 3, 102, 1723, 8, 102, 1, 102, 1, 102, 1, 102, 1, 102, 3, 102, 1729, 8, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 103, 1, 103, 1, 103, 1, 103, 3, 103, 1739, 8, 103, 1, 103, 1, 103, 3, 103, 1743, 8, 103, 1, 103, 1, 103, 1, 103, 1, 103, 3, 103, 1749, 8, 103, 1, 103, 1, 103, 1, 103, 1, 103, 1, 104, 1, 104, 3, 104, 1757, 8, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 3, 104, 1768, 8, 104, 1, 104, 1, 104, 1, 104, 1, 104, 3, 104, 1774, 8, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 3, 104, 1786, 8, 104, 1, 104, 1, 104, 1, 104, 1, 104, 3, 104, 1792, 8, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 3, 104, 1804, 8, 104, 1, 104, 1, 104, 3, 104, 1808, 8, 104, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 3, 105, 1818, 8, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 3, 105, 1831, 8, 105, 1, 106, 1, 106, 3, 106, 1835, 8, 106, 1, 106, 1, 106, 3, 106, 1839, 8, 106, 1, 106, 1, 106, 5, 106, 1843, 8, 106, 10, 106, 12, 106, 1846, 9, 106, 1, 106, 3, 106, 1849, 8, 106, 1, 106, 3, 106, 1852, 8, 106, 1, 107, 1, 107, 3, 107, 1856, 8, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 108, 1, 108, 3, 108, 1866, 8, 108, 1, 108, 1, 108, 1, 108, 5, 108, 1871, 8, 108, 10, 108, 12, 108, 1874, 9, 108, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 3, 109, 1886, 8, 109, 1, 110, 1, 110, 3, 110, 1890, 8, 110, 1, 110, 1, 110, 1, 111, 1, 111, 1, 111, 1, 111, 3, 111, 1898, 8, 111, 1, 111, 1, 111, 1, 112, 1, 112, 3, 112, 1904, 8, 112, 1, 112, 1, 112, 3, 112, 1908, 8, 112, 1, 112, 1, 112, 3, 112, 1912, 8, 112, 1, 112, 5, 112, 1915, 8, 112, 10, 112, 12, 112, 1918, 9, 112, 1, 113, 1, 113, 3, 113, 1922, 8, 113, 1, 113, 1, 113, 3, 113, 1926, 8, 113, 1, 113, 1, 113, 1, 113, 1, 113, 3, 113, 1932, 8, 113, 1, 113, 1, 113, 3, 113, 1936, 8, 113, 1, 113, 1, 113, 1, 113, 1, 113, 3, 113, 1942, 8, 113, 1, 113, 1, 113, 3, 113, 1946, 8, 113, 1, 113, 1, 113, 1, 113, 1, 113, 3, 113, 1952, 8, 113, 1, 113, 1, 113, 3, 113, 1956, 8, 113, 1, 114, 1, 114, 3, 114, 1960, 8, 114, 1, 114, 1, 114, 3, 114, 1964, 8, 114, 1, 114, 1, 114, 3, 114, 1968, 8, 114, 1, 114, 1, 114, 3, 114, 1972, 8, 114, 1, 114, 5, 114, 1975, 8, 114, 10, 114, 12, 114, 1978, 9, 114, 1, 115, 1, 115, 1, 115, 1, 115, 3, 115, 1984, 8, 115, 1, 115, 1, 115, 3, 115, 1988, 8, 115, 1, 115, 5, 115, 1991, 8, 115, 10, 115, 12, 115, 1994, 9, 115, 1, 116, 1, 116, 1, 116, 1, 116, 3, 116, 2e3, 8, 116, 1, 117, 1, 117, 3, 117, 2004, 8, 117, 1, 117, 1, 117, 3, 117, 2008, 8, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 3, 117, 2016, 8, 117, 1, 117, 1, 117, 1, 117, 4, 117, 2021, 8, 117, 11, 117, 12, 117, 2022, 1, 117, 3, 117, 2026, 8, 117, 1, 117, 1, 117, 1, 118, 1, 118, 3, 118, 2032, 8, 118, 1, 118, 3, 118, 2035, 8, 118, 1, 118, 1, 118, 1, 118, 3, 118, 2040, 8, 118, 1, 118, 3, 118, 2043, 8, 118, 1, 119, 1, 119, 3, 119, 2047, 8, 119, 1, 119, 3, 119, 2050, 8, 119, 1, 119, 3, 119, 2053, 8, 119, 1, 119, 1, 119, 1, 120, 1, 120, 1, 120, 3, 120, 2060, 8, 120, 1, 120, 1, 120, 3, 120, 2064, 8, 120, 1, 120, 1, 120, 3, 120, 2068, 8, 120, 1, 121, 1, 121, 3, 121, 2072, 8, 121, 1, 121, 3, 121, 2075, 8, 121, 1, 122, 1, 122, 3, 122, 2079, 8, 122, 1, 122, 1, 122, 3, 122, 2083, 8, 122, 1, 122, 5, 122, 2086, 8, 122, 10, 122, 12, 122, 2089, 9, 122, 1, 122, 1, 122, 3, 122, 2093, 8, 122, 1, 122, 1, 122, 3, 122, 2097, 8, 122, 1, 122, 5, 122, 2100, 8, 122, 10, 122, 12, 122, 2103, 9, 122, 1, 122, 3, 122, 2106, 8, 122, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 3, 123, 2115, 8, 123, 1, 124, 1, 124, 1, 124, 1, 124, 3, 124, 2121, 8, 124, 1, 124, 3, 124, 2124, 8, 124, 1, 125, 1, 125, 3, 125, 2128, 8, 125, 1, 125, 3, 125, 2131, 8, 125, 1, 126, 1, 126, 1, 126, 1, 127, 1, 127, 3, 127, 2138, 8, 127, 1, 127, 3, 127, 2141, 8, 127, 1, 127, 3, 127, 2144, 8, 127, 1, 127, 1, 127, 3, 127, 2148, 8, 127, 1, 127, 5, 127, 2151, 8, 127, 10, 127, 12, 127, 2154, 9, 127, 1, 127, 3, 127, 2157, 8, 127, 1, 127, 1, 127, 1, 128, 1, 128, 1, 128, 1, 128, 3, 128, 2165, 8, 128, 1, 128, 1, 128, 3, 128, 2169, 8, 128, 1, 128, 5, 128, 2172, 8, 128, 10, 128, 12, 128, 2175, 9, 128, 1, 128, 1, 128, 3, 128, 2179, 8, 128, 1, 129, 1, 129, 3, 129, 2183, 8, 129, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 131, 1, 131, 1, 132, 1, 132, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 3, 133, 2201, 8, 133, 1, 133, 1, 133, 3, 133, 2205, 8, 133, 1, 133, 5, 133, 2208, 8, 133, 10, 133, 12, 133, 2211, 9, 133, 1, 134, 1, 134, 1, 134, 1, 134, 1, 135, 1, 135, 1, 135, 1, 135, 1, 136, 1, 136, 3, 136, 2223, 8, 136, 1, 136, 1, 136, 3, 136, 2227, 8, 136, 3, 136, 2229, 8, 136, 1, 137, 3, 137, 2232, 8, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 3, 137, 2241, 8, 137, 1, 137, 1, 137, 3, 137, 2245, 8, 137, 1, 137, 1, 137, 3, 137, 2249, 8, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 3, 137, 2261, 8, 137, 1, 137, 1, 137, 3, 137, 2265, 8, 137, 1, 137, 5, 137, 2268, 8, 137, 10, 137, 12, 137, 2271, 9, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 3, 137, 2280, 8, 137, 1, 138, 1, 138, 1, 138, 1, 138, 3, 138, 2286, 8, 138, 1, 138, 1, 138, 3, 138, 2290, 8, 138, 1, 138, 5, 138, 2293, 8, 138, 10, 138, 12, 138, 2296, 9, 138, 1, 138, 3, 138, 2299, 8, 138, 1, 139, 1, 139, 3, 139, 2303, 8, 139, 1, 139, 1, 139, 3, 139, 2307, 8, 139, 1, 139, 1, 139, 1, 140, 1, 140, 3, 140, 2313, 8, 140, 1, 141, 1, 141, 3, 141, 2317, 8, 141, 1, 141, 1, 141, 1, 141, 3, 141, 2322, 8, 141, 1, 142, 1, 142, 1, 142, 1, 142, 3, 142, 2328, 8, 142, 1, 143, 1, 143, 1, 143, 1, 143, 1, 143, 1, 143, 1, 143, 3, 143, 2337, 8, 143, 1, 143, 1, 143, 1, 144, 1, 144, 1, 144, 1, 144, 1, 144, 3, 144, 2346, 8, 144, 1, 144, 1, 144, 1, 145, 1, 145, 1, 145, 1, 145, 3, 145, 2354, 8, 145, 1, 145, 1, 145, 1, 146, 1, 146, 3, 146, 2360, 8, 146, 1, 146, 1, 146, 3, 146, 2364, 8, 146, 1, 146, 5, 146, 2367, 8, 146, 10, 146, 12, 146, 2370, 9, 146, 1, 147, 1, 147, 1, 147, 1, 147, 1, 148, 1, 148, 3, 148, 2378, 8, 148, 1, 148, 1, 148, 3, 148, 2382, 8, 148, 1, 148, 5, 148, 2385, 8, 148, 10, 148, 12, 148, 2388, 9, 148, 1, 149, 1, 149, 3, 149, 2392, 8, 149, 1, 149, 1, 149, 3, 149, 2396, 8, 149, 1, 149, 1, 149, 1, 149, 3, 149, 2401, 8, 149, 1, 150, 1, 150, 3, 150, 2405, 8, 150, 1, 151, 1, 151, 3, 151, 2409, 8, 151, 1, 151, 5, 151, 2412, 8, 151, 10, 151, 12, 151, 2415, 9, 151, 1, 151, 1, 151, 1, 151, 1, 151, 3, 151, 2421, 8, 151, 1, 152, 1, 152, 3, 152, 2425, 8, 152, 1, 152, 1, 152, 3, 152, 2429, 8, 152, 3, 152, 2431, 8, 152, 1, 152, 1, 152, 3, 152, 2435, 8, 152, 3, 152, 2437, 8, 152, 1, 152, 1, 152, 3, 152, 2441, 8, 152, 3, 152, 2443, 8, 152, 1, 152, 1, 152, 1, 153, 1, 153, 3, 153, 2449, 8, 153, 1, 153, 1, 153, 1, 154, 1, 154, 3, 154, 2455, 8, 154, 1, 154, 3, 154, 2458, 8, 154, 1, 154, 3, 154, 2461, 8, 154, 1, 154, 1, 154, 1, 155, 1, 155, 3, 155, 2467, 8, 155, 1, 155, 1, 155, 1, 155, 3, 155, 2472, 8, 155, 1, 156, 1, 156, 3, 156, 2476, 8, 156, 1, 156, 1, 156, 1, 156, 3, 156, 2481, 8, 156, 1, 157, 1, 157, 3, 157, 2485, 8, 157, 1, 157, 1, 157, 3, 157, 2489, 8, 157, 3, 157, 2491, 8, 157, 1, 157, 1, 157, 3, 157, 2495, 8, 157, 3, 157, 2497, 8, 157, 1, 157, 3, 157, 2500, 8, 157, 1, 157, 1, 157, 3, 157, 2504, 8, 157, 3, 157, 2506, 8, 157, 1, 157, 1, 157, 1, 158, 1, 158, 3, 158, 2512, 8, 158, 1, 159, 1, 159, 3, 159, 2516, 8, 159, 1, 159, 1, 159, 1, 160, 1, 160, 3, 160, 2522, 8, 160, 1, 160, 1, 160, 5, 160, 2526, 8, 160, 10, 160, 12, 160, 2529, 9, 160, 1, 161, 1, 161, 1, 161, 1, 162, 3, 162, 2535, 8, 162, 1, 162, 1, 162, 1, 163, 1, 163, 3, 163, 2541, 8, 163, 1, 163, 5, 163, 2544, 8, 163, 10, 163, 12, 163, 2547, 9, 163, 1, 164, 1, 164, 1, 164, 1, 165, 1, 165, 3, 165, 2554, 8, 165, 1, 165, 1, 165, 3, 165, 2558, 8, 165, 3, 165, 2560, 8, 165, 1, 165, 1, 165, 3, 165, 2564, 8, 165, 1, 165, 1, 165, 3, 165, 2568, 8, 165, 3, 165, 2570, 8, 165, 3, 165, 2572, 8, 165, 1, 166, 1, 166, 1, 167, 1, 167, 1, 168, 1, 168, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 5, 169, 2585, 8, 169, 10, 169, 12, 169, 2588, 9, 169, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 5, 170, 2595, 8, 170, 10, 170, 12, 170, 2598, 9, 170, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 5, 171, 2605, 8, 171, 10, 171, 12, 171, 2608, 9, 171, 1, 172, 1, 172, 3, 172, 2612, 8, 172, 5, 172, 2614, 8, 172, 10, 172, 12, 172, 2617, 9, 172, 1, 172, 1, 172, 1, 173, 1, 173, 3, 173, 2623, 8, 173, 1, 173, 5, 173, 2626, 8, 173, 10, 173, 12, 173, 2629, 9, 173, 1, 174, 1, 174, 3, 174, 2633, 8, 174, 1, 174, 1, 174, 3, 174, 2637, 8, 174, 1, 174, 1, 174, 3, 174, 2641, 8, 174, 1, 174, 1, 174, 3, 174, 2645, 8, 174, 1, 174, 5, 174, 2648, 8, 174, 10, 174, 12, 174, 2651, 9, 174, 1, 175, 1, 175, 3, 175, 2655, 8, 175, 1, 175, 1, 175, 3, 175, 2659, 8, 175, 1, 175, 1, 175, 3, 175, 2663, 8, 175, 1, 175, 1, 175, 3, 175, 2667, 8, 175, 1, 175, 1, 175, 3, 175, 2671, 8, 175, 1, 175, 1, 175, 3, 175, 2675, 8, 175, 1, 175, 5, 175, 2678, 8, 175, 10, 175, 12, 175, 2681, 9, 175, 1, 176, 1, 176, 3, 176, 2685, 8, 176, 1, 176, 1, 176, 3, 176, 2689, 8, 176, 1, 176, 5, 176, 2692, 8, 176, 10, 176, 12, 176, 2695, 9, 176, 1, 177, 1, 177, 3, 177, 2699, 8, 177, 5, 177, 2701, 8, 177, 10, 177, 12, 177, 2704, 9, 177, 1, 177, 1, 177, 1, 178, 1, 178, 3, 178, 2710, 8, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 3, 178, 2717, 8, 178, 1, 178, 1, 178, 3, 178, 2721, 8, 178, 1, 178, 1, 178, 3, 178, 2725, 8, 178, 1, 178, 1, 178, 3, 178, 2729, 8, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 3, 178, 2744, 8, 178, 1, 178, 3, 178, 2747, 8, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 5, 178, 2760, 8, 178, 10, 178, 12, 178, 2763, 9, 178, 1, 179, 1, 179, 3, 179, 2767, 8, 179, 1, 179, 1, 179, 3, 179, 2771, 8, 179, 5, 179, 2773, 8, 179, 10, 179, 12, 179, 2776, 9, 179, 1, 180, 1, 180, 3, 180, 2780, 8, 180, 1, 180, 1, 180, 3, 180, 2784, 8, 180, 1, 180, 1, 180, 3, 180, 2788, 8, 180, 1, 180, 1, 180, 1, 181, 1, 181, 1, 182, 1, 182, 3, 182, 2796, 8, 182, 1, 182, 1, 182, 3, 182, 2800, 8, 182, 1, 182, 1, 182, 3, 182, 2804, 8, 182, 1, 182, 1, 182, 1, 183, 1, 183, 1, 184, 1, 184, 3, 184, 2812, 8, 184, 1, 184, 1, 184, 3, 184, 2816, 8, 184, 1, 184, 1, 184, 3, 184, 2820, 8, 184, 1, 184, 1, 184, 1, 185, 1, 185, 1, 186, 1, 186, 3, 186, 2828, 8, 186, 1, 186, 1, 186, 3, 186, 2832, 8, 186, 1, 186, 1, 186, 3, 186, 2836, 8, 186, 1, 186, 1, 186, 1, 187, 1, 187, 1, 188, 1, 188, 3, 188, 2844, 8, 188, 1, 188, 1, 188, 3, 188, 2848, 8, 188, 1, 188, 1, 188, 3, 188, 2852, 8, 188, 1, 188, 1, 188, 1, 189, 1, 189, 1, 190, 1, 190, 3, 190, 2860, 8, 190, 1, 190, 1, 190, 3, 190, 2864, 8, 190, 1, 190, 1, 190, 3, 190, 2868, 8, 190, 1, 190, 1, 190, 1, 191, 1, 191, 1, 192, 1, 192, 3, 192, 2876, 8, 192, 1, 192, 1, 192, 3, 192, 2880, 8, 192, 1, 192, 1, 192, 3, 192, 2884, 8, 192, 1, 192, 1, 192, 3, 192, 2888, 8, 192, 1, 192, 3, 192, 2891, 8, 192, 1, 192, 3, 192, 2894, 8, 192, 1, 192, 1, 192, 1, 193, 1, 193, 1, 194, 1, 194, 3, 194, 2902, 8, 194, 1, 194, 1, 194, 3, 194, 2906, 8, 194, 1, 194, 1, 194, 3, 194, 2910, 8, 194, 1, 194, 1, 194, 3, 194, 2914, 8, 194, 1, 194, 1, 194, 3, 194, 2918, 8, 194, 1, 194, 1, 194, 3, 194, 2922, 8, 194, 1, 194, 1, 194, 3, 194, 2926, 8, 194, 1, 194, 1, 194, 3, 194, 2930, 8, 194, 1, 194, 1, 194, 3, 194, 2934, 8, 194, 1, 194, 1, 194, 1, 195, 1, 195, 1, 196, 1, 196, 3, 196, 2942, 8, 196, 1, 196, 1, 196, 3, 196, 2946, 8, 196, 1, 196, 1, 196, 3, 196, 2950, 8, 196, 1, 196, 1, 196, 1, 196, 1, 196, 3, 196, 2956, 8, 196, 1, 196, 1, 196, 3, 196, 2960, 8, 196, 1, 196, 1, 196, 3, 196, 2964, 8, 196, 1, 196, 1, 196, 3, 196, 2968, 8, 196, 1, 197, 1, 197, 1, 198, 1, 198, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 3, 199, 2979, 8, 199, 1, 199, 1, 199, 3, 199, 2983, 8, 199, 1, 199, 1, 199, 3, 199, 2987, 8, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 3, 199, 3005, 8, 199, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 3, 200, 3014, 8, 200, 1, 201, 1, 201, 1, 202, 1, 202, 1, 203, 1, 203, 3, 203, 3022, 8, 203, 1, 203, 1, 203, 3, 203, 3026, 8, 203, 1, 203, 1, 203, 3, 203, 3030, 8, 203, 1, 203, 1, 203, 3, 203, 3034, 8, 203, 5, 203, 3036, 8, 203, 10, 203, 12, 203, 3039, 9, 203, 3, 203, 3041, 8, 203, 1, 203, 1, 203, 1, 204, 1, 204, 3, 204, 3047, 8, 204, 1, 204, 1, 204, 1, 204, 3, 204, 3052, 8, 204, 1, 204, 1, 204, 1, 204, 3, 204, 3057, 8, 204, 1, 204, 1, 204, 1, 204, 3, 204, 3062, 8, 204, 1, 204, 1, 204, 1, 204, 3, 204, 3067, 8, 204, 1, 204, 1, 204, 1, 204, 3, 204, 3072, 8, 204, 1, 204, 1, 204, 1, 204, 3, 204, 3077, 8, 204, 1, 204, 3, 204, 3080, 8, 204, 1, 205, 1, 205, 3, 205, 3084, 8, 205, 1, 205, 1, 205, 3, 205, 3088, 8, 205, 1, 205, 1, 205, 1, 206, 1, 206, 3, 206, 3094, 8, 206, 1, 206, 4, 206, 3097, 8, 206, 11, 206, 12, 206, 3098, 1, 207, 1, 207, 3, 207, 3103, 8, 207, 1, 207, 3, 207, 3106, 8, 207, 1, 208, 1, 208, 1, 208, 1, 208, 1, 208, 1, 208, 1, 209, 1, 209, 3, 209, 3116, 8, 209, 1, 209, 1, 209, 3, 209, 3120, 8, 209, 1, 209, 1, 209, 3, 209, 3124, 8, 209, 3, 209, 3126, 8, 209, 1, 209, 1, 209, 3, 209, 3130, 8, 209, 1, 209, 1, 209, 3, 209, 3134, 8, 209, 1, 209, 1, 209, 3, 209, 3138, 8, 209, 5, 209, 3140, 8, 209, 10, 209, 12, 209, 3143, 9, 209, 3, 209, 3145, 8, 209, 1, 209, 1, 209, 1, 210, 1, 210, 1, 210, 1, 211, 1, 211, 1, 212, 1, 212, 1, 213, 1, 213, 3, 213, 3158, 8, 213, 1, 213, 1, 213, 3, 213, 3162, 8, 213, 1, 213, 1, 213, 3, 213, 3166, 8, 213, 1, 213, 3, 213, 3169, 8, 213, 1, 213, 3, 213, 3172, 8, 213, 1, 213, 1, 213, 1, 214, 1, 214, 3, 214, 3178, 8, 214, 1, 214, 1, 214, 3, 214, 3182, 8, 214, 1, 214, 1, 214, 3, 214, 3186, 8, 214, 3, 214, 3188, 8, 214, 1, 214, 1, 214, 3, 214, 3192, 8, 214, 1, 214, 1, 214, 3, 214, 3196, 8, 214, 1, 214, 1, 214, 3, 214, 3200, 8, 214, 3, 214, 3202, 8, 214, 1, 214, 1, 214, 3, 214, 3206, 8, 214, 1, 214, 1, 214, 3, 214, 3210, 8, 214, 1, 214, 1, 214, 1, 215, 1, 215, 3, 215, 3216, 8, 215, 1, 215, 1, 215, 1, 216, 1, 216, 3, 216, 3222, 8, 216, 1, 216, 4, 216, 3225, 8, 216, 11, 216, 12, 216, 3226, 1, 216, 1, 216, 3, 216, 3231, 8, 216, 1, 216, 1, 216, 3, 216, 3235, 8, 216, 1, 216, 4, 216, 3238, 8, 216, 11, 216, 12, 216, 3239, 3, 216, 3242, 8, 216, 1, 216, 3, 216, 3245, 8, 216, 1, 216, 1, 216, 3, 216, 3249, 8, 216, 1, 216, 3, 216, 3252, 8, 216, 1, 216, 3, 216, 3255, 8, 216, 1, 216, 1, 216, 1, 217, 1, 217, 3, 217, 3261, 8, 217, 1, 217, 1, 217, 3, 217, 3265, 8, 217, 1, 217, 1, 217, 3, 217, 3269, 8, 217, 1, 217, 1, 217, 1, 218, 1, 218, 1, 219, 1, 219, 3, 219, 3277, 8, 219, 1, 220, 1, 220, 3, 220, 3281, 8, 220, 1, 220, 1, 220, 3, 220, 3285, 8, 220, 1, 220, 1, 220, 3, 220, 3289, 8, 220, 1, 220, 1, 220, 3, 220, 3293, 8, 220, 5, 220, 3295, 8, 220, 10, 220, 12, 220, 3298, 9, 220, 3, 220, 3300, 8, 220, 1, 220, 1, 220, 1, 221, 1, 221, 3, 221, 3306, 8, 221, 1, 221, 1, 221, 3, 221, 3310, 8, 221, 1, 221, 3, 221, 3313, 8, 221, 1, 221, 3, 221, 3316, 8, 221, 1, 221, 1, 221, 3, 221, 3320, 8, 221, 1, 221, 5, 221, 3323, 8, 221, 10, 221, 12, 221, 3326, 9, 221, 1, 221, 3, 221, 3329, 8, 221, 1, 221, 1, 221, 1, 222, 1, 222, 1, 222, 1, 222, 3, 222, 3337, 8, 222, 1, 223, 1, 223, 3, 223, 3341, 8, 223, 1, 223, 1, 223, 3, 223, 3345, 8, 223, 1, 223, 1, 223, 1, 224, 1, 224, 1, 224, 1, 225, 1, 225, 1, 226, 1, 226, 1, 226, 1, 227, 1, 227, 3, 227, 3359, 8, 227, 1, 228, 1, 228, 3, 228, 3363, 8, 228, 1, 228, 1, 228, 3, 228, 3367, 8, 228, 1, 228, 1, 228, 1, 229, 1, 229, 1, 229, 1, 230, 1, 230, 3, 230, 3376, 8, 230, 1, 231, 1, 231, 3, 231, 3380, 8, 231, 1, 231, 1, 231, 3, 231, 3384, 8, 231, 1, 231, 5, 231, 3387, 8, 231, 10, 231, 12, 231, 3390, 9, 231, 1, 232, 1, 232, 3, 232, 3394, 8, 232, 1, 232, 4, 232, 3397, 8, 232, 11, 232, 12, 232, 3398, 1, 233, 1, 233, 3, 233, 3403, 8, 233, 1, 233, 1, 233, 3, 233, 3407, 8, 233, 1, 233, 5, 233, 3410, 8, 233, 10, 233, 12, 233, 3413, 9, 233, 1, 234, 1, 234, 1, 235, 1, 235, 1, 236, 1, 236, 1, 237, 1, 237, 1, 237, 5, 237, 3424, 8, 237, 10, 237, 12, 237, 3427, 9, 237, 1, 238, 1, 238, 1, 239, 1, 239, 1, 240, 1, 240, 1, 241, 1, 241, 1, 241, 1, 241, 3, 241, 3439, 8, 241, 1, 242, 1, 242, 1, 242, 1, 649, 0, 243, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408, 410, 412, 414, 416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442, 444, 446, 448, 450, 452, 454, 456, 458, 460, 462, 464, 466, 468, 470, 472, 474, 476, 478, 480, 482, 484, 0, 24, 2, 0, 7, 7, 13, 13, 1, 0, 158, 159, 1, 0, 136, 137, 1, 0, 138, 139, 2, 0, 64, 64, 171, 171, 2, 0, 66, 66, 181, 181, 1, 0, 174, 175, 1, 0, 178, 179, 1, 0, 176, 177, 2, 0, 102, 102, 161, 161, 2, 0, 101, 101, 162, 162, 1, 0, 163, 164, 1, 0, 152, 153, 1, 0, 94, 97, 1, 0, 102, 103, 2, 0, 3, 3, 13, 13, 1, 0, 121, 122, 3, 0, 115, 115, 214, 214, 217, 217, 1, 0, 202, 204, 1, 0, 212, 213, 2, 0, 30, 30, 35, 38, 2, 0, 31, 31, 39, 42, 2, 0, 3, 3, 43, 53, 1, 0, 54, 198, 3816, 0, 486, 1, 0, 0, 0, 2, 500, 1, 0, 0, 0, 4, 509, 1, 0, 0, 0, 6, 514, 1, 0, 0, 0, 8, 523, 1, 0, 0, 0, 10, 541, 1, 0, 0, 0, 12, 543, 1, 0, 0, 0, 14, 553, 1, 0, 0, 0, 16, 555, 1, 0, 0, 0, 18, 575, 1, 0, 0, 0, 20, 578, 1, 0, 0, 0, 22, 584, 1, 0, 0, 0, 24, 592, 1, 0, 0, 0, 26, 600, 1, 0, 0, 0, 28, 602, 1, 0, 0, 0, 30, 610, 1, 0, 0, 0, 32, 612, 1, 0, 0, 0, 34, 617, 1, 0, 0, 0, 36, 619, 1, 0, 0, 0, 38, 622, 1, 0, 0, 0, 40, 625, 1, 0, 0, 0, 42, 633, 1, 0, 0, 0, 44, 642, 1, 0, 0, 0, 46, 653, 1, 0, 0, 0, 48, 657, 1, 0, 0, 0, 50, 687, 1, 0, 0, 0, 52, 689, 1, 0, 0, 0, 54, 727, 1, 0, 0, 0, 56, 735, 1, 0, 0, 0, 58, 737, 1, 0, 0, 0, 60, 751, 1, 0, 0, 0, 62, 758, 1, 0, 0, 0, 64, 766, 1, 0, 0, 0, 66, 775, 1, 0, 0, 0, 68, 781, 1, 0, 0, 0, 70, 783, 1, 0, 0, 0, 72, 795, 1, 0, 0, 0, 74, 797, 1, 0, 0, 0, 76, 799, 1, 0, 0, 0, 78, 801, 1, 0, 0, 0, 80, 818, 1, 0, 0, 0, 82, 822, 1, 0, 0, 0, 84, 824, 1, 0, 0, 0, 86, 834, 1, 0, 0, 0, 88, 840, 1, 0, 0, 0, 90, 850, 1, 0, 0, 0, 92, 859, 1, 0, 0, 0, 94, 881, 1, 0, 0, 0, 96, 897, 1, 0, 0, 0, 98, 909, 1, 0, 0, 0, 100, 914, 1, 0, 0, 0, 102, 921, 1, 0, 0, 0, 104, 930, 1, 0, 0, 0, 106, 936, 1, 0, 0, 0, 108, 964, 1, 0, 0, 0, 110, 993, 1, 0, 0, 0, 112, 995, 1, 0, 0, 0, 114, 1003, 1, 0, 0, 0, 116, 1014, 1, 0, 0, 0, 118, 1049, 1, 0, 0, 0, 120, 1051, 1, 0, 0, 0, 122, 1101, 1, 0, 0, 0, 124, 1130, 1, 0, 0, 0, 126, 1177, 1, 0, 0, 0, 128, 1224, 1, 0, 0, 0, 130, 1247, 1, 0, 0, 0, 132, 1267, 1, 0, 0, 0, 134, 1288, 1, 0, 0, 0, 136, 1309, 1, 0, 0, 0, 138, 1311, 1, 0, 0, 0, 140, 1335, 1, 0, 0, 0, 142, 1348, 1, 0, 0, 0, 144, 1412, 1, 0, 0, 0, 146, 1432, 1, 0, 0, 0, 148, 1455, 1, 0, 0, 0, 150, 1472, 1, 0, 0, 0, 152, 1474, 1, 0, 0, 0, 154, 1494, 1, 0, 0, 0, 156, 1515, 1, 0, 0, 0, 158, 1517, 1, 0, 0, 0, 160, 1526, 1, 0, 0, 0, 162, 1532, 1, 0, 0, 0, 164, 1538, 1, 0, 0, 0, 166, 1544, 1, 0, 0, 0, 168, 1548, 1, 0, 0, 0, 170, 1569, 1, 0, 0, 0, 172, 1571, 1, 0, 0, 0, 174, 1579, 1, 0, 0, 0, 176, 1585, 1, 0, 0, 0, 178, 1587, 1, 0, 0, 0, 180, 1591, 1, 0, 0, 0, 182, 1595, 1, 0, 0, 0, 184, 1599, 1, 0, 0, 0, 186, 1603, 1, 0, 0, 0, 188, 1607, 1, 0, 0, 0, 190, 1611, 1, 0, 0, 0, 192, 1615, 1, 0, 0, 0, 194, 1619, 1, 0, 0, 0, 196, 1623, 1, 0, 0, 0, 198, 1627, 1, 0, 0, 0, 200, 1647, 1, 0, 0, 0, 202, 1674, 1, 0, 0, 0, 204, 1711, 1, 0, 0, 0, 206, 1734, 1, 0, 0, 0, 208, 1807, 1, 0, 0, 0, 210, 1809, 1, 0, 0, 0, 212, 1834, 1, 0, 0, 0, 214, 1853, 1, 0, 0, 0, 216, 1863, 1, 0, 0, 0, 218, 1885, 1, 0, 0, 0, 220, 1887, 1, 0, 0, 0, 222, 1893, 1, 0, 0, 0, 224, 1901, 1, 0, 0, 0, 226, 1955, 1, 0, 0, 0, 228, 1959, 1, 0, 0, 0, 230, 1979, 1, 0, 0, 0, 232, 1999, 1, 0, 0, 0, 234, 2001, 1, 0, 0, 0, 236, 2029, 1, 0, 0, 0, 238, 2044, 1, 0, 0, 0, 240, 2056, 1, 0, 0, 0, 242, 2069, 1, 0, 0, 0, 244, 2105, 1, 0, 0, 0, 246, 2114, 1, 0, 0, 0, 248, 2116, 1, 0, 0, 0, 250, 2125, 1, 0, 0, 0, 252, 2132, 1, 0, 0, 0, 254, 2135, 1, 0, 0, 0, 256, 2160, 1, 0, 0, 0, 258, 2182, 1, 0, 0, 0, 260, 2184, 1, 0, 0, 0, 262, 2190, 1, 0, 0, 0, 264, 2192, 1, 0, 0, 0, 266, 2194, 1, 0, 0, 0, 268, 2212, 1, 0, 0, 0, 270, 2216, 1, 0, 0, 0, 272, 2220, 1, 0, 0, 0, 274, 2231, 1, 0, 0, 0, 276, 2281, 1, 0, 0, 0, 278, 2300, 1, 0, 0, 0, 280, 2312, 1, 0, 0, 0, 282, 2314, 1, 0, 0, 0, 284, 2323, 1, 0, 0, 0, 286, 2329, 1, 0, 0, 0, 288, 2340, 1, 0, 0, 0, 290, 2349, 1, 0, 0, 0, 292, 2357, 1, 0, 0, 0, 294, 2371, 1, 0, 0, 0, 296, 2375, 1, 0, 0, 0, 298, 2400, 1, 0, 0, 0, 300, 2404, 1, 0, 0, 0, 302, 2420, 1, 0, 0, 0, 304, 2422, 1, 0, 0, 0, 306, 2446, 1, 0, 0, 0, 308, 2452, 1, 0, 0, 0, 310, 2471, 1, 0, 0, 0, 312, 2480, 1, 0, 0, 0, 314, 2482, 1, 0, 0, 0, 316, 2511, 1, 0, 0, 0, 318, 2513, 1, 0, 0, 0, 320, 2519, 1, 0, 0, 0, 322, 2530, 1, 0, 0, 0, 324, 2534, 1, 0, 0, 0, 326, 2538, 1, 0, 0, 0, 328, 2548, 1, 0, 0, 0, 330, 2551, 1, 0, 0, 0, 332, 2573, 1, 0, 0, 0, 334, 2575, 1, 0, 0, 0, 336, 2577, 1, 0, 0, 0, 338, 2579, 1, 0, 0, 0, 340, 2589, 1, 0, 0, 0, 342, 2599, 1, 0, 0, 0, 344, 2615, 1, 0, 0, 0, 346, 2620, 1, 0, 0, 0, 348, 2630, 1, 0, 0, 0, 350, 2652, 1, 0, 0, 0, 352, 2682, 1, 0, 0, 0, 354, 2702, 1, 0, 0, 0, 356, 2707, 1, 0, 0, 0, 358, 2764, 1, 0, 0, 0, 360, 2777, 1, 0, 0, 0, 362, 2791, 1, 0, 0, 0, 364, 2793, 1, 0, 0, 0, 366, 2807, 1, 0, 0, 0, 368, 2809, 1, 0, 0, 0, 370, 2823, 1, 0, 0, 0, 372, 2825, 1, 0, 0, 0, 374, 2839, 1, 0, 0, 0, 376, 2841, 1, 0, 0, 0, 378, 2855, 1, 0, 0, 0, 380, 2857, 1, 0, 0, 0, 382, 2871, 1, 0, 0, 0, 384, 2873, 1, 0, 0, 0, 386, 2897, 1, 0, 0, 0, 388, 2899, 1, 0, 0, 0, 390, 2937, 1, 0, 0, 0, 392, 2967, 1, 0, 0, 0, 394, 2969, 1, 0, 0, 0, 396, 2971, 1, 0, 0, 0, 398, 3004, 1, 0, 0, 0, 400, 3013, 1, 0, 0, 0, 402, 3015, 1, 0, 0, 0, 404, 3017, 1, 0, 0, 0, 406, 3019, 1, 0, 0, 0, 408, 3079, 1, 0, 0, 0, 410, 3081, 1, 0, 0, 0, 412, 3091, 1, 0, 0, 0, 414, 3100, 1, 0, 0, 0, 416, 3107, 1, 0, 0, 0, 418, 3113, 1, 0, 0, 0, 420, 3148, 1, 0, 0, 0, 422, 3151, 1, 0, 0, 0, 424, 3153, 1, 0, 0, 0, 426, 3155, 1, 0, 0, 0, 428, 3175, 1, 0, 0, 0, 430, 3213, 1, 0, 0, 0, 432, 3241, 1, 0, 0, 0, 434, 3258, 1, 0, 0, 0, 436, 3272, 1, 0, 0, 0, 438, 3276, 1, 0, 0, 0, 440, 3278, 1, 0, 0, 0, 442, 3303, 1, 0, 0, 0, 444, 3336, 1, 0, 0, 0, 446, 3338, 1, 0, 0, 0, 448, 3348, 1, 0, 0, 0, 450, 3351, 1, 0, 0, 0, 452, 3353, 1, 0, 0, 0, 454, 3358, 1, 0, 0, 0, 456, 3360, 1, 0, 0, 0, 458, 3370, 1, 0, 0, 0, 460, 3375, 1, 0, 0, 0, 462, 3377, 1, 0, 0, 0, 464, 3391, 1, 0, 0, 0, 466, 3400, 1, 0, 0, 0, 468, 3414, 1, 0, 0, 0, 470, 3416, 1, 0, 0, 0, 472, 3418, 1, 0, 0, 0, 474, 3425, 1, 0, 0, 0, 476, 3428, 1, 0, 0, 0, 478, 3430, 1, 0, 0, 0, 480, 3432, 1, 0, 0, 0, 482, 3438, 1, 0, 0, 0, 484, 3440, 1, 0, 0, 0, 486, 491, 3, 2, 1, 0, 487, 488, 5, 1, 0, 0, 488, 490, 3, 2, 1, 0, 489, 487, 1, 0, 0, 0, 490, 493, 1, 0, 0, 0, 491, 489, 1, 0, 0, 0, 491, 492, 1, 0, 0, 0, 492, 495, 1, 0, 0, 0, 493, 491, 1, 0, 0, 0, 494, 496, 5, 1, 0, 0, 495, 494, 1, 0, 0, 0, 495, 496, 1, 0, 0, 0, 496, 497, 1, 0, 0, 0, 497, 498, 5, 0, 0, 1, 498, 1, 1, 0, 0, 0, 499, 501, 5, 218, 0, 0, 500, 499, 1, 0, 0, 0, 500, 501, 1, 0, 0, 0, 501, 504, 1, 0, 0, 0, 502, 505, 3, 64, 32, 0, 503, 505, 3, 4, 2, 0, 504, 502, 1, 0, 0, 0, 504, 503, 1, 0, 0, 0, 505, 507, 1, 0, 0, 0, 506, 508, 5, 218, 0, 0, 507, 506, 1, 0, 0, 0, 507, 508, 1, 0, 0, 0, 508, 3, 1, 0, 0, 0, 509, 512, 3, 6, 3, 0, 510, 511, 5, 218, 0, 0, 511, 513, 3, 8, 4, 0, 512, 510, 1, 0, 0, 0, 512, 513, 1, 0, 0, 0, 513, 5, 1, 0, 0, 0, 514, 515, 5, 2, 0, 0, 515, 520, 3, 482, 241, 0, 516, 517, 5, 3, 0, 0, 517, 519, 3, 482, 241, 0, 518, 516, 1, 0, 0, 0, 519, 522, 1, 0, 0, 0, 520, 518, 1, 0, 0, 0, 520, 521, 1, 0, 0, 0, 521, 7, 1, 0, 0, 0, 522, 520, 1, 0, 0, 0, 523, 528, 3, 10, 5, 0, 524, 525, 5, 218, 0, 0, 525, 527, 3, 10, 5, 0, 526, 524, 1, 0, 0, 0, 527, 530, 1, 0, 0, 0, 528, 526, 1, 0, 0, 0, 528, 529, 1, 0, 0, 0, 529, 9, 1, 0, 0, 0, 530, 528, 1, 0, 0, 0, 531, 542, 3, 14, 7, 0, 532, 542, 3, 48, 24, 0, 533, 542, 3, 12, 6, 0, 534, 542, 3, 440, 220, 0, 535, 542, 3, 58, 29, 0, 536, 542, 3, 402, 201, 0, 537, 542, 3, 438, 219, 0, 538, 542, 3, 404, 202, 0, 539, 542, 3, 62, 31, 0, 540, 542, 3, 60, 30, 0, 541, 531, 1, 0, 0, 0, 541, 532, 1, 0, 0, 0, 541, 533, 1, 0, 0, 0, 541, 534, 1, 0, 0, 0, 541, 535, 1, 0, 0, 0, 541, 536, 1, 0, 0, 0, 541, 537, 1, 0, 0, 0, 541, 538, 1, 0, 0, 0, 541, 539, 1, 0, 0, 0, 541, 540, 1, 0, 0, 0, 542, 11, 1, 0, 0, 0, 543, 545, 3, 482, 241, 0, 544, 546, 5, 218, 0, 0, 545, 544, 1, 0, 0, 0, 545, 546, 1, 0, 0, 0, 546, 547, 1, 0, 0, 0, 547, 549, 5, 4, 0, 0, 548, 550, 5, 218, 0, 0, 549, 548, 1, 0, 0, 0, 549, 550, 1, 0, 0, 0, 550, 551, 1, 0, 0, 0, 551, 552, 3, 336, 168, 0, 552, 13, 1, 0, 0, 0, 553, 554, 3, 16, 8, 0, 554, 15, 1, 0, 0, 0, 555, 556, 3, 18, 9, 0, 556, 558, 5, 5, 0, 0, 557, 559, 3, 32, 16, 0, 558, 557, 1, 0, 0, 0, 558, 559, 1, 0, 0, 0, 559, 560, 1, 0, 0, 0, 560, 563, 3, 20, 10, 0, 561, 562, 5, 2, 0, 0, 562, 564, 3, 26, 13, 0, 563, 561, 1, 0, 0, 0, 563, 564, 1, 0, 0, 0, 564, 567, 1, 0, 0, 0, 565, 566, 5, 6, 0, 0, 566, 568, 3, 28, 14, 0, 567, 565, 1, 0, 0, 0, 567, 568, 1, 0, 0, 0, 568, 570, 1, 0, 0, 0, 569, 571, 3, 38, 19, 0, 570, 569, 1, 0, 0, 0, 570, 571, 1, 0, 0, 0, 571, 573, 1, 0, 0, 0, 572, 574, 3, 36, 18, 0, 573, 572, 1, 0, 0, 0, 573, 574, 1, 0, 0, 0, 574, 17, 1, 0, 0, 0, 575, 576, 3, 44, 22, 0, 576, 19, 1, 0, 0, 0, 577, 579, 5, 6, 0, 0, 578, 577, 1, 0, 0, 0, 578, 579, 1, 0, 0, 0, 579, 582, 1, 0, 0, 0, 580, 583, 3, 22, 11, 0, 581, 583, 3, 24, 12, 0, 582, 580, 1, 0, 0, 0, 582, 581, 1, 0, 0, 0, 583, 21, 1, 0, 0, 0, 584, 589, 3, 44, 22, 0, 585, 586, 5, 7, 0, 0, 586, 588, 3, 44, 22, 0, 587, 585, 1, 0, 0, 0, 588, 591, 1, 0, 0, 0, 589, 587, 1, 0, 0, 0, 589, 590, 1, 0, 0, 0, 590, 23, 1, 0, 0, 0, 591, 589, 1, 0, 0, 0, 592, 593, 3, 46, 23, 0, 593, 594, 5, 7, 0, 0, 594, 595, 3, 46, 23, 0, 595, 596, 5, 7, 0, 0, 596, 597, 3, 46, 23, 0, 597, 598, 5, 7, 0, 0, 598, 599, 3, 46, 23, 0, 599, 25, 1, 0, 0, 0, 600, 601, 3, 46, 23, 0, 601, 27, 1, 0, 0, 0, 602, 607, 3, 44, 22, 0, 603, 604, 5, 6, 0, 0, 604, 606, 3, 44, 22, 0, 605, 603, 1, 0, 0, 0, 606, 609, 1, 0, 0, 0, 607, 605, 1, 0, 0, 0, 607, 608, 1, 0, 0, 0, 608, 29, 1, 0, 0, 0, 609, 607, 1, 0, 0, 0, 610, 611, 3, 44, 22, 0, 611, 31, 1, 0, 0, 0, 612, 613, 3, 30, 15, 0, 613, 614, 5, 2, 0, 0, 614, 615, 3, 34, 17, 0, 615, 616, 5, 8, 0, 0, 616, 33, 1, 0, 0, 0, 617, 618, 3, 44, 22, 0, 618, 35, 1, 0, 0, 0, 619, 620, 5, 9, 0, 0, 620, 621, 3, 44, 22, 0, 621, 37, 1, 0, 0, 0, 622, 623, 5, 10, 0, 0, 623, 624, 3, 40, 20, 0, 624, 39, 1, 0, 0, 0, 625, 630, 3, 42, 21, 0, 626, 627, 5, 11, 0, 0, 627, 629, 3, 42, 21, 0, 628, 626, 1, 0, 0, 0, 629, 632, 1, 0, 0, 0, 630, 628, 1, 0, 0, 0, 630, 631, 1, 0, 0, 0, 631, 41, 1, 0, 0, 0, 632, 630, 1, 0, 0, 0, 633, 640, 3, 44, 22, 0, 634, 638, 5, 12, 0, 0, 635, 639, 3, 44, 22, 0, 636, 639, 3, 46, 23, 0, 637, 639, 5, 200, 0, 0, 638, 635, 1, 0, 0, 0, 638, 636, 1, 0, 0, 0, 638, 637, 1, 0, 0, 0, 639, 641, 1, 0, 0, 0, 640, 634, 1, 0, 0, 0, 640, 641, 1, 0, 0, 0, 641, 43, 1, 0, 0, 0, 642, 649, 3, 482, 241, 0, 643, 645, 7, 0, 0, 0, 644, 643, 1, 0, 0, 0, 644, 645, 1, 0, 0, 0, 645, 646, 1, 0, 0, 0, 646, 648, 3, 482, 241, 0, 647, 644, 1, 0, 0, 0, 648, 651, 1, 0, 0, 0, 649, 650, 1, 0, 0, 0, 649, 647, 1, 0, 0, 0, 650, 45, 1, 0, 0, 0, 651, 649, 1, 0, 0, 0, 652, 654, 3, 470, 235, 0, 653, 652, 1, 0, 0, 0, 654, 655, 1, 0, 0, 0, 655, 653, 1, 0, 0, 0, 655, 656, 1, 0, 0, 0, 656, 47, 1, 0, 0, 0, 657, 658, 3, 56, 28, 0, 658, 49, 1, 0, 0, 0, 659, 661, 5, 14, 0, 0, 660, 662, 5, 218, 0, 0, 661, 660, 1, 0, 0, 0, 661, 662, 1, 0, 0, 0, 662, 663, 1, 0, 0, 0, 663, 665, 3, 52, 26, 0, 664, 666, 5, 218, 0, 0, 665, 664, 1, 0, 0, 0, 665, 666, 1, 0, 0, 0, 666, 677, 1, 0, 0, 0, 667, 669, 5, 15, 0, 0, 668, 670, 5, 218, 0, 0, 669, 668, 1, 0, 0, 0, 669, 670, 1, 0, 0, 0, 670, 671, 1, 0, 0, 0, 671, 673, 3, 52, 26, 0, 672, 674, 5, 218, 0, 0, 673, 672, 1, 0, 0, 0, 673, 674, 1, 0, 0, 0, 674, 676, 1, 0, 0, 0, 675, 667, 1, 0, 0, 0, 676, 679, 1, 0, 0, 0, 677, 675, 1, 0, 0, 0, 677, 678, 1, 0, 0, 0, 678, 680, 1, 0, 0, 0, 679, 677, 1, 0, 0, 0, 680, 681, 5, 16, 0, 0, 681, 688, 1, 0, 0, 0, 682, 684, 5, 14, 0, 0, 683, 685, 5, 218, 0, 0, 684, 683, 1, 0, 0, 0, 684, 685, 1, 0, 0, 0, 685, 686, 1, 0, 0, 0, 686, 688, 5, 16, 0, 0, 687, 659, 1, 0, 0, 0, 687, 682, 1, 0, 0, 0, 688, 51, 1, 0, 0, 0, 689, 691, 3, 402, 201, 0, 690, 692, 5, 218, 0, 0, 691, 690, 1, 0, 0, 0, 691, 692, 1, 0, 0, 0, 692, 693, 1, 0, 0, 0, 693, 695, 5, 2, 0, 0, 694, 696, 5, 218, 0, 0, 695, 694, 1, 0, 0, 0, 695, 696, 1, 0, 0, 0, 696, 697, 1, 0, 0, 0, 697, 698, 3, 56, 28, 0, 698, 53, 1, 0, 0, 0, 699, 701, 5, 17, 0, 0, 700, 702, 5, 218, 0, 0, 701, 700, 1, 0, 0, 0, 701, 702, 1, 0, 0, 0, 702, 703, 1, 0, 0, 0, 703, 705, 3, 56, 28, 0, 704, 706, 5, 218, 0, 0, 705, 704, 1, 0, 0, 0, 705, 706, 1, 0, 0, 0, 706, 717, 1, 0, 0, 0, 707, 709, 5, 15, 0, 0, 708, 710, 5, 218, 0, 0, 709, 708, 1, 0, 0, 0, 709, 710, 1, 0, 0, 0, 710, 711, 1, 0, 0, 0, 711, 713, 3, 56, 28, 0, 712, 714, 5, 218, 0, 0, 713, 712, 1, 0, 0, 0, 713, 714, 1, 0, 0, 0, 714, 716, 1, 0, 0, 0, 715, 707, 1, 0, 0, 0, 716, 719, 1, 0, 0, 0, 717, 715, 1, 0, 0, 0, 717, 718, 1, 0, 0, 0, 718, 720, 1, 0, 0, 0, 719, 717, 1, 0, 0, 0, 720, 721, 5, 18, 0, 0, 721, 728, 1, 0, 0, 0, 722, 724, 5, 17, 0, 0, 723, 725, 5, 218, 0, 0, 724, 723, 1, 0, 0, 0, 724, 725, 1, 0, 0, 0, 725, 726, 1, 0, 0, 0, 726, 728, 5, 18, 0, 0, 727, 699, 1, 0, 0, 0, 727, 722, 1, 0, 0, 0, 728, 55, 1, 0, 0, 0, 729, 736, 3, 402, 201, 0, 730, 736, 3, 438, 219, 0, 731, 736, 3, 50, 25, 0, 732, 736, 3, 54, 27, 0, 733, 736, 3, 404, 202, 0, 734, 736, 5, 114, 0, 0, 735, 729, 1, 0, 0, 0, 735, 730, 1, 0, 0, 0, 735, 731, 1, 0, 0, 0, 735, 732, 1, 0, 0, 0, 735, 733, 1, 0, 0, 0, 735, 734, 1, 0, 0, 0, 736, 57, 1, 0, 0, 0, 737, 738, 3, 436, 218, 0, 738, 739, 5, 2, 0, 0, 739, 744, 5, 218, 0, 0, 740, 745, 5, 199, 0, 0, 741, 745, 3, 438, 219, 0, 742, 745, 3, 404, 202, 0, 743, 745, 3, 482, 241, 0, 744, 740, 1, 0, 0, 0, 744, 741, 1, 0, 0, 0, 744, 742, 1, 0, 0, 0, 744, 743, 1, 0, 0, 0, 745, 59, 1, 0, 0, 0, 746, 749, 5, 6, 0, 0, 747, 750, 3, 482, 241, 0, 748, 750, 3, 438, 219, 0, 749, 747, 1, 0, 0, 0, 749, 748, 1, 0, 0, 0, 750, 752, 1, 0, 0, 0, 751, 746, 1, 0, 0, 0, 752, 753, 1, 0, 0, 0, 753, 751, 1, 0, 0, 0, 753, 754, 1, 0, 0, 0, 754, 756, 1, 0, 0, 0, 755, 757, 5, 6, 0, 0, 756, 755, 1, 0, 0, 0, 756, 757, 1, 0, 0, 0, 757, 61, 1, 0, 0, 0, 758, 763, 3, 482, 241, 0, 759, 760, 5, 3, 0, 0, 760, 762, 3, 482, 241, 0, 761, 759, 1, 0, 0, 0, 762, 765, 1, 0, 0, 0, 763, 761, 1, 0, 0, 0, 763, 764, 1, 0, 0, 0, 764, 63, 1, 0, 0, 0, 765, 763, 1, 0, 0, 0, 766, 767, 3, 66, 33, 0, 767, 768, 3, 80, 40, 0, 768, 65, 1, 0, 0, 0, 769, 771, 3, 68, 34, 0, 770, 772, 5, 218, 0, 0, 771, 770, 1, 0, 0, 0, 771, 772, 1, 0, 0, 0, 772, 774, 1, 0, 0, 0, 773, 769, 1, 0, 0, 0, 774, 777, 1, 0, 0, 0, 775, 773, 1, 0, 0, 0, 775, 776, 1, 0, 0, 0, 776, 67, 1, 0, 0, 0, 777, 775, 1, 0, 0, 0, 778, 782, 3, 70, 35, 0, 779, 782, 3, 74, 37, 0, 780, 782, 3, 76, 38, 0, 781, 778, 1, 0, 0, 0, 781, 779, 1, 0, 0, 0, 781, 780, 1, 0, 0, 0, 782, 69, 1, 0, 0, 0, 783, 786, 5, 54, 0, 0, 784, 785, 5, 218, 0, 0, 785, 787, 3, 72, 36, 0, 786, 784, 1, 0, 0, 0, 786, 787, 1, 0, 0, 0, 787, 792, 1, 0, 0, 0, 788, 789, 5, 218, 0, 0, 789, 791, 3, 78, 39, 0, 790, 788, 1, 0, 0, 0, 791, 794, 1, 0, 0, 0, 792, 790, 1, 0, 0, 0, 792, 793, 1, 0, 0, 0, 793, 71, 1, 0, 0, 0, 794, 792, 1, 0, 0, 0, 795, 796, 5, 213, 0, 0, 796, 73, 1, 0, 0, 0, 797, 798, 5, 55, 0, 0, 798, 75, 1, 0, 0, 0, 799, 800, 5, 56, 0, 0, 800, 77, 1, 0, 0, 0, 801, 803, 3, 482, 241, 0, 802, 804, 5, 218, 0, 0, 803, 802, 1, 0, 0, 0, 803, 804, 1, 0, 0, 0, 804, 805, 1, 0, 0, 0, 805, 807, 5, 12, 0, 0, 806, 808, 5, 218, 0, 0, 807, 806, 1, 0, 0, 0, 807, 808, 1, 0, 0, 0, 808, 809, 1, 0, 0, 0, 809, 810, 3, 482, 241, 0, 810, 79, 1, 0, 0, 0, 811, 819, 3, 98, 49, 0, 812, 819, 3, 82, 41, 0, 813, 814, 5, 132, 0, 0, 814, 816, 5, 218, 0, 0, 815, 813, 1, 0, 0, 0, 815, 816, 1, 0, 0, 0, 816, 817, 1, 0, 0, 0, 817, 819, 3, 100, 50, 0, 818, 811, 1, 0, 0, 0, 818, 812, 1, 0, 0, 0, 818, 815, 1, 0, 0, 0, 819, 81, 1, 0, 0, 0, 820, 823, 3, 84, 42, 0, 821, 823, 3, 86, 43, 0, 822, 820, 1, 0, 0, 0, 822, 821, 1, 0, 0, 0, 823, 83, 1, 0, 0, 0, 824, 831, 3, 88, 44, 0, 825, 827, 5, 218, 0, 0, 826, 825, 1, 0, 0, 0, 826, 827, 1, 0, 0, 0, 827, 828, 1, 0, 0, 0, 828, 830, 3, 94, 47, 0, 829, 826, 1, 0, 0, 0, 830, 833, 1, 0, 0, 0, 831, 829, 1, 0, 0, 0, 831, 832, 1, 0, 0, 0, 832, 85, 1, 0, 0, 0, 833, 831, 1, 0, 0, 0, 834, 836, 3, 90, 45, 0, 835, 837, 5, 218, 0, 0, 836, 835, 1, 0, 0, 0, 836, 837, 1, 0, 0, 0, 837, 838, 1, 0, 0, 0, 838, 839, 3, 92, 46, 0, 839, 87, 1, 0, 0, 0, 840, 847, 3, 96, 48, 0, 841, 843, 5, 218, 0, 0, 842, 841, 1, 0, 0, 0, 842, 843, 1, 0, 0, 0, 843, 844, 1, 0, 0, 0, 844, 846, 3, 96, 48, 0, 845, 842, 1, 0, 0, 0, 846, 849, 1, 0, 0, 0, 847, 845, 1, 0, 0, 0, 847, 848, 1, 0, 0, 0, 848, 89, 1, 0, 0, 0, 849, 847, 1, 0, 0, 0, 850, 851, 5, 57, 0, 0, 851, 852, 5, 218, 0, 0, 852, 853, 5, 58, 0, 0, 853, 854, 5, 218, 0, 0, 854, 857, 5, 59, 0, 0, 855, 856, 5, 218, 0, 0, 856, 858, 3, 470, 235, 0, 857, 855, 1, 0, 0, 0, 857, 858, 1, 0, 0, 0, 858, 91, 1, 0, 0, 0, 859, 866, 3, 210, 105, 0, 860, 862, 5, 218, 0, 0, 861, 860, 1, 0, 0, 0, 861, 862, 1, 0, 0, 0, 862, 863, 1, 0, 0, 0, 863, 865, 3, 96, 48, 0, 864, 861, 1, 0, 0, 0, 865, 868, 1, 0, 0, 0, 866, 864, 1, 0, 0, 0, 866, 867, 1, 0, 0, 0, 867, 93, 1, 0, 0, 0, 868, 866, 1, 0, 0, 0, 869, 870, 5, 60, 0, 0, 870, 871, 5, 218, 0, 0, 871, 873, 5, 61, 0, 0, 872, 874, 5, 218, 0, 0, 873, 872, 1, 0, 0, 0, 873, 874, 1, 0, 0, 0, 874, 875, 1, 0, 0, 0, 875, 882, 3, 88, 44, 0, 876, 878, 5, 60, 0, 0, 877, 879, 5, 218, 0, 0, 878, 877, 1, 0, 0, 0, 878, 879, 1, 0, 0, 0, 879, 880, 1, 0, 0, 0, 880, 882, 3, 88, 44, 0, 881, 869, 1, 0, 0, 0, 881, 876, 1, 0, 0, 0, 882, 95, 1, 0, 0, 0, 883, 898, 3, 210, 105, 0, 884, 898, 3, 276, 138, 0, 885, 898, 3, 212, 106, 0, 886, 898, 3, 214, 107, 0, 887, 898, 3, 216, 108, 0, 888, 898, 3, 220, 110, 0, 889, 898, 3, 222, 111, 0, 890, 898, 3, 224, 112, 0, 891, 898, 3, 228, 114, 0, 892, 898, 3, 230, 115, 0, 893, 898, 3, 234, 117, 0, 894, 898, 3, 236, 118, 0, 895, 898, 3, 238, 119, 0, 896, 898, 3, 248, 124, 0, 897, 883, 1, 0, 0, 0, 897, 884, 1, 0, 0, 0, 897, 885, 1, 0, 0, 0, 897, 886, 1, 0, 0, 0, 897, 887, 1, 0, 0, 0, 897, 888, 1, 0, 0, 0, 897, 889, 1, 0, 0, 0, 897, 890, 1, 0, 0, 0, 897, 891, 1, 0, 0, 0, 897, 892, 1, 0, 0, 0, 897, 893, 1, 0, 0, 0, 897, 894, 1, 0, 0, 0, 897, 895, 1, 0, 0, 0, 897, 896, 1, 0, 0, 0, 898, 97, 1, 0, 0, 0, 899, 910, 3, 186, 93, 0, 900, 910, 3, 196, 98, 0, 901, 910, 3, 178, 89, 0, 902, 910, 3, 188, 94, 0, 903, 910, 3, 180, 90, 0, 904, 910, 3, 190, 95, 0, 905, 910, 3, 182, 91, 0, 906, 910, 3, 192, 96, 0, 907, 910, 3, 184, 92, 0, 908, 910, 3, 194, 97, 0, 909, 899, 1, 0, 0, 0, 909, 900, 1, 0, 0, 0, 909, 901, 1, 0, 0, 0, 909, 902, 1, 0, 0, 0, 909, 903, 1, 0, 0, 0, 909, 904, 1, 0, 0, 0, 909, 905, 1, 0, 0, 0, 909, 906, 1, 0, 0, 0, 909, 907, 1, 0, 0, 0, 909, 908, 1, 0, 0, 0, 910, 99, 1, 0, 0, 0, 911, 915, 3, 102, 51, 0, 912, 915, 3, 104, 52, 0, 913, 915, 3, 106, 53, 0, 914, 911, 1, 0, 0, 0, 914, 912, 1, 0, 0, 0, 914, 913, 1, 0, 0, 0, 915, 101, 1, 0, 0, 0, 916, 922, 3, 154, 77, 0, 917, 922, 3, 156, 78, 0, 918, 922, 3, 158, 79, 0, 919, 922, 3, 160, 80, 0, 920, 922, 3, 162, 81, 0, 921, 916, 1, 0, 0, 0, 921, 917, 1, 0, 0, 0, 921, 918, 1, 0, 0, 0, 921, 919, 1, 0, 0, 0, 921, 920, 1, 0, 0, 0, 922, 103, 1, 0, 0, 0, 923, 931, 3, 108, 54, 0, 924, 931, 3, 110, 55, 0, 925, 931, 3, 114, 57, 0, 926, 931, 3, 116, 58, 0, 927, 931, 3, 118, 59, 0, 928, 931, 3, 120, 60, 0, 929, 931, 3, 122, 61, 0, 930, 923, 1, 0, 0, 0, 930, 924, 1, 0, 0, 0, 930, 925, 1, 0, 0, 0, 930, 926, 1, 0, 0, 0, 930, 927, 1, 0, 0, 0, 930, 928, 1, 0, 0, 0, 930, 929, 1, 0, 0, 0, 931, 105, 1, 0, 0, 0, 932, 937, 3, 124, 62, 0, 933, 937, 3, 126, 63, 0, 934, 937, 3, 128, 64, 0, 935, 937, 3, 130, 65, 0, 936, 932, 1, 0, 0, 0, 936, 933, 1, 0, 0, 0, 936, 934, 1, 0, 0, 0, 936, 935, 1, 0, 0, 0, 937, 107, 1, 0, 0, 0, 938, 939, 5, 133, 0, 0, 939, 942, 5, 218, 0, 0, 940, 941, 5, 61, 0, 0, 941, 943, 5, 218, 0, 0, 942, 940, 1, 0, 0, 0, 942, 943, 1, 0, 0, 0, 943, 944, 1, 0, 0, 0, 944, 949, 5, 144, 0, 0, 945, 946, 5, 218, 0, 0, 946, 947, 5, 73, 0, 0, 947, 948, 5, 218, 0, 0, 948, 950, 5, 146, 0, 0, 949, 945, 1, 0, 0, 0, 949, 950, 1, 0, 0, 0, 950, 965, 1, 0, 0, 0, 951, 952, 5, 133, 0, 0, 952, 955, 5, 218, 0, 0, 953, 954, 5, 147, 0, 0, 954, 956, 5, 218, 0, 0, 955, 953, 1, 0, 0, 0, 955, 956, 1, 0, 0, 0, 956, 957, 1, 0, 0, 0, 957, 962, 5, 144, 0, 0, 958, 959, 5, 218, 0, 0, 959, 960, 5, 73, 0, 0, 960, 961, 5, 218, 0, 0, 961, 963, 5, 146, 0, 0, 962, 958, 1, 0, 0, 0, 962, 963, 1, 0, 0, 0, 963, 965, 1, 0, 0, 0, 964, 938, 1, 0, 0, 0, 964, 951, 1, 0, 0, 0, 965, 109, 1, 0, 0, 0, 966, 967, 5, 62, 0, 0, 967, 968, 5, 218, 0, 0, 968, 969, 5, 143, 0, 0, 969, 970, 5, 218, 0, 0, 970, 973, 3, 482, 241, 0, 971, 972, 5, 218, 0, 0, 972, 974, 3, 164, 82, 0, 973, 971, 1, 0, 0, 0, 973, 974, 1, 0, 0, 0, 974, 977, 1, 0, 0, 0, 975, 976, 5, 218, 0, 0, 976, 978, 3, 112, 56, 0, 977, 975, 1, 0, 0, 0, 977, 978, 1, 0, 0, 0, 978, 994, 1, 0, 0, 0, 979, 980, 5, 62, 0, 0, 980, 984, 5, 218, 0, 0, 981, 982, 3, 168, 84, 0, 982, 983, 5, 218, 0, 0, 983, 985, 1, 0, 0, 0, 984, 981, 1, 0, 0, 0, 984, 985, 1, 0, 0, 0, 985, 986, 1, 0, 0, 0, 986, 987, 5, 143, 0, 0, 987, 988, 5, 218, 0, 0, 988, 991, 3, 482, 241, 0, 989, 990, 5, 218, 0, 0, 990, 992, 3, 112, 56, 0, 991, 989, 1, 0, 0, 0, 991, 992, 1, 0, 0, 0, 992, 994, 1, 0, 0, 0, 993, 966, 1, 0, 0, 0, 993, 979, 1, 0, 0, 0, 994, 111, 1, 0, 0, 0, 995, 996, 5, 76, 0, 0, 996, 997, 5, 218, 0, 0, 997, 998, 5, 165, 0, 0, 998, 999, 5, 218, 0, 0, 999, 1e3, 5, 166, 0, 0, 1e3, 1001, 5, 218, 0, 0, 1001, 1002, 3, 482, 241, 0, 1002, 113, 1, 0, 0, 0, 1003, 1004, 5, 63, 0, 0, 1004, 1005, 5, 218, 0, 0, 1005, 1006, 5, 143, 0, 0, 1006, 1007, 5, 218, 0, 0, 1007, 1012, 3, 482, 241, 0, 1008, 1009, 5, 218, 0, 0, 1009, 1010, 5, 141, 0, 0, 1010, 1011, 5, 218, 0, 0, 1011, 1013, 5, 70, 0, 0, 1012, 1008, 1, 0, 0, 0, 1012, 1013, 1, 0, 0, 0, 1013, 115, 1, 0, 0, 0, 1014, 1015, 5, 133, 0, 0, 1015, 1016, 5, 218, 0, 0, 1016, 1017, 5, 146, 0, 0, 1017, 117, 1, 0, 0, 0, 1018, 1019, 5, 62, 0, 0, 1019, 1020, 5, 218, 0, 0, 1020, 1021, 5, 145, 0, 0, 1021, 1022, 5, 218, 0, 0, 1022, 1023, 3, 30, 15, 0, 1023, 1026, 5, 218, 0, 0, 1024, 1025, 5, 218, 0, 0, 1025, 1027, 3, 164, 82, 0, 1026, 1024, 1, 0, 0, 0, 1026, 1027, 1, 0, 0, 0, 1027, 1028, 1, 0, 0, 0, 1028, 1031, 3, 170, 85, 0, 1029, 1030, 5, 218, 0, 0, 1030, 1032, 3, 174, 87, 0, 1031, 1029, 1, 0, 0, 0, 1031, 1032, 1, 0, 0, 0, 1032, 1050, 1, 0, 0, 0, 1033, 1034, 5, 62, 0, 0, 1034, 1038, 5, 218, 0, 0, 1035, 1036, 3, 168, 84, 0, 1036, 1037, 5, 218, 0, 0, 1037, 1039, 1, 0, 0, 0, 1038, 1035, 1, 0, 0, 0, 1038, 1039, 1, 0, 0, 0, 1039, 1040, 1, 0, 0, 0, 1040, 1041, 5, 145, 0, 0, 1041, 1042, 5, 218, 0, 0, 1042, 1043, 3, 30, 15, 0, 1043, 1044, 5, 218, 0, 0, 1044, 1047, 3, 170, 85, 0, 1045, 1046, 5, 218, 0, 0, 1046, 1048, 3, 174, 87, 0, 1047, 1045, 1, 0, 0, 0, 1047, 1048, 1, 0, 0, 0, 1048, 1050, 1, 0, 0, 0, 1049, 1018, 1, 0, 0, 0, 1049, 1033, 1, 0, 0, 0, 1050, 119, 1, 0, 0, 0, 1051, 1052, 5, 63, 0, 0, 1052, 1053, 5, 218, 0, 0, 1053, 1054, 5, 145, 0, 0, 1054, 1055, 5, 218, 0, 0, 1055, 1058, 3, 30, 15, 0, 1056, 1057, 5, 218, 0, 0, 1057, 1059, 3, 166, 83, 0, 1058, 1056, 1, 0, 0, 0, 1058, 1059, 1, 0, 0, 0, 1059, 121, 1, 0, 0, 0, 1060, 1061, 5, 154, 0, 0, 1061, 1062, 5, 218, 0, 0, 1062, 1063, 5, 155, 0, 0, 1063, 1064, 5, 218, 0, 0, 1064, 1065, 5, 145, 0, 0, 1065, 1066, 5, 218, 0, 0, 1066, 1067, 5, 82, 0, 0, 1067, 1068, 5, 218, 0, 0, 1068, 1069, 5, 148, 0, 0, 1069, 1070, 5, 218, 0, 0, 1070, 1071, 5, 75, 0, 0, 1071, 1074, 5, 218, 0, 0, 1072, 1075, 3, 34, 17, 0, 1073, 1075, 3, 454, 227, 0, 1074, 1072, 1, 0, 0, 0, 1074, 1073, 1, 0, 0, 0, 1075, 1076, 1, 0, 0, 0, 1076, 1077, 5, 156, 0, 0, 1077, 1080, 5, 218, 0, 0, 1078, 1081, 3, 34, 17, 0, 1079, 1081, 3, 454, 227, 0, 1080, 1078, 1, 0, 0, 0, 1080, 1079, 1, 0, 0, 0, 1081, 1102, 1, 0, 0, 0, 1082, 1083, 5, 154, 0, 0, 1083, 1084, 5, 218, 0, 0, 1084, 1085, 5, 145, 0, 0, 1085, 1086, 5, 218, 0, 0, 1086, 1087, 3, 30, 15, 0, 1087, 1088, 5, 218, 0, 0, 1088, 1091, 3, 170, 85, 0, 1089, 1090, 5, 218, 0, 0, 1090, 1092, 3, 174, 87, 0, 1091, 1089, 1, 0, 0, 0, 1091, 1092, 1, 0, 0, 0, 1092, 1102, 1, 0, 0, 0, 1093, 1094, 5, 154, 0, 0, 1094, 1095, 5, 218, 0, 0, 1095, 1096, 5, 145, 0, 0, 1096, 1097, 5, 218, 0, 0, 1097, 1098, 3, 30, 15, 0, 1098, 1099, 5, 218, 0, 0, 1099, 1100, 3, 174, 87, 0, 1100, 1102, 1, 0, 0, 0, 1101, 1060, 1, 0, 0, 0, 1101, 1082, 1, 0, 0, 0, 1101, 1093, 1, 0, 0, 0, 1102, 123, 1, 0, 0, 0, 1103, 1104, 5, 133, 0, 0, 1104, 1107, 5, 218, 0, 0, 1105, 1106, 5, 61, 0, 0, 1106, 1108, 5, 218, 0, 0, 1107, 1105, 1, 0, 0, 0, 1107, 1108, 1, 0, 0, 0, 1108, 1109, 1, 0, 0, 0, 1109, 1131, 5, 157, 0, 0, 1110, 1111, 5, 133, 0, 0, 1111, 1117, 5, 218, 0, 0, 1112, 1113, 5, 143, 0, 0, 1113, 1114, 5, 218, 0, 0, 1114, 1115, 3, 482, 241, 0, 1115, 1116, 5, 218, 0, 0, 1116, 1118, 1, 0, 0, 0, 1117, 1112, 1, 0, 0, 0, 1117, 1118, 1, 0, 0, 0, 1118, 1119, 1, 0, 0, 0, 1119, 1131, 5, 157, 0, 0, 1120, 1121, 5, 133, 0, 0, 1121, 1127, 5, 218, 0, 0, 1122, 1123, 5, 145, 0, 0, 1123, 1124, 5, 218, 0, 0, 1124, 1125, 3, 30, 15, 0, 1125, 1126, 5, 218, 0, 0, 1126, 1128, 1, 0, 0, 0, 1127, 1122, 1, 0, 0, 0, 1127, 1128, 1, 0, 0, 0, 1128, 1129, 1, 0, 0, 0, 1129, 1131, 5, 157, 0, 0, 1130, 1103, 1, 0, 0, 0, 1130, 1110, 1, 0, 0, 0, 1130, 1120, 1, 0, 0, 0, 1131, 125, 1, 0, 0, 0, 1132, 1133, 5, 158, 0, 0, 1133, 1134, 5, 218, 0, 0, 1134, 1135, 5, 143, 0, 0, 1135, 1136, 5, 218, 0, 0, 1136, 1137, 3, 138, 69, 0, 1137, 1138, 5, 218, 0, 0, 1138, 1139, 5, 156, 0, 0, 1139, 1140, 5, 218, 0, 0, 1140, 1141, 3, 30, 15, 0, 1141, 1178, 1, 0, 0, 0, 1142, 1143, 5, 158, 0, 0, 1143, 1144, 5, 218, 0, 0, 1144, 1145, 3, 144, 72, 0, 1145, 1146, 5, 218, 0, 0, 1146, 1147, 5, 65, 0, 0, 1147, 1148, 5, 218, 0, 0, 1148, 1149, 3, 134, 67, 0, 1149, 1150, 5, 218, 0, 0, 1150, 1151, 5, 156, 0, 0, 1151, 1152, 3, 138, 69, 0, 1152, 1178, 1, 0, 0, 0, 1153, 1154, 5, 158, 0, 0, 1154, 1155, 5, 218, 0, 0, 1155, 1156, 3, 140, 70, 0, 1156, 1157, 5, 218, 0, 0, 1157, 1158, 5, 65, 0, 0, 1158, 1159, 5, 218, 0, 0, 1159, 1160, 3, 136, 68, 0, 1160, 1161, 5, 218, 0, 0, 1161, 1162, 3, 148, 74, 0, 1162, 1163, 5, 218, 0, 0, 1163, 1164, 5, 156, 0, 0, 1164, 1165, 3, 138, 69, 0, 1165, 1178, 1, 0, 0, 0, 1166, 1167, 5, 158, 0, 0, 1167, 1168, 5, 218, 0, 0, 1168, 1169, 3, 146, 73, 0, 1169, 1170, 5, 218, 0, 0, 1170, 1171, 5, 65, 0, 0, 1171, 1172, 5, 218, 0, 0, 1172, 1173, 5, 135, 0, 0, 1173, 1174, 5, 218, 0, 0, 1174, 1175, 5, 156, 0, 0, 1175, 1176, 3, 138, 69, 0, 1176, 1178, 1, 0, 0, 0, 1177, 1132, 1, 0, 0, 0, 1177, 1142, 1, 0, 0, 0, 1177, 1153, 1, 0, 0, 0, 1177, 1166, 1, 0, 0, 0, 1178, 127, 1, 0, 0, 0, 1179, 1180, 5, 159, 0, 0, 1180, 1181, 5, 218, 0, 0, 1181, 1182, 5, 143, 0, 0, 1182, 1183, 5, 218, 0, 0, 1183, 1184, 3, 138, 69, 0, 1184, 1185, 5, 218, 0, 0, 1185, 1186, 5, 156, 0, 0, 1186, 1187, 5, 218, 0, 0, 1187, 1188, 3, 30, 15, 0, 1188, 1225, 1, 0, 0, 0, 1189, 1190, 5, 159, 0, 0, 1190, 1191, 5, 218, 0, 0, 1191, 1192, 3, 144, 72, 0, 1192, 1193, 5, 218, 0, 0, 1193, 1194, 5, 65, 0, 0, 1194, 1195, 5, 218, 0, 0, 1195, 1196, 3, 134, 67, 0, 1196, 1197, 5, 218, 0, 0, 1197, 1198, 5, 156, 0, 0, 1198, 1199, 3, 138, 69, 0, 1199, 1225, 1, 0, 0, 0, 1200, 1201, 5, 159, 0, 0, 1201, 1202, 5, 218, 0, 0, 1202, 1203, 3, 140, 70, 0, 1203, 1204, 5, 218, 0, 0, 1204, 1205, 5, 65, 0, 0, 1205, 1206, 5, 218, 0, 0, 1206, 1207, 3, 136, 68, 0, 1207, 1208, 5, 218, 0, 0, 1208, 1209, 3, 148, 74, 0, 1209, 1210, 5, 218, 0, 0, 1210, 1211, 5, 156, 0, 0, 1211, 1212, 3, 138, 69, 0, 1212, 1225, 1, 0, 0, 0, 1213, 1214, 5, 159, 0, 0, 1214, 1215, 5, 218, 0, 0, 1215, 1216, 3, 146, 73, 0, 1216, 1217, 5, 218, 0, 0, 1217, 1218, 5, 65, 0, 0, 1218, 1219, 5, 218, 0, 0, 1219, 1220, 5, 135, 0, 0, 1220, 1221, 5, 218, 0, 0, 1221, 1222, 5, 156, 0, 0, 1222, 1223, 3, 138, 69, 0, 1223, 1225, 1, 0, 0, 0, 1224, 1179, 1, 0, 0, 0, 1224, 1189, 1, 0, 0, 0, 1224, 1200, 1, 0, 0, 0, 1224, 1213, 1, 0, 0, 0, 1225, 129, 1, 0, 0, 0, 1226, 1227, 5, 160, 0, 0, 1227, 1228, 5, 218, 0, 0, 1228, 1229, 5, 143, 0, 0, 1229, 1230, 5, 218, 0, 0, 1230, 1231, 3, 138, 69, 0, 1231, 1232, 5, 218, 0, 0, 1232, 1233, 5, 75, 0, 0, 1233, 1234, 5, 218, 0, 0, 1234, 1235, 3, 30, 15, 0, 1235, 1248, 1, 0, 0, 0, 1236, 1239, 5, 160, 0, 0, 1237, 1238, 5, 218, 0, 0, 1238, 1240, 7, 1, 0, 0, 1239, 1237, 1, 0, 0, 0, 1239, 1240, 1, 0, 0, 0, 1240, 1241, 1, 0, 0, 0, 1241, 1242, 3, 132, 66, 0, 1242, 1243, 5, 218, 0, 0, 1243, 1244, 5, 75, 0, 0, 1244, 1245, 5, 218, 0, 0, 1245, 1246, 3, 138, 69, 0, 1246, 1248, 1, 0, 0, 0, 1247, 1226, 1, 0, 0, 0, 1247, 1236, 1, 0, 0, 0, 1248, 131, 1, 0, 0, 0, 1249, 1250, 3, 144, 72, 0, 1250, 1251, 5, 218, 0, 0, 1251, 1252, 5, 65, 0, 0, 1252, 1253, 5, 218, 0, 0, 1253, 1254, 3, 134, 67, 0, 1254, 1268, 1, 0, 0, 0, 1255, 1256, 3, 142, 71, 0, 1256, 1257, 5, 218, 0, 0, 1257, 1258, 5, 65, 0, 0, 1258, 1259, 5, 218, 0, 0, 1259, 1260, 3, 136, 68, 0, 1260, 1268, 1, 0, 0, 0, 1261, 1262, 3, 146, 73, 0, 1262, 1263, 5, 218, 0, 0, 1263, 1264, 5, 65, 0, 0, 1264, 1265, 5, 218, 0, 0, 1265, 1266, 5, 135, 0, 0, 1266, 1268, 1, 0, 0, 0, 1267, 1249, 1, 0, 0, 0, 1267, 1255, 1, 0, 0, 0, 1267, 1261, 1, 0, 0, 0, 1268, 133, 1, 0, 0, 0, 1269, 1270, 7, 2, 0, 0, 1270, 1271, 5, 218, 0, 0, 1271, 1289, 5, 19, 0, 0, 1272, 1273, 7, 2, 0, 0, 1273, 1274, 5, 218, 0, 0, 1274, 1285, 3, 482, 241, 0, 1275, 1277, 5, 218, 0, 0, 1276, 1275, 1, 0, 0, 0, 1276, 1277, 1, 0, 0, 0, 1277, 1278, 1, 0, 0, 0, 1278, 1280, 5, 15, 0, 0, 1279, 1281, 5, 218, 0, 0, 1280, 1279, 1, 0, 0, 0, 1280, 1281, 1, 0, 0, 0, 1281, 1282, 1, 0, 0, 0, 1282, 1284, 3, 482, 241, 0, 1283, 1276, 1, 0, 0, 0, 1284, 1287, 1, 0, 0, 0, 1285, 1283, 1, 0, 0, 0, 1285, 1286, 1, 0, 0, 0, 1286, 1289, 1, 0, 0, 0, 1287, 1285, 1, 0, 0, 0, 1288, 1269, 1, 0, 0, 0, 1288, 1272, 1, 0, 0, 0, 1289, 135, 1, 0, 0, 0, 1290, 1291, 7, 3, 0, 0, 1291, 1292, 5, 218, 0, 0, 1292, 1310, 5, 19, 0, 0, 1293, 1294, 7, 3, 0, 0, 1294, 1295, 5, 218, 0, 0, 1295, 1306, 3, 482, 241, 0, 1296, 1298, 5, 218, 0, 0, 1297, 1296, 1, 0, 0, 0, 1297, 1298, 1, 0, 0, 0, 1298, 1299, 1, 0, 0, 0, 1299, 1301, 5, 15, 0, 0, 1300, 1302, 5, 218, 0, 0, 1301, 1300, 1, 0, 0, 0, 1301, 1302, 1, 0, 0, 0, 1302, 1303, 1, 0, 0, 0, 1303, 1305, 3, 482, 241, 0, 1304, 1297, 1, 0, 0, 0, 1305, 1308, 1, 0, 0, 0, 1306, 1304, 1, 0, 0, 0, 1306, 1307, 1, 0, 0, 0, 1307, 1310, 1, 0, 0, 0, 1308, 1306, 1, 0, 0, 0, 1309, 1290, 1, 0, 0, 0, 1309, 1293, 1, 0, 0, 0, 1310, 137, 1, 0, 0, 0, 1311, 1322, 3, 482, 241, 0, 1312, 1314, 5, 218, 0, 0, 1313, 1312, 1, 0, 0, 0, 1313, 1314, 1, 0, 0, 0, 1314, 1315, 1, 0, 0, 0, 1315, 1317, 5, 15, 0, 0, 1316, 1318, 5, 218, 0, 0, 1317, 1316, 1, 0, 0, 0, 1317, 1318, 1, 0, 0, 0, 1318, 1319, 1, 0, 0, 0, 1319, 1321, 3, 482, 241, 0, 1320, 1313, 1, 0, 0, 0, 1321, 1324, 1, 0, 0, 0, 1322, 1320, 1, 0, 0, 0, 1322, 1323, 1, 0, 0, 0, 1323, 139, 1, 0, 0, 0, 1324, 1322, 1, 0, 0, 0, 1325, 1336, 3, 142, 71, 0, 1326, 1327, 5, 79, 0, 0, 1327, 1328, 5, 218, 0, 0, 1328, 1330, 5, 14, 0, 0, 1329, 1331, 5, 218, 0, 0, 1330, 1329, 1, 0, 0, 0, 1330, 1331, 1, 0, 0, 0, 1331, 1332, 1, 0, 0, 0, 1332, 1333, 3, 150, 75, 0, 1333, 1334, 5, 16, 0, 0, 1334, 1336, 1, 0, 0, 0, 1335, 1325, 1, 0, 0, 0, 1335, 1326, 1, 0, 0, 0, 1336, 141, 1, 0, 0, 0, 1337, 1349, 5, 167, 0, 0, 1338, 1339, 5, 168, 0, 0, 1339, 1340, 5, 218, 0, 0, 1340, 1342, 5, 14, 0, 0, 1341, 1343, 5, 218, 0, 0, 1342, 1341, 1, 0, 0, 0, 1342, 1343, 1, 0, 0, 0, 1343, 1344, 1, 0, 0, 0, 1344, 1345, 3, 150, 75, 0, 1345, 1346, 5, 16, 0, 0, 1346, 1349, 1, 0, 0, 0, 1347, 1349, 5, 169, 0, 0, 1348, 1337, 1, 0, 0, 0, 1348, 1338, 1, 0, 0, 0, 1348, 1347, 1, 0, 0, 0, 1349, 143, 1, 0, 0, 0, 1350, 1413, 5, 170, 0, 0, 1351, 1413, 5, 100, 0, 0, 1352, 1413, 5, 142, 0, 0, 1353, 1354, 5, 62, 0, 0, 1354, 1355, 5, 218, 0, 0, 1355, 1413, 7, 4, 0, 0, 1356, 1357, 5, 63, 0, 0, 1357, 1358, 5, 218, 0, 0, 1358, 1413, 7, 4, 0, 0, 1359, 1360, 7, 4, 0, 0, 1360, 1361, 5, 218, 0, 0, 1361, 1413, 5, 172, 0, 0, 1362, 1363, 5, 62, 0, 0, 1363, 1364, 5, 218, 0, 0, 1364, 1413, 7, 5, 0, 0, 1365, 1366, 5, 63, 0, 0, 1366, 1367, 5, 218, 0, 0, 1367, 1413, 7, 5, 0, 0, 1368, 1369, 7, 5, 0, 0, 1369, 1370, 5, 218, 0, 0, 1370, 1413, 5, 172, 0, 0, 1371, 1372, 5, 62, 0, 0, 1372, 1373, 5, 218, 0, 0, 1373, 1374, 5, 173, 0, 0, 1374, 1377, 5, 218, 0, 0, 1375, 1376, 5, 101, 0, 0, 1376, 1378, 5, 218, 0, 0, 1377, 1375, 1, 0, 0, 0, 1377, 1378, 1, 0, 0, 0, 1378, 1379, 1, 0, 0, 0, 1379, 1413, 7, 6, 0, 0, 1380, 1381, 5, 62, 0, 0, 1381, 1382, 5, 218, 0, 0, 1382, 1383, 5, 173, 0, 0, 1383, 1386, 5, 218, 0, 0, 1384, 1385, 5, 102, 0, 0, 1385, 1387, 5, 218, 0, 0, 1386, 1384, 1, 0, 0, 0, 1386, 1387, 1, 0, 0, 0, 1387, 1388, 1, 0, 0, 0, 1388, 1413, 7, 7, 0, 0, 1389, 1390, 5, 62, 0, 0, 1390, 1391, 5, 218, 0, 0, 1391, 1392, 5, 173, 0, 0, 1392, 1395, 5, 218, 0, 0, 1393, 1394, 5, 180, 0, 0, 1394, 1396, 5, 218, 0, 0, 1395, 1393, 1, 0, 0, 0, 1395, 1396, 1, 0, 0, 0, 1396, 1397, 1, 0, 0, 0, 1397, 1413, 7, 8, 0, 0, 1398, 1401, 5, 176, 0, 0, 1399, 1400, 5, 218, 0, 0, 1400, 1402, 5, 172, 0, 0, 1401, 1399, 1, 0, 0, 0, 1401, 1402, 1, 0, 0, 0, 1402, 1413, 1, 0, 0, 0, 1403, 1410, 5, 61, 0, 0, 1404, 1407, 5, 218, 0, 0, 1405, 1406, 5, 136, 0, 0, 1406, 1408, 5, 218, 0, 0, 1407, 1405, 1, 0, 0, 0, 1407, 1408, 1, 0, 0, 0, 1408, 1409, 1, 0, 0, 0, 1409, 1411, 5, 157, 0, 0, 1410, 1404, 1, 0, 0, 0, 1410, 1411, 1, 0, 0, 0, 1411, 1413, 1, 0, 0, 0, 1412, 1350, 1, 0, 0, 0, 1412, 1351, 1, 0, 0, 0, 1412, 1352, 1, 0, 0, 0, 1412, 1353, 1, 0, 0, 0, 1412, 1356, 1, 0, 0, 0, 1412, 1359, 1, 0, 0, 0, 1412, 1362, 1, 0, 0, 0, 1412, 1365, 1, 0, 0, 0, 1412, 1368, 1, 0, 0, 0, 1412, 1371, 1, 0, 0, 0, 1412, 1380, 1, 0, 0, 0, 1412, 1389, 1, 0, 0, 0, 1412, 1398, 1, 0, 0, 0, 1412, 1403, 1, 0, 0, 0, 1413, 145, 1, 0, 0, 0, 1414, 1415, 5, 143, 0, 0, 1415, 1416, 5, 218, 0, 0, 1416, 1433, 5, 172, 0, 0, 1417, 1418, 5, 62, 0, 0, 1418, 1419, 5, 218, 0, 0, 1419, 1433, 5, 143, 0, 0, 1420, 1421, 5, 63, 0, 0, 1421, 1422, 5, 218, 0, 0, 1422, 1433, 5, 143, 0, 0, 1423, 1424, 5, 182, 0, 0, 1424, 1425, 5, 218, 0, 0, 1425, 1433, 5, 143, 0, 0, 1426, 1427, 5, 85, 0, 0, 1427, 1428, 5, 218, 0, 0, 1428, 1433, 5, 143, 0, 0, 1429, 1430, 5, 133, 0, 0, 1430, 1431, 5, 218, 0, 0, 1431, 1433, 5, 143, 0, 0, 1432, 1414, 1, 0, 0, 0, 1432, 1417, 1, 0, 0, 0, 1432, 1420, 1, 0, 0, 0, 1432, 1423, 1, 0, 0, 0, 1432, 1426, 1, 0, 0, 0, 1432, 1429, 1, 0, 0, 0, 1433, 147, 1, 0, 0, 0, 1434, 1435, 7, 9, 0, 0, 1435, 1436, 5, 218, 0, 0, 1436, 1439, 3, 150, 75, 0, 1437, 1438, 5, 218, 0, 0, 1438, 1440, 3, 152, 76, 0, 1439, 1437, 1, 0, 0, 0, 1439, 1440, 1, 0, 0, 0, 1440, 1456, 1, 0, 0, 0, 1441, 1442, 7, 10, 0, 0, 1442, 1443, 5, 218, 0, 0, 1443, 1446, 3, 150, 75, 0, 1444, 1445, 5, 218, 0, 0, 1445, 1447, 3, 152, 76, 0, 1446, 1444, 1, 0, 0, 0, 1446, 1447, 1, 0, 0, 0, 1447, 1456, 1, 0, 0, 0, 1448, 1449, 7, 11, 0, 0, 1449, 1450, 5, 218, 0, 0, 1450, 1453, 3, 150, 75, 0, 1451, 1452, 5, 218, 0, 0, 1452, 1454, 3, 152, 76, 0, 1453, 1451, 1, 0, 0, 0, 1453, 1454, 1, 0, 0, 0, 1454, 1456, 1, 0, 0, 0, 1455, 1434, 1, 0, 0, 0, 1455, 1441, 1, 0, 0, 0, 1455, 1448, 1, 0, 0, 0, 1456, 149, 1, 0, 0, 0, 1457, 1473, 5, 19, 0, 0, 1458, 1469, 3, 482, 241, 0, 1459, 1461, 5, 218, 0, 0, 1460, 1459, 1, 0, 0, 0, 1460, 1461, 1, 0, 0, 0, 1461, 1462, 1, 0, 0, 0, 1462, 1464, 5, 15, 0, 0, 1463, 1465, 5, 218, 0, 0, 1464, 1463, 1, 0, 0, 0, 1464, 1465, 1, 0, 0, 0, 1465, 1466, 1, 0, 0, 0, 1466, 1468, 3, 482, 241, 0, 1467, 1460, 1, 0, 0, 0, 1468, 1471, 1, 0, 0, 0, 1469, 1467, 1, 0, 0, 0, 1469, 1470, 1, 0, 0, 0, 1470, 1473, 1, 0, 0, 0, 1471, 1469, 1, 0, 0, 0, 1472, 1457, 1, 0, 0, 0, 1472, 1458, 1, 0, 0, 0, 1473, 151, 1, 0, 0, 0, 1474, 1476, 5, 20, 0, 0, 1475, 1477, 5, 218, 0, 0, 1476, 1475, 1, 0, 0, 0, 1476, 1477, 1, 0, 0, 0, 1477, 1478, 1, 0, 0, 0, 1478, 1480, 5, 19, 0, 0, 1479, 1481, 5, 218, 0, 0, 1480, 1479, 1, 0, 0, 0, 1480, 1481, 1, 0, 0, 0, 1481, 1482, 1, 0, 0, 0, 1482, 1483, 5, 21, 0, 0, 1483, 153, 1, 0, 0, 0, 1484, 1485, 5, 133, 0, 0, 1485, 1488, 5, 218, 0, 0, 1486, 1487, 5, 134, 0, 0, 1487, 1489, 5, 218, 0, 0, 1488, 1486, 1, 0, 0, 0, 1488, 1489, 1, 0, 0, 0, 1489, 1490, 1, 0, 0, 0, 1490, 1495, 5, 136, 0, 0, 1491, 1492, 5, 133, 0, 0, 1492, 1493, 5, 218, 0, 0, 1493, 1495, 5, 137, 0, 0, 1494, 1484, 1, 0, 0, 0, 1494, 1491, 1, 0, 0, 0, 1495, 155, 1, 0, 0, 0, 1496, 1497, 5, 62, 0, 0, 1497, 1498, 5, 218, 0, 0, 1498, 1499, 5, 136, 0, 0, 1499, 1500, 5, 218, 0, 0, 1500, 1503, 3, 482, 241, 0, 1501, 1502, 5, 218, 0, 0, 1502, 1504, 3, 164, 82, 0, 1503, 1501, 1, 0, 0, 0, 1503, 1504, 1, 0, 0, 0, 1504, 1516, 1, 0, 0, 0, 1505, 1506, 5, 62, 0, 0, 1506, 1510, 5, 218, 0, 0, 1507, 1508, 3, 168, 84, 0, 1508, 1509, 5, 218, 0, 0, 1509, 1511, 1, 0, 0, 0, 1510, 1507, 1, 0, 0, 0, 1510, 1511, 1, 0, 0, 0, 1511, 1512, 1, 0, 0, 0, 1512, 1513, 5, 136, 0, 0, 1513, 1514, 5, 218, 0, 0, 1514, 1516, 3, 482, 241, 0, 1515, 1496, 1, 0, 0, 0, 1515, 1505, 1, 0, 0, 0, 1516, 157, 1, 0, 0, 0, 1517, 1518, 5, 63, 0, 0, 1518, 1519, 5, 218, 0, 0, 1519, 1520, 5, 136, 0, 0, 1520, 1521, 5, 218, 0, 0, 1521, 1524, 3, 482, 241, 0, 1522, 1523, 5, 218, 0, 0, 1523, 1525, 3, 166, 83, 0, 1524, 1522, 1, 0, 0, 0, 1524, 1525, 1, 0, 0, 0, 1525, 159, 1, 0, 0, 0, 1526, 1527, 5, 100, 0, 0, 1527, 1528, 5, 218, 0, 0, 1528, 1529, 5, 136, 0, 0, 1529, 1530, 5, 218, 0, 0, 1530, 1531, 3, 482, 241, 0, 1531, 161, 1, 0, 0, 0, 1532, 1533, 5, 142, 0, 0, 1533, 1534, 5, 218, 0, 0, 1534, 1535, 5, 136, 0, 0, 1535, 1536, 5, 218, 0, 0, 1536, 1537, 3, 482, 241, 0, 1537, 163, 1, 0, 0, 0, 1538, 1539, 5, 141, 0, 0, 1539, 1540, 5, 218, 0, 0, 1540, 1541, 5, 110, 0, 0, 1541, 1542, 5, 218, 0, 0, 1542, 1543, 5, 70, 0, 0, 1543, 165, 1, 0, 0, 0, 1544, 1545, 5, 141, 0, 0, 1545, 1546, 5, 218, 0, 0, 1546, 1547, 5, 70, 0, 0, 1547, 167, 1, 0, 0, 0, 1548, 1549, 5, 107, 0, 0, 1549, 1550, 5, 218, 0, 0, 1550, 1551, 5, 140, 0, 0, 1551, 169, 1, 0, 0, 0, 1552, 1553, 5, 82, 0, 0, 1553, 1554, 5, 218, 0, 0, 1554, 1555, 5, 148, 0, 0, 1555, 1558, 5, 218, 0, 0, 1556, 1559, 3, 34, 17, 0, 1557, 1559, 3, 454, 227, 0, 1558, 1556, 1, 0, 0, 0, 1558, 1557, 1, 0, 0, 0, 1559, 1562, 1, 0, 0, 0, 1560, 1561, 5, 218, 0, 0, 1561, 1563, 3, 172, 86, 0, 1562, 1560, 1, 0, 0, 0, 1562, 1563, 1, 0, 0, 0, 1563, 1570, 1, 0, 0, 0, 1564, 1565, 5, 82, 0, 0, 1565, 1566, 5, 218, 0, 0, 1566, 1567, 5, 148, 0, 0, 1567, 1568, 5, 218, 0, 0, 1568, 1570, 3, 172, 86, 0, 1569, 1552, 1, 0, 0, 0, 1569, 1564, 1, 0, 0, 0, 1570, 171, 1, 0, 0, 0, 1571, 1572, 5, 149, 0, 0, 1572, 1575, 5, 218, 0, 0, 1573, 1574, 5, 110, 0, 0, 1574, 1576, 5, 218, 0, 0, 1575, 1573, 1, 0, 0, 0, 1575, 1576, 1, 0, 0, 0, 1576, 1577, 1, 0, 0, 0, 1577, 1578, 5, 150, 0, 0, 1578, 173, 1, 0, 0, 0, 1579, 1580, 5, 82, 0, 0, 1580, 1581, 5, 218, 0, 0, 1581, 1582, 5, 151, 0, 0, 1582, 1583, 5, 218, 0, 0, 1583, 1584, 3, 176, 88, 0, 1584, 175, 1, 0, 0, 0, 1585, 1586, 7, 12, 0, 0, 1586, 177, 1, 0, 0, 0, 1587, 1588, 5, 62, 0, 0, 1588, 1589, 5, 218, 0, 0, 1589, 1590, 3, 200, 100, 0, 1590, 179, 1, 0, 0, 0, 1591, 1592, 5, 62, 0, 0, 1592, 1593, 5, 218, 0, 0, 1593, 1594, 3, 202, 101, 0, 1594, 181, 1, 0, 0, 0, 1595, 1596, 5, 62, 0, 0, 1596, 1597, 5, 218, 0, 0, 1597, 1598, 3, 204, 102, 0, 1598, 183, 1, 0, 0, 0, 1599, 1600, 5, 62, 0, 0, 1600, 1601, 5, 218, 0, 0, 1601, 1602, 3, 206, 103, 0, 1602, 185, 1, 0, 0, 0, 1603, 1604, 5, 62, 0, 0, 1604, 1605, 5, 218, 0, 0, 1605, 1606, 3, 198, 99, 0, 1606, 187, 1, 0, 0, 0, 1607, 1608, 5, 63, 0, 0, 1608, 1609, 5, 218, 0, 0, 1609, 1610, 3, 200, 100, 0, 1610, 189, 1, 0, 0, 0, 1611, 1612, 5, 63, 0, 0, 1612, 1613, 5, 218, 0, 0, 1613, 1614, 3, 202, 101, 0, 1614, 191, 1, 0, 0, 0, 1615, 1616, 5, 63, 0, 0, 1616, 1617, 5, 218, 0, 0, 1617, 1618, 3, 204, 102, 0, 1618, 193, 1, 0, 0, 0, 1619, 1620, 5, 63, 0, 0, 1620, 1621, 5, 218, 0, 0, 1621, 1622, 3, 206, 103, 0, 1622, 195, 1, 0, 0, 0, 1623, 1624, 5, 63, 0, 0, 1624, 1625, 5, 218, 0, 0, 1625, 1626, 3, 198, 99, 0, 1626, 197, 1, 0, 0, 0, 1627, 1628, 5, 64, 0, 0, 1628, 1629, 5, 218, 0, 0, 1629, 1631, 5, 65, 0, 0, 1630, 1632, 5, 218, 0, 0, 1631, 1630, 1, 0, 0, 0, 1631, 1632, 1, 0, 0, 0, 1632, 1633, 1, 0, 0, 0, 1633, 1635, 3, 328, 164, 0, 1634, 1636, 5, 218, 0, 0, 1635, 1634, 1, 0, 0, 0, 1635, 1636, 1, 0, 0, 0, 1636, 1637, 1, 0, 0, 0, 1637, 1639, 5, 20, 0, 0, 1638, 1640, 5, 218, 0, 0, 1639, 1638, 1, 0, 0, 0, 1639, 1640, 1, 0, 0, 0, 1640, 1641, 1, 0, 0, 0, 1641, 1643, 3, 466, 233, 0, 1642, 1644, 5, 218, 0, 0, 1643, 1642, 1, 0, 0, 0, 1643, 1644, 1, 0, 0, 0, 1644, 1645, 1, 0, 0, 0, 1645, 1646, 5, 21, 0, 0, 1646, 199, 1, 0, 0, 0, 1647, 1648, 5, 66, 0, 0, 1648, 1649, 5, 218, 0, 0, 1649, 1651, 5, 65, 0, 0, 1650, 1652, 5, 218, 0, 0, 1651, 1650, 1, 0, 0, 0, 1651, 1652, 1, 0, 0, 0, 1652, 1653, 1, 0, 0, 0, 1653, 1655, 5, 20, 0, 0, 1654, 1656, 5, 218, 0, 0, 1655, 1654, 1, 0, 0, 0, 1655, 1656, 1, 0, 0, 0, 1656, 1657, 1, 0, 0, 0, 1657, 1658, 3, 436, 218, 0, 1658, 1660, 3, 328, 164, 0, 1659, 1661, 5, 218, 0, 0, 1660, 1659, 1, 0, 0, 0, 1660, 1661, 1, 0, 0, 0, 1661, 1662, 1, 0, 0, 0, 1662, 1664, 5, 21, 0, 0, 1663, 1665, 5, 218, 0, 0, 1664, 1663, 1, 0, 0, 0, 1664, 1665, 1, 0, 0, 0, 1665, 1666, 1, 0, 0, 0, 1666, 1667, 5, 67, 0, 0, 1667, 1668, 5, 218, 0, 0, 1668, 1669, 3, 464, 232, 0, 1669, 1670, 5, 218, 0, 0, 1670, 1671, 5, 68, 0, 0, 1671, 1672, 5, 218, 0, 0, 1672, 1673, 5, 69, 0, 0, 1673, 201, 1, 0, 0, 0, 1674, 1675, 5, 66, 0, 0, 1675, 1676, 5, 218, 0, 0, 1676, 1678, 5, 65, 0, 0, 1677, 1679, 5, 218, 0, 0, 1678, 1677, 1, 0, 0, 0, 1678, 1679, 1, 0, 0, 0, 1679, 1680, 1, 0, 0, 0, 1680, 1682, 5, 20, 0, 0, 1681, 1683, 5, 218, 0, 0, 1682, 1681, 1, 0, 0, 0, 1682, 1683, 1, 0, 0, 0, 1683, 1684, 1, 0, 0, 0, 1684, 1685, 3, 436, 218, 0, 1685, 1687, 3, 328, 164, 0, 1686, 1688, 5, 218, 0, 0, 1687, 1686, 1, 0, 0, 0, 1687, 1688, 1, 0, 0, 0, 1688, 1689, 1, 0, 0, 0, 1689, 1691, 5, 21, 0, 0, 1690, 1692, 5, 218, 0, 0, 1691, 1690, 1, 0, 0, 0, 1691, 1692, 1, 0, 0, 0, 1692, 1693, 1, 0, 0, 0, 1693, 1694, 5, 67, 0, 0, 1694, 1695, 5, 218, 0, 0, 1695, 1697, 5, 20, 0, 0, 1696, 1698, 5, 218, 0, 0, 1697, 1696, 1, 0, 0, 0, 1697, 1698, 1, 0, 0, 0, 1698, 1699, 1, 0, 0, 0, 1699, 1701, 3, 462, 231, 0, 1700, 1702, 5, 218, 0, 0, 1701, 1700, 1, 0, 0, 0, 1701, 1702, 1, 0, 0, 0, 1702, 1703, 1, 0, 0, 0, 1703, 1704, 5, 21, 0, 0, 1704, 1705, 5, 218, 0, 0, 1705, 1706, 5, 68, 0, 0, 1706, 1707, 5, 218, 0, 0, 1707, 1708, 5, 101, 0, 0, 1708, 1709, 5, 218, 0, 0, 1709, 1710, 5, 131, 0, 0, 1710, 203, 1, 0, 0, 0, 1711, 1712, 5, 66, 0, 0, 1712, 1713, 5, 218, 0, 0, 1713, 1715, 5, 65, 0, 0, 1714, 1716, 5, 218, 0, 0, 1715, 1714, 1, 0, 0, 0, 1715, 1716, 1, 0, 0, 0, 1716, 1717, 1, 0, 0, 0, 1717, 1718, 5, 20, 0, 0, 1718, 1719, 3, 436, 218, 0, 1719, 1720, 3, 328, 164, 0, 1720, 1722, 5, 21, 0, 0, 1721, 1723, 5, 218, 0, 0, 1722, 1721, 1, 0, 0, 0, 1722, 1723, 1, 0, 0, 0, 1723, 1724, 1, 0, 0, 0, 1724, 1725, 5, 67, 0, 0, 1725, 1726, 5, 218, 0, 0, 1726, 1728, 5, 70, 0, 0, 1727, 1729, 5, 218, 0, 0, 1728, 1727, 1, 0, 0, 0, 1728, 1729, 1, 0, 0, 0, 1729, 1730, 1, 0, 0, 0, 1730, 1731, 5, 20, 0, 0, 1731, 1732, 3, 464, 232, 0, 1732, 1733, 5, 21, 0, 0, 1733, 205, 1, 0, 0, 0, 1734, 1735, 5, 66, 0, 0, 1735, 1736, 5, 218, 0, 0, 1736, 1738, 5, 65, 0, 0, 1737, 1739, 5, 218, 0, 0, 1738, 1737, 1, 0, 0, 0, 1738, 1739, 1, 0, 0, 0, 1739, 1740, 1, 0, 0, 0, 1740, 1742, 3, 208, 104, 0, 1741, 1743, 5, 218, 0, 0, 1742, 1741, 1, 0, 0, 0, 1742, 1743, 1, 0, 0, 0, 1743, 1744, 1, 0, 0, 0, 1744, 1745, 5, 67, 0, 0, 1745, 1746, 5, 218, 0, 0, 1746, 1748, 5, 70, 0, 0, 1747, 1749, 5, 218, 0, 0, 1748, 1747, 1, 0, 0, 0, 1748, 1749, 1, 0, 0, 0, 1749, 1750, 1, 0, 0, 0, 1750, 1751, 5, 20, 0, 0, 1751, 1752, 3, 464, 232, 0, 1752, 1753, 5, 21, 0, 0, 1753, 207, 1, 0, 0, 0, 1754, 1756, 5, 20, 0, 0, 1755, 1757, 5, 218, 0, 0, 1756, 1755, 1, 0, 0, 0, 1756, 1757, 1, 0, 0, 0, 1757, 1758, 1, 0, 0, 0, 1758, 1759, 5, 21, 0, 0, 1759, 1760, 3, 480, 240, 0, 1760, 1761, 5, 17, 0, 0, 1761, 1762, 3, 436, 218, 0, 1762, 1763, 3, 318, 159, 0, 1763, 1764, 5, 18, 0, 0, 1764, 1765, 3, 480, 240, 0, 1765, 1767, 5, 20, 0, 0, 1766, 1768, 5, 218, 0, 0, 1767, 1766, 1, 0, 0, 0, 1767, 1768, 1, 0, 0, 0, 1768, 1769, 1, 0, 0, 0, 1769, 1770, 5, 21, 0, 0, 1770, 1808, 1, 0, 0, 0, 1771, 1773, 5, 20, 0, 0, 1772, 1774, 5, 218, 0, 0, 1773, 1772, 1, 0, 0, 0, 1773, 1774, 1, 0, 0, 0, 1774, 1775, 1, 0, 0, 0, 1775, 1776, 5, 21, 0, 0, 1776, 1777, 3, 480, 240, 0, 1777, 1778, 5, 17, 0, 0, 1778, 1779, 3, 436, 218, 0, 1779, 1780, 3, 318, 159, 0, 1780, 1781, 5, 18, 0, 0, 1781, 1782, 3, 480, 240, 0, 1782, 1783, 3, 478, 239, 0, 1783, 1785, 5, 20, 0, 0, 1784, 1786, 5, 218, 0, 0, 1785, 1784, 1, 0, 0, 0, 1785, 1786, 1, 0, 0, 0, 1786, 1787, 1, 0, 0, 0, 1787, 1788, 5, 21, 0, 0, 1788, 1808, 1, 0, 0, 0, 1789, 1791, 5, 20, 0, 0, 1790, 1792, 5, 218, 0, 0, 1791, 1790, 1, 0, 0, 0, 1791, 1792, 1, 0, 0, 0, 1792, 1793, 1, 0, 0, 0, 1793, 1794, 5, 21, 0, 0, 1794, 1795, 3, 476, 238, 0, 1795, 1796, 3, 480, 240, 0, 1796, 1797, 5, 17, 0, 0, 1797, 1798, 3, 436, 218, 0, 1798, 1799, 3, 318, 159, 0, 1799, 1800, 5, 18, 0, 0, 1800, 1801, 3, 480, 240, 0, 1801, 1803, 5, 20, 0, 0, 1802, 1804, 5, 218, 0, 0, 1803, 1802, 1, 0, 0, 0, 1803, 1804, 1, 0, 0, 0, 1804, 1805, 1, 0, 0, 0, 1805, 1806, 5, 21, 0, 0, 1806, 1808, 1, 0, 0, 0, 1807, 1754, 1, 0, 0, 0, 1807, 1771, 1, 0, 0, 0, 1807, 1789, 1, 0, 0, 0, 1808, 209, 1, 0, 0, 0, 1809, 1810, 5, 71, 0, 0, 1810, 1811, 5, 218, 0, 0, 1811, 1812, 5, 72, 0, 0, 1812, 1817, 5, 218, 0, 0, 1813, 1814, 5, 73, 0, 0, 1814, 1815, 5, 218, 0, 0, 1815, 1816, 5, 74, 0, 0, 1816, 1818, 5, 218, 0, 0, 1817, 1813, 1, 0, 0, 0, 1817, 1818, 1, 0, 0, 0, 1818, 1819, 1, 0, 0, 0, 1819, 1820, 5, 75, 0, 0, 1820, 1821, 5, 218, 0, 0, 1821, 1822, 3, 336, 168, 0, 1822, 1823, 5, 218, 0, 0, 1823, 1824, 5, 76, 0, 0, 1824, 1825, 5, 218, 0, 0, 1825, 1826, 3, 436, 218, 0, 1826, 1830, 5, 218, 0, 0, 1827, 1828, 5, 77, 0, 0, 1828, 1829, 5, 218, 0, 0, 1829, 1831, 5, 199, 0, 0, 1830, 1827, 1, 0, 0, 0, 1830, 1831, 1, 0, 0, 0, 1831, 211, 1, 0, 0, 0, 1832, 1833, 5, 78, 0, 0, 1833, 1835, 5, 218, 0, 0, 1834, 1832, 1, 0, 0, 0, 1834, 1835, 1, 0, 0, 0, 1835, 1836, 1, 0, 0, 0, 1836, 1838, 5, 79, 0, 0, 1837, 1839, 5, 218, 0, 0, 1838, 1837, 1, 0, 0, 0, 1838, 1839, 1, 0, 0, 0, 1839, 1840, 1, 0, 0, 0, 1840, 1844, 3, 296, 148, 0, 1841, 1843, 3, 274, 137, 0, 1842, 1841, 1, 0, 0, 0, 1843, 1846, 1, 0, 0, 0, 1844, 1842, 1, 0, 0, 0, 1844, 1845, 1, 0, 0, 0, 1845, 1851, 1, 0, 0, 0, 1846, 1844, 1, 0, 0, 0, 1847, 1849, 5, 218, 0, 0, 1848, 1847, 1, 0, 0, 0, 1848, 1849, 1, 0, 0, 0, 1849, 1850, 1, 0, 0, 0, 1850, 1852, 3, 294, 147, 0, 1851, 1848, 1, 0, 0, 0, 1851, 1852, 1, 0, 0, 0, 1852, 213, 1, 0, 0, 0, 1853, 1855, 5, 80, 0, 0, 1854, 1856, 5, 218, 0, 0, 1855, 1854, 1, 0, 0, 0, 1855, 1856, 1, 0, 0, 0, 1856, 1857, 1, 0, 0, 0, 1857, 1858, 3, 336, 168, 0, 1858, 1859, 5, 218, 0, 0, 1859, 1860, 5, 76, 0, 0, 1860, 1861, 5, 218, 0, 0, 1861, 1862, 3, 436, 218, 0, 1862, 215, 1, 0, 0, 0, 1863, 1865, 5, 81, 0, 0, 1864, 1866, 5, 218, 0, 0, 1865, 1864, 1, 0, 0, 0, 1865, 1866, 1, 0, 0, 0, 1866, 1867, 1, 0, 0, 0, 1867, 1872, 3, 298, 149, 0, 1868, 1869, 5, 218, 0, 0, 1869, 1871, 3, 218, 109, 0, 1870, 1868, 1, 0, 0, 0, 1871, 1874, 1, 0, 0, 0, 1872, 1870, 1, 0, 0, 0, 1872, 1873, 1, 0, 0, 0, 1873, 217, 1, 0, 0, 0, 1874, 1872, 1, 0, 0, 0, 1875, 1876, 5, 65, 0, 0, 1876, 1877, 5, 218, 0, 0, 1877, 1878, 5, 79, 0, 0, 1878, 1879, 5, 218, 0, 0, 1879, 1886, 3, 224, 112, 0, 1880, 1881, 5, 65, 0, 0, 1881, 1882, 5, 218, 0, 0, 1882, 1883, 5, 62, 0, 0, 1883, 1884, 5, 218, 0, 0, 1884, 1886, 3, 224, 112, 0, 1885, 1875, 1, 0, 0, 0, 1885, 1880, 1, 0, 0, 0, 1886, 219, 1, 0, 0, 0, 1887, 1889, 5, 62, 0, 0, 1888, 1890, 5, 218, 0, 0, 1889, 1888, 1, 0, 0, 0, 1889, 1890, 1, 0, 0, 0, 1890, 1891, 1, 0, 0, 0, 1891, 1892, 3, 296, 148, 0, 1892, 221, 1, 0, 0, 0, 1893, 1894, 5, 62, 0, 0, 1894, 1895, 5, 218, 0, 0, 1895, 1897, 5, 69, 0, 0, 1896, 1898, 5, 218, 0, 0, 1897, 1896, 1, 0, 0, 0, 1897, 1898, 1, 0, 0, 0, 1898, 1899, 1, 0, 0, 0, 1899, 1900, 3, 296, 148, 0, 1900, 223, 1, 0, 0, 0, 1901, 1903, 5, 82, 0, 0, 1902, 1904, 5, 218, 0, 0, 1903, 1902, 1, 0, 0, 0, 1903, 1904, 1, 0, 0, 0, 1904, 1905, 1, 0, 0, 0, 1905, 1916, 3, 226, 113, 0, 1906, 1908, 5, 218, 0, 0, 1907, 1906, 1, 0, 0, 0, 1907, 1908, 1, 0, 0, 0, 1908, 1909, 1, 0, 0, 0, 1909, 1911, 5, 15, 0, 0, 1910, 1912, 5, 218, 0, 0, 1911, 1910, 1, 0, 0, 0, 1911, 1912, 1, 0, 0, 0, 1912, 1913, 1, 0, 0, 0, 1913, 1915, 3, 226, 113, 0, 1914, 1907, 1, 0, 0, 0, 1915, 1918, 1, 0, 0, 0, 1916, 1914, 1, 0, 0, 0, 1916, 1917, 1, 0, 0, 0, 1917, 225, 1, 0, 0, 0, 1918, 1916, 1, 0, 0, 0, 1919, 1921, 3, 464, 232, 0, 1920, 1922, 5, 218, 0, 0, 1921, 1920, 1, 0, 0, 0, 1921, 1922, 1, 0, 0, 0, 1922, 1923, 1, 0, 0, 0, 1923, 1925, 5, 12, 0, 0, 1924, 1926, 5, 218, 0, 0, 1925, 1924, 1, 0, 0, 0, 1925, 1926, 1, 0, 0, 0, 1926, 1927, 1, 0, 0, 0, 1927, 1928, 3, 336, 168, 0, 1928, 1956, 1, 0, 0, 0, 1929, 1931, 3, 436, 218, 0, 1930, 1932, 5, 218, 0, 0, 1931, 1930, 1, 0, 0, 0, 1931, 1932, 1, 0, 0, 0, 1932, 1933, 1, 0, 0, 0, 1933, 1935, 5, 12, 0, 0, 1934, 1936, 5, 218, 0, 0, 1935, 1934, 1, 0, 0, 0, 1935, 1936, 1, 0, 0, 0, 1936, 1937, 1, 0, 0, 0, 1937, 1938, 3, 336, 168, 0, 1938, 1956, 1, 0, 0, 0, 1939, 1941, 3, 436, 218, 0, 1940, 1942, 5, 218, 0, 0, 1941, 1940, 1, 0, 0, 0, 1941, 1942, 1, 0, 0, 0, 1942, 1943, 1, 0, 0, 0, 1943, 1945, 5, 22, 0, 0, 1944, 1946, 5, 218, 0, 0, 1945, 1944, 1, 0, 0, 0, 1945, 1946, 1, 0, 0, 0, 1946, 1947, 1, 0, 0, 0, 1947, 1948, 3, 336, 168, 0, 1948, 1956, 1, 0, 0, 0, 1949, 1951, 3, 436, 218, 0, 1950, 1952, 5, 218, 0, 0, 1951, 1950, 1, 0, 0, 0, 1951, 1952, 1, 0, 0, 0, 1952, 1953, 1, 0, 0, 0, 1953, 1954, 3, 326, 163, 0, 1954, 1956, 1, 0, 0, 0, 1955, 1919, 1, 0, 0, 0, 1955, 1929, 1, 0, 0, 0, 1955, 1939, 1, 0, 0, 0, 1955, 1949, 1, 0, 0, 0, 1956, 227, 1, 0, 0, 0, 1957, 1958, 5, 83, 0, 0, 1958, 1960, 5, 218, 0, 0, 1959, 1957, 1, 0, 0, 0, 1959, 1960, 1, 0, 0, 0, 1960, 1961, 1, 0, 0, 0, 1961, 1963, 5, 84, 0, 0, 1962, 1964, 5, 218, 0, 0, 1963, 1962, 1, 0, 0, 0, 1963, 1964, 1, 0, 0, 0, 1964, 1965, 1, 0, 0, 0, 1965, 1976, 3, 336, 168, 0, 1966, 1968, 5, 218, 0, 0, 1967, 1966, 1, 0, 0, 0, 1967, 1968, 1, 0, 0, 0, 1968, 1969, 1, 0, 0, 0, 1969, 1971, 5, 15, 0, 0, 1970, 1972, 5, 218, 0, 0, 1971, 1970, 1, 0, 0, 0, 1971, 1972, 1, 0, 0, 0, 1972, 1973, 1, 0, 0, 0, 1973, 1975, 3, 336, 168, 0, 1974, 1967, 1, 0, 0, 0, 1975, 1978, 1, 0, 0, 0, 1976, 1974, 1, 0, 0, 0, 1976, 1977, 1, 0, 0, 0, 1977, 229, 1, 0, 0, 0, 1978, 1976, 1, 0, 0, 0, 1979, 1980, 5, 85, 0, 0, 1980, 1981, 5, 218, 0, 0, 1981, 1992, 3, 232, 116, 0, 1982, 1984, 5, 218, 0, 0, 1983, 1982, 1, 0, 0, 0, 1983, 1984, 1, 0, 0, 0, 1984, 1985, 1, 0, 0, 0, 1985, 1987, 5, 15, 0, 0, 1986, 1988, 5, 218, 0, 0, 1987, 1986, 1, 0, 0, 0, 1987, 1988, 1, 0, 0, 0, 1988, 1989, 1, 0, 0, 0, 1989, 1991, 3, 232, 116, 0, 1990, 1983, 1, 0, 0, 0, 1991, 1994, 1, 0, 0, 0, 1992, 1990, 1, 0, 0, 0, 1992, 1993, 1, 0, 0, 0, 1993, 231, 1, 0, 0, 0, 1994, 1992, 1, 0, 0, 0, 1995, 1996, 3, 436, 218, 0, 1996, 1997, 3, 326, 163, 0, 1997, 2e3, 1, 0, 0, 0, 1998, 2e3, 3, 464, 232, 0, 1999, 1995, 1, 0, 0, 0, 1999, 1998, 1, 0, 0, 0, 2e3, 233, 1, 0, 0, 0, 2001, 2003, 5, 86, 0, 0, 2002, 2004, 5, 218, 0, 0, 2003, 2002, 1, 0, 0, 0, 2003, 2004, 1, 0, 0, 0, 2004, 2005, 1, 0, 0, 0, 2005, 2007, 5, 20, 0, 0, 2006, 2008, 5, 218, 0, 0, 2007, 2006, 1, 0, 0, 0, 2007, 2008, 1, 0, 0, 0, 2008, 2009, 1, 0, 0, 0, 2009, 2010, 3, 436, 218, 0, 2010, 2011, 5, 218, 0, 0, 2011, 2012, 5, 87, 0, 0, 2012, 2013, 5, 218, 0, 0, 2013, 2015, 3, 336, 168, 0, 2014, 2016, 5, 218, 0, 0, 2015, 2014, 1, 0, 0, 0, 2015, 2016, 1, 0, 0, 0, 2016, 2017, 1, 0, 0, 0, 2017, 2020, 5, 23, 0, 0, 2018, 2019, 5, 218, 0, 0, 2019, 2021, 3, 96, 48, 0, 2020, 2018, 1, 0, 0, 0, 2021, 2022, 1, 0, 0, 0, 2022, 2020, 1, 0, 0, 0, 2022, 2023, 1, 0, 0, 0, 2023, 2025, 1, 0, 0, 0, 2024, 2026, 5, 218, 0, 0, 2025, 2024, 1, 0, 0, 0, 2025, 2026, 1, 0, 0, 0, 2026, 2027, 1, 0, 0, 0, 2027, 2028, 5, 21, 0, 0, 2028, 235, 1, 0, 0, 0, 2029, 2034, 5, 73, 0, 0, 2030, 2032, 5, 218, 0, 0, 2031, 2030, 1, 0, 0, 0, 2031, 2032, 1, 0, 0, 0, 2032, 2033, 1, 0, 0, 0, 2033, 2035, 5, 88, 0, 0, 2034, 2031, 1, 0, 0, 0, 2034, 2035, 1, 0, 0, 0, 2035, 2036, 1, 0, 0, 0, 2036, 2037, 5, 218, 0, 0, 2037, 2042, 3, 240, 120, 0, 2038, 2040, 5, 218, 0, 0, 2039, 2038, 1, 0, 0, 0, 2039, 2040, 1, 0, 0, 0, 2040, 2041, 1, 0, 0, 0, 2041, 2043, 3, 294, 147, 0, 2042, 2039, 1, 0, 0, 0, 2042, 2043, 1, 0, 0, 0, 2043, 237, 1, 0, 0, 0, 2044, 2049, 5, 89, 0, 0, 2045, 2047, 5, 218, 0, 0, 2046, 2045, 1, 0, 0, 0, 2046, 2047, 1, 0, 0, 0, 2047, 2048, 1, 0, 0, 0, 2048, 2050, 5, 88, 0, 0, 2049, 2046, 1, 0, 0, 0, 2049, 2050, 1, 0, 0, 0, 2050, 2052, 1, 0, 0, 0, 2051, 2053, 5, 218, 0, 0, 2052, 2051, 1, 0, 0, 0, 2052, 2053, 1, 0, 0, 0, 2053, 2054, 1, 0, 0, 0, 2054, 2055, 3, 240, 120, 0, 2055, 239, 1, 0, 0, 0, 2056, 2059, 3, 244, 122, 0, 2057, 2058, 5, 218, 0, 0, 2058, 2060, 3, 266, 133, 0, 2059, 2057, 1, 0, 0, 0, 2059, 2060, 1, 0, 0, 0, 2060, 2063, 1, 0, 0, 0, 2061, 2062, 5, 218, 0, 0, 2062, 2064, 3, 268, 134, 0, 2063, 2061, 1, 0, 0, 0, 2063, 2064, 1, 0, 0, 0, 2064, 2067, 1, 0, 0, 0, 2065, 2066, 5, 218, 0, 0, 2066, 2068, 3, 270, 135, 0, 2067, 2065, 1, 0, 0, 0, 2067, 2068, 1, 0, 0, 0, 2068, 241, 1, 0, 0, 0, 2069, 2071, 3, 250, 125, 0, 2070, 2072, 5, 218, 0, 0, 2071, 2070, 1, 0, 0, 0, 2071, 2072, 1, 0, 0, 0, 2072, 2074, 1, 0, 0, 0, 2073, 2075, 3, 256, 128, 0, 2074, 2073, 1, 0, 0, 0, 2074, 2075, 1, 0, 0, 0, 2075, 243, 1, 0, 0, 0, 2076, 2087, 5, 19, 0, 0, 2077, 2079, 5, 218, 0, 0, 2078, 2077, 1, 0, 0, 0, 2078, 2079, 1, 0, 0, 0, 2079, 2080, 1, 0, 0, 0, 2080, 2082, 5, 15, 0, 0, 2081, 2083, 5, 218, 0, 0, 2082, 2081, 1, 0, 0, 0, 2082, 2083, 1, 0, 0, 0, 2083, 2084, 1, 0, 0, 0, 2084, 2086, 3, 246, 123, 0, 2085, 2078, 1, 0, 0, 0, 2086, 2089, 1, 0, 0, 0, 2087, 2085, 1, 0, 0, 0, 2087, 2088, 1, 0, 0, 0, 2088, 2106, 1, 0, 0, 0, 2089, 2087, 1, 0, 0, 0, 2090, 2101, 3, 246, 123, 0, 2091, 2093, 5, 218, 0, 0, 2092, 2091, 1, 0, 0, 0, 2092, 2093, 1, 0, 0, 0, 2093, 2094, 1, 0, 0, 0, 2094, 2096, 5, 15, 0, 0, 2095, 2097, 5, 218, 0, 0, 2096, 2095, 1, 0, 0, 0, 2096, 2097, 1, 0, 0, 0, 2097, 2098, 1, 0, 0, 0, 2098, 2100, 3, 246, 123, 0, 2099, 2092, 1, 0, 0, 0, 2100, 2103, 1, 0, 0, 0, 2101, 2099, 1, 0, 0, 0, 2101, 2102, 1, 0, 0, 0, 2102, 2106, 1, 0, 0, 0, 2103, 2101, 1, 0, 0, 0, 2104, 2106, 3, 242, 121, 0, 2105, 2076, 1, 0, 0, 0, 2105, 2090, 1, 0, 0, 0, 2105, 2104, 1, 0, 0, 0, 2106, 245, 1, 0, 0, 0, 2107, 2108, 3, 336, 168, 0, 2108, 2109, 5, 218, 0, 0, 2109, 2110, 5, 76, 0, 0, 2110, 2111, 5, 218, 0, 0, 2111, 2112, 3, 436, 218, 0, 2112, 2115, 1, 0, 0, 0, 2113, 2115, 3, 336, 168, 0, 2114, 2107, 1, 0, 0, 0, 2114, 2113, 1, 0, 0, 0, 2115, 247, 1, 0, 0, 0, 2116, 2117, 5, 129, 0, 0, 2117, 2118, 5, 218, 0, 0, 2118, 2120, 3, 250, 125, 0, 2119, 2121, 5, 218, 0, 0, 2120, 2119, 1, 0, 0, 0, 2120, 2121, 1, 0, 0, 0, 2121, 2123, 1, 0, 0, 0, 2122, 2124, 3, 256, 128, 0, 2123, 2122, 1, 0, 0, 0, 2123, 2124, 1, 0, 0, 0, 2124, 249, 1, 0, 0, 0, 2125, 2127, 3, 252, 126, 0, 2126, 2128, 5, 218, 0, 0, 2127, 2126, 1, 0, 0, 0, 2127, 2128, 1, 0, 0, 0, 2128, 2130, 1, 0, 0, 0, 2129, 2131, 3, 254, 127, 0, 2130, 2129, 1, 0, 0, 0, 2130, 2131, 1, 0, 0, 0, 2131, 251, 1, 0, 0, 0, 2132, 2133, 3, 474, 237, 0, 2133, 2134, 3, 424, 212, 0, 2134, 253, 1, 0, 0, 0, 2135, 2137, 5, 20, 0, 0, 2136, 2138, 5, 218, 0, 0, 2137, 2136, 1, 0, 0, 0, 2137, 2138, 1, 0, 0, 0, 2138, 2140, 1, 0, 0, 0, 2139, 2141, 3, 336, 168, 0, 2140, 2139, 1, 0, 0, 0, 2140, 2141, 1, 0, 0, 0, 2141, 2152, 1, 0, 0, 0, 2142, 2144, 5, 218, 0, 0, 2143, 2142, 1, 0, 0, 0, 2143, 2144, 1, 0, 0, 0, 2144, 2145, 1, 0, 0, 0, 2145, 2147, 5, 15, 0, 0, 2146, 2148, 5, 218, 0, 0, 2147, 2146, 1, 0, 0, 0, 2147, 2148, 1, 0, 0, 0, 2148, 2149, 1, 0, 0, 0, 2149, 2151, 3, 336, 168, 0, 2150, 2143, 1, 0, 0, 0, 2151, 2154, 1, 0, 0, 0, 2152, 2150, 1, 0, 0, 0, 2152, 2153, 1, 0, 0, 0, 2153, 2156, 1, 0, 0, 0, 2154, 2152, 1, 0, 0, 0, 2155, 2157, 5, 218, 0, 0, 2156, 2155, 1, 0, 0, 0, 2156, 2157, 1, 0, 0, 0, 2157, 2158, 1, 0, 0, 0, 2158, 2159, 5, 21, 0, 0, 2159, 255, 1, 0, 0, 0, 2160, 2161, 5, 130, 0, 0, 2161, 2162, 5, 218, 0, 0, 2162, 2173, 3, 258, 129, 0, 2163, 2165, 5, 218, 0, 0, 2164, 2163, 1, 0, 0, 0, 2164, 2165, 1, 0, 0, 0, 2165, 2166, 1, 0, 0, 0, 2166, 2168, 5, 15, 0, 0, 2167, 2169, 5, 218, 0, 0, 2168, 2167, 1, 0, 0, 0, 2168, 2169, 1, 0, 0, 0, 2169, 2170, 1, 0, 0, 0, 2170, 2172, 3, 258, 129, 0, 2171, 2164, 1, 0, 0, 0, 2172, 2175, 1, 0, 0, 0, 2173, 2171, 1, 0, 0, 0, 2173, 2174, 1, 0, 0, 0, 2174, 2178, 1, 0, 0, 0, 2175, 2173, 1, 0, 0, 0, 2176, 2177, 5, 218, 0, 0, 2177, 2179, 3, 294, 147, 0, 2178, 2176, 1, 0, 0, 0, 2178, 2179, 1, 0, 0, 0, 2179, 257, 1, 0, 0, 0, 2180, 2183, 3, 260, 130, 0, 2181, 2183, 3, 262, 131, 0, 2182, 2180, 1, 0, 0, 0, 2182, 2181, 1, 0, 0, 0, 2183, 259, 1, 0, 0, 0, 2184, 2185, 3, 264, 132, 0, 2185, 2186, 5, 218, 0, 0, 2186, 2187, 5, 76, 0, 0, 2187, 2188, 5, 218, 0, 0, 2188, 2189, 3, 436, 218, 0, 2189, 261, 1, 0, 0, 0, 2190, 2191, 3, 264, 132, 0, 2191, 263, 1, 0, 0, 0, 2192, 2193, 3, 482, 241, 0, 2193, 265, 1, 0, 0, 0, 2194, 2195, 5, 90, 0, 0, 2195, 2196, 5, 218, 0, 0, 2196, 2197, 5, 91, 0, 0, 2197, 2198, 5, 218, 0, 0, 2198, 2209, 3, 272, 136, 0, 2199, 2201, 5, 218, 0, 0, 2200, 2199, 1, 0, 0, 0, 2200, 2201, 1, 0, 0, 0, 2201, 2202, 1, 0, 0, 0, 2202, 2204, 5, 15, 0, 0, 2203, 2205, 5, 218, 0, 0, 2204, 2203, 1, 0, 0, 0, 2204, 2205, 1, 0, 0, 0, 2205, 2206, 1, 0, 0, 0, 2206, 2208, 3, 272, 136, 0, 2207, 2200, 1, 0, 0, 0, 2208, 2211, 1, 0, 0, 0, 2209, 2207, 1, 0, 0, 0, 2209, 2210, 1, 0, 0, 0, 2210, 267, 1, 0, 0, 0, 2211, 2209, 1, 0, 0, 0, 2212, 2213, 5, 92, 0, 0, 2213, 2214, 5, 218, 0, 0, 2214, 2215, 3, 336, 168, 0, 2215, 269, 1, 0, 0, 0, 2216, 2217, 5, 93, 0, 0, 2217, 2218, 5, 218, 0, 0, 2218, 2219, 3, 336, 168, 0, 2219, 271, 1, 0, 0, 0, 2220, 2228, 3, 336, 168, 0, 2221, 2223, 5, 218, 0, 0, 2222, 2221, 1, 0, 0, 0, 2222, 2223, 1, 0, 0, 0, 2223, 2224, 1, 0, 0, 0, 2224, 2226, 7, 13, 0, 0, 2225, 2227, 5, 218, 0, 0, 2226, 2225, 1, 0, 0, 0, 2226, 2227, 1, 0, 0, 0, 2227, 2229, 1, 0, 0, 0, 2228, 2222, 1, 0, 0, 0, 2228, 2229, 1, 0, 0, 0, 2229, 273, 1, 0, 0, 0, 2230, 2232, 5, 218, 0, 0, 2231, 2230, 1, 0, 0, 0, 2231, 2232, 1, 0, 0, 0, 2232, 2279, 1, 0, 0, 0, 2233, 2234, 5, 57, 0, 0, 2234, 2235, 5, 218, 0, 0, 2235, 2236, 5, 64, 0, 0, 2236, 2237, 5, 218, 0, 0, 2237, 2238, 3, 436, 218, 0, 2238, 2240, 3, 328, 164, 0, 2239, 2241, 5, 218, 0, 0, 2240, 2239, 1, 0, 0, 0, 2240, 2241, 1, 0, 0, 0, 2241, 2242, 1, 0, 0, 0, 2242, 2244, 5, 20, 0, 0, 2243, 2245, 5, 218, 0, 0, 2244, 2243, 1, 0, 0, 0, 2244, 2245, 1, 0, 0, 0, 2245, 2246, 1, 0, 0, 0, 2246, 2248, 3, 466, 233, 0, 2247, 2249, 5, 218, 0, 0, 2248, 2247, 1, 0, 0, 0, 2248, 2249, 1, 0, 0, 0, 2249, 2250, 1, 0, 0, 0, 2250, 2251, 5, 21, 0, 0, 2251, 2280, 1, 0, 0, 0, 2252, 2253, 5, 57, 0, 0, 2253, 2254, 5, 218, 0, 0, 2254, 2255, 5, 98, 0, 0, 2255, 2256, 5, 218, 0, 0, 2256, 2257, 5, 65, 0, 0, 2257, 2258, 5, 218, 0, 0, 2258, 2269, 3, 436, 218, 0, 2259, 2261, 5, 218, 0, 0, 2260, 2259, 1, 0, 0, 0, 2260, 2261, 1, 0, 0, 0, 2261, 2262, 1, 0, 0, 0, 2262, 2264, 5, 15, 0, 0, 2263, 2265, 5, 218, 0, 0, 2264, 2263, 1, 0, 0, 0, 2264, 2265, 1, 0, 0, 0, 2265, 2266, 1, 0, 0, 0, 2266, 2268, 3, 436, 218, 0, 2267, 2260, 1, 0, 0, 0, 2268, 2271, 1, 0, 0, 0, 2269, 2267, 1, 0, 0, 0, 2269, 2270, 1, 0, 0, 0, 2270, 2280, 1, 0, 0, 0, 2271, 2269, 1, 0, 0, 0, 2272, 2273, 5, 57, 0, 0, 2273, 2274, 5, 218, 0, 0, 2274, 2275, 5, 99, 0, 0, 2275, 2276, 5, 218, 0, 0, 2276, 2277, 3, 436, 218, 0, 2277, 2278, 3, 328, 164, 0, 2278, 2280, 1, 0, 0, 0, 2279, 2233, 1, 0, 0, 0, 2279, 2252, 1, 0, 0, 0, 2279, 2272, 1, 0, 0, 0, 2280, 275, 1, 0, 0, 0, 2281, 2282, 5, 100, 0, 0, 2282, 2283, 5, 218, 0, 0, 2283, 2294, 3, 278, 139, 0, 2284, 2286, 5, 218, 0, 0, 2285, 2284, 1, 0, 0, 0, 2285, 2286, 1, 0, 0, 0, 2286, 2287, 1, 0, 0, 0, 2287, 2289, 5, 15, 0, 0, 2288, 2290, 5, 218, 0, 0, 2289, 2288, 1, 0, 0, 0, 2289, 2290, 1, 0, 0, 0, 2290, 2291, 1, 0, 0, 0, 2291, 2293, 3, 278, 139, 0, 2292, 2285, 1, 0, 0, 0, 2293, 2296, 1, 0, 0, 0, 2294, 2292, 1, 0, 0, 0, 2294, 2295, 1, 0, 0, 0, 2295, 2298, 1, 0, 0, 0, 2296, 2294, 1, 0, 0, 0, 2297, 2299, 3, 294, 147, 0, 2298, 2297, 1, 0, 0, 0, 2298, 2299, 1, 0, 0, 0, 2299, 277, 1, 0, 0, 0, 2300, 2302, 3, 436, 218, 0, 2301, 2303, 5, 218, 0, 0, 2302, 2301, 1, 0, 0, 0, 2302, 2303, 1, 0, 0, 0, 2303, 2304, 1, 0, 0, 0, 2304, 2306, 5, 12, 0, 0, 2305, 2307, 5, 218, 0, 0, 2306, 2305, 1, 0, 0, 0, 2306, 2307, 1, 0, 0, 0, 2307, 2308, 1, 0, 0, 0, 2308, 2309, 3, 280, 140, 0, 2309, 279, 1, 0, 0, 0, 2310, 2313, 3, 282, 141, 0, 2311, 2313, 3, 284, 142, 0, 2312, 2310, 1, 0, 0, 0, 2312, 2311, 1, 0, 0, 0, 2313, 281, 1, 0, 0, 0, 2314, 2316, 5, 101, 0, 0, 2315, 2317, 5, 218, 0, 0, 2316, 2315, 1, 0, 0, 0, 2316, 2317, 1, 0, 0, 0, 2317, 2321, 1, 0, 0, 0, 2318, 2322, 3, 286, 143, 0, 2319, 2322, 3, 288, 144, 0, 2320, 2322, 3, 290, 145, 0, 2321, 2318, 1, 0, 0, 0, 2321, 2319, 1, 0, 0, 0, 2321, 2320, 1, 0, 0, 0, 2322, 283, 1, 0, 0, 0, 2323, 2327, 7, 14, 0, 0, 2324, 2328, 3, 286, 143, 0, 2325, 2328, 3, 288, 144, 0, 2326, 2328, 3, 290, 145, 0, 2327, 2324, 1, 0, 0, 0, 2327, 2325, 1, 0, 0, 0, 2327, 2326, 1, 0, 0, 0, 2328, 285, 1, 0, 0, 0, 2329, 2330, 5, 2, 0, 0, 2330, 2331, 3, 482, 241, 0, 2331, 2332, 5, 20, 0, 0, 2332, 2333, 3, 482, 241, 0, 2333, 2336, 5, 12, 0, 0, 2334, 2337, 5, 199, 0, 0, 2335, 2337, 3, 454, 227, 0, 2336, 2334, 1, 0, 0, 0, 2336, 2335, 1, 0, 0, 0, 2337, 2338, 1, 0, 0, 0, 2338, 2339, 5, 21, 0, 0, 2339, 287, 1, 0, 0, 0, 2340, 2341, 5, 2, 0, 0, 2341, 2342, 3, 482, 241, 0, 2342, 2345, 5, 20, 0, 0, 2343, 2346, 5, 199, 0, 0, 2344, 2346, 3, 454, 227, 0, 2345, 2343, 1, 0, 0, 0, 2345, 2344, 1, 0, 0, 0, 2346, 2347, 1, 0, 0, 0, 2347, 2348, 5, 21, 0, 0, 2348, 289, 1, 0, 0, 0, 2349, 2353, 5, 20, 0, 0, 2350, 2354, 3, 292, 146, 0, 2351, 2354, 3, 454, 227, 0, 2352, 2354, 5, 19, 0, 0, 2353, 2350, 1, 0, 0, 0, 2353, 2351, 1, 0, 0, 0, 2353, 2352, 1, 0, 0, 0, 2354, 2355, 1, 0, 0, 0, 2355, 2356, 5, 21, 0, 0, 2356, 291, 1, 0, 0, 0, 2357, 2368, 3, 470, 235, 0, 2358, 2360, 5, 218, 0, 0, 2359, 2358, 1, 0, 0, 0, 2359, 2360, 1, 0, 0, 0, 2360, 2361, 1, 0, 0, 0, 2361, 2363, 5, 15, 0, 0, 2362, 2364, 5, 218, 0, 0, 2363, 2362, 1, 0, 0, 0, 2363, 2364, 1, 0, 0, 0, 2364, 2365, 1, 0, 0, 0, 2365, 2367, 3, 470, 235, 0, 2366, 2359, 1, 0, 0, 0, 2367, 2370, 1, 0, 0, 0, 2368, 2366, 1, 0, 0, 0, 2368, 2369, 1, 0, 0, 0, 2369, 293, 1, 0, 0, 0, 2370, 2368, 1, 0, 0, 0, 2371, 2372, 5, 104, 0, 0, 2372, 2373, 5, 218, 0, 0, 2373, 2374, 3, 336, 168, 0, 2374, 295, 1, 0, 0, 0, 2375, 2386, 3, 298, 149, 0, 2376, 2378, 5, 218, 0, 0, 2377, 2376, 1, 0, 0, 0, 2377, 2378, 1, 0, 0, 0, 2378, 2379, 1, 0, 0, 0, 2379, 2381, 5, 15, 0, 0, 2380, 2382, 5, 218, 0, 0, 2381, 2380, 1, 0, 0, 0, 2381, 2382, 1, 0, 0, 0, 2382, 2383, 1, 0, 0, 0, 2383, 2385, 3, 298, 149, 0, 2384, 2377, 1, 0, 0, 0, 2385, 2388, 1, 0, 0, 0, 2386, 2384, 1, 0, 0, 0, 2386, 2387, 1, 0, 0, 0, 2387, 297, 1, 0, 0, 0, 2388, 2386, 1, 0, 0, 0, 2389, 2391, 3, 436, 218, 0, 2390, 2392, 5, 218, 0, 0, 2391, 2390, 1, 0, 0, 0, 2391, 2392, 1, 0, 0, 0, 2392, 2393, 1, 0, 0, 0, 2393, 2395, 5, 12, 0, 0, 2394, 2396, 5, 218, 0, 0, 2395, 2394, 1, 0, 0, 0, 2395, 2396, 1, 0, 0, 0, 2396, 2397, 1, 0, 0, 0, 2397, 2398, 3, 300, 150, 0, 2398, 2401, 1, 0, 0, 0, 2399, 2401, 3, 300, 150, 0, 2400, 2389, 1, 0, 0, 0, 2400, 2399, 1, 0, 0, 0, 2401, 299, 1, 0, 0, 0, 2402, 2405, 3, 392, 196, 0, 2403, 2405, 3, 302, 151, 0, 2404, 2402, 1, 0, 0, 0, 2404, 2403, 1, 0, 0, 0, 2405, 301, 1, 0, 0, 0, 2406, 2413, 3, 304, 152, 0, 2407, 2409, 5, 218, 0, 0, 2408, 2407, 1, 0, 0, 0, 2408, 2409, 1, 0, 0, 0, 2409, 2410, 1, 0, 0, 0, 2410, 2412, 3, 306, 153, 0, 2411, 2408, 1, 0, 0, 0, 2412, 2415, 1, 0, 0, 0, 2413, 2411, 1, 0, 0, 0, 2413, 2414, 1, 0, 0, 0, 2414, 2421, 1, 0, 0, 0, 2415, 2413, 1, 0, 0, 0, 2416, 2417, 5, 20, 0, 0, 2417, 2418, 3, 302, 151, 0, 2418, 2419, 5, 21, 0, 0, 2419, 2421, 1, 0, 0, 0, 2420, 2406, 1, 0, 0, 0, 2420, 2416, 1, 0, 0, 0, 2421, 303, 1, 0, 0, 0, 2422, 2424, 5, 20, 0, 0, 2423, 2425, 5, 218, 0, 0, 2424, 2423, 1, 0, 0, 0, 2424, 2425, 1, 0, 0, 0, 2425, 2430, 1, 0, 0, 0, 2426, 2428, 3, 436, 218, 0, 2427, 2429, 5, 218, 0, 0, 2428, 2427, 1, 0, 0, 0, 2428, 2429, 1, 0, 0, 0, 2429, 2431, 1, 0, 0, 0, 2430, 2426, 1, 0, 0, 0, 2430, 2431, 1, 0, 0, 0, 2431, 2436, 1, 0, 0, 0, 2432, 2434, 3, 326, 163, 0, 2433, 2435, 5, 218, 0, 0, 2434, 2433, 1, 0, 0, 0, 2434, 2435, 1, 0, 0, 0, 2435, 2437, 1, 0, 0, 0, 2436, 2432, 1, 0, 0, 0, 2436, 2437, 1, 0, 0, 0, 2437, 2442, 1, 0, 0, 0, 2438, 2440, 3, 316, 158, 0, 2439, 2441, 5, 218, 0, 0, 2440, 2439, 1, 0, 0, 0, 2440, 2441, 1, 0, 0, 0, 2441, 2443, 1, 0, 0, 0, 2442, 2438, 1, 0, 0, 0, 2442, 2443, 1, 0, 0, 0, 2443, 2444, 1, 0, 0, 0, 2444, 2445, 5, 21, 0, 0, 2445, 305, 1, 0, 0, 0, 2446, 2448, 3, 308, 154, 0, 2447, 2449, 5, 218, 0, 0, 2448, 2447, 1, 0, 0, 0, 2448, 2449, 1, 0, 0, 0, 2449, 2450, 1, 0, 0, 0, 2450, 2451, 3, 304, 152, 0, 2451, 307, 1, 0, 0, 0, 2452, 2454, 3, 310, 155, 0, 2453, 2455, 5, 218, 0, 0, 2454, 2453, 1, 0, 0, 0, 2454, 2455, 1, 0, 0, 0, 2455, 2457, 1, 0, 0, 0, 2456, 2458, 3, 314, 157, 0, 2457, 2456, 1, 0, 0, 0, 2457, 2458, 1, 0, 0, 0, 2458, 2460, 1, 0, 0, 0, 2459, 2461, 5, 218, 0, 0, 2460, 2459, 1, 0, 0, 0, 2460, 2461, 1, 0, 0, 0, 2461, 2462, 1, 0, 0, 0, 2462, 2463, 3, 312, 156, 0, 2463, 309, 1, 0, 0, 0, 2464, 2466, 3, 476, 238, 0, 2465, 2467, 5, 218, 0, 0, 2466, 2465, 1, 0, 0, 0, 2466, 2467, 1, 0, 0, 0, 2467, 2468, 1, 0, 0, 0, 2468, 2469, 3, 480, 240, 0, 2469, 2472, 1, 0, 0, 0, 2470, 2472, 3, 480, 240, 0, 2471, 2464, 1, 0, 0, 0, 2471, 2470, 1, 0, 0, 0, 2472, 311, 1, 0, 0, 0, 2473, 2475, 3, 480, 240, 0, 2474, 2476, 5, 218, 0, 0, 2475, 2474, 1, 0, 0, 0, 2475, 2476, 1, 0, 0, 0, 2476, 2477, 1, 0, 0, 0, 2477, 2478, 3, 478, 239, 0, 2478, 2481, 1, 0, 0, 0, 2479, 2481, 3, 480, 240, 0, 2480, 2473, 1, 0, 0, 0, 2480, 2479, 1, 0, 0, 0, 2481, 313, 1, 0, 0, 0, 2482, 2484, 5, 17, 0, 0, 2483, 2485, 5, 218, 0, 0, 2484, 2483, 1, 0, 0, 0, 2484, 2485, 1, 0, 0, 0, 2485, 2490, 1, 0, 0, 0, 2486, 2488, 3, 436, 218, 0, 2487, 2489, 5, 218, 0, 0, 2488, 2487, 1, 0, 0, 0, 2488, 2489, 1, 0, 0, 0, 2489, 2491, 1, 0, 0, 0, 2490, 2486, 1, 0, 0, 0, 2490, 2491, 1, 0, 0, 0, 2491, 2496, 1, 0, 0, 0, 2492, 2494, 3, 320, 160, 0, 2493, 2495, 5, 218, 0, 0, 2494, 2493, 1, 0, 0, 0, 2494, 2495, 1, 0, 0, 0, 2495, 2497, 1, 0, 0, 0, 2496, 2492, 1, 0, 0, 0, 2496, 2497, 1, 0, 0, 0, 2497, 2499, 1, 0, 0, 0, 2498, 2500, 3, 330, 165, 0, 2499, 2498, 1, 0, 0, 0, 2499, 2500, 1, 0, 0, 0, 2500, 2505, 1, 0, 0, 0, 2501, 2503, 3, 316, 158, 0, 2502, 2504, 5, 218, 0, 0, 2503, 2502, 1, 0, 0, 0, 2503, 2504, 1, 0, 0, 0, 2504, 2506, 1, 0, 0, 0, 2505, 2501, 1, 0, 0, 0, 2505, 2506, 1, 0, 0, 0, 2506, 2507, 1, 0, 0, 0, 2507, 2508, 5, 18, 0, 0, 2508, 315, 1, 0, 0, 0, 2509, 2512, 3, 440, 220, 0, 2510, 2512, 3, 454, 227, 0, 2511, 2509, 1, 0, 0, 0, 2511, 2510, 1, 0, 0, 0, 2512, 317, 1, 0, 0, 0, 2513, 2515, 5, 2, 0, 0, 2514, 2516, 5, 218, 0, 0, 2515, 2514, 1, 0, 0, 0, 2515, 2516, 1, 0, 0, 0, 2516, 2517, 1, 0, 0, 0, 2517, 2518, 3, 334, 167, 0, 2518, 319, 1, 0, 0, 0, 2519, 2527, 3, 322, 161, 0, 2520, 2522, 5, 218, 0, 0, 2521, 2520, 1, 0, 0, 0, 2521, 2522, 1, 0, 0, 0, 2522, 2523, 1, 0, 0, 0, 2523, 2524, 5, 23, 0, 0, 2524, 2526, 3, 324, 162, 0, 2525, 2521, 1, 0, 0, 0, 2526, 2529, 1, 0, 0, 0, 2527, 2525, 1, 0, 0, 0, 2527, 2528, 1, 0, 0, 0, 2528, 321, 1, 0, 0, 0, 2529, 2527, 1, 0, 0, 0, 2530, 2531, 5, 2, 0, 0, 2531, 2532, 3, 334, 167, 0, 2532, 323, 1, 0, 0, 0, 2533, 2535, 5, 2, 0, 0, 2534, 2533, 1, 0, 0, 0, 2534, 2535, 1, 0, 0, 0, 2535, 2536, 1, 0, 0, 0, 2536, 2537, 3, 334, 167, 0, 2537, 325, 1, 0, 0, 0, 2538, 2545, 3, 328, 164, 0, 2539, 2541, 5, 218, 0, 0, 2540, 2539, 1, 0, 0, 0, 2540, 2541, 1, 0, 0, 0, 2541, 2542, 1, 0, 0, 0, 2542, 2544, 3, 328, 164, 0, 2543, 2540, 1, 0, 0, 0, 2544, 2547, 1, 0, 0, 0, 2545, 2543, 1, 0, 0, 0, 2545, 2546, 1, 0, 0, 0, 2546, 327, 1, 0, 0, 0, 2547, 2545, 1, 0, 0, 0, 2548, 2549, 5, 2, 0, 0, 2549, 2550, 3, 332, 166, 0, 2550, 329, 1, 0, 0, 0, 2551, 2553, 5, 19, 0, 0, 2552, 2554, 5, 218, 0, 0, 2553, 2552, 1, 0, 0, 0, 2553, 2554, 1, 0, 0, 0, 2554, 2559, 1, 0, 0, 0, 2555, 2557, 3, 470, 235, 0, 2556, 2558, 5, 218, 0, 0, 2557, 2556, 1, 0, 0, 0, 2557, 2558, 1, 0, 0, 0, 2558, 2560, 1, 0, 0, 0, 2559, 2555, 1, 0, 0, 0, 2559, 2560, 1, 0, 0, 0, 2560, 2571, 1, 0, 0, 0, 2561, 2563, 5, 24, 0, 0, 2562, 2564, 5, 218, 0, 0, 2563, 2562, 1, 0, 0, 0, 2563, 2564, 1, 0, 0, 0, 2564, 2569, 1, 0, 0, 0, 2565, 2567, 3, 470, 235, 0, 2566, 2568, 5, 218, 0, 0, 2567, 2566, 1, 0, 0, 0, 2567, 2568, 1, 0, 0, 0, 2568, 2570, 1, 0, 0, 0, 2569, 2565, 1, 0, 0, 0, 2569, 2570, 1, 0, 0, 0, 2570, 2572, 1, 0, 0, 0, 2571, 2561, 1, 0, 0, 0, 2571, 2572, 1, 0, 0, 0, 2572, 331, 1, 0, 0, 0, 2573, 2574, 3, 482, 241, 0, 2574, 333, 1, 0, 0, 0, 2575, 2576, 3, 482, 241, 0, 2576, 335, 1, 0, 0, 0, 2577, 2578, 3, 338, 169, 0, 2578, 337, 1, 0, 0, 0, 2579, 2586, 3, 340, 170, 0, 2580, 2581, 5, 218, 0, 0, 2581, 2582, 5, 107, 0, 0, 2582, 2583, 5, 218, 0, 0, 2583, 2585, 3, 340, 170, 0, 2584, 2580, 1, 0, 0, 0, 2585, 2588, 1, 0, 0, 0, 2586, 2584, 1, 0, 0, 0, 2586, 2587, 1, 0, 0, 0, 2587, 339, 1, 0, 0, 0, 2588, 2586, 1, 0, 0, 0, 2589, 2596, 3, 342, 171, 0, 2590, 2591, 5, 218, 0, 0, 2591, 2592, 5, 108, 0, 0, 2592, 2593, 5, 218, 0, 0, 2593, 2595, 3, 342, 171, 0, 2594, 2590, 1, 0, 0, 0, 2595, 2598, 1, 0, 0, 0, 2596, 2594, 1, 0, 0, 0, 2596, 2597, 1, 0, 0, 0, 2597, 341, 1, 0, 0, 0, 2598, 2596, 1, 0, 0, 0, 2599, 2606, 3, 344, 172, 0, 2600, 2601, 5, 218, 0, 0, 2601, 2602, 5, 109, 0, 0, 2602, 2603, 5, 218, 0, 0, 2603, 2605, 3, 344, 172, 0, 2604, 2600, 1, 0, 0, 0, 2605, 2608, 1, 0, 0, 0, 2606, 2604, 1, 0, 0, 0, 2606, 2607, 1, 0, 0, 0, 2607, 343, 1, 0, 0, 0, 2608, 2606, 1, 0, 0, 0, 2609, 2611, 5, 110, 0, 0, 2610, 2612, 5, 218, 0, 0, 2611, 2610, 1, 0, 0, 0, 2611, 2612, 1, 0, 0, 0, 2612, 2614, 1, 0, 0, 0, 2613, 2609, 1, 0, 0, 0, 2614, 2617, 1, 0, 0, 0, 2615, 2613, 1, 0, 0, 0, 2615, 2616, 1, 0, 0, 0, 2616, 2618, 1, 0, 0, 0, 2617, 2615, 1, 0, 0, 0, 2618, 2619, 3, 346, 173, 0, 2619, 345, 1, 0, 0, 0, 2620, 2627, 3, 348, 174, 0, 2621, 2623, 5, 218, 0, 0, 2622, 2621, 1, 0, 0, 0, 2622, 2623, 1, 0, 0, 0, 2623, 2624, 1, 0, 0, 0, 2624, 2626, 3, 408, 204, 0, 2625, 2622, 1, 0, 0, 0, 2626, 2629, 1, 0, 0, 0, 2627, 2625, 1, 0, 0, 0, 2627, 2628, 1, 0, 0, 0, 2628, 347, 1, 0, 0, 0, 2629, 2627, 1, 0, 0, 0, 2630, 2649, 3, 350, 175, 0, 2631, 2633, 5, 218, 0, 0, 2632, 2631, 1, 0, 0, 0, 2632, 2633, 1, 0, 0, 0, 2633, 2634, 1, 0, 0, 0, 2634, 2636, 5, 13, 0, 0, 2635, 2637, 5, 218, 0, 0, 2636, 2635, 1, 0, 0, 0, 2636, 2637, 1, 0, 0, 0, 2637, 2638, 1, 0, 0, 0, 2638, 2648, 3, 350, 175, 0, 2639, 2641, 5, 218, 0, 0, 2640, 2639, 1, 0, 0, 0, 2640, 2641, 1, 0, 0, 0, 2641, 2642, 1, 0, 0, 0, 2642, 2644, 5, 3, 0, 0, 2643, 2645, 5, 218, 0, 0, 2644, 2643, 1, 0, 0, 0, 2644, 2645, 1, 0, 0, 0, 2645, 2646, 1, 0, 0, 0, 2646, 2648, 3, 350, 175, 0, 2647, 2632, 1, 0, 0, 0, 2647, 2640, 1, 0, 0, 0, 2648, 2651, 1, 0, 0, 0, 2649, 2647, 1, 0, 0, 0, 2649, 2650, 1, 0, 0, 0, 2650, 349, 1, 0, 0, 0, 2651, 2649, 1, 0, 0, 0, 2652, 2679, 3, 352, 176, 0, 2653, 2655, 5, 218, 0, 0, 2654, 2653, 1, 0, 0, 0, 2654, 2655, 1, 0, 0, 0, 2655, 2656, 1, 0, 0, 0, 2656, 2658, 5, 19, 0, 0, 2657, 2659, 5, 218, 0, 0, 2658, 2657, 1, 0, 0, 0, 2658, 2659, 1, 0, 0, 0, 2659, 2660, 1, 0, 0, 0, 2660, 2678, 3, 352, 176, 0, 2661, 2663, 5, 218, 0, 0, 2662, 2661, 1, 0, 0, 0, 2662, 2663, 1, 0, 0, 0, 2663, 2664, 1, 0, 0, 0, 2664, 2666, 5, 6, 0, 0, 2665, 2667, 5, 218, 0, 0, 2666, 2665, 1, 0, 0, 0, 2666, 2667, 1, 0, 0, 0, 2667, 2668, 1, 0, 0, 0, 2668, 2678, 3, 352, 176, 0, 2669, 2671, 5, 218, 0, 0, 2670, 2669, 1, 0, 0, 0, 2670, 2671, 1, 0, 0, 0, 2671, 2672, 1, 0, 0, 0, 2672, 2674, 5, 25, 0, 0, 2673, 2675, 5, 218, 0, 0, 2674, 2673, 1, 0, 0, 0, 2674, 2675, 1, 0, 0, 0, 2675, 2676, 1, 0, 0, 0, 2676, 2678, 3, 352, 176, 0, 2677, 2654, 1, 0, 0, 0, 2677, 2662, 1, 0, 0, 0, 2677, 2670, 1, 0, 0, 0, 2678, 2681, 1, 0, 0, 0, 2679, 2677, 1, 0, 0, 0, 2679, 2680, 1, 0, 0, 0, 2680, 351, 1, 0, 0, 0, 2681, 2679, 1, 0, 0, 0, 2682, 2693, 3, 354, 177, 0, 2683, 2685, 5, 218, 0, 0, 2684, 2683, 1, 0, 0, 0, 2684, 2685, 1, 0, 0, 0, 2685, 2686, 1, 0, 0, 0, 2686, 2688, 5, 26, 0, 0, 2687, 2689, 5, 218, 0, 0, 2688, 2687, 1, 0, 0, 0, 2688, 2689, 1, 0, 0, 0, 2689, 2690, 1, 0, 0, 0, 2690, 2692, 3, 354, 177, 0, 2691, 2684, 1, 0, 0, 0, 2692, 2695, 1, 0, 0, 0, 2693, 2691, 1, 0, 0, 0, 2693, 2694, 1, 0, 0, 0, 2694, 353, 1, 0, 0, 0, 2695, 2693, 1, 0, 0, 0, 2696, 2698, 7, 15, 0, 0, 2697, 2699, 5, 218, 0, 0, 2698, 2697, 1, 0, 0, 0, 2698, 2699, 1, 0, 0, 0, 2699, 2701, 1, 0, 0, 0, 2700, 2696, 1, 0, 0, 0, 2701, 2704, 1, 0, 0, 0, 2702, 2700, 1, 0, 0, 0, 2702, 2703, 1, 0, 0, 0, 2703, 2705, 1, 0, 0, 0, 2704, 2702, 1, 0, 0, 0, 2705, 2706, 3, 356, 178, 0, 2706, 355, 1, 0, 0, 0, 2707, 2761, 3, 358, 179, 0, 2708, 2710, 5, 218, 0, 0, 2709, 2708, 1, 0, 0, 0, 2709, 2710, 1, 0, 0, 0, 2710, 2711, 1, 0, 0, 0, 2711, 2712, 5, 17, 0, 0, 2712, 2713, 3, 336, 168, 0, 2713, 2714, 5, 18, 0, 0, 2714, 2760, 1, 0, 0, 0, 2715, 2717, 5, 218, 0, 0, 2716, 2715, 1, 0, 0, 0, 2716, 2717, 1, 0, 0, 0, 2717, 2718, 1, 0, 0, 0, 2718, 2720, 5, 17, 0, 0, 2719, 2721, 3, 336, 168, 0, 2720, 2719, 1, 0, 0, 0, 2720, 2721, 1, 0, 0, 0, 2721, 2722, 1, 0, 0, 0, 2722, 2724, 5, 24, 0, 0, 2723, 2725, 3, 336, 168, 0, 2724, 2723, 1, 0, 0, 0, 2724, 2725, 1, 0, 0, 0, 2725, 2726, 1, 0, 0, 0, 2726, 2760, 5, 18, 0, 0, 2727, 2729, 5, 218, 0, 0, 2728, 2727, 1, 0, 0, 0, 2728, 2729, 1, 0, 0, 0, 2729, 2730, 1, 0, 0, 0, 2730, 2744, 5, 27, 0, 0, 2731, 2732, 5, 218, 0, 0, 2732, 2744, 5, 87, 0, 0, 2733, 2734, 5, 218, 0, 0, 2734, 2735, 5, 111, 0, 0, 2735, 2736, 5, 218, 0, 0, 2736, 2744, 5, 73, 0, 0, 2737, 2738, 5, 218, 0, 0, 2738, 2739, 5, 112, 0, 0, 2739, 2740, 5, 218, 0, 0, 2740, 2744, 5, 73, 0, 0, 2741, 2742, 5, 218, 0, 0, 2742, 2744, 5, 113, 0, 0, 2743, 2728, 1, 0, 0, 0, 2743, 2731, 1, 0, 0, 0, 2743, 2733, 1, 0, 0, 0, 2743, 2737, 1, 0, 0, 0, 2743, 2741, 1, 0, 0, 0, 2744, 2746, 1, 0, 0, 0, 2745, 2747, 5, 218, 0, 0, 2746, 2745, 1, 0, 0, 0, 2746, 2747, 1, 0, 0, 0, 2747, 2748, 1, 0, 0, 0, 2748, 2760, 3, 358, 179, 0, 2749, 2750, 5, 218, 0, 0, 2750, 2751, 5, 68, 0, 0, 2751, 2752, 5, 218, 0, 0, 2752, 2760, 5, 114, 0, 0, 2753, 2754, 5, 218, 0, 0, 2754, 2755, 5, 68, 0, 0, 2755, 2756, 5, 218, 0, 0, 2756, 2757, 5, 110, 0, 0, 2757, 2758, 5, 218, 0, 0, 2758, 2760, 5, 114, 0, 0, 2759, 2709, 1, 0, 0, 0, 2759, 2716, 1, 0, 0, 0, 2759, 2743, 1, 0, 0, 0, 2759, 2749, 1, 0, 0, 0, 2759, 2753, 1, 0, 0, 0, 2760, 2763, 1, 0, 0, 0, 2761, 2759, 1, 0, 0, 0, 2761, 2762, 1, 0, 0, 0, 2762, 357, 1, 0, 0, 0, 2763, 2761, 1, 0, 0, 0, 2764, 2774, 3, 398, 199, 0, 2765, 2767, 5, 218, 0, 0, 2766, 2765, 1, 0, 0, 0, 2766, 2767, 1, 0, 0, 0, 2767, 2770, 1, 0, 0, 0, 2768, 2771, 3, 430, 215, 0, 2769, 2771, 3, 326, 163, 0, 2770, 2768, 1, 0, 0, 0, 2770, 2769, 1, 0, 0, 0, 2771, 2773, 1, 0, 0, 0, 2772, 2766, 1, 0, 0, 0, 2773, 2776, 1, 0, 0, 0, 2774, 2772, 1, 0, 0, 0, 2774, 2775, 1, 0, 0, 0, 2775, 359, 1, 0, 0, 0, 2776, 2774, 1, 0, 0, 0, 2777, 2779, 3, 362, 181, 0, 2778, 2780, 5, 218, 0, 0, 2779, 2778, 1, 0, 0, 0, 2779, 2780, 1, 0, 0, 0, 2780, 2781, 1, 0, 0, 0, 2781, 2783, 5, 20, 0, 0, 2782, 2784, 5, 218, 0, 0, 2783, 2782, 1, 0, 0, 0, 2783, 2784, 1, 0, 0, 0, 2784, 2785, 1, 0, 0, 0, 2785, 2787, 3, 414, 207, 0, 2786, 2788, 5, 218, 0, 0, 2787, 2786, 1, 0, 0, 0, 2787, 2788, 1, 0, 0, 0, 2788, 2789, 1, 0, 0, 0, 2789, 2790, 5, 21, 0, 0, 2790, 361, 1, 0, 0, 0, 2791, 2792, 5, 116, 0, 0, 2792, 363, 1, 0, 0, 0, 2793, 2795, 3, 366, 183, 0, 2794, 2796, 5, 218, 0, 0, 2795, 2794, 1, 0, 0, 0, 2795, 2796, 1, 0, 0, 0, 2796, 2797, 1, 0, 0, 0, 2797, 2799, 5, 20, 0, 0, 2798, 2800, 5, 218, 0, 0, 2799, 2798, 1, 0, 0, 0, 2799, 2800, 1, 0, 0, 0, 2800, 2801, 1, 0, 0, 0, 2801, 2803, 3, 336, 168, 0, 2802, 2804, 5, 218, 0, 0, 2803, 2802, 1, 0, 0, 0, 2803, 2804, 1, 0, 0, 0, 2804, 2805, 1, 0, 0, 0, 2805, 2806, 5, 21, 0, 0, 2806, 365, 1, 0, 0, 0, 2807, 2808, 5, 70, 0, 0, 2808, 367, 1, 0, 0, 0, 2809, 2811, 3, 370, 185, 0, 2810, 2812, 5, 218, 0, 0, 2811, 2810, 1, 0, 0, 0, 2811, 2812, 1, 0, 0, 0, 2812, 2813, 1, 0, 0, 0, 2813, 2815, 5, 20, 0, 0, 2814, 2816, 5, 218, 0, 0, 2815, 2814, 1, 0, 0, 0, 2815, 2816, 1, 0, 0, 0, 2816, 2817, 1, 0, 0, 0, 2817, 2819, 3, 414, 207, 0, 2818, 2820, 5, 218, 0, 0, 2819, 2818, 1, 0, 0, 0, 2819, 2820, 1, 0, 0, 0, 2820, 2821, 1, 0, 0, 0, 2821, 2822, 5, 21, 0, 0, 2822, 369, 1, 0, 0, 0, 2823, 2824, 5, 61, 0, 0, 2824, 371, 1, 0, 0, 0, 2825, 2827, 3, 374, 187, 0, 2826, 2828, 5, 218, 0, 0, 2827, 2826, 1, 0, 0, 0, 2827, 2828, 1, 0, 0, 0, 2828, 2829, 1, 0, 0, 0, 2829, 2831, 5, 20, 0, 0, 2830, 2832, 5, 218, 0, 0, 2831, 2830, 1, 0, 0, 0, 2831, 2832, 1, 0, 0, 0, 2832, 2833, 1, 0, 0, 0, 2833, 2835, 3, 414, 207, 0, 2834, 2836, 5, 218, 0, 0, 2835, 2834, 1, 0, 0, 0, 2835, 2836, 1, 0, 0, 0, 2836, 2837, 1, 0, 0, 0, 2837, 2838, 5, 21, 0, 0, 2838, 373, 1, 0, 0, 0, 2839, 2840, 5, 118, 0, 0, 2840, 375, 1, 0, 0, 0, 2841, 2843, 3, 378, 189, 0, 2842, 2844, 5, 218, 0, 0, 2843, 2842, 1, 0, 0, 0, 2843, 2844, 1, 0, 0, 0, 2844, 2845, 1, 0, 0, 0, 2845, 2847, 5, 20, 0, 0, 2846, 2848, 5, 218, 0, 0, 2847, 2846, 1, 0, 0, 0, 2847, 2848, 1, 0, 0, 0, 2848, 2849, 1, 0, 0, 0, 2849, 2851, 3, 414, 207, 0, 2850, 2852, 5, 218, 0, 0, 2851, 2850, 1, 0, 0, 0, 2851, 2852, 1, 0, 0, 0, 2852, 2853, 1, 0, 0, 0, 2853, 2854, 5, 21, 0, 0, 2854, 377, 1, 0, 0, 0, 2855, 2856, 5, 119, 0, 0, 2856, 379, 1, 0, 0, 0, 2857, 2859, 3, 382, 191, 0, 2858, 2860, 5, 218, 0, 0, 2859, 2858, 1, 0, 0, 0, 2859, 2860, 1, 0, 0, 0, 2860, 2861, 1, 0, 0, 0, 2861, 2863, 5, 20, 0, 0, 2862, 2864, 5, 218, 0, 0, 2863, 2862, 1, 0, 0, 0, 2863, 2864, 1, 0, 0, 0, 2864, 2865, 1, 0, 0, 0, 2865, 2867, 3, 414, 207, 0, 2866, 2868, 5, 218, 0, 0, 2867, 2866, 1, 0, 0, 0, 2867, 2868, 1, 0, 0, 0, 2868, 2869, 1, 0, 0, 0, 2869, 2870, 5, 21, 0, 0, 2870, 381, 1, 0, 0, 0, 2871, 2872, 5, 120, 0, 0, 2872, 383, 1, 0, 0, 0, 2873, 2875, 3, 386, 193, 0, 2874, 2876, 5, 218, 0, 0, 2875, 2874, 1, 0, 0, 0, 2875, 2876, 1, 0, 0, 0, 2876, 2877, 1, 0, 0, 0, 2877, 2879, 5, 20, 0, 0, 2878, 2880, 5, 218, 0, 0, 2879, 2878, 1, 0, 0, 0, 2879, 2880, 1, 0, 0, 0, 2880, 2881, 1, 0, 0, 0, 2881, 2890, 3, 414, 207, 0, 2882, 2884, 5, 218, 0, 0, 2883, 2882, 1, 0, 0, 0, 2883, 2884, 1, 0, 0, 0, 2884, 2885, 1, 0, 0, 0, 2885, 2887, 5, 23, 0, 0, 2886, 2888, 5, 218, 0, 0, 2887, 2886, 1, 0, 0, 0, 2887, 2888, 1, 0, 0, 0, 2888, 2889, 1, 0, 0, 0, 2889, 2891, 3, 336, 168, 0, 2890, 2883, 1, 0, 0, 0, 2890, 2891, 1, 0, 0, 0, 2891, 2893, 1, 0, 0, 0, 2892, 2894, 5, 218, 0, 0, 2893, 2892, 1, 0, 0, 0, 2893, 2894, 1, 0, 0, 0, 2894, 2895, 1, 0, 0, 0, 2895, 2896, 5, 21, 0, 0, 2896, 385, 1, 0, 0, 0, 2897, 2898, 5, 117, 0, 0, 2898, 387, 1, 0, 0, 0, 2899, 2901, 3, 390, 195, 0, 2900, 2902, 5, 218, 0, 0, 2901, 2900, 1, 0, 0, 0, 2901, 2902, 1, 0, 0, 0, 2902, 2903, 1, 0, 0, 0, 2903, 2905, 5, 20, 0, 0, 2904, 2906, 5, 218, 0, 0, 2905, 2904, 1, 0, 0, 0, 2905, 2906, 1, 0, 0, 0, 2906, 2907, 1, 0, 0, 0, 2907, 2909, 3, 436, 218, 0, 2908, 2910, 5, 218, 0, 0, 2909, 2908, 1, 0, 0, 0, 2909, 2910, 1, 0, 0, 0, 2910, 2911, 1, 0, 0, 0, 2911, 2913, 5, 12, 0, 0, 2912, 2914, 5, 218, 0, 0, 2913, 2912, 1, 0, 0, 0, 2913, 2914, 1, 0, 0, 0, 2914, 2915, 1, 0, 0, 0, 2915, 2917, 3, 336, 168, 0, 2916, 2918, 5, 218, 0, 0, 2917, 2916, 1, 0, 0, 0, 2917, 2918, 1, 0, 0, 0, 2918, 2919, 1, 0, 0, 0, 2919, 2921, 5, 15, 0, 0, 2920, 2922, 5, 218, 0, 0, 2921, 2920, 1, 0, 0, 0, 2921, 2922, 1, 0, 0, 0, 2922, 2923, 1, 0, 0, 0, 2923, 2925, 3, 416, 208, 0, 2924, 2926, 5, 218, 0, 0, 2925, 2924, 1, 0, 0, 0, 2925, 2926, 1, 0, 0, 0, 2926, 2927, 1, 0, 0, 0, 2927, 2929, 5, 23, 0, 0, 2928, 2930, 5, 218, 0, 0, 2929, 2928, 1, 0, 0, 0, 2929, 2930, 1, 0, 0, 0, 2930, 2931, 1, 0, 0, 0, 2931, 2933, 3, 336, 168, 0, 2932, 2934, 5, 218, 0, 0, 2933, 2932, 1, 0, 0, 0, 2933, 2934, 1, 0, 0, 0, 2934, 2935, 1, 0, 0, 0, 2935, 2936, 5, 21, 0, 0, 2936, 389, 1, 0, 0, 0, 2937, 2938, 5, 123, 0, 0, 2938, 391, 1, 0, 0, 0, 2939, 2941, 3, 394, 197, 0, 2940, 2942, 5, 218, 0, 0, 2941, 2940, 1, 0, 0, 0, 2941, 2942, 1, 0, 0, 0, 2942, 2943, 1, 0, 0, 0, 2943, 2945, 5, 20, 0, 0, 2944, 2946, 5, 218, 0, 0, 2945, 2944, 1, 0, 0, 0, 2945, 2946, 1, 0, 0, 0, 2946, 2947, 1, 0, 0, 0, 2947, 2949, 3, 302, 151, 0, 2948, 2950, 5, 218, 0, 0, 2949, 2948, 1, 0, 0, 0, 2949, 2950, 1, 0, 0, 0, 2950, 2951, 1, 0, 0, 0, 2951, 2952, 5, 21, 0, 0, 2952, 2968, 1, 0, 0, 0, 2953, 2955, 3, 396, 198, 0, 2954, 2956, 5, 218, 0, 0, 2955, 2954, 1, 0, 0, 0, 2955, 2956, 1, 0, 0, 0, 2956, 2957, 1, 0, 0, 0, 2957, 2959, 5, 20, 0, 0, 2958, 2960, 5, 218, 0, 0, 2959, 2958, 1, 0, 0, 0, 2959, 2960, 1, 0, 0, 0, 2960, 2961, 1, 0, 0, 0, 2961, 2963, 3, 302, 151, 0, 2962, 2964, 5, 218, 0, 0, 2963, 2962, 1, 0, 0, 0, 2963, 2964, 1, 0, 0, 0, 2964, 2965, 1, 0, 0, 0, 2965, 2966, 5, 21, 0, 0, 2966, 2968, 1, 0, 0, 0, 2967, 2939, 1, 0, 0, 0, 2967, 2953, 1, 0, 0, 0, 2968, 393, 1, 0, 0, 0, 2969, 2970, 5, 105, 0, 0, 2970, 395, 1, 0, 0, 0, 2971, 2972, 5, 106, 0, 0, 2972, 397, 1, 0, 0, 0, 2973, 3005, 3, 400, 200, 0, 2974, 3005, 3, 454, 227, 0, 2975, 3005, 3, 432, 216, 0, 2976, 2978, 5, 115, 0, 0, 2977, 2979, 5, 218, 0, 0, 2978, 2977, 1, 0, 0, 0, 2978, 2979, 1, 0, 0, 0, 2979, 2980, 1, 0, 0, 0, 2980, 2982, 5, 20, 0, 0, 2981, 2983, 5, 218, 0, 0, 2982, 2981, 1, 0, 0, 0, 2982, 2983, 1, 0, 0, 0, 2983, 2984, 1, 0, 0, 0, 2984, 2986, 5, 19, 0, 0, 2985, 2987, 5, 218, 0, 0, 2986, 2985, 1, 0, 0, 0, 2986, 2987, 1, 0, 0, 0, 2987, 2988, 1, 0, 0, 0, 2988, 3005, 5, 21, 0, 0, 2989, 3005, 3, 426, 213, 0, 2990, 3005, 3, 428, 214, 0, 2991, 3005, 3, 360, 180, 0, 2992, 3005, 3, 384, 192, 0, 2993, 3005, 3, 388, 194, 0, 2994, 3005, 3, 368, 184, 0, 2995, 3005, 3, 372, 186, 0, 2996, 3005, 3, 376, 188, 0, 2997, 3005, 3, 380, 190, 0, 2998, 3005, 3, 364, 182, 0, 2999, 3005, 3, 392, 196, 0, 3e3, 3005, 3, 412, 206, 0, 3001, 3005, 3, 410, 205, 0, 3002, 3005, 3, 418, 209, 0, 3003, 3005, 3, 436, 218, 0, 3004, 2973, 1, 0, 0, 0, 3004, 2974, 1, 0, 0, 0, 3004, 2975, 1, 0, 0, 0, 3004, 2976, 1, 0, 0, 0, 3004, 2989, 1, 0, 0, 0, 3004, 2990, 1, 0, 0, 0, 3004, 2991, 1, 0, 0, 0, 3004, 2992, 1, 0, 0, 0, 3004, 2993, 1, 0, 0, 0, 3004, 2994, 1, 0, 0, 0, 3004, 2995, 1, 0, 0, 0, 3004, 2996, 1, 0, 0, 0, 3004, 2997, 1, 0, 0, 0, 3004, 2998, 1, 0, 0, 0, 3004, 2999, 1, 0, 0, 0, 3004, 3e3, 1, 0, 0, 0, 3004, 3001, 1, 0, 0, 0, 3004, 3002, 1, 0, 0, 0, 3004, 3003, 1, 0, 0, 0, 3005, 399, 1, 0, 0, 0, 3006, 3014, 3, 438, 219, 0, 3007, 3014, 3, 402, 201, 0, 3008, 3014, 3, 404, 202, 0, 3009, 3014, 5, 114, 0, 0, 3010, 3014, 3, 440, 220, 0, 3011, 3014, 3, 406, 203, 0, 3012, 3014, 3, 442, 221, 0, 3013, 3006, 1, 0, 0, 0, 3013, 3007, 1, 0, 0, 0, 3013, 3008, 1, 0, 0, 0, 3013, 3009, 1, 0, 0, 0, 3013, 3010, 1, 0, 0, 0, 3013, 3011, 1, 0, 0, 0, 3013, 3012, 1, 0, 0, 0, 3014, 401, 1, 0, 0, 0, 3015, 3016, 5, 199, 0, 0, 3016, 403, 1, 0, 0, 0, 3017, 3018, 7, 16, 0, 0, 3018, 405, 1, 0, 0, 0, 3019, 3021, 5, 17, 0, 0, 3020, 3022, 5, 218, 0, 0, 3021, 3020, 1, 0, 0, 0, 3021, 3022, 1, 0, 0, 0, 3022, 3040, 1, 0, 0, 0, 3023, 3025, 3, 336, 168, 0, 3024, 3026, 5, 218, 0, 0, 3025, 3024, 1, 0, 0, 0, 3025, 3026, 1, 0, 0, 0, 3026, 3037, 1, 0, 0, 0, 3027, 3029, 5, 15, 0, 0, 3028, 3030, 5, 218, 0, 0, 3029, 3028, 1, 0, 0, 0, 3029, 3030, 1, 0, 0, 0, 3030, 3031, 1, 0, 0, 0, 3031, 3033, 3, 336, 168, 0, 3032, 3034, 5, 218, 0, 0, 3033, 3032, 1, 0, 0, 0, 3033, 3034, 1, 0, 0, 0, 3034, 3036, 1, 0, 0, 0, 3035, 3027, 1, 0, 0, 0, 3036, 3039, 1, 0, 0, 0, 3037, 3035, 1, 0, 0, 0, 3037, 3038, 1, 0, 0, 0, 3038, 3041, 1, 0, 0, 0, 3039, 3037, 1, 0, 0, 0, 3040, 3023, 1, 0, 0, 0, 3040, 3041, 1, 0, 0, 0, 3041, 3042, 1, 0, 0, 0, 3042, 3043, 5, 18, 0, 0, 3043, 407, 1, 0, 0, 0, 3044, 3046, 5, 12, 0, 0, 3045, 3047, 5, 218, 0, 0, 3046, 3045, 1, 0, 0, 0, 3046, 3047, 1, 0, 0, 0, 3047, 3048, 1, 0, 0, 0, 3048, 3080, 3, 348, 174, 0, 3049, 3051, 5, 28, 0, 0, 3050, 3052, 5, 218, 0, 0, 3051, 3050, 1, 0, 0, 0, 3051, 3052, 1, 0, 0, 0, 3052, 3053, 1, 0, 0, 0, 3053, 3080, 3, 348, 174, 0, 3054, 3056, 5, 29, 0, 0, 3055, 3057, 5, 218, 0, 0, 3056, 3055, 1, 0, 0, 0, 3056, 3057, 1, 0, 0, 0, 3057, 3058, 1, 0, 0, 0, 3058, 3080, 3, 348, 174, 0, 3059, 3061, 5, 30, 0, 0, 3060, 3062, 5, 218, 0, 0, 3061, 3060, 1, 0, 0, 0, 3061, 3062, 1, 0, 0, 0, 3062, 3063, 1, 0, 0, 0, 3063, 3080, 3, 348, 174, 0, 3064, 3066, 5, 31, 0, 0, 3065, 3067, 5, 218, 0, 0, 3066, 3065, 1, 0, 0, 0, 3066, 3067, 1, 0, 0, 0, 3067, 3068, 1, 0, 0, 0, 3068, 3080, 3, 348, 174, 0, 3069, 3071, 5, 32, 0, 0, 3070, 3072, 5, 218, 0, 0, 3071, 3070, 1, 0, 0, 0, 3071, 3072, 1, 0, 0, 0, 3072, 3073, 1, 0, 0, 0, 3073, 3080, 3, 348, 174, 0, 3074, 3076, 5, 33, 0, 0, 3075, 3077, 5, 218, 0, 0, 3076, 3075, 1, 0, 0, 0, 3076, 3077, 1, 0, 0, 0, 3077, 3078, 1, 0, 0, 0, 3078, 3080, 3, 348, 174, 0, 3079, 3044, 1, 0, 0, 0, 3079, 3049, 1, 0, 0, 0, 3079, 3054, 1, 0, 0, 0, 3079, 3059, 1, 0, 0, 0, 3079, 3064, 1, 0, 0, 0, 3079, 3069, 1, 0, 0, 0, 3079, 3074, 1, 0, 0, 0, 3080, 409, 1, 0, 0, 0, 3081, 3083, 5, 20, 0, 0, 3082, 3084, 5, 218, 0, 0, 3083, 3082, 1, 0, 0, 0, 3083, 3084, 1, 0, 0, 0, 3084, 3085, 1, 0, 0, 0, 3085, 3087, 3, 336, 168, 0, 3086, 3088, 5, 218, 0, 0, 3087, 3086, 1, 0, 0, 0, 3087, 3088, 1, 0, 0, 0, 3088, 3089, 1, 0, 0, 0, 3089, 3090, 5, 21, 0, 0, 3090, 411, 1, 0, 0, 0, 3091, 3096, 3, 304, 152, 0, 3092, 3094, 5, 218, 0, 0, 3093, 3092, 1, 0, 0, 0, 3093, 3094, 1, 0, 0, 0, 3094, 3095, 1, 0, 0, 0, 3095, 3097, 3, 306, 153, 0, 3096, 3093, 1, 0, 0, 0, 3097, 3098, 1, 0, 0, 0, 3098, 3096, 1, 0, 0, 0, 3098, 3099, 1, 0, 0, 0, 3099, 413, 1, 0, 0, 0, 3100, 3105, 3, 416, 208, 0, 3101, 3103, 5, 218, 0, 0, 3102, 3101, 1, 0, 0, 0, 3102, 3103, 1, 0, 0, 0, 3103, 3104, 1, 0, 0, 0, 3104, 3106, 3, 294, 147, 0, 3105, 3102, 1, 0, 0, 0, 3105, 3106, 1, 0, 0, 0, 3106, 415, 1, 0, 0, 0, 3107, 3108, 3, 436, 218, 0, 3108, 3109, 5, 218, 0, 0, 3109, 3110, 5, 87, 0, 0, 3110, 3111, 5, 218, 0, 0, 3111, 3112, 3, 336, 168, 0, 3112, 417, 1, 0, 0, 0, 3113, 3115, 3, 420, 210, 0, 3114, 3116, 5, 218, 0, 0, 3115, 3114, 1, 0, 0, 0, 3115, 3116, 1, 0, 0, 0, 3116, 3117, 1, 0, 0, 0, 3117, 3119, 5, 20, 0, 0, 3118, 3120, 5, 218, 0, 0, 3119, 3118, 1, 0, 0, 0, 3119, 3120, 1, 0, 0, 0, 3120, 3125, 1, 0, 0, 0, 3121, 3123, 5, 88, 0, 0, 3122, 3124, 5, 218, 0, 0, 3123, 3122, 1, 0, 0, 0, 3123, 3124, 1, 0, 0, 0, 3124, 3126, 1, 0, 0, 0, 3125, 3121, 1, 0, 0, 0, 3125, 3126, 1, 0, 0, 0, 3126, 3144, 1, 0, 0, 0, 3127, 3129, 3, 336, 168, 0, 3128, 3130, 5, 218, 0, 0, 3129, 3128, 1, 0, 0, 0, 3129, 3130, 1, 0, 0, 0, 3130, 3141, 1, 0, 0, 0, 3131, 3133, 5, 15, 0, 0, 3132, 3134, 5, 218, 0, 0, 3133, 3132, 1, 0, 0, 0, 3133, 3134, 1, 0, 0, 0, 3134, 3135, 1, 0, 0, 0, 3135, 3137, 3, 336, 168, 0, 3136, 3138, 5, 218, 0, 0, 3137, 3136, 1, 0, 0, 0, 3137, 3138, 1, 0, 0, 0, 3138, 3140, 1, 0, 0, 0, 3139, 3131, 1, 0, 0, 0, 3140, 3143, 1, 0, 0, 0, 3141, 3139, 1, 0, 0, 0, 3141, 3142, 1, 0, 0, 0, 3142, 3145, 1, 0, 0, 0, 3143, 3141, 1, 0, 0, 0, 3144, 3127, 1, 0, 0, 0, 3144, 3145, 1, 0, 0, 0, 3145, 3146, 1, 0, 0, 0, 3146, 3147, 5, 21, 0, 0, 3147, 419, 1, 0, 0, 0, 3148, 3149, 3, 474, 237, 0, 3149, 3150, 3, 422, 211, 0, 3150, 421, 1, 0, 0, 0, 3151, 3152, 7, 17, 0, 0, 3152, 423, 1, 0, 0, 0, 3153, 3154, 3, 482, 241, 0, 3154, 425, 1, 0, 0, 0, 3155, 3157, 5, 17, 0, 0, 3156, 3158, 5, 218, 0, 0, 3157, 3156, 1, 0, 0, 0, 3157, 3158, 1, 0, 0, 0, 3158, 3159, 1, 0, 0, 0, 3159, 3168, 3, 414, 207, 0, 3160, 3162, 5, 218, 0, 0, 3161, 3160, 1, 0, 0, 0, 3161, 3162, 1, 0, 0, 0, 3162, 3163, 1, 0, 0, 0, 3163, 3165, 5, 23, 0, 0, 3164, 3166, 5, 218, 0, 0, 3165, 3164, 1, 0, 0, 0, 3165, 3166, 1, 0, 0, 0, 3166, 3167, 1, 0, 0, 0, 3167, 3169, 3, 336, 168, 0, 3168, 3161, 1, 0, 0, 0, 3168, 3169, 1, 0, 0, 0, 3169, 3171, 1, 0, 0, 0, 3170, 3172, 5, 218, 0, 0, 3171, 3170, 1, 0, 0, 0, 3171, 3172, 1, 0, 0, 0, 3172, 3173, 1, 0, 0, 0, 3173, 3174, 5, 18, 0, 0, 3174, 427, 1, 0, 0, 0, 3175, 3177, 5, 17, 0, 0, 3176, 3178, 5, 218, 0, 0, 3177, 3176, 1, 0, 0, 0, 3177, 3178, 1, 0, 0, 0, 3178, 3187, 1, 0, 0, 0, 3179, 3181, 3, 436, 218, 0, 3180, 3182, 5, 218, 0, 0, 3181, 3180, 1, 0, 0, 0, 3181, 3182, 1, 0, 0, 0, 3182, 3183, 1, 0, 0, 0, 3183, 3185, 5, 12, 0, 0, 3184, 3186, 5, 218, 0, 0, 3185, 3184, 1, 0, 0, 0, 3185, 3186, 1, 0, 0, 0, 3186, 3188, 1, 0, 0, 0, 3187, 3179, 1, 0, 0, 0, 3187, 3188, 1, 0, 0, 0, 3188, 3189, 1, 0, 0, 0, 3189, 3191, 3, 412, 206, 0, 3190, 3192, 5, 218, 0, 0, 3191, 3190, 1, 0, 0, 0, 3191, 3192, 1, 0, 0, 0, 3192, 3201, 1, 0, 0, 0, 3193, 3195, 5, 104, 0, 0, 3194, 3196, 5, 218, 0, 0, 3195, 3194, 1, 0, 0, 0, 3195, 3196, 1, 0, 0, 0, 3196, 3197, 1, 0, 0, 0, 3197, 3199, 3, 336, 168, 0, 3198, 3200, 5, 218, 0, 0, 3199, 3198, 1, 0, 0, 0, 3199, 3200, 1, 0, 0, 0, 3200, 3202, 1, 0, 0, 0, 3201, 3193, 1, 0, 0, 0, 3201, 3202, 1, 0, 0, 0, 3202, 3203, 1, 0, 0, 0, 3203, 3205, 5, 23, 0, 0, 3204, 3206, 5, 218, 0, 0, 3205, 3204, 1, 0, 0, 0, 3205, 3206, 1, 0, 0, 0, 3206, 3207, 1, 0, 0, 0, 3207, 3209, 3, 336, 168, 0, 3208, 3210, 5, 218, 0, 0, 3209, 3208, 1, 0, 0, 0, 3209, 3210, 1, 0, 0, 0, 3210, 3211, 1, 0, 0, 0, 3211, 3212, 5, 18, 0, 0, 3212, 429, 1, 0, 0, 0, 3213, 3215, 5, 7, 0, 0, 3214, 3216, 5, 218, 0, 0, 3215, 3214, 1, 0, 0, 0, 3215, 3216, 1, 0, 0, 0, 3216, 3217, 1, 0, 0, 0, 3217, 3218, 3, 468, 234, 0, 3218, 431, 1, 0, 0, 0, 3219, 3224, 5, 124, 0, 0, 3220, 3222, 5, 218, 0, 0, 3221, 3220, 1, 0, 0, 0, 3221, 3222, 1, 0, 0, 0, 3222, 3223, 1, 0, 0, 0, 3223, 3225, 3, 434, 217, 0, 3224, 3221, 1, 0, 0, 0, 3225, 3226, 1, 0, 0, 0, 3226, 3224, 1, 0, 0, 0, 3226, 3227, 1, 0, 0, 0, 3227, 3242, 1, 0, 0, 0, 3228, 3230, 5, 124, 0, 0, 3229, 3231, 5, 218, 0, 0, 3230, 3229, 1, 0, 0, 0, 3230, 3231, 1, 0, 0, 0, 3231, 3232, 1, 0, 0, 0, 3232, 3237, 3, 336, 168, 0, 3233, 3235, 5, 218, 0, 0, 3234, 3233, 1, 0, 0, 0, 3234, 3235, 1, 0, 0, 0, 3235, 3236, 1, 0, 0, 0, 3236, 3238, 3, 434, 217, 0, 3237, 3234, 1, 0, 0, 0, 3238, 3239, 1, 0, 0, 0, 3239, 3237, 1, 0, 0, 0, 3239, 3240, 1, 0, 0, 0, 3240, 3242, 1, 0, 0, 0, 3241, 3219, 1, 0, 0, 0, 3241, 3228, 1, 0, 0, 0, 3242, 3251, 1, 0, 0, 0, 3243, 3245, 5, 218, 0, 0, 3244, 3243, 1, 0, 0, 0, 3244, 3245, 1, 0, 0, 0, 3245, 3246, 1, 0, 0, 0, 3246, 3248, 5, 125, 0, 0, 3247, 3249, 5, 218, 0, 0, 3248, 3247, 1, 0, 0, 0, 3248, 3249, 1, 0, 0, 0, 3249, 3250, 1, 0, 0, 0, 3250, 3252, 3, 336, 168, 0, 3251, 3244, 1, 0, 0, 0, 3251, 3252, 1, 0, 0, 0, 3252, 3254, 1, 0, 0, 0, 3253, 3255, 5, 218, 0, 0, 3254, 3253, 1, 0, 0, 0, 3254, 3255, 1, 0, 0, 0, 3255, 3256, 1, 0, 0, 0, 3256, 3257, 5, 126, 0, 0, 3257, 433, 1, 0, 0, 0, 3258, 3260, 5, 127, 0, 0, 3259, 3261, 5, 218, 0, 0, 3260, 3259, 1, 0, 0, 0, 3260, 3261, 1, 0, 0, 0, 3261, 3262, 1, 0, 0, 0, 3262, 3264, 3, 336, 168, 0, 3263, 3265, 5, 218, 0, 0, 3264, 3263, 1, 0, 0, 0, 3264, 3265, 1, 0, 0, 0, 3265, 3266, 1, 0, 0, 0, 3266, 3268, 5, 128, 0, 0, 3267, 3269, 5, 218, 0, 0, 3268, 3267, 1, 0, 0, 0, 3268, 3269, 1, 0, 0, 0, 3269, 3270, 1, 0, 0, 0, 3270, 3271, 3, 336, 168, 0, 3271, 435, 1, 0, 0, 0, 3272, 3273, 3, 482, 241, 0, 3273, 437, 1, 0, 0, 0, 3274, 3277, 3, 472, 236, 0, 3275, 3277, 3, 470, 235, 0, 3276, 3274, 1, 0, 0, 0, 3276, 3275, 1, 0, 0, 0, 3277, 439, 1, 0, 0, 0, 3278, 3280, 5, 14, 0, 0, 3279, 3281, 5, 218, 0, 0, 3280, 3279, 1, 0, 0, 0, 3280, 3281, 1, 0, 0, 0, 3281, 3299, 1, 0, 0, 0, 3282, 3284, 3, 446, 223, 0, 3283, 3285, 5, 218, 0, 0, 3284, 3283, 1, 0, 0, 0, 3284, 3285, 1, 0, 0, 0, 3285, 3296, 1, 0, 0, 0, 3286, 3288, 5, 15, 0, 0, 3287, 3289, 5, 218, 0, 0, 3288, 3287, 1, 0, 0, 0, 3288, 3289, 1, 0, 0, 0, 3289, 3290, 1, 0, 0, 0, 3290, 3292, 3, 446, 223, 0, 3291, 3293, 5, 218, 0, 0, 3292, 3291, 1, 0, 0, 0, 3292, 3293, 1, 0, 0, 0, 3293, 3295, 1, 0, 0, 0, 3294, 3286, 1, 0, 0, 0, 3295, 3298, 1, 0, 0, 0, 3296, 3294, 1, 0, 0, 0, 3296, 3297, 1, 0, 0, 0, 3297, 3300, 1, 0, 0, 0, 3298, 3296, 1, 0, 0, 0, 3299, 3282, 1, 0, 0, 0, 3299, 3300, 1, 0, 0, 0, 3300, 3301, 1, 0, 0, 0, 3301, 3302, 5, 16, 0, 0, 3302, 441, 1, 0, 0, 0, 3303, 3305, 3, 436, 218, 0, 3304, 3306, 5, 218, 0, 0, 3305, 3304, 1, 0, 0, 0, 3305, 3306, 1, 0, 0, 0, 3306, 3307, 1, 0, 0, 0, 3307, 3309, 5, 14, 0, 0, 3308, 3310, 5, 218, 0, 0, 3309, 3308, 1, 0, 0, 0, 3309, 3310, 1, 0, 0, 0, 3310, 3312, 1, 0, 0, 0, 3311, 3313, 3, 444, 222, 0, 3312, 3311, 1, 0, 0, 0, 3312, 3313, 1, 0, 0, 0, 3313, 3324, 1, 0, 0, 0, 3314, 3316, 5, 218, 0, 0, 3315, 3314, 1, 0, 0, 0, 3315, 3316, 1, 0, 0, 0, 3316, 3317, 1, 0, 0, 0, 3317, 3319, 5, 15, 0, 0, 3318, 3320, 5, 218, 0, 0, 3319, 3318, 1, 0, 0, 0, 3319, 3320, 1, 0, 0, 0, 3320, 3321, 1, 0, 0, 0, 3321, 3323, 3, 444, 222, 0, 3322, 3315, 1, 0, 0, 0, 3323, 3326, 1, 0, 0, 0, 3324, 3322, 1, 0, 0, 0, 3324, 3325, 1, 0, 0, 0, 3325, 3328, 1, 0, 0, 0, 3326, 3324, 1, 0, 0, 0, 3327, 3329, 5, 218, 0, 0, 3328, 3327, 1, 0, 0, 0, 3328, 3329, 1, 0, 0, 0, 3329, 3330, 1, 0, 0, 0, 3330, 3331, 5, 16, 0, 0, 3331, 443, 1, 0, 0, 0, 3332, 3337, 3, 446, 223, 0, 3333, 3337, 3, 448, 224, 0, 3334, 3337, 3, 450, 225, 0, 3335, 3337, 3, 452, 226, 0, 3336, 3332, 1, 0, 0, 0, 3336, 3333, 1, 0, 0, 0, 3336, 3334, 1, 0, 0, 0, 3336, 3335, 1, 0, 0, 0, 3337, 445, 1, 0, 0, 0, 3338, 3340, 3, 468, 234, 0, 3339, 3341, 5, 218, 0, 0, 3340, 3339, 1, 0, 0, 0, 3340, 3341, 1, 0, 0, 0, 3341, 3342, 1, 0, 0, 0, 3342, 3344, 5, 2, 0, 0, 3343, 3345, 5, 218, 0, 0, 3344, 3343, 1, 0, 0, 0, 3344, 3345, 1, 0, 0, 0, 3345, 3346, 1, 0, 0, 0, 3346, 3347, 3, 336, 168, 0, 3347, 447, 1, 0, 0, 0, 3348, 3349, 5, 7, 0, 0, 3349, 3350, 3, 436, 218, 0, 3350, 449, 1, 0, 0, 0, 3351, 3352, 3, 436, 218, 0, 3352, 451, 1, 0, 0, 0, 3353, 3354, 5, 7, 0, 0, 3354, 3355, 5, 19, 0, 0, 3355, 453, 1, 0, 0, 0, 3356, 3359, 3, 456, 228, 0, 3357, 3359, 3, 458, 229, 0, 3358, 3356, 1, 0, 0, 0, 3358, 3357, 1, 0, 0, 0, 3359, 455, 1, 0, 0, 0, 3360, 3362, 5, 14, 0, 0, 3361, 3363, 5, 218, 0, 0, 3362, 3361, 1, 0, 0, 0, 3362, 3363, 1, 0, 0, 0, 3363, 3364, 1, 0, 0, 0, 3364, 3366, 3, 460, 230, 0, 3365, 3367, 5, 218, 0, 0, 3366, 3365, 1, 0, 0, 0, 3366, 3367, 1, 0, 0, 0, 3367, 3368, 1, 0, 0, 0, 3368, 3369, 5, 16, 0, 0, 3369, 457, 1, 0, 0, 0, 3370, 3371, 5, 34, 0, 0, 3371, 3372, 3, 460, 230, 0, 3372, 459, 1, 0, 0, 0, 3373, 3376, 3, 482, 241, 0, 3374, 3376, 5, 203, 0, 0, 3375, 3373, 1, 0, 0, 0, 3375, 3374, 1, 0, 0, 0, 3376, 461, 1, 0, 0, 0, 3377, 3388, 3, 464, 232, 0, 3378, 3380, 5, 218, 0, 0, 3379, 3378, 1, 0, 0, 0, 3379, 3380, 1, 0, 0, 0, 3380, 3381, 1, 0, 0, 0, 3381, 3383, 5, 15, 0, 0, 3382, 3384, 5, 218, 0, 0, 3383, 3382, 1, 0, 0, 0, 3383, 3384, 1, 0, 0, 0, 3384, 3385, 1, 0, 0, 0, 3385, 3387, 3, 464, 232, 0, 3386, 3379, 1, 0, 0, 0, 3387, 3390, 1, 0, 0, 0, 3388, 3386, 1, 0, 0, 0, 3388, 3389, 1, 0, 0, 0, 3389, 463, 1, 0, 0, 0, 3390, 3388, 1, 0, 0, 0, 3391, 3396, 3, 398, 199, 0, 3392, 3394, 5, 218, 0, 0, 3393, 3392, 1, 0, 0, 0, 3393, 3394, 1, 0, 0, 0, 3394, 3395, 1, 0, 0, 0, 3395, 3397, 3, 430, 215, 0, 3396, 3393, 1, 0, 0, 0, 3397, 3398, 1, 0, 0, 0, 3398, 3396, 1, 0, 0, 0, 3398, 3399, 1, 0, 0, 0, 3399, 465, 1, 0, 0, 0, 3400, 3411, 3, 468, 234, 0, 3401, 3403, 5, 218, 0, 0, 3402, 3401, 1, 0, 0, 0, 3402, 3403, 1, 0, 0, 0, 3403, 3404, 1, 0, 0, 0, 3404, 3406, 5, 15, 0, 0, 3405, 3407, 5, 218, 0, 0, 3406, 3405, 1, 0, 0, 0, 3406, 3407, 1, 0, 0, 0, 3407, 3408, 1, 0, 0, 0, 3408, 3410, 3, 468, 234, 0, 3409, 3402, 1, 0, 0, 0, 3410, 3413, 1, 0, 0, 0, 3411, 3409, 1, 0, 0, 0, 3411, 3412, 1, 0, 0, 0, 3412, 467, 1, 0, 0, 0, 3413, 3411, 1, 0, 0, 0, 3414, 3415, 3, 482, 241, 0, 3415, 469, 1, 0, 0, 0, 3416, 3417, 7, 18, 0, 0, 3417, 471, 1, 0, 0, 0, 3418, 3419, 7, 19, 0, 0, 3419, 473, 1, 0, 0, 0, 3420, 3421, 3, 482, 241, 0, 3421, 3422, 5, 7, 0, 0, 3422, 3424, 1, 0, 0, 0, 3423, 3420, 1, 0, 0, 0, 3424, 3427, 1, 0, 0, 0, 3425, 3423, 1, 0, 0, 0, 3425, 3426, 1, 0, 0, 0, 3426, 475, 1, 0, 0, 0, 3427, 3425, 1, 0, 0, 0, 3428, 3429, 7, 20, 0, 0, 3429, 477, 1, 0, 0, 0, 3430, 3431, 7, 21, 0, 0, 3431, 479, 1, 0, 0, 0, 3432, 3433, 7, 22, 0, 0, 3433, 481, 1, 0, 0, 0, 3434, 3439, 3, 484, 242, 0, 3435, 3439, 5, 214, 0, 0, 3436, 3439, 5, 217, 0, 0, 3437, 3439, 5, 205, 0, 0, 3438, 3434, 1, 0, 0, 0, 3438, 3435, 1, 0, 0, 0, 3438, 3436, 1, 0, 0, 0, 3438, 3437, 1, 0, 0, 0, 3439, 483, 1, 0, 0, 0, 3440, 3441, 7, 23, 0, 0, 3441, 485, 1, 0, 0, 0, 498, 491, 495, 500, 504, 507, 512, 520, 528, 541, 545, 549, 558, 563, 567, 570, 573, 578, 582, 589, 607, 630, 638, 640, 644, 649, 655, 661, 665, 669, 673, 677, 684, 687, 691, 695, 701, 705, 709, 713, 717, 724, 727, 735, 744, 749, 753, 756, 763, 771, 775, 781, 786, 792, 803, 807, 815, 818, 822, 826, 831, 836, 842, 847, 857, 861, 866, 873, 878, 881, 897, 909, 914, 921, 930, 936, 942, 949, 955, 962, 964, 973, 977, 984, 991, 993, 1012, 1026, 1031, 1038, 1047, 1049, 1058, 1074, 1080, 1091, 1101, 1107, 1117, 1127, 1130, 1177, 1224, 1239, 1247, 1267, 1276, 1280, 1285, 1288, 1297, 1301, 1306, 1309, 1313, 1317, 1322, 1330, 1335, 1342, 1348, 1377, 1386, 1395, 1401, 1407, 1410, 1412, 1432, 1439, 1446, 1453, 1455, 1460, 1464, 1469, 1472, 1476, 1480, 1488, 1494, 1503, 1510, 1515, 1524, 1558, 1562, 1569, 1575, 1631, 1635, 1639, 1643, 1651, 1655, 1660, 1664, 1678, 1682, 1687, 1691, 1697, 1701, 1715, 1722, 1728, 1738, 1742, 1748, 1756, 1767, 1773, 1785, 1791, 1803, 1807, 1817, 1830, 1834, 1838, 1844, 1848, 1851, 1855, 1865, 1872, 1885, 1889, 1897, 1903, 1907, 1911, 1916, 1921, 1925, 1931, 1935, 1941, 1945, 1951, 1955, 1959, 1963, 1967, 1971, 1976, 1983, 1987, 1992, 1999, 2003, 2007, 2015, 2022, 2025, 2031, 2034, 2039, 2042, 2046, 2049, 2052, 2059, 2063, 2067, 2071, 2074, 2078, 2082, 2087, 2092, 2096, 2101, 2105, 2114, 2120, 2123, 2127, 2130, 2137, 2140, 2143, 2147, 2152, 2156, 2164, 2168, 2173, 2178, 2182, 2200, 2204, 2209, 2222, 2226, 2228, 2231, 2240, 2244, 2248, 2260, 2264, 2269, 2279, 2285, 2289, 2294, 2298, 2302, 2306, 2312, 2316, 2321, 2327, 2336, 2345, 2353, 2359, 2363, 2368, 2377, 2381, 2386, 2391, 2395, 2400, 2404, 2408, 2413, 2420, 2424, 2428, 2430, 2434, 2436, 2440, 2442, 2448, 2454, 2457, 2460, 2466, 2471, 2475, 2480, 2484, 2488, 2490, 2494, 2496, 2499, 2503, 2505, 2511, 2515, 2521, 2527, 2534, 2540, 2545, 2553, 2557, 2559, 2563, 2567, 2569, 2571, 2586, 2596, 2606, 2611, 2615, 2622, 2627, 2632, 2636, 2640, 2644, 2647, 2649, 2654, 2658, 2662, 2666, 2670, 2674, 2677, 2679, 2684, 2688, 2693, 2698, 2702, 2709, 2716, 2720, 2724, 2728, 2743, 2746, 2759, 2761, 2766, 2770, 2774, 2779, 2783, 2787, 2795, 2799, 2803, 2811, 2815, 2819, 2827, 2831, 2835, 2843, 2847, 2851, 2859, 2863, 2867, 2875, 2879, 2883, 2887, 2890, 2893, 2901, 2905, 2909, 2913, 2917, 2921, 2925, 2929, 2933, 2941, 2945, 2949, 2955, 2959, 2963, 2967, 2978, 2982, 2986, 3004, 3013, 3021, 3025, 3029, 3033, 3037, 3040, 3046, 3051, 3056, 3061, 3066, 3071, 3076, 3079, 3083, 3087, 3093, 3098, 3102, 3105, 3115, 3119, 3123, 3125, 3129, 3133, 3137, 3141, 3144, 3157, 3161, 3165, 3168, 3171, 3177, 3181, 3185, 3187, 3191, 3195, 3199, 3201, 3205, 3209, 3215, 3221, 3226, 3230, 3234, 3239, 3241, 3244, 3248, 3251, 3254, 3260, 3264, 3268, 3276, 3280, 3284, 3288, 3292, 3296, 3299, 3305, 3309, 3312, 3315, 3319, 3324, 3328, 3336, 3340, 3344, 3358, 3362, 3366, 3375, 3379, 3383, 3388, 3393, 3398, 3402, 3406, 3411, 3425, 3438];
var atn2 = new es_default.atn.ATNDeserializer().deserialize(serializedATN2);
var decisionsToDFA2 = atn2.decisionToState.map((ds, index4) => new es_default.dfa.DFA(ds, index4));
var sharedContextCache = new es_default.PredictionContextCache();
var CypherParser = class _CypherParser extends es_default.Parser {
  constructor(input) {
    super(input);
    this._interp = new es_default.atn.ParserATNSimulator(this, atn2, decisionsToDFA2, sharedContextCache);
    this.ruleNames = _CypherParser.ruleNames;
    this.literalNames = _CypherParser.literalNames;
    this.symbolicNames = _CypherParser.symbolicNames;
  }
  get atn() {
    return atn2;
  }
  cypher() {
    let localctx = new CypherContext(this, this._ctx, this.state);
    this.enterRule(localctx, 0, _CypherParser.RULE_cypher);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 486;
      this.cypherPart();
      this.state = 491;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 0, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 487;
          this.match(_CypherParser.T__0);
          this.state = 488;
          this.cypherPart();
        }
        this.state = 493;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 0, this._ctx);
      }
      this.state = 495;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.T__0) {
        this.state = 494;
        this.match(_CypherParser.T__0);
      }
      this.state = 497;
      this.match(_CypherParser.EOF);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  cypherPart() {
    let localctx = new CypherPartContext(this, this._ctx, this.state);
    this.enterRule(localctx, 2, _CypherParser.RULE_cypherPart);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 500;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 499;
        this.match(_CypherParser.SP);
      }
      this.state = 504;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.CYPHER:
        case _CypherParser.EXPLAIN:
        case _CypherParser.PROFILE:
        case _CypherParser.USING:
        case _CypherParser.CREATE:
        case _CypherParser.DROP:
        case _CypherParser.LOAD:
        case _CypherParser.WITH:
        case _CypherParser.OPTIONAL:
        case _CypherParser.MATCH:
        case _CypherParser.UNWIND:
        case _CypherParser.MERGE:
        case _CypherParser.SET:
        case _CypherParser.DETACH:
        case _CypherParser.DELETE:
        case _CypherParser.REMOVE:
        case _CypherParser.FOREACH:
        case _CypherParser.RETURN:
        case _CypherParser.START:
        case _CypherParser.CALL:
        case _CypherParser.CATALOG:
        case _CypherParser.SHOW:
        case _CypherParser.STOP:
        case _CypherParser.ALTER:
        case _CypherParser.GRANT:
        case _CypherParser.DENY:
        case _CypherParser.REVOKE:
          this.state = 502;
          this.cypherQuery();
          break;
        case _CypherParser.T__1:
          this.state = 503;
          this.cypherConsoleCommand();
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
      this.state = 507;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 506;
        this.match(_CypherParser.SP);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  cypherConsoleCommand() {
    let localctx = new CypherConsoleCommandContext(this, this._ctx, this.state);
    this.enterRule(localctx, 4, _CypherParser.RULE_cypherConsoleCommand);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 509;
      this.cypherConsoleCommandName();
      this.state = 512;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 5, this._ctx);
      if (la_ === 1) {
        this.state = 510;
        this.match(_CypherParser.SP);
        this.state = 511;
        this.cypherConsoleCommandParameters();
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  cypherConsoleCommandName() {
    let localctx = new CypherConsoleCommandNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 6, _CypherParser.RULE_cypherConsoleCommandName);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 514;
      this.match(_CypherParser.T__1);
      this.state = 515;
      this.symbolicName();
      this.state = 520;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      while (_la === _CypherParser.T__2) {
        this.state = 516;
        this.match(_CypherParser.T__2);
        this.state = 517;
        this.symbolicName();
        this.state = 522;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  cypherConsoleCommandParameters() {
    let localctx = new CypherConsoleCommandParametersContext(this, this._ctx, this.state);
    this.enterRule(localctx, 8, _CypherParser.RULE_cypherConsoleCommandParameters);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 523;
      this.cypherConsoleCommandParameter();
      this.state = 528;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 7, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 524;
          this.match(_CypherParser.SP);
          this.state = 525;
          this.cypherConsoleCommandParameter();
        }
        this.state = 530;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 7, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  cypherConsoleCommandParameter() {
    let localctx = new CypherConsoleCommandParameterContext(this, this._ctx, this.state);
    this.enterRule(localctx, 10, _CypherParser.RULE_cypherConsoleCommandParameter);
    try {
      this.state = 541;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 8, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 531;
          this.url();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 532;
          this.json();
          break;
        case 3:
          this.enterOuterAlt(localctx, 3);
          this.state = 533;
          this.arrowExpression();
          break;
        case 4:
          this.enterOuterAlt(localctx, 4);
          this.state = 534;
          this.mapLiteral();
          break;
        case 5:
          this.enterOuterAlt(localctx, 5);
          this.state = 535;
          this.keyValueLiteral();
          break;
        case 6:
          this.enterOuterAlt(localctx, 6);
          this.state = 536;
          this.stringLiteral();
          break;
        case 7:
          this.enterOuterAlt(localctx, 7);
          this.state = 537;
          this.numberLiteral();
          break;
        case 8:
          this.enterOuterAlt(localctx, 8);
          this.state = 538;
          this.booleanLiteral();
          break;
        case 9:
          this.enterOuterAlt(localctx, 9);
          this.state = 539;
          this.subCommand();
          break;
        case 10:
          this.enterOuterAlt(localctx, 10);
          this.state = 540;
          this.commandPath();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  arrowExpression() {
    let localctx = new ArrowExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 12, _CypherParser.RULE_arrowExpression);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 543;
      this.symbolicName();
      this.state = 545;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 544;
        this.match(_CypherParser.SP);
      }
      this.state = 547;
      this.match(_CypherParser.T__3);
      this.state = 549;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 548;
        this.match(_CypherParser.SP);
      }
      this.state = 551;
      this.expression();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  url() {
    let localctx = new UrlContext(this, this._ctx, this.state);
    this.enterRule(localctx, 14, _CypherParser.RULE_url);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 553;
      this.uri();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  uri() {
    let localctx = new UriContext(this, this._ctx, this.state);
    this.enterRule(localctx, 16, _CypherParser.RULE_uri);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 555;
      this.scheme();
      this.state = 556;
      this.match(_CypherParser.T__4);
      this.state = 558;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 11, this._ctx);
      if (la_ === 1) {
        this.state = 557;
        this.login();
      }
      this.state = 560;
      this.host();
      this.state = 563;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.T__1) {
        this.state = 561;
        this.match(_CypherParser.T__1);
        this.state = 562;
        this.port();
      }
      this.state = 567;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.T__5) {
        this.state = 565;
        this.match(_CypherParser.T__5);
        this.state = 566;
        this.path();
      }
      this.state = 570;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.T__9) {
        this.state = 569;
        this.urlQuery();
      }
      this.state = 573;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.T__8) {
        this.state = 572;
        this.frag();
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  scheme() {
    let localctx = new SchemeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 18, _CypherParser.RULE_scheme);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 575;
      this.string();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  host() {
    let localctx = new HostContext(this, this._ctx, this.state);
    this.enterRule(localctx, 20, _CypherParser.RULE_host);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 578;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.T__5) {
        this.state = 577;
        this.match(_CypherParser.T__5);
      }
      this.state = 582;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.CYPHER:
        case _CypherParser.EXPLAIN:
        case _CypherParser.PROFILE:
        case _CypherParser.USING:
        case _CypherParser.PERIODIC:
        case _CypherParser.COMMIT:
        case _CypherParser.UNION:
        case _CypherParser.ALL:
        case _CypherParser.CREATE:
        case _CypherParser.DROP:
        case _CypherParser.INDEX:
        case _CypherParser.ON:
        case _CypherParser.CONSTRAINT:
        case _CypherParser.ASSERT:
        case _CypherParser.IS:
        case _CypherParser.UNIQUE:
        case _CypherParser.EXISTS:
        case _CypherParser.LOAD:
        case _CypherParser.CSV:
        case _CypherParser.WITH:
        case _CypherParser.HEADERS:
        case _CypherParser.FROM:
        case _CypherParser.AS:
        case _CypherParser.FIELDTERMINATOR:
        case _CypherParser.OPTIONAL:
        case _CypherParser.MATCH:
        case _CypherParser.UNWIND:
        case _CypherParser.MERGE:
        case _CypherParser.SET:
        case _CypherParser.DETACH:
        case _CypherParser.DELETE:
        case _CypherParser.REMOVE:
        case _CypherParser.FOREACH:
        case _CypherParser.IN:
        case _CypherParser.DISTINCT:
        case _CypherParser.RETURN:
        case _CypherParser.ORDER:
        case _CypherParser.BY:
        case _CypherParser.L_SKIP:
        case _CypherParser.LIMIT:
        case _CypherParser.ASCENDING:
        case _CypherParser.ASC:
        case _CypherParser.DESCENDING:
        case _CypherParser.DESC:
        case _CypherParser.JOIN:
        case _CypherParser.SCAN:
        case _CypherParser.START:
        case _CypherParser.NODE:
        case _CypherParser.RELATIONSHIP:
        case _CypherParser.REL:
        case _CypherParser.WHERE:
        case _CypherParser.SHORTESTPATH:
        case _CypherParser.ALLSHORTESTPATHS:
        case _CypherParser.OR:
        case _CypherParser.XOR:
        case _CypherParser.AND:
        case _CypherParser.NOT:
        case _CypherParser.STARTS:
        case _CypherParser.ENDS:
        case _CypherParser.CONTAINS:
        case _CypherParser.NULL:
        case _CypherParser.COUNT:
        case _CypherParser.FILTER:
        case _CypherParser.EXTRACT:
        case _CypherParser.ANY:
        case _CypherParser.NONE:
        case _CypherParser.SINGLE:
        case _CypherParser.TRUE:
        case _CypherParser.FALSE:
        case _CypherParser.REDUCE:
        case _CypherParser.CASE:
        case _CypherParser.ELSE:
        case _CypherParser.END:
        case _CypherParser.WHEN:
        case _CypherParser.THEN:
        case _CypherParser.CALL:
        case _CypherParser.YIELD:
        case _CypherParser.KEY:
        case _CypherParser.CATALOG:
        case _CypherParser.SHOW:
        case _CypherParser.DEFAULT:
        case _CypherParser.DBMS:
        case _CypherParser.DATABASE:
        case _CypherParser.DATABASES:
        case _CypherParser.GRAPH:
        case _CypherParser.GRAPHS:
        case _CypherParser.REPLACE:
        case _CypherParser.IF:
        case _CypherParser.STOP:
        case _CypherParser.ROLE:
        case _CypherParser.ROLES:
        case _CypherParser.USER:
        case _CypherParser.USERS:
        case _CypherParser.POPULATED:
        case _CypherParser.PASSWORD:
        case _CypherParser.CHANGE:
        case _CypherParser.REQUIRED:
        case _CypherParser.STATUS:
        case _CypherParser.ACTIVE:
        case _CypherParser.SUSPENDED:
        case _CypherParser.ALTER:
        case _CypherParser.CURRENT:
        case _CypherParser.TO:
        case _CypherParser.PRIVILEGES:
        case _CypherParser.GRANT:
        case _CypherParser.DENY:
        case _CypherParser.REVOKE:
        case _CypherParser.RELATIONSHIPS:
        case _CypherParser.NODES:
        case _CypherParser.ELEMENT:
        case _CypherParser.ELEMENTS:
        case _CypherParser.COPY:
        case _CypherParser.OF:
        case _CypherParser.TRAVERSE:
        case _CypherParser.READ:
        case _CypherParser.WRITE:
        case _CypherParser.ACCESS:
        case _CypherParser.INDEXES:
        case _CypherParser.MANAGEMENT:
        case _CypherParser.NEW:
        case _CypherParser.LABEL:
        case _CypherParser.LABELS:
        case _CypherParser.NAME:
        case _CypherParser.NAMES:
        case _CypherParser.TYPE:
        case _CypherParser.TYPES:
        case _CypherParser.PROPERTY:
        case _CypherParser.CONSTRAINTS:
        case _CypherParser.ASSIGN:
        case _CypherParser.BTREE:
        case _CypherParser.EXIST:
        case _CypherParser.FOR:
        case _CypherParser.OPTIONS:
        case _CypherParser.EXECUTE:
        case _CypherParser.DEFINED:
        case _CypherParser.FUNCTION:
        case _CypherParser.FUNCTIONS:
        case _CypherParser.BOOSTED:
        case _CypherParser.PROCEDURE:
        case _CypherParser.PROCEDURES:
        case _CypherParser.ADMIN:
        case _CypherParser.ADMINISTRATOR:
        case _CypherParser.BRIEF:
        case _CypherParser.VERBOSE:
        case _CypherParser.OUTPUT:
        case _CypherParser.HexLetter:
        case _CypherParser.UnescapedSymbolicName:
        case _CypherParser.EscapedSymbolicName:
          this.state = 580;
          this.hostname();
          break;
        case _CypherParser.HexInteger:
        case _CypherParser.DecimalInteger:
        case _CypherParser.OctalInteger:
          this.state = 581;
          this.hostnumber();
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  hostname() {
    let localctx = new HostnameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 22, _CypherParser.RULE_hostname);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 584;
      this.string();
      this.state = 589;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      while (_la === _CypherParser.T__6) {
        this.state = 585;
        this.match(_CypherParser.T__6);
        this.state = 586;
        this.string();
        this.state = 591;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  hostnumber() {
    let localctx = new HostnumberContext(this, this._ctx, this.state);
    this.enterRule(localctx, 24, _CypherParser.RULE_hostnumber);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 592;
      this.urlDigits();
      this.state = 593;
      this.match(_CypherParser.T__6);
      this.state = 594;
      this.urlDigits();
      this.state = 595;
      this.match(_CypherParser.T__6);
      this.state = 596;
      this.urlDigits();
      this.state = 597;
      this.match(_CypherParser.T__6);
      this.state = 598;
      this.urlDigits();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  port() {
    let localctx = new PortContext(this, this._ctx, this.state);
    this.enterRule(localctx, 26, _CypherParser.RULE_port);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 600;
      this.urlDigits();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  path() {
    let localctx = new PathContext(this, this._ctx, this.state);
    this.enterRule(localctx, 28, _CypherParser.RULE_path);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 602;
      this.string();
      this.state = 607;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      while (_la === _CypherParser.T__5) {
        this.state = 603;
        this.match(_CypherParser.T__5);
        this.state = 604;
        this.string();
        this.state = 609;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  user() {
    let localctx = new UserContext(this, this._ctx, this.state);
    this.enterRule(localctx, 30, _CypherParser.RULE_user);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 610;
      this.string();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  login() {
    let localctx = new LoginContext(this, this._ctx, this.state);
    this.enterRule(localctx, 32, _CypherParser.RULE_login);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 612;
      this.user();
      this.state = 613;
      this.match(_CypherParser.T__1);
      this.state = 614;
      this.password();
      this.state = 615;
      this.match(_CypherParser.T__7);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  password() {
    let localctx = new PasswordContext(this, this._ctx, this.state);
    this.enterRule(localctx, 34, _CypherParser.RULE_password);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 617;
      this.string();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  frag() {
    let localctx = new FragContext(this, this._ctx, this.state);
    this.enterRule(localctx, 36, _CypherParser.RULE_frag);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 619;
      this.match(_CypherParser.T__8);
      this.state = 620;
      this.string();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  urlQuery() {
    let localctx = new UrlQueryContext(this, this._ctx, this.state);
    this.enterRule(localctx, 38, _CypherParser.RULE_urlQuery);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 622;
      this.match(_CypherParser.T__9);
      this.state = 623;
      this.search();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  search() {
    let localctx = new SearchContext(this, this._ctx, this.state);
    this.enterRule(localctx, 40, _CypherParser.RULE_search);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 625;
      this.searchparameter();
      this.state = 630;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      while (_la === _CypherParser.T__10) {
        this.state = 626;
        this.match(_CypherParser.T__10);
        this.state = 627;
        this.searchparameter();
        this.state = 632;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  searchparameter() {
    let localctx = new SearchparameterContext(this, this._ctx, this.state);
    this.enterRule(localctx, 42, _CypherParser.RULE_searchparameter);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 633;
      this.string();
      this.state = 640;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.T__11) {
        this.state = 634;
        this.match(_CypherParser.T__11);
        this.state = 638;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case _CypherParser.CYPHER:
          case _CypherParser.EXPLAIN:
          case _CypherParser.PROFILE:
          case _CypherParser.USING:
          case _CypherParser.PERIODIC:
          case _CypherParser.COMMIT:
          case _CypherParser.UNION:
          case _CypherParser.ALL:
          case _CypherParser.CREATE:
          case _CypherParser.DROP:
          case _CypherParser.INDEX:
          case _CypherParser.ON:
          case _CypherParser.CONSTRAINT:
          case _CypherParser.ASSERT:
          case _CypherParser.IS:
          case _CypherParser.UNIQUE:
          case _CypherParser.EXISTS:
          case _CypherParser.LOAD:
          case _CypherParser.CSV:
          case _CypherParser.WITH:
          case _CypherParser.HEADERS:
          case _CypherParser.FROM:
          case _CypherParser.AS:
          case _CypherParser.FIELDTERMINATOR:
          case _CypherParser.OPTIONAL:
          case _CypherParser.MATCH:
          case _CypherParser.UNWIND:
          case _CypherParser.MERGE:
          case _CypherParser.SET:
          case _CypherParser.DETACH:
          case _CypherParser.DELETE:
          case _CypherParser.REMOVE:
          case _CypherParser.FOREACH:
          case _CypherParser.IN:
          case _CypherParser.DISTINCT:
          case _CypherParser.RETURN:
          case _CypherParser.ORDER:
          case _CypherParser.BY:
          case _CypherParser.L_SKIP:
          case _CypherParser.LIMIT:
          case _CypherParser.ASCENDING:
          case _CypherParser.ASC:
          case _CypherParser.DESCENDING:
          case _CypherParser.DESC:
          case _CypherParser.JOIN:
          case _CypherParser.SCAN:
          case _CypherParser.START:
          case _CypherParser.NODE:
          case _CypherParser.RELATIONSHIP:
          case _CypherParser.REL:
          case _CypherParser.WHERE:
          case _CypherParser.SHORTESTPATH:
          case _CypherParser.ALLSHORTESTPATHS:
          case _CypherParser.OR:
          case _CypherParser.XOR:
          case _CypherParser.AND:
          case _CypherParser.NOT:
          case _CypherParser.STARTS:
          case _CypherParser.ENDS:
          case _CypherParser.CONTAINS:
          case _CypherParser.NULL:
          case _CypherParser.COUNT:
          case _CypherParser.FILTER:
          case _CypherParser.EXTRACT:
          case _CypherParser.ANY:
          case _CypherParser.NONE:
          case _CypherParser.SINGLE:
          case _CypherParser.TRUE:
          case _CypherParser.FALSE:
          case _CypherParser.REDUCE:
          case _CypherParser.CASE:
          case _CypherParser.ELSE:
          case _CypherParser.END:
          case _CypherParser.WHEN:
          case _CypherParser.THEN:
          case _CypherParser.CALL:
          case _CypherParser.YIELD:
          case _CypherParser.KEY:
          case _CypherParser.CATALOG:
          case _CypherParser.SHOW:
          case _CypherParser.DEFAULT:
          case _CypherParser.DBMS:
          case _CypherParser.DATABASE:
          case _CypherParser.DATABASES:
          case _CypherParser.GRAPH:
          case _CypherParser.GRAPHS:
          case _CypherParser.REPLACE:
          case _CypherParser.IF:
          case _CypherParser.STOP:
          case _CypherParser.ROLE:
          case _CypherParser.ROLES:
          case _CypherParser.USER:
          case _CypherParser.USERS:
          case _CypherParser.POPULATED:
          case _CypherParser.PASSWORD:
          case _CypherParser.CHANGE:
          case _CypherParser.REQUIRED:
          case _CypherParser.STATUS:
          case _CypherParser.ACTIVE:
          case _CypherParser.SUSPENDED:
          case _CypherParser.ALTER:
          case _CypherParser.CURRENT:
          case _CypherParser.TO:
          case _CypherParser.PRIVILEGES:
          case _CypherParser.GRANT:
          case _CypherParser.DENY:
          case _CypherParser.REVOKE:
          case _CypherParser.RELATIONSHIPS:
          case _CypherParser.NODES:
          case _CypherParser.ELEMENT:
          case _CypherParser.ELEMENTS:
          case _CypherParser.COPY:
          case _CypherParser.OF:
          case _CypherParser.TRAVERSE:
          case _CypherParser.READ:
          case _CypherParser.WRITE:
          case _CypherParser.ACCESS:
          case _CypherParser.INDEXES:
          case _CypherParser.MANAGEMENT:
          case _CypherParser.NEW:
          case _CypherParser.LABEL:
          case _CypherParser.LABELS:
          case _CypherParser.NAME:
          case _CypherParser.NAMES:
          case _CypherParser.TYPE:
          case _CypherParser.TYPES:
          case _CypherParser.PROPERTY:
          case _CypherParser.CONSTRAINTS:
          case _CypherParser.ASSIGN:
          case _CypherParser.BTREE:
          case _CypherParser.EXIST:
          case _CypherParser.FOR:
          case _CypherParser.OPTIONS:
          case _CypherParser.EXECUTE:
          case _CypherParser.DEFINED:
          case _CypherParser.FUNCTION:
          case _CypherParser.FUNCTIONS:
          case _CypherParser.BOOSTED:
          case _CypherParser.PROCEDURE:
          case _CypherParser.PROCEDURES:
          case _CypherParser.ADMIN:
          case _CypherParser.ADMINISTRATOR:
          case _CypherParser.BRIEF:
          case _CypherParser.VERBOSE:
          case _CypherParser.OUTPUT:
          case _CypherParser.HexLetter:
          case _CypherParser.UnescapedSymbolicName:
          case _CypherParser.EscapedSymbolicName:
            this.state = 635;
            this.string();
            break;
          case _CypherParser.HexInteger:
          case _CypherParser.DecimalInteger:
          case _CypherParser.OctalInteger:
            this.state = 636;
            this.urlDigits();
            break;
          case _CypherParser.UrlHex:
            this.state = 637;
            this.match(_CypherParser.UrlHex);
            break;
          default:
            throw new es_default.error.NoViableAltException(this);
        }
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  string() {
    let localctx = new StringContext(this, this._ctx, this.state);
    this.enterRule(localctx, 44, _CypherParser.RULE_string);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 642;
      this.symbolicName();
      this.state = 649;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 24, this._ctx);
      while (_alt != 1 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1 + 1) {
          this.state = 644;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.T__6 || _la === _CypherParser.T__12) {
            this.state = 643;
            _la = this._input.LA(1);
            if (!(_la === _CypherParser.T__6 || _la === _CypherParser.T__12)) {
              this._errHandler.recoverInline(this);
            } else {
              this._errHandler.reportMatch(this);
              this.consume();
            }
          }
          this.state = 646;
          this.symbolicName();
        }
        this.state = 651;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 24, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  urlDigits() {
    let localctx = new UrlDigitsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 46, _CypherParser.RULE_urlDigits);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 653;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      do {
        this.state = 652;
        this.integerLiteral();
        this.state = 655;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
      } while ((_la - 202 & ~31) == 0 && (1 << _la - 202 & (1 << _CypherParser.HexInteger - 202 | 1 << _CypherParser.DecimalInteger - 202 | 1 << _CypherParser.OctalInteger - 202)) !== 0);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  json() {
    let localctx = new JsonContext(this, this._ctx, this.state);
    this.enterRule(localctx, 48, _CypherParser.RULE_json);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 657;
      this.value();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  obj() {
    let localctx = new ObjContext(this, this._ctx, this.state);
    this.enterRule(localctx, 50, _CypherParser.RULE_obj);
    var _la = 0;
    try {
      this.state = 687;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 32, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 659;
          this.match(_CypherParser.T__13);
          this.state = 661;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 660;
            this.match(_CypherParser.SP);
          }
          this.state = 663;
          this.pair();
          this.state = 665;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 664;
            this.match(_CypherParser.SP);
          }
          this.state = 677;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          while (_la === _CypherParser.T__14) {
            this.state = 667;
            this.match(_CypherParser.T__14);
            this.state = 669;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _CypherParser.SP) {
              this.state = 668;
              this.match(_CypherParser.SP);
            }
            this.state = 671;
            this.pair();
            this.state = 673;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _CypherParser.SP) {
              this.state = 672;
              this.match(_CypherParser.SP);
            }
            this.state = 679;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
          }
          this.state = 680;
          this.match(_CypherParser.T__15);
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 682;
          this.match(_CypherParser.T__13);
          this.state = 684;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 683;
            this.match(_CypherParser.SP);
          }
          this.state = 686;
          this.match(_CypherParser.T__15);
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  pair() {
    let localctx = new PairContext(this, this._ctx, this.state);
    this.enterRule(localctx, 52, _CypherParser.RULE_pair);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 689;
      this.stringLiteral();
      this.state = 691;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 690;
        this.match(_CypherParser.SP);
      }
      this.state = 693;
      this.match(_CypherParser.T__1);
      this.state = 695;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 694;
        this.match(_CypherParser.SP);
      }
      this.state = 697;
      this.value();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  array() {
    let localctx = new ArrayContext(this, this._ctx, this.state);
    this.enterRule(localctx, 54, _CypherParser.RULE_array);
    var _la = 0;
    try {
      this.state = 727;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 41, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 699;
          this.match(_CypherParser.T__16);
          this.state = 701;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 700;
            this.match(_CypherParser.SP);
          }
          this.state = 703;
          this.value();
          this.state = 705;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 704;
            this.match(_CypherParser.SP);
          }
          this.state = 717;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          while (_la === _CypherParser.T__14) {
            this.state = 707;
            this.match(_CypherParser.T__14);
            this.state = 709;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _CypherParser.SP) {
              this.state = 708;
              this.match(_CypherParser.SP);
            }
            this.state = 711;
            this.value();
            this.state = 713;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _CypherParser.SP) {
              this.state = 712;
              this.match(_CypherParser.SP);
            }
            this.state = 719;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
          }
          this.state = 720;
          this.match(_CypherParser.T__17);
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 722;
          this.match(_CypherParser.T__16);
          this.state = 724;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 723;
            this.match(_CypherParser.SP);
          }
          this.state = 726;
          this.match(_CypherParser.T__17);
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  value() {
    let localctx = new ValueContext(this, this._ctx, this.state);
    this.enterRule(localctx, 56, _CypherParser.RULE_value);
    try {
      this.state = 735;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.StringLiteral:
          this.enterOuterAlt(localctx, 1);
          this.state = 729;
          this.stringLiteral();
          break;
        case _CypherParser.HexInteger:
        case _CypherParser.DecimalInteger:
        case _CypherParser.OctalInteger:
        case _CypherParser.ExponentDecimalReal:
        case _CypherParser.RegularDecimalReal:
          this.enterOuterAlt(localctx, 2);
          this.state = 730;
          this.numberLiteral();
          break;
        case _CypherParser.T__13:
          this.enterOuterAlt(localctx, 3);
          this.state = 731;
          this.obj();
          break;
        case _CypherParser.T__16:
          this.enterOuterAlt(localctx, 4);
          this.state = 732;
          this.array();
          break;
        case _CypherParser.TRUE:
        case _CypherParser.FALSE:
          this.enterOuterAlt(localctx, 5);
          this.state = 733;
          this.booleanLiteral();
          break;
        case _CypherParser.NULL:
          this.enterOuterAlt(localctx, 6);
          this.state = 734;
          this.match(_CypherParser.NULL);
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  keyValueLiteral() {
    let localctx = new KeyValueLiteralContext(this, this._ctx, this.state);
    this.enterRule(localctx, 58, _CypherParser.RULE_keyValueLiteral);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 737;
      this.variable();
      this.state = 738;
      this.match(_CypherParser.T__1);
      this.state = 739;
      this.match(_CypherParser.SP);
      this.state = 744;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 43, this._ctx);
      switch (la_) {
        case 1:
          this.state = 740;
          this.match(_CypherParser.StringLiteral);
          break;
        case 2:
          this.state = 741;
          this.numberLiteral();
          break;
        case 3:
          this.state = 742;
          this.booleanLiteral();
          break;
        case 4:
          this.state = 743;
          this.symbolicName();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  commandPath() {
    let localctx = new CommandPathContext(this, this._ctx, this.state);
    this.enterRule(localctx, 60, _CypherParser.RULE_commandPath);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 751;
      this._errHandler.sync(this);
      var _alt = 1;
      do {
        switch (_alt) {
          case 1:
            this.state = 746;
            this.match(_CypherParser.T__5);
            this.state = 749;
            this._errHandler.sync(this);
            switch (this._input.LA(1)) {
              case _CypherParser.CYPHER:
              case _CypherParser.EXPLAIN:
              case _CypherParser.PROFILE:
              case _CypherParser.USING:
              case _CypherParser.PERIODIC:
              case _CypherParser.COMMIT:
              case _CypherParser.UNION:
              case _CypherParser.ALL:
              case _CypherParser.CREATE:
              case _CypherParser.DROP:
              case _CypherParser.INDEX:
              case _CypherParser.ON:
              case _CypherParser.CONSTRAINT:
              case _CypherParser.ASSERT:
              case _CypherParser.IS:
              case _CypherParser.UNIQUE:
              case _CypherParser.EXISTS:
              case _CypherParser.LOAD:
              case _CypherParser.CSV:
              case _CypherParser.WITH:
              case _CypherParser.HEADERS:
              case _CypherParser.FROM:
              case _CypherParser.AS:
              case _CypherParser.FIELDTERMINATOR:
              case _CypherParser.OPTIONAL:
              case _CypherParser.MATCH:
              case _CypherParser.UNWIND:
              case _CypherParser.MERGE:
              case _CypherParser.SET:
              case _CypherParser.DETACH:
              case _CypherParser.DELETE:
              case _CypherParser.REMOVE:
              case _CypherParser.FOREACH:
              case _CypherParser.IN:
              case _CypherParser.DISTINCT:
              case _CypherParser.RETURN:
              case _CypherParser.ORDER:
              case _CypherParser.BY:
              case _CypherParser.L_SKIP:
              case _CypherParser.LIMIT:
              case _CypherParser.ASCENDING:
              case _CypherParser.ASC:
              case _CypherParser.DESCENDING:
              case _CypherParser.DESC:
              case _CypherParser.JOIN:
              case _CypherParser.SCAN:
              case _CypherParser.START:
              case _CypherParser.NODE:
              case _CypherParser.RELATIONSHIP:
              case _CypherParser.REL:
              case _CypherParser.WHERE:
              case _CypherParser.SHORTESTPATH:
              case _CypherParser.ALLSHORTESTPATHS:
              case _CypherParser.OR:
              case _CypherParser.XOR:
              case _CypherParser.AND:
              case _CypherParser.NOT:
              case _CypherParser.STARTS:
              case _CypherParser.ENDS:
              case _CypherParser.CONTAINS:
              case _CypherParser.NULL:
              case _CypherParser.COUNT:
              case _CypherParser.FILTER:
              case _CypherParser.EXTRACT:
              case _CypherParser.ANY:
              case _CypherParser.NONE:
              case _CypherParser.SINGLE:
              case _CypherParser.TRUE:
              case _CypherParser.FALSE:
              case _CypherParser.REDUCE:
              case _CypherParser.CASE:
              case _CypherParser.ELSE:
              case _CypherParser.END:
              case _CypherParser.WHEN:
              case _CypherParser.THEN:
              case _CypherParser.CALL:
              case _CypherParser.YIELD:
              case _CypherParser.KEY:
              case _CypherParser.CATALOG:
              case _CypherParser.SHOW:
              case _CypherParser.DEFAULT:
              case _CypherParser.DBMS:
              case _CypherParser.DATABASE:
              case _CypherParser.DATABASES:
              case _CypherParser.GRAPH:
              case _CypherParser.GRAPHS:
              case _CypherParser.REPLACE:
              case _CypherParser.IF:
              case _CypherParser.STOP:
              case _CypherParser.ROLE:
              case _CypherParser.ROLES:
              case _CypherParser.USER:
              case _CypherParser.USERS:
              case _CypherParser.POPULATED:
              case _CypherParser.PASSWORD:
              case _CypherParser.CHANGE:
              case _CypherParser.REQUIRED:
              case _CypherParser.STATUS:
              case _CypherParser.ACTIVE:
              case _CypherParser.SUSPENDED:
              case _CypherParser.ALTER:
              case _CypherParser.CURRENT:
              case _CypherParser.TO:
              case _CypherParser.PRIVILEGES:
              case _CypherParser.GRANT:
              case _CypherParser.DENY:
              case _CypherParser.REVOKE:
              case _CypherParser.RELATIONSHIPS:
              case _CypherParser.NODES:
              case _CypherParser.ELEMENT:
              case _CypherParser.ELEMENTS:
              case _CypherParser.COPY:
              case _CypherParser.OF:
              case _CypherParser.TRAVERSE:
              case _CypherParser.READ:
              case _CypherParser.WRITE:
              case _CypherParser.ACCESS:
              case _CypherParser.INDEXES:
              case _CypherParser.MANAGEMENT:
              case _CypherParser.NEW:
              case _CypherParser.LABEL:
              case _CypherParser.LABELS:
              case _CypherParser.NAME:
              case _CypherParser.NAMES:
              case _CypherParser.TYPE:
              case _CypherParser.TYPES:
              case _CypherParser.PROPERTY:
              case _CypherParser.CONSTRAINTS:
              case _CypherParser.ASSIGN:
              case _CypherParser.BTREE:
              case _CypherParser.EXIST:
              case _CypherParser.FOR:
              case _CypherParser.OPTIONS:
              case _CypherParser.EXECUTE:
              case _CypherParser.DEFINED:
              case _CypherParser.FUNCTION:
              case _CypherParser.FUNCTIONS:
              case _CypherParser.BOOSTED:
              case _CypherParser.PROCEDURE:
              case _CypherParser.PROCEDURES:
              case _CypherParser.ADMIN:
              case _CypherParser.ADMINISTRATOR:
              case _CypherParser.BRIEF:
              case _CypherParser.VERBOSE:
              case _CypherParser.OUTPUT:
              case _CypherParser.HexLetter:
              case _CypherParser.UnescapedSymbolicName:
              case _CypherParser.EscapedSymbolicName:
                this.state = 747;
                this.symbolicName();
                break;
              case _CypherParser.HexInteger:
              case _CypherParser.DecimalInteger:
              case _CypherParser.OctalInteger:
              case _CypherParser.ExponentDecimalReal:
              case _CypherParser.RegularDecimalReal:
                this.state = 748;
                this.numberLiteral();
                break;
              default:
                throw new es_default.error.NoViableAltException(this);
            }
            break;
          default:
            throw new es_default.error.NoViableAltException(this);
        }
        this.state = 753;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 45, this._ctx);
      } while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER);
      this.state = 756;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.T__5) {
        this.state = 755;
        this.match(_CypherParser.T__5);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  subCommand() {
    let localctx = new SubCommandContext(this, this._ctx, this.state);
    this.enterRule(localctx, 62, _CypherParser.RULE_subCommand);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 758;
      this.symbolicName();
      this.state = 763;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      while (_la === _CypherParser.T__2) {
        this.state = 759;
        this.match(_CypherParser.T__2);
        this.state = 760;
        this.symbolicName();
        this.state = 765;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  cypherQuery() {
    let localctx = new CypherQueryContext(this, this._ctx, this.state);
    this.enterRule(localctx, 64, _CypherParser.RULE_cypherQuery);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 766;
      this.queryOptions();
      this.state = 767;
      this.statement();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  queryOptions() {
    let localctx = new QueryOptionsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 66, _CypherParser.RULE_queryOptions);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 775;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      while ((_la - 54 & ~31) == 0 && (1 << _la - 54 & (1 << _CypherParser.CYPHER - 54 | 1 << _CypherParser.EXPLAIN - 54 | 1 << _CypherParser.PROFILE - 54)) !== 0) {
        this.state = 769;
        this.anyCypherOption();
        this.state = 771;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 770;
          this.match(_CypherParser.SP);
        }
        this.state = 777;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  anyCypherOption() {
    let localctx = new AnyCypherOptionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 68, _CypherParser.RULE_anyCypherOption);
    try {
      this.state = 781;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.CYPHER:
          this.enterOuterAlt(localctx, 1);
          this.state = 778;
          this.cypherOption();
          break;
        case _CypherParser.EXPLAIN:
          this.enterOuterAlt(localctx, 2);
          this.state = 779;
          this.explain();
          break;
        case _CypherParser.PROFILE:
          this.enterOuterAlt(localctx, 3);
          this.state = 780;
          this.profile();
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  cypherOption() {
    let localctx = new CypherOptionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 70, _CypherParser.RULE_cypherOption);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 783;
      this.match(_CypherParser.CYPHER);
      this.state = 786;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 51, this._ctx);
      if (la_ === 1) {
        this.state = 784;
        this.match(_CypherParser.SP);
        this.state = 785;
        this.versionNumber();
      }
      this.state = 792;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 52, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 788;
          this.match(_CypherParser.SP);
          this.state = 789;
          this.configurationOption();
        }
        this.state = 794;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 52, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  versionNumber() {
    let localctx = new VersionNumberContext(this, this._ctx, this.state);
    this.enterRule(localctx, 72, _CypherParser.RULE_versionNumber);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 795;
      this.match(_CypherParser.RegularDecimalReal);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  explain() {
    let localctx = new ExplainContext(this, this._ctx, this.state);
    this.enterRule(localctx, 74, _CypherParser.RULE_explain);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 797;
      this.match(_CypherParser.EXPLAIN);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  profile() {
    let localctx = new ProfileContext(this, this._ctx, this.state);
    this.enterRule(localctx, 76, _CypherParser.RULE_profile);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 799;
      this.match(_CypherParser.PROFILE);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  configurationOption() {
    let localctx = new ConfigurationOptionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 78, _CypherParser.RULE_configurationOption);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 801;
      this.symbolicName();
      this.state = 803;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 802;
        this.match(_CypherParser.SP);
      }
      this.state = 805;
      this.match(_CypherParser.T__11);
      this.state = 807;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 806;
        this.match(_CypherParser.SP);
      }
      this.state = 809;
      this.symbolicName();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  statement() {
    let localctx = new StatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 80, _CypherParser.RULE_statement);
    var _la = 0;
    try {
      this.state = 818;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 56, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 811;
          this.command();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 812;
          this.query();
          break;
        case 3:
          this.enterOuterAlt(localctx, 3);
          this.state = 815;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.CATALOG) {
            this.state = 813;
            this.match(_CypherParser.CATALOG);
            this.state = 814;
            this.match(_CypherParser.SP);
          }
          this.state = 817;
          this.systemCommand();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  query() {
    let localctx = new QueryContext(this, this._ctx, this.state);
    this.enterRule(localctx, 82, _CypherParser.RULE_query);
    try {
      this.state = 822;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.CREATE:
        case _CypherParser.LOAD:
        case _CypherParser.WITH:
        case _CypherParser.OPTIONAL:
        case _CypherParser.MATCH:
        case _CypherParser.UNWIND:
        case _CypherParser.MERGE:
        case _CypherParser.SET:
        case _CypherParser.DETACH:
        case _CypherParser.DELETE:
        case _CypherParser.REMOVE:
        case _CypherParser.FOREACH:
        case _CypherParser.RETURN:
        case _CypherParser.START:
        case _CypherParser.CALL:
          this.enterOuterAlt(localctx, 1);
          this.state = 820;
          this.regularQuery();
          break;
        case _CypherParser.USING:
          this.enterOuterAlt(localctx, 2);
          this.state = 821;
          this.bulkImportQuery();
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  regularQuery() {
    let localctx = new RegularQueryContext(this, this._ctx, this.state);
    this.enterRule(localctx, 84, _CypherParser.RULE_regularQuery);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 824;
      this.singleQuery();
      this.state = 831;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 59, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 826;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 825;
            this.match(_CypherParser.SP);
          }
          this.state = 828;
          this.union();
        }
        this.state = 833;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 59, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  bulkImportQuery() {
    let localctx = new BulkImportQueryContext(this, this._ctx, this.state);
    this.enterRule(localctx, 86, _CypherParser.RULE_bulkImportQuery);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 834;
      this.periodicCommitHint();
      this.state = 836;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 835;
        this.match(_CypherParser.SP);
      }
      this.state = 838;
      this.loadCSVQuery();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  singleQuery() {
    let localctx = new SingleQueryContext(this, this._ctx, this.state);
    this.enterRule(localctx, 88, _CypherParser.RULE_singleQuery);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 840;
      this.clause();
      this.state = 847;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 62, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 842;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 841;
            this.match(_CypherParser.SP);
          }
          this.state = 844;
          this.clause();
        }
        this.state = 849;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 62, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  periodicCommitHint() {
    let localctx = new PeriodicCommitHintContext(this, this._ctx, this.state);
    this.enterRule(localctx, 90, _CypherParser.RULE_periodicCommitHint);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 850;
      this.match(_CypherParser.USING);
      this.state = 851;
      this.match(_CypherParser.SP);
      this.state = 852;
      this.match(_CypherParser.PERIODIC);
      this.state = 853;
      this.match(_CypherParser.SP);
      this.state = 854;
      this.match(_CypherParser.COMMIT);
      this.state = 857;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 63, this._ctx);
      if (la_ === 1) {
        this.state = 855;
        this.match(_CypherParser.SP);
        this.state = 856;
        this.integerLiteral();
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  loadCSVQuery() {
    let localctx = new LoadCSVQueryContext(this, this._ctx, this.state);
    this.enterRule(localctx, 92, _CypherParser.RULE_loadCSVQuery);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 859;
      this.loadCSVClause();
      this.state = 866;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 65, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 861;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 860;
            this.match(_CypherParser.SP);
          }
          this.state = 863;
          this.clause();
        }
        this.state = 868;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 65, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  union() {
    let localctx = new UnionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 94, _CypherParser.RULE_union);
    var _la = 0;
    try {
      this.state = 881;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 68, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 869;
          this.match(_CypherParser.UNION);
          this.state = 870;
          this.match(_CypherParser.SP);
          this.state = 871;
          this.match(_CypherParser.ALL);
          this.state = 873;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 872;
            this.match(_CypherParser.SP);
          }
          this.state = 875;
          this.singleQuery();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 876;
          this.match(_CypherParser.UNION);
          this.state = 878;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 877;
            this.match(_CypherParser.SP);
          }
          this.state = 880;
          this.singleQuery();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  clause() {
    let localctx = new ClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 96, _CypherParser.RULE_clause);
    try {
      this.state = 897;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 69, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 883;
          this.loadCSVClause();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 884;
          this.startClause();
          break;
        case 3:
          this.enterOuterAlt(localctx, 3);
          this.state = 885;
          this.matchClause();
          break;
        case 4:
          this.enterOuterAlt(localctx, 4);
          this.state = 886;
          this.unwindClause();
          break;
        case 5:
          this.enterOuterAlt(localctx, 5);
          this.state = 887;
          this.mergeClause();
          break;
        case 6:
          this.enterOuterAlt(localctx, 6);
          this.state = 888;
          this.createClause();
          break;
        case 7:
          this.enterOuterAlt(localctx, 7);
          this.state = 889;
          this.createUniqueClause();
          break;
        case 8:
          this.enterOuterAlt(localctx, 8);
          this.state = 890;
          this.setClause();
          break;
        case 9:
          this.enterOuterAlt(localctx, 9);
          this.state = 891;
          this.deleteClause();
          break;
        case 10:
          this.enterOuterAlt(localctx, 10);
          this.state = 892;
          this.removeClause();
          break;
        case 11:
          this.enterOuterAlt(localctx, 11);
          this.state = 893;
          this.foreachClause();
          break;
        case 12:
          this.enterOuterAlt(localctx, 12);
          this.state = 894;
          this.withClause();
          break;
        case 13:
          this.enterOuterAlt(localctx, 13);
          this.state = 895;
          this.returnClause();
          break;
        case 14:
          this.enterOuterAlt(localctx, 14);
          this.state = 896;
          this.call();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  command() {
    let localctx = new CommandContext(this, this._ctx, this.state);
    this.enterRule(localctx, 98, _CypherParser.RULE_command);
    try {
      this.state = 909;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 70, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 899;
          this.createIndex();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 900;
          this.dropIndex();
          break;
        case 3:
          this.enterOuterAlt(localctx, 3);
          this.state = 901;
          this.createUniqueConstraint();
          break;
        case 4:
          this.enterOuterAlt(localctx, 4);
          this.state = 902;
          this.dropUniqueConstraint();
          break;
        case 5:
          this.enterOuterAlt(localctx, 5);
          this.state = 903;
          this.createNodeKeyConstraint();
          break;
        case 6:
          this.enterOuterAlt(localctx, 6);
          this.state = 904;
          this.dropNodeKeyConstraint();
          break;
        case 7:
          this.enterOuterAlt(localctx, 7);
          this.state = 905;
          this.createNodePropertyExistenceConstraint();
          break;
        case 8:
          this.enterOuterAlt(localctx, 8);
          this.state = 906;
          this.dropNodePropertyExistenceConstraint();
          break;
        case 9:
          this.enterOuterAlt(localctx, 9);
          this.state = 907;
          this.createRelationshipPropertyExistenceConstraint();
          break;
        case 10:
          this.enterOuterAlt(localctx, 10);
          this.state = 908;
          this.dropRelationshipPropertyExistenceConstraint();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  systemCommand() {
    let localctx = new SystemCommandContext(this, this._ctx, this.state);
    this.enterRule(localctx, 100, _CypherParser.RULE_systemCommand);
    try {
      this.state = 914;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 71, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 911;
          this.multidatabaseCommand();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 912;
          this.userCommand();
          break;
        case 3:
          this.enterOuterAlt(localctx, 3);
          this.state = 913;
          this.privilegeCommand();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  multidatabaseCommand() {
    let localctx = new MultidatabaseCommandContext(this, this._ctx, this.state);
    this.enterRule(localctx, 102, _CypherParser.RULE_multidatabaseCommand);
    try {
      this.state = 921;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.SHOW:
          this.enterOuterAlt(localctx, 1);
          this.state = 916;
          this.showDatabase();
          break;
        case _CypherParser.CREATE:
          this.enterOuterAlt(localctx, 2);
          this.state = 917;
          this.createDatabase();
          break;
        case _CypherParser.DROP:
          this.enterOuterAlt(localctx, 3);
          this.state = 918;
          this.dropDatabase();
          break;
        case _CypherParser.START:
          this.enterOuterAlt(localctx, 4);
          this.state = 919;
          this.startDatabase();
          break;
        case _CypherParser.STOP:
          this.enterOuterAlt(localctx, 5);
          this.state = 920;
          this.stopDatabase();
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  userCommand() {
    let localctx = new UserCommandContext(this, this._ctx, this.state);
    this.enterRule(localctx, 104, _CypherParser.RULE_userCommand);
    try {
      this.state = 930;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 73, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 923;
          this.showRoles();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 924;
          this.createRole();
          break;
        case 3:
          this.enterOuterAlt(localctx, 3);
          this.state = 925;
          this.dropRole();
          break;
        case 4:
          this.enterOuterAlt(localctx, 4);
          this.state = 926;
          this.showUsers();
          break;
        case 5:
          this.enterOuterAlt(localctx, 5);
          this.state = 927;
          this.createUser();
          break;
        case 6:
          this.enterOuterAlt(localctx, 6);
          this.state = 928;
          this.dropUser();
          break;
        case 7:
          this.enterOuterAlt(localctx, 7);
          this.state = 929;
          this.alterUser();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  privilegeCommand() {
    let localctx = new PrivilegeCommandContext(this, this._ctx, this.state);
    this.enterRule(localctx, 106, _CypherParser.RULE_privilegeCommand);
    try {
      this.state = 936;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.SHOW:
          this.enterOuterAlt(localctx, 1);
          this.state = 932;
          this.showPrivileges();
          break;
        case _CypherParser.GRANT:
          this.enterOuterAlt(localctx, 2);
          this.state = 933;
          this.grantPrivilege();
          break;
        case _CypherParser.DENY:
          this.enterOuterAlt(localctx, 3);
          this.state = 934;
          this.denyPrivilege();
          break;
        case _CypherParser.REVOKE:
          this.enterOuterAlt(localctx, 4);
          this.state = 935;
          this.revokePrivilege();
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  showRoles() {
    let localctx = new ShowRolesContext(this, this._ctx, this.state);
    this.enterRule(localctx, 108, _CypherParser.RULE_showRoles);
    var _la = 0;
    try {
      this.state = 964;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 79, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 938;
          this.match(_CypherParser.SHOW);
          this.state = 939;
          this.match(_CypherParser.SP);
          this.state = 942;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.ALL) {
            this.state = 940;
            this.match(_CypherParser.ALL);
            this.state = 941;
            this.match(_CypherParser.SP);
          }
          this.state = 944;
          this.match(_CypherParser.ROLES);
          this.state = 949;
          this._errHandler.sync(this);
          var la_ = this._interp.adaptivePredict(this._input, 76, this._ctx);
          if (la_ === 1) {
            this.state = 945;
            this.match(_CypherParser.SP);
            this.state = 946;
            this.match(_CypherParser.WITH);
            this.state = 947;
            this.match(_CypherParser.SP);
            this.state = 948;
            this.match(_CypherParser.USERS);
          }
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 951;
          this.match(_CypherParser.SHOW);
          this.state = 952;
          this.match(_CypherParser.SP);
          this.state = 955;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.POPULATED) {
            this.state = 953;
            this.match(_CypherParser.POPULATED);
            this.state = 954;
            this.match(_CypherParser.SP);
          }
          this.state = 957;
          this.match(_CypherParser.ROLES);
          this.state = 962;
          this._errHandler.sync(this);
          var la_ = this._interp.adaptivePredict(this._input, 78, this._ctx);
          if (la_ === 1) {
            this.state = 958;
            this.match(_CypherParser.SP);
            this.state = 959;
            this.match(_CypherParser.WITH);
            this.state = 960;
            this.match(_CypherParser.SP);
            this.state = 961;
            this.match(_CypherParser.USERS);
          }
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  createRole() {
    let localctx = new CreateRoleContext(this, this._ctx, this.state);
    this.enterRule(localctx, 110, _CypherParser.RULE_createRole);
    var _la = 0;
    try {
      this.state = 993;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 84, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 966;
          this.match(_CypherParser.CREATE);
          this.state = 967;
          this.match(_CypherParser.SP);
          this.state = 968;
          this.match(_CypherParser.ROLE);
          this.state = 969;
          this.match(_CypherParser.SP);
          this.state = 970;
          this.symbolicName();
          this.state = 973;
          this._errHandler.sync(this);
          var la_ = this._interp.adaptivePredict(this._input, 80, this._ctx);
          if (la_ === 1) {
            this.state = 971;
            this.match(_CypherParser.SP);
            this.state = 972;
            this.ifNotExists();
          }
          this.state = 977;
          this._errHandler.sync(this);
          var la_ = this._interp.adaptivePredict(this._input, 81, this._ctx);
          if (la_ === 1) {
            this.state = 975;
            this.match(_CypherParser.SP);
            this.state = 976;
            this.copyRole();
          }
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 979;
          this.match(_CypherParser.CREATE);
          this.state = 980;
          this.match(_CypherParser.SP);
          this.state = 984;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.OR) {
            this.state = 981;
            this.orReplace();
            this.state = 982;
            this.match(_CypherParser.SP);
          }
          this.state = 986;
          this.match(_CypherParser.ROLE);
          this.state = 987;
          this.match(_CypherParser.SP);
          this.state = 988;
          this.symbolicName();
          this.state = 991;
          this._errHandler.sync(this);
          var la_ = this._interp.adaptivePredict(this._input, 83, this._ctx);
          if (la_ === 1) {
            this.state = 989;
            this.match(_CypherParser.SP);
            this.state = 990;
            this.copyRole();
          }
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  copyRole() {
    let localctx = new CopyRoleContext(this, this._ctx, this.state);
    this.enterRule(localctx, 112, _CypherParser.RULE_copyRole);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 995;
      this.match(_CypherParser.AS);
      this.state = 996;
      this.match(_CypherParser.SP);
      this.state = 997;
      this.match(_CypherParser.COPY);
      this.state = 998;
      this.match(_CypherParser.SP);
      this.state = 999;
      this.match(_CypherParser.OF);
      this.state = 1e3;
      this.match(_CypherParser.SP);
      this.state = 1001;
      this.symbolicName();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  dropRole() {
    let localctx = new DropRoleContext(this, this._ctx, this.state);
    this.enterRule(localctx, 114, _CypherParser.RULE_dropRole);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1003;
      this.match(_CypherParser.DROP);
      this.state = 1004;
      this.match(_CypherParser.SP);
      this.state = 1005;
      this.match(_CypherParser.ROLE);
      this.state = 1006;
      this.match(_CypherParser.SP);
      this.state = 1007;
      this.symbolicName();
      this.state = 1012;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 85, this._ctx);
      if (la_ === 1) {
        this.state = 1008;
        this.match(_CypherParser.SP);
        this.state = 1009;
        this.match(_CypherParser.IF);
        this.state = 1010;
        this.match(_CypherParser.SP);
        this.state = 1011;
        this.match(_CypherParser.EXISTS);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  showUsers() {
    let localctx = new ShowUsersContext(this, this._ctx, this.state);
    this.enterRule(localctx, 116, _CypherParser.RULE_showUsers);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1014;
      this.match(_CypherParser.SHOW);
      this.state = 1015;
      this.match(_CypherParser.SP);
      this.state = 1016;
      this.match(_CypherParser.USERS);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  createUser() {
    let localctx = new CreateUserContext(this, this._ctx, this.state);
    this.enterRule(localctx, 118, _CypherParser.RULE_createUser);
    var _la = 0;
    try {
      this.state = 1049;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 90, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 1018;
          this.match(_CypherParser.CREATE);
          this.state = 1019;
          this.match(_CypherParser.SP);
          this.state = 1020;
          this.match(_CypherParser.USER);
          this.state = 1021;
          this.match(_CypherParser.SP);
          this.state = 1022;
          this.user();
          this.state = 1023;
          this.match(_CypherParser.SP);
          this.state = 1026;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1024;
            this.match(_CypherParser.SP);
            this.state = 1025;
            this.ifNotExists();
          }
          this.state = 1028;
          this.setPassword();
          this.state = 1031;
          this._errHandler.sync(this);
          var la_ = this._interp.adaptivePredict(this._input, 87, this._ctx);
          if (la_ === 1) {
            this.state = 1029;
            this.match(_CypherParser.SP);
            this.state = 1030;
            this.setStatus();
          }
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 1033;
          this.match(_CypherParser.CREATE);
          this.state = 1034;
          this.match(_CypherParser.SP);
          this.state = 1038;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.OR) {
            this.state = 1035;
            this.orReplace();
            this.state = 1036;
            this.match(_CypherParser.SP);
          }
          this.state = 1040;
          this.match(_CypherParser.USER);
          this.state = 1041;
          this.match(_CypherParser.SP);
          this.state = 1042;
          this.user();
          this.state = 1043;
          this.match(_CypherParser.SP);
          this.state = 1044;
          this.setPassword();
          this.state = 1047;
          this._errHandler.sync(this);
          var la_ = this._interp.adaptivePredict(this._input, 89, this._ctx);
          if (la_ === 1) {
            this.state = 1045;
            this.match(_CypherParser.SP);
            this.state = 1046;
            this.setStatus();
          }
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  dropUser() {
    let localctx = new DropUserContext(this, this._ctx, this.state);
    this.enterRule(localctx, 120, _CypherParser.RULE_dropUser);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1051;
      this.match(_CypherParser.DROP);
      this.state = 1052;
      this.match(_CypherParser.SP);
      this.state = 1053;
      this.match(_CypherParser.USER);
      this.state = 1054;
      this.match(_CypherParser.SP);
      this.state = 1055;
      this.user();
      this.state = 1058;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 91, this._ctx);
      if (la_ === 1) {
        this.state = 1056;
        this.match(_CypherParser.SP);
        this.state = 1057;
        this.ifExists();
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  alterUser() {
    let localctx = new AlterUserContext(this, this._ctx, this.state);
    this.enterRule(localctx, 122, _CypherParser.RULE_alterUser);
    try {
      this.state = 1101;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 95, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 1060;
          this.match(_CypherParser.ALTER);
          this.state = 1061;
          this.match(_CypherParser.SP);
          this.state = 1062;
          this.match(_CypherParser.CURRENT);
          this.state = 1063;
          this.match(_CypherParser.SP);
          this.state = 1064;
          this.match(_CypherParser.USER);
          this.state = 1065;
          this.match(_CypherParser.SP);
          this.state = 1066;
          this.match(_CypherParser.SET);
          this.state = 1067;
          this.match(_CypherParser.SP);
          this.state = 1068;
          this.match(_CypherParser.PASSWORD);
          this.state = 1069;
          this.match(_CypherParser.SP);
          this.state = 1070;
          this.match(_CypherParser.FROM);
          this.state = 1071;
          this.match(_CypherParser.SP);
          this.state = 1074;
          this._errHandler.sync(this);
          switch (this._input.LA(1)) {
            case _CypherParser.CYPHER:
            case _CypherParser.EXPLAIN:
            case _CypherParser.PROFILE:
            case _CypherParser.USING:
            case _CypherParser.PERIODIC:
            case _CypherParser.COMMIT:
            case _CypherParser.UNION:
            case _CypherParser.ALL:
            case _CypherParser.CREATE:
            case _CypherParser.DROP:
            case _CypherParser.INDEX:
            case _CypherParser.ON:
            case _CypherParser.CONSTRAINT:
            case _CypherParser.ASSERT:
            case _CypherParser.IS:
            case _CypherParser.UNIQUE:
            case _CypherParser.EXISTS:
            case _CypherParser.LOAD:
            case _CypherParser.CSV:
            case _CypherParser.WITH:
            case _CypherParser.HEADERS:
            case _CypherParser.FROM:
            case _CypherParser.AS:
            case _CypherParser.FIELDTERMINATOR:
            case _CypherParser.OPTIONAL:
            case _CypherParser.MATCH:
            case _CypherParser.UNWIND:
            case _CypherParser.MERGE:
            case _CypherParser.SET:
            case _CypherParser.DETACH:
            case _CypherParser.DELETE:
            case _CypherParser.REMOVE:
            case _CypherParser.FOREACH:
            case _CypherParser.IN:
            case _CypherParser.DISTINCT:
            case _CypherParser.RETURN:
            case _CypherParser.ORDER:
            case _CypherParser.BY:
            case _CypherParser.L_SKIP:
            case _CypherParser.LIMIT:
            case _CypherParser.ASCENDING:
            case _CypherParser.ASC:
            case _CypherParser.DESCENDING:
            case _CypherParser.DESC:
            case _CypherParser.JOIN:
            case _CypherParser.SCAN:
            case _CypherParser.START:
            case _CypherParser.NODE:
            case _CypherParser.RELATIONSHIP:
            case _CypherParser.REL:
            case _CypherParser.WHERE:
            case _CypherParser.SHORTESTPATH:
            case _CypherParser.ALLSHORTESTPATHS:
            case _CypherParser.OR:
            case _CypherParser.XOR:
            case _CypherParser.AND:
            case _CypherParser.NOT:
            case _CypherParser.STARTS:
            case _CypherParser.ENDS:
            case _CypherParser.CONTAINS:
            case _CypherParser.NULL:
            case _CypherParser.COUNT:
            case _CypherParser.FILTER:
            case _CypherParser.EXTRACT:
            case _CypherParser.ANY:
            case _CypherParser.NONE:
            case _CypherParser.SINGLE:
            case _CypherParser.TRUE:
            case _CypherParser.FALSE:
            case _CypherParser.REDUCE:
            case _CypherParser.CASE:
            case _CypherParser.ELSE:
            case _CypherParser.END:
            case _CypherParser.WHEN:
            case _CypherParser.THEN:
            case _CypherParser.CALL:
            case _CypherParser.YIELD:
            case _CypherParser.KEY:
            case _CypherParser.CATALOG:
            case _CypherParser.SHOW:
            case _CypherParser.DEFAULT:
            case _CypherParser.DBMS:
            case _CypherParser.DATABASE:
            case _CypherParser.DATABASES:
            case _CypherParser.GRAPH:
            case _CypherParser.GRAPHS:
            case _CypherParser.REPLACE:
            case _CypherParser.IF:
            case _CypherParser.STOP:
            case _CypherParser.ROLE:
            case _CypherParser.ROLES:
            case _CypherParser.USER:
            case _CypherParser.USERS:
            case _CypherParser.POPULATED:
            case _CypherParser.PASSWORD:
            case _CypherParser.CHANGE:
            case _CypherParser.REQUIRED:
            case _CypherParser.STATUS:
            case _CypherParser.ACTIVE:
            case _CypherParser.SUSPENDED:
            case _CypherParser.ALTER:
            case _CypherParser.CURRENT:
            case _CypherParser.TO:
            case _CypherParser.PRIVILEGES:
            case _CypherParser.GRANT:
            case _CypherParser.DENY:
            case _CypherParser.REVOKE:
            case _CypherParser.RELATIONSHIPS:
            case _CypherParser.NODES:
            case _CypherParser.ELEMENT:
            case _CypherParser.ELEMENTS:
            case _CypherParser.COPY:
            case _CypherParser.OF:
            case _CypherParser.TRAVERSE:
            case _CypherParser.READ:
            case _CypherParser.WRITE:
            case _CypherParser.ACCESS:
            case _CypherParser.INDEXES:
            case _CypherParser.MANAGEMENT:
            case _CypherParser.NEW:
            case _CypherParser.LABEL:
            case _CypherParser.LABELS:
            case _CypherParser.NAME:
            case _CypherParser.NAMES:
            case _CypherParser.TYPE:
            case _CypherParser.TYPES:
            case _CypherParser.PROPERTY:
            case _CypherParser.CONSTRAINTS:
            case _CypherParser.ASSIGN:
            case _CypherParser.BTREE:
            case _CypherParser.EXIST:
            case _CypherParser.FOR:
            case _CypherParser.OPTIONS:
            case _CypherParser.EXECUTE:
            case _CypherParser.DEFINED:
            case _CypherParser.FUNCTION:
            case _CypherParser.FUNCTIONS:
            case _CypherParser.BOOSTED:
            case _CypherParser.PROCEDURE:
            case _CypherParser.PROCEDURES:
            case _CypherParser.ADMIN:
            case _CypherParser.ADMINISTRATOR:
            case _CypherParser.BRIEF:
            case _CypherParser.VERBOSE:
            case _CypherParser.OUTPUT:
            case _CypherParser.HexLetter:
            case _CypherParser.UnescapedSymbolicName:
            case _CypherParser.EscapedSymbolicName:
              this.state = 1072;
              this.password();
              break;
            case _CypherParser.T__13:
            case _CypherParser.T__33:
              this.state = 1073;
              this.parameter();
              break;
            default:
              throw new es_default.error.NoViableAltException(this);
          }
          this.state = 1076;
          this.match(_CypherParser.TO);
          this.state = 1077;
          this.match(_CypherParser.SP);
          this.state = 1080;
          this._errHandler.sync(this);
          switch (this._input.LA(1)) {
            case _CypherParser.CYPHER:
            case _CypherParser.EXPLAIN:
            case _CypherParser.PROFILE:
            case _CypherParser.USING:
            case _CypherParser.PERIODIC:
            case _CypherParser.COMMIT:
            case _CypherParser.UNION:
            case _CypherParser.ALL:
            case _CypherParser.CREATE:
            case _CypherParser.DROP:
            case _CypherParser.INDEX:
            case _CypherParser.ON:
            case _CypherParser.CONSTRAINT:
            case _CypherParser.ASSERT:
            case _CypherParser.IS:
            case _CypherParser.UNIQUE:
            case _CypherParser.EXISTS:
            case _CypherParser.LOAD:
            case _CypherParser.CSV:
            case _CypherParser.WITH:
            case _CypherParser.HEADERS:
            case _CypherParser.FROM:
            case _CypherParser.AS:
            case _CypherParser.FIELDTERMINATOR:
            case _CypherParser.OPTIONAL:
            case _CypherParser.MATCH:
            case _CypherParser.UNWIND:
            case _CypherParser.MERGE:
            case _CypherParser.SET:
            case _CypherParser.DETACH:
            case _CypherParser.DELETE:
            case _CypherParser.REMOVE:
            case _CypherParser.FOREACH:
            case _CypherParser.IN:
            case _CypherParser.DISTINCT:
            case _CypherParser.RETURN:
            case _CypherParser.ORDER:
            case _CypherParser.BY:
            case _CypherParser.L_SKIP:
            case _CypherParser.LIMIT:
            case _CypherParser.ASCENDING:
            case _CypherParser.ASC:
            case _CypherParser.DESCENDING:
            case _CypherParser.DESC:
            case _CypherParser.JOIN:
            case _CypherParser.SCAN:
            case _CypherParser.START:
            case _CypherParser.NODE:
            case _CypherParser.RELATIONSHIP:
            case _CypherParser.REL:
            case _CypherParser.WHERE:
            case _CypherParser.SHORTESTPATH:
            case _CypherParser.ALLSHORTESTPATHS:
            case _CypherParser.OR:
            case _CypherParser.XOR:
            case _CypherParser.AND:
            case _CypherParser.NOT:
            case _CypherParser.STARTS:
            case _CypherParser.ENDS:
            case _CypherParser.CONTAINS:
            case _CypherParser.NULL:
            case _CypherParser.COUNT:
            case _CypherParser.FILTER:
            case _CypherParser.EXTRACT:
            case _CypherParser.ANY:
            case _CypherParser.NONE:
            case _CypherParser.SINGLE:
            case _CypherParser.TRUE:
            case _CypherParser.FALSE:
            case _CypherParser.REDUCE:
            case _CypherParser.CASE:
            case _CypherParser.ELSE:
            case _CypherParser.END:
            case _CypherParser.WHEN:
            case _CypherParser.THEN:
            case _CypherParser.CALL:
            case _CypherParser.YIELD:
            case _CypherParser.KEY:
            case _CypherParser.CATALOG:
            case _CypherParser.SHOW:
            case _CypherParser.DEFAULT:
            case _CypherParser.DBMS:
            case _CypherParser.DATABASE:
            case _CypherParser.DATABASES:
            case _CypherParser.GRAPH:
            case _CypherParser.GRAPHS:
            case _CypherParser.REPLACE:
            case _CypherParser.IF:
            case _CypherParser.STOP:
            case _CypherParser.ROLE:
            case _CypherParser.ROLES:
            case _CypherParser.USER:
            case _CypherParser.USERS:
            case _CypherParser.POPULATED:
            case _CypherParser.PASSWORD:
            case _CypherParser.CHANGE:
            case _CypherParser.REQUIRED:
            case _CypherParser.STATUS:
            case _CypherParser.ACTIVE:
            case _CypherParser.SUSPENDED:
            case _CypherParser.ALTER:
            case _CypherParser.CURRENT:
            case _CypherParser.TO:
            case _CypherParser.PRIVILEGES:
            case _CypherParser.GRANT:
            case _CypherParser.DENY:
            case _CypherParser.REVOKE:
            case _CypherParser.RELATIONSHIPS:
            case _CypherParser.NODES:
            case _CypherParser.ELEMENT:
            case _CypherParser.ELEMENTS:
            case _CypherParser.COPY:
            case _CypherParser.OF:
            case _CypherParser.TRAVERSE:
            case _CypherParser.READ:
            case _CypherParser.WRITE:
            case _CypherParser.ACCESS:
            case _CypherParser.INDEXES:
            case _CypherParser.MANAGEMENT:
            case _CypherParser.NEW:
            case _CypherParser.LABEL:
            case _CypherParser.LABELS:
            case _CypherParser.NAME:
            case _CypherParser.NAMES:
            case _CypherParser.TYPE:
            case _CypherParser.TYPES:
            case _CypherParser.PROPERTY:
            case _CypherParser.CONSTRAINTS:
            case _CypherParser.ASSIGN:
            case _CypherParser.BTREE:
            case _CypherParser.EXIST:
            case _CypherParser.FOR:
            case _CypherParser.OPTIONS:
            case _CypherParser.EXECUTE:
            case _CypherParser.DEFINED:
            case _CypherParser.FUNCTION:
            case _CypherParser.FUNCTIONS:
            case _CypherParser.BOOSTED:
            case _CypherParser.PROCEDURE:
            case _CypherParser.PROCEDURES:
            case _CypherParser.ADMIN:
            case _CypherParser.ADMINISTRATOR:
            case _CypherParser.BRIEF:
            case _CypherParser.VERBOSE:
            case _CypherParser.OUTPUT:
            case _CypherParser.HexLetter:
            case _CypherParser.UnescapedSymbolicName:
            case _CypherParser.EscapedSymbolicName:
              this.state = 1078;
              this.password();
              break;
            case _CypherParser.T__13:
            case _CypherParser.T__33:
              this.state = 1079;
              this.parameter();
              break;
            default:
              throw new es_default.error.NoViableAltException(this);
          }
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 1082;
          this.match(_CypherParser.ALTER);
          this.state = 1083;
          this.match(_CypherParser.SP);
          this.state = 1084;
          this.match(_CypherParser.USER);
          this.state = 1085;
          this.match(_CypherParser.SP);
          this.state = 1086;
          this.user();
          this.state = 1087;
          this.match(_CypherParser.SP);
          this.state = 1088;
          this.setPassword();
          this.state = 1091;
          this._errHandler.sync(this);
          var la_ = this._interp.adaptivePredict(this._input, 94, this._ctx);
          if (la_ === 1) {
            this.state = 1089;
            this.match(_CypherParser.SP);
            this.state = 1090;
            this.setStatus();
          }
          break;
        case 3:
          this.enterOuterAlt(localctx, 3);
          this.state = 1093;
          this.match(_CypherParser.ALTER);
          this.state = 1094;
          this.match(_CypherParser.SP);
          this.state = 1095;
          this.match(_CypherParser.USER);
          this.state = 1096;
          this.match(_CypherParser.SP);
          this.state = 1097;
          this.user();
          this.state = 1098;
          this.match(_CypherParser.SP);
          this.state = 1099;
          this.setStatus();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  showPrivileges() {
    let localctx = new ShowPrivilegesContext(this, this._ctx, this.state);
    this.enterRule(localctx, 124, _CypherParser.RULE_showPrivileges);
    var _la = 0;
    try {
      this.state = 1130;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 99, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 1103;
          this.match(_CypherParser.SHOW);
          this.state = 1104;
          this.match(_CypherParser.SP);
          this.state = 1107;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.ALL) {
            this.state = 1105;
            this.match(_CypherParser.ALL);
            this.state = 1106;
            this.match(_CypherParser.SP);
          }
          this.state = 1109;
          this.match(_CypherParser.PRIVILEGES);
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 1110;
          this.match(_CypherParser.SHOW);
          this.state = 1111;
          this.match(_CypherParser.SP);
          this.state = 1117;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.ROLE) {
            this.state = 1112;
            this.match(_CypherParser.ROLE);
            this.state = 1113;
            this.match(_CypherParser.SP);
            this.state = 1114;
            this.symbolicName();
            this.state = 1115;
            this.match(_CypherParser.SP);
          }
          this.state = 1119;
          this.match(_CypherParser.PRIVILEGES);
          break;
        case 3:
          this.enterOuterAlt(localctx, 3);
          this.state = 1120;
          this.match(_CypherParser.SHOW);
          this.state = 1121;
          this.match(_CypherParser.SP);
          this.state = 1127;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.USER) {
            this.state = 1122;
            this.match(_CypherParser.USER);
            this.state = 1123;
            this.match(_CypherParser.SP);
            this.state = 1124;
            this.user();
            this.state = 1125;
            this.match(_CypherParser.SP);
          }
          this.state = 1129;
          this.match(_CypherParser.PRIVILEGES);
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  grantPrivilege() {
    let localctx = new GrantPrivilegeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 126, _CypherParser.RULE_grantPrivilege);
    try {
      this.state = 1177;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 100, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 1132;
          this.match(_CypherParser.GRANT);
          this.state = 1133;
          this.match(_CypherParser.SP);
          this.state = 1134;
          this.match(_CypherParser.ROLE);
          this.state = 1135;
          this.match(_CypherParser.SP);
          this.state = 1136;
          this.roles();
          this.state = 1137;
          this.match(_CypherParser.SP);
          this.state = 1138;
          this.match(_CypherParser.TO);
          this.state = 1139;
          this.match(_CypherParser.SP);
          this.state = 1140;
          this.user();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 1142;
          this.match(_CypherParser.GRANT);
          this.state = 1143;
          this.match(_CypherParser.SP);
          this.state = 1144;
          this.datasbasePrivilege();
          this.state = 1145;
          this.match(_CypherParser.SP);
          this.state = 1146;
          this.match(_CypherParser.ON);
          this.state = 1147;
          this.match(_CypherParser.SP);
          this.state = 1148;
          this.databaseScope();
          this.state = 1149;
          this.match(_CypherParser.SP);
          this.state = 1150;
          this.match(_CypherParser.TO);
          this.state = 1151;
          this.roles();
          break;
        case 3:
          this.enterOuterAlt(localctx, 3);
          this.state = 1153;
          this.match(_CypherParser.GRANT);
          this.state = 1154;
          this.match(_CypherParser.SP);
          this.state = 1155;
          this.grantableGraphPrivileges();
          this.state = 1156;
          this.match(_CypherParser.SP);
          this.state = 1157;
          this.match(_CypherParser.ON);
          this.state = 1158;
          this.match(_CypherParser.SP);
          this.state = 1159;
          this.graphScope();
          this.state = 1160;
          this.match(_CypherParser.SP);
          this.state = 1161;
          this.elementScope();
          this.state = 1162;
          this.match(_CypherParser.SP);
          this.state = 1163;
          this.match(_CypherParser.TO);
          this.state = 1164;
          this.roles();
          break;
        case 4:
          this.enterOuterAlt(localctx, 4);
          this.state = 1166;
          this.match(_CypherParser.GRANT);
          this.state = 1167;
          this.match(_CypherParser.SP);
          this.state = 1168;
          this.dbmsPrivilege();
          this.state = 1169;
          this.match(_CypherParser.SP);
          this.state = 1170;
          this.match(_CypherParser.ON);
          this.state = 1171;
          this.match(_CypherParser.SP);
          this.state = 1172;
          this.match(_CypherParser.DBMS);
          this.state = 1173;
          this.match(_CypherParser.SP);
          this.state = 1174;
          this.match(_CypherParser.TO);
          this.state = 1175;
          this.roles();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  denyPrivilege() {
    let localctx = new DenyPrivilegeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 128, _CypherParser.RULE_denyPrivilege);
    try {
      this.state = 1224;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 101, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 1179;
          this.match(_CypherParser.DENY);
          this.state = 1180;
          this.match(_CypherParser.SP);
          this.state = 1181;
          this.match(_CypherParser.ROLE);
          this.state = 1182;
          this.match(_CypherParser.SP);
          this.state = 1183;
          this.roles();
          this.state = 1184;
          this.match(_CypherParser.SP);
          this.state = 1185;
          this.match(_CypherParser.TO);
          this.state = 1186;
          this.match(_CypherParser.SP);
          this.state = 1187;
          this.user();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 1189;
          this.match(_CypherParser.DENY);
          this.state = 1190;
          this.match(_CypherParser.SP);
          this.state = 1191;
          this.datasbasePrivilege();
          this.state = 1192;
          this.match(_CypherParser.SP);
          this.state = 1193;
          this.match(_CypherParser.ON);
          this.state = 1194;
          this.match(_CypherParser.SP);
          this.state = 1195;
          this.databaseScope();
          this.state = 1196;
          this.match(_CypherParser.SP);
          this.state = 1197;
          this.match(_CypherParser.TO);
          this.state = 1198;
          this.roles();
          break;
        case 3:
          this.enterOuterAlt(localctx, 3);
          this.state = 1200;
          this.match(_CypherParser.DENY);
          this.state = 1201;
          this.match(_CypherParser.SP);
          this.state = 1202;
          this.grantableGraphPrivileges();
          this.state = 1203;
          this.match(_CypherParser.SP);
          this.state = 1204;
          this.match(_CypherParser.ON);
          this.state = 1205;
          this.match(_CypherParser.SP);
          this.state = 1206;
          this.graphScope();
          this.state = 1207;
          this.match(_CypherParser.SP);
          this.state = 1208;
          this.elementScope();
          this.state = 1209;
          this.match(_CypherParser.SP);
          this.state = 1210;
          this.match(_CypherParser.TO);
          this.state = 1211;
          this.roles();
          break;
        case 4:
          this.enterOuterAlt(localctx, 4);
          this.state = 1213;
          this.match(_CypherParser.DENY);
          this.state = 1214;
          this.match(_CypherParser.SP);
          this.state = 1215;
          this.dbmsPrivilege();
          this.state = 1216;
          this.match(_CypherParser.SP);
          this.state = 1217;
          this.match(_CypherParser.ON);
          this.state = 1218;
          this.match(_CypherParser.SP);
          this.state = 1219;
          this.match(_CypherParser.DBMS);
          this.state = 1220;
          this.match(_CypherParser.SP);
          this.state = 1221;
          this.match(_CypherParser.TO);
          this.state = 1222;
          this.roles();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  revokePrivilege() {
    let localctx = new RevokePrivilegeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 130, _CypherParser.RULE_revokePrivilege);
    var _la = 0;
    try {
      this.state = 1247;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 103, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 1226;
          this.match(_CypherParser.REVOKE);
          this.state = 1227;
          this.match(_CypherParser.SP);
          this.state = 1228;
          this.match(_CypherParser.ROLE);
          this.state = 1229;
          this.match(_CypherParser.SP);
          this.state = 1230;
          this.roles();
          this.state = 1231;
          this.match(_CypherParser.SP);
          this.state = 1232;
          this.match(_CypherParser.FROM);
          this.state = 1233;
          this.match(_CypherParser.SP);
          this.state = 1234;
          this.user();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 1236;
          this.match(_CypherParser.REVOKE);
          this.state = 1239;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1237;
            this.match(_CypherParser.SP);
            this.state = 1238;
            _la = this._input.LA(1);
            if (!(_la === _CypherParser.GRANT || _la === _CypherParser.DENY)) {
              this._errHandler.recoverInline(this);
            } else {
              this._errHandler.reportMatch(this);
              this.consume();
            }
          }
          this.state = 1241;
          this.revokePart();
          this.state = 1242;
          this.match(_CypherParser.SP);
          this.state = 1243;
          this.match(_CypherParser.FROM);
          this.state = 1244;
          this.match(_CypherParser.SP);
          this.state = 1245;
          this.roles();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  revokePart() {
    let localctx = new RevokePartContext(this, this._ctx, this.state);
    this.enterRule(localctx, 132, _CypherParser.RULE_revokePart);
    try {
      this.state = 1267;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 104, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 1249;
          this.datasbasePrivilege();
          this.state = 1250;
          this.match(_CypherParser.SP);
          this.state = 1251;
          this.match(_CypherParser.ON);
          this.state = 1252;
          this.match(_CypherParser.SP);
          this.state = 1253;
          this.databaseScope();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 1255;
          this.revokeableGraphPrivileges();
          this.state = 1256;
          this.match(_CypherParser.SP);
          this.state = 1257;
          this.match(_CypherParser.ON);
          this.state = 1258;
          this.match(_CypherParser.SP);
          this.state = 1259;
          this.graphScope();
          break;
        case 3:
          this.enterOuterAlt(localctx, 3);
          this.state = 1261;
          this.dbmsPrivilege();
          this.state = 1262;
          this.match(_CypherParser.SP);
          this.state = 1263;
          this.match(_CypherParser.ON);
          this.state = 1264;
          this.match(_CypherParser.SP);
          this.state = 1265;
          this.match(_CypherParser.DBMS);
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  databaseScope() {
    let localctx = new DatabaseScopeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 134, _CypherParser.RULE_databaseScope);
    var _la = 0;
    try {
      this.state = 1288;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 108, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 1269;
          _la = this._input.LA(1);
          if (!(_la === _CypherParser.DATABASE || _la === _CypherParser.DATABASES)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);
            this.consume();
          }
          this.state = 1270;
          this.match(_CypherParser.SP);
          this.state = 1271;
          this.match(_CypherParser.T__18);
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 1272;
          _la = this._input.LA(1);
          if (!(_la === _CypherParser.DATABASE || _la === _CypherParser.DATABASES)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);
            this.consume();
          }
          this.state = 1273;
          this.match(_CypherParser.SP);
          this.state = 1274;
          this.symbolicName();
          this.state = 1285;
          this._errHandler.sync(this);
          var _alt = this._interp.adaptivePredict(this._input, 107, this._ctx);
          while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
            if (_alt === 1) {
              this.state = 1276;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 1275;
                this.match(_CypherParser.SP);
              }
              this.state = 1278;
              this.match(_CypherParser.T__14);
              this.state = 1280;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 1279;
                this.match(_CypherParser.SP);
              }
              this.state = 1282;
              this.symbolicName();
            }
            this.state = 1287;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input, 107, this._ctx);
          }
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  graphScope() {
    let localctx = new GraphScopeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 136, _CypherParser.RULE_graphScope);
    var _la = 0;
    try {
      this.state = 1309;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 112, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 1290;
          _la = this._input.LA(1);
          if (!(_la === _CypherParser.GRAPH || _la === _CypherParser.GRAPHS)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);
            this.consume();
          }
          this.state = 1291;
          this.match(_CypherParser.SP);
          this.state = 1292;
          this.match(_CypherParser.T__18);
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 1293;
          _la = this._input.LA(1);
          if (!(_la === _CypherParser.GRAPH || _la === _CypherParser.GRAPHS)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);
            this.consume();
          }
          this.state = 1294;
          this.match(_CypherParser.SP);
          this.state = 1295;
          this.symbolicName();
          this.state = 1306;
          this._errHandler.sync(this);
          var _alt = this._interp.adaptivePredict(this._input, 111, this._ctx);
          while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
            if (_alt === 1) {
              this.state = 1297;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 1296;
                this.match(_CypherParser.SP);
              }
              this.state = 1299;
              this.match(_CypherParser.T__14);
              this.state = 1301;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 1300;
                this.match(_CypherParser.SP);
              }
              this.state = 1303;
              this.symbolicName();
            }
            this.state = 1308;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input, 111, this._ctx);
          }
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  roles() {
    let localctx = new RolesContext(this, this._ctx, this.state);
    this.enterRule(localctx, 138, _CypherParser.RULE_roles);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1311;
      this.symbolicName();
      this.state = 1322;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 115, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 1313;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1312;
            this.match(_CypherParser.SP);
          }
          this.state = 1315;
          this.match(_CypherParser.T__14);
          this.state = 1317;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1316;
            this.match(_CypherParser.SP);
          }
          this.state = 1319;
          this.symbolicName();
        }
        this.state = 1324;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 115, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  grantableGraphPrivileges() {
    let localctx = new GrantableGraphPrivilegesContext(this, this._ctx, this.state);
    this.enterRule(localctx, 140, _CypherParser.RULE_grantableGraphPrivileges);
    var _la = 0;
    try {
      this.state = 1335;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.TRAVERSE:
        case _CypherParser.READ:
        case _CypherParser.WRITE:
          this.enterOuterAlt(localctx, 1);
          this.state = 1325;
          this.revokeableGraphPrivileges();
          break;
        case _CypherParser.MATCH:
          this.enterOuterAlt(localctx, 2);
          this.state = 1326;
          this.match(_CypherParser.MATCH);
          this.state = 1327;
          this.match(_CypherParser.SP);
          this.state = 1328;
          this.match(_CypherParser.T__13);
          this.state = 1330;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1329;
            this.match(_CypherParser.SP);
          }
          this.state = 1332;
          this.propertiesList();
          this.state = 1333;
          this.match(_CypherParser.T__15);
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  revokeableGraphPrivileges() {
    let localctx = new RevokeableGraphPrivilegesContext(this, this._ctx, this.state);
    this.enterRule(localctx, 142, _CypherParser.RULE_revokeableGraphPrivileges);
    var _la = 0;
    try {
      this.state = 1348;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.TRAVERSE:
          this.enterOuterAlt(localctx, 1);
          this.state = 1337;
          this.match(_CypherParser.TRAVERSE);
          break;
        case _CypherParser.READ:
          this.enterOuterAlt(localctx, 2);
          this.state = 1338;
          this.match(_CypherParser.READ);
          this.state = 1339;
          this.match(_CypherParser.SP);
          this.state = 1340;
          this.match(_CypherParser.T__13);
          this.state = 1342;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1341;
            this.match(_CypherParser.SP);
          }
          this.state = 1344;
          this.propertiesList();
          this.state = 1345;
          this.match(_CypherParser.T__15);
          break;
        case _CypherParser.WRITE:
          this.enterOuterAlt(localctx, 3);
          this.state = 1347;
          this.match(_CypherParser.WRITE);
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  datasbasePrivilege() {
    let localctx = new DatasbasePrivilegeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 144, _CypherParser.RULE_datasbasePrivilege);
    var _la = 0;
    try {
      this.state = 1412;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 126, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 1350;
          this.match(_CypherParser.ACCESS);
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 1351;
          this.match(_CypherParser.START);
          break;
        case 3:
          this.enterOuterAlt(localctx, 3);
          this.state = 1352;
          this.match(_CypherParser.STOP);
          break;
        case 4:
          this.enterOuterAlt(localctx, 4);
          this.state = 1353;
          this.match(_CypherParser.CREATE);
          this.state = 1354;
          this.match(_CypherParser.SP);
          this.state = 1355;
          _la = this._input.LA(1);
          if (!(_la === _CypherParser.INDEX || _la === _CypherParser.INDEXES)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);
            this.consume();
          }
          break;
        case 5:
          this.enterOuterAlt(localctx, 5);
          this.state = 1356;
          this.match(_CypherParser.DROP);
          this.state = 1357;
          this.match(_CypherParser.SP);
          this.state = 1358;
          _la = this._input.LA(1);
          if (!(_la === _CypherParser.INDEX || _la === _CypherParser.INDEXES)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);
            this.consume();
          }
          break;
        case 6:
          this.enterOuterAlt(localctx, 6);
          this.state = 1359;
          _la = this._input.LA(1);
          if (!(_la === _CypherParser.INDEX || _la === _CypherParser.INDEXES)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);
            this.consume();
          }
          this.state = 1360;
          this.match(_CypherParser.SP);
          this.state = 1361;
          this.match(_CypherParser.MANAGEMENT);
          break;
        case 7:
          this.enterOuterAlt(localctx, 7);
          this.state = 1362;
          this.match(_CypherParser.CREATE);
          this.state = 1363;
          this.match(_CypherParser.SP);
          this.state = 1364;
          _la = this._input.LA(1);
          if (!(_la === _CypherParser.CONSTRAINT || _la === _CypherParser.CONSTRAINTS)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);
            this.consume();
          }
          break;
        case 8:
          this.enterOuterAlt(localctx, 8);
          this.state = 1365;
          this.match(_CypherParser.DROP);
          this.state = 1366;
          this.match(_CypherParser.SP);
          this.state = 1367;
          _la = this._input.LA(1);
          if (!(_la === _CypherParser.CONSTRAINT || _la === _CypherParser.CONSTRAINTS)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);
            this.consume();
          }
          break;
        case 9:
          this.enterOuterAlt(localctx, 9);
          this.state = 1368;
          _la = this._input.LA(1);
          if (!(_la === _CypherParser.CONSTRAINT || _la === _CypherParser.CONSTRAINTS)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);
            this.consume();
          }
          this.state = 1369;
          this.match(_CypherParser.SP);
          this.state = 1370;
          this.match(_CypherParser.MANAGEMENT);
          break;
        case 10:
          this.enterOuterAlt(localctx, 10);
          this.state = 1371;
          this.match(_CypherParser.CREATE);
          this.state = 1372;
          this.match(_CypherParser.SP);
          this.state = 1373;
          this.match(_CypherParser.NEW);
          this.state = 1374;
          this.match(_CypherParser.SP);
          this.state = 1377;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.NODE) {
            this.state = 1375;
            this.match(_CypherParser.NODE);
            this.state = 1376;
            this.match(_CypherParser.SP);
          }
          this.state = 1379;
          _la = this._input.LA(1);
          if (!(_la === _CypherParser.LABEL || _la === _CypherParser.LABELS)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);
            this.consume();
          }
          break;
        case 11:
          this.enterOuterAlt(localctx, 11);
          this.state = 1380;
          this.match(_CypherParser.CREATE);
          this.state = 1381;
          this.match(_CypherParser.SP);
          this.state = 1382;
          this.match(_CypherParser.NEW);
          this.state = 1383;
          this.match(_CypherParser.SP);
          this.state = 1386;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.RELATIONSHIP) {
            this.state = 1384;
            this.match(_CypherParser.RELATIONSHIP);
            this.state = 1385;
            this.match(_CypherParser.SP);
          }
          this.state = 1388;
          _la = this._input.LA(1);
          if (!(_la === _CypherParser.TYPE || _la === _CypherParser.TYPES)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);
            this.consume();
          }
          break;
        case 12:
          this.enterOuterAlt(localctx, 12);
          this.state = 1389;
          this.match(_CypherParser.CREATE);
          this.state = 1390;
          this.match(_CypherParser.SP);
          this.state = 1391;
          this.match(_CypherParser.NEW);
          this.state = 1392;
          this.match(_CypherParser.SP);
          this.state = 1395;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.PROPERTY) {
            this.state = 1393;
            this.match(_CypherParser.PROPERTY);
            this.state = 1394;
            this.match(_CypherParser.SP);
          }
          this.state = 1397;
          _la = this._input.LA(1);
          if (!(_la === _CypherParser.NAME || _la === _CypherParser.NAMES)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);
            this.consume();
          }
          break;
        case 13:
          this.enterOuterAlt(localctx, 13);
          this.state = 1398;
          this.match(_CypherParser.NAME);
          this.state = 1401;
          this._errHandler.sync(this);
          var la_ = this._interp.adaptivePredict(this._input, 123, this._ctx);
          if (la_ === 1) {
            this.state = 1399;
            this.match(_CypherParser.SP);
            this.state = 1400;
            this.match(_CypherParser.MANAGEMENT);
          }
          break;
        case 14:
          this.enterOuterAlt(localctx, 14);
          this.state = 1403;
          this.match(_CypherParser.ALL);
          this.state = 1410;
          this._errHandler.sync(this);
          var la_ = this._interp.adaptivePredict(this._input, 125, this._ctx);
          if (la_ === 1) {
            this.state = 1404;
            this.match(_CypherParser.SP);
            this.state = 1407;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _CypherParser.DATABASE) {
              this.state = 1405;
              this.match(_CypherParser.DATABASE);
              this.state = 1406;
              this.match(_CypherParser.SP);
            }
            this.state = 1409;
            this.match(_CypherParser.PRIVILEGES);
          }
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  dbmsPrivilege() {
    let localctx = new DbmsPrivilegeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 146, _CypherParser.RULE_dbmsPrivilege);
    try {
      this.state = 1432;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.ROLE:
          this.enterOuterAlt(localctx, 1);
          this.state = 1414;
          this.match(_CypherParser.ROLE);
          this.state = 1415;
          this.match(_CypherParser.SP);
          this.state = 1416;
          this.match(_CypherParser.MANAGEMENT);
          break;
        case _CypherParser.CREATE:
          this.enterOuterAlt(localctx, 2);
          this.state = 1417;
          this.match(_CypherParser.CREATE);
          this.state = 1418;
          this.match(_CypherParser.SP);
          this.state = 1419;
          this.match(_CypherParser.ROLE);
          break;
        case _CypherParser.DROP:
          this.enterOuterAlt(localctx, 3);
          this.state = 1420;
          this.match(_CypherParser.DROP);
          this.state = 1421;
          this.match(_CypherParser.SP);
          this.state = 1422;
          this.match(_CypherParser.ROLE);
          break;
        case _CypherParser.ASSIGN:
          this.enterOuterAlt(localctx, 4);
          this.state = 1423;
          this.match(_CypherParser.ASSIGN);
          this.state = 1424;
          this.match(_CypherParser.SP);
          this.state = 1425;
          this.match(_CypherParser.ROLE);
          break;
        case _CypherParser.REMOVE:
          this.enterOuterAlt(localctx, 5);
          this.state = 1426;
          this.match(_CypherParser.REMOVE);
          this.state = 1427;
          this.match(_CypherParser.SP);
          this.state = 1428;
          this.match(_CypherParser.ROLE);
          break;
        case _CypherParser.SHOW:
          this.enterOuterAlt(localctx, 6);
          this.state = 1429;
          this.match(_CypherParser.SHOW);
          this.state = 1430;
          this.match(_CypherParser.SP);
          this.state = 1431;
          this.match(_CypherParser.ROLE);
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  elementScope() {
    let localctx = new ElementScopeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 148, _CypherParser.RULE_elementScope);
    var _la = 0;
    try {
      this.state = 1455;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.RELATIONSHIP:
        case _CypherParser.RELATIONSHIPS:
          this.enterOuterAlt(localctx, 1);
          this.state = 1434;
          _la = this._input.LA(1);
          if (!(_la === _CypherParser.RELATIONSHIP || _la === _CypherParser.RELATIONSHIPS)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);
            this.consume();
          }
          this.state = 1435;
          this.match(_CypherParser.SP);
          this.state = 1436;
          this.propertiesList();
          this.state = 1439;
          this._errHandler.sync(this);
          var la_ = this._interp.adaptivePredict(this._input, 128, this._ctx);
          if (la_ === 1) {
            this.state = 1437;
            this.match(_CypherParser.SP);
            this.state = 1438;
            this.propertyScope();
          }
          break;
        case _CypherParser.NODE:
        case _CypherParser.NODES:
          this.enterOuterAlt(localctx, 2);
          this.state = 1441;
          _la = this._input.LA(1);
          if (!(_la === _CypherParser.NODE || _la === _CypherParser.NODES)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);
            this.consume();
          }
          this.state = 1442;
          this.match(_CypherParser.SP);
          this.state = 1443;
          this.propertiesList();
          this.state = 1446;
          this._errHandler.sync(this);
          var la_ = this._interp.adaptivePredict(this._input, 129, this._ctx);
          if (la_ === 1) {
            this.state = 1444;
            this.match(_CypherParser.SP);
            this.state = 1445;
            this.propertyScope();
          }
          break;
        case _CypherParser.ELEMENT:
        case _CypherParser.ELEMENTS:
          this.enterOuterAlt(localctx, 3);
          this.state = 1448;
          _la = this._input.LA(1);
          if (!(_la === _CypherParser.ELEMENT || _la === _CypherParser.ELEMENTS)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);
            this.consume();
          }
          this.state = 1449;
          this.match(_CypherParser.SP);
          this.state = 1450;
          this.propertiesList();
          this.state = 1453;
          this._errHandler.sync(this);
          var la_ = this._interp.adaptivePredict(this._input, 130, this._ctx);
          if (la_ === 1) {
            this.state = 1451;
            this.match(_CypherParser.SP);
            this.state = 1452;
            this.propertyScope();
          }
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  propertiesList() {
    let localctx = new PropertiesListContext(this, this._ctx, this.state);
    this.enterRule(localctx, 150, _CypherParser.RULE_propertiesList);
    var _la = 0;
    try {
      this.state = 1472;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.T__18:
          this.enterOuterAlt(localctx, 1);
          this.state = 1457;
          this.match(_CypherParser.T__18);
          break;
        case _CypherParser.CYPHER:
        case _CypherParser.EXPLAIN:
        case _CypherParser.PROFILE:
        case _CypherParser.USING:
        case _CypherParser.PERIODIC:
        case _CypherParser.COMMIT:
        case _CypherParser.UNION:
        case _CypherParser.ALL:
        case _CypherParser.CREATE:
        case _CypherParser.DROP:
        case _CypherParser.INDEX:
        case _CypherParser.ON:
        case _CypherParser.CONSTRAINT:
        case _CypherParser.ASSERT:
        case _CypherParser.IS:
        case _CypherParser.UNIQUE:
        case _CypherParser.EXISTS:
        case _CypherParser.LOAD:
        case _CypherParser.CSV:
        case _CypherParser.WITH:
        case _CypherParser.HEADERS:
        case _CypherParser.FROM:
        case _CypherParser.AS:
        case _CypherParser.FIELDTERMINATOR:
        case _CypherParser.OPTIONAL:
        case _CypherParser.MATCH:
        case _CypherParser.UNWIND:
        case _CypherParser.MERGE:
        case _CypherParser.SET:
        case _CypherParser.DETACH:
        case _CypherParser.DELETE:
        case _CypherParser.REMOVE:
        case _CypherParser.FOREACH:
        case _CypherParser.IN:
        case _CypherParser.DISTINCT:
        case _CypherParser.RETURN:
        case _CypherParser.ORDER:
        case _CypherParser.BY:
        case _CypherParser.L_SKIP:
        case _CypherParser.LIMIT:
        case _CypherParser.ASCENDING:
        case _CypherParser.ASC:
        case _CypherParser.DESCENDING:
        case _CypherParser.DESC:
        case _CypherParser.JOIN:
        case _CypherParser.SCAN:
        case _CypherParser.START:
        case _CypherParser.NODE:
        case _CypherParser.RELATIONSHIP:
        case _CypherParser.REL:
        case _CypherParser.WHERE:
        case _CypherParser.SHORTESTPATH:
        case _CypherParser.ALLSHORTESTPATHS:
        case _CypherParser.OR:
        case _CypherParser.XOR:
        case _CypherParser.AND:
        case _CypherParser.NOT:
        case _CypherParser.STARTS:
        case _CypherParser.ENDS:
        case _CypherParser.CONTAINS:
        case _CypherParser.NULL:
        case _CypherParser.COUNT:
        case _CypherParser.FILTER:
        case _CypherParser.EXTRACT:
        case _CypherParser.ANY:
        case _CypherParser.NONE:
        case _CypherParser.SINGLE:
        case _CypherParser.TRUE:
        case _CypherParser.FALSE:
        case _CypherParser.REDUCE:
        case _CypherParser.CASE:
        case _CypherParser.ELSE:
        case _CypherParser.END:
        case _CypherParser.WHEN:
        case _CypherParser.THEN:
        case _CypherParser.CALL:
        case _CypherParser.YIELD:
        case _CypherParser.KEY:
        case _CypherParser.CATALOG:
        case _CypherParser.SHOW:
        case _CypherParser.DEFAULT:
        case _CypherParser.DBMS:
        case _CypherParser.DATABASE:
        case _CypherParser.DATABASES:
        case _CypherParser.GRAPH:
        case _CypherParser.GRAPHS:
        case _CypherParser.REPLACE:
        case _CypherParser.IF:
        case _CypherParser.STOP:
        case _CypherParser.ROLE:
        case _CypherParser.ROLES:
        case _CypherParser.USER:
        case _CypherParser.USERS:
        case _CypherParser.POPULATED:
        case _CypherParser.PASSWORD:
        case _CypherParser.CHANGE:
        case _CypherParser.REQUIRED:
        case _CypherParser.STATUS:
        case _CypherParser.ACTIVE:
        case _CypherParser.SUSPENDED:
        case _CypherParser.ALTER:
        case _CypherParser.CURRENT:
        case _CypherParser.TO:
        case _CypherParser.PRIVILEGES:
        case _CypherParser.GRANT:
        case _CypherParser.DENY:
        case _CypherParser.REVOKE:
        case _CypherParser.RELATIONSHIPS:
        case _CypherParser.NODES:
        case _CypherParser.ELEMENT:
        case _CypherParser.ELEMENTS:
        case _CypherParser.COPY:
        case _CypherParser.OF:
        case _CypherParser.TRAVERSE:
        case _CypherParser.READ:
        case _CypherParser.WRITE:
        case _CypherParser.ACCESS:
        case _CypherParser.INDEXES:
        case _CypherParser.MANAGEMENT:
        case _CypherParser.NEW:
        case _CypherParser.LABEL:
        case _CypherParser.LABELS:
        case _CypherParser.NAME:
        case _CypherParser.NAMES:
        case _CypherParser.TYPE:
        case _CypherParser.TYPES:
        case _CypherParser.PROPERTY:
        case _CypherParser.CONSTRAINTS:
        case _CypherParser.ASSIGN:
        case _CypherParser.BTREE:
        case _CypherParser.EXIST:
        case _CypherParser.FOR:
        case _CypherParser.OPTIONS:
        case _CypherParser.EXECUTE:
        case _CypherParser.DEFINED:
        case _CypherParser.FUNCTION:
        case _CypherParser.FUNCTIONS:
        case _CypherParser.BOOSTED:
        case _CypherParser.PROCEDURE:
        case _CypherParser.PROCEDURES:
        case _CypherParser.ADMIN:
        case _CypherParser.ADMINISTRATOR:
        case _CypherParser.BRIEF:
        case _CypherParser.VERBOSE:
        case _CypherParser.OUTPUT:
        case _CypherParser.HexLetter:
        case _CypherParser.UnescapedSymbolicName:
        case _CypherParser.EscapedSymbolicName:
          this.enterOuterAlt(localctx, 2);
          this.state = 1458;
          this.symbolicName();
          this.state = 1469;
          this._errHandler.sync(this);
          var _alt = this._interp.adaptivePredict(this._input, 134, this._ctx);
          while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
            if (_alt === 1) {
              this.state = 1460;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 1459;
                this.match(_CypherParser.SP);
              }
              this.state = 1462;
              this.match(_CypherParser.T__14);
              this.state = 1464;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 1463;
                this.match(_CypherParser.SP);
              }
              this.state = 1466;
              this.symbolicName();
            }
            this.state = 1471;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input, 134, this._ctx);
          }
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  propertyScope() {
    let localctx = new PropertyScopeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 152, _CypherParser.RULE_propertyScope);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1474;
      this.match(_CypherParser.T__19);
      this.state = 1476;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1475;
        this.match(_CypherParser.SP);
      }
      this.state = 1478;
      this.match(_CypherParser.T__18);
      this.state = 1480;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1479;
        this.match(_CypherParser.SP);
      }
      this.state = 1482;
      this.match(_CypherParser.T__20);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  showDatabase() {
    let localctx = new ShowDatabaseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 154, _CypherParser.RULE_showDatabase);
    var _la = 0;
    try {
      this.state = 1494;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 139, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 1484;
          this.match(_CypherParser.SHOW);
          this.state = 1485;
          this.match(_CypherParser.SP);
          this.state = 1488;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.DEFAULT) {
            this.state = 1486;
            this.match(_CypherParser.DEFAULT);
            this.state = 1487;
            this.match(_CypherParser.SP);
          }
          this.state = 1490;
          this.match(_CypherParser.DATABASE);
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 1491;
          this.match(_CypherParser.SHOW);
          this.state = 1492;
          this.match(_CypherParser.SP);
          this.state = 1493;
          this.match(_CypherParser.DATABASES);
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  createDatabase() {
    let localctx = new CreateDatabaseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 156, _CypherParser.RULE_createDatabase);
    var _la = 0;
    try {
      this.state = 1515;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 142, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 1496;
          this.match(_CypherParser.CREATE);
          this.state = 1497;
          this.match(_CypherParser.SP);
          this.state = 1498;
          this.match(_CypherParser.DATABASE);
          this.state = 1499;
          this.match(_CypherParser.SP);
          this.state = 1500;
          this.symbolicName();
          this.state = 1503;
          this._errHandler.sync(this);
          var la_ = this._interp.adaptivePredict(this._input, 140, this._ctx);
          if (la_ === 1) {
            this.state = 1501;
            this.match(_CypherParser.SP);
            this.state = 1502;
            this.ifNotExists();
          }
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 1505;
          this.match(_CypherParser.CREATE);
          this.state = 1506;
          this.match(_CypherParser.SP);
          this.state = 1510;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.OR) {
            this.state = 1507;
            this.orReplace();
            this.state = 1508;
            this.match(_CypherParser.SP);
          }
          this.state = 1512;
          this.match(_CypherParser.DATABASE);
          this.state = 1513;
          this.match(_CypherParser.SP);
          this.state = 1514;
          this.symbolicName();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  dropDatabase() {
    let localctx = new DropDatabaseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 158, _CypherParser.RULE_dropDatabase);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1517;
      this.match(_CypherParser.DROP);
      this.state = 1518;
      this.match(_CypherParser.SP);
      this.state = 1519;
      this.match(_CypherParser.DATABASE);
      this.state = 1520;
      this.match(_CypherParser.SP);
      this.state = 1521;
      this.symbolicName();
      this.state = 1524;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 143, this._ctx);
      if (la_ === 1) {
        this.state = 1522;
        this.match(_CypherParser.SP);
        this.state = 1523;
        this.ifExists();
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  startDatabase() {
    let localctx = new StartDatabaseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 160, _CypherParser.RULE_startDatabase);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1526;
      this.match(_CypherParser.START);
      this.state = 1527;
      this.match(_CypherParser.SP);
      this.state = 1528;
      this.match(_CypherParser.DATABASE);
      this.state = 1529;
      this.match(_CypherParser.SP);
      this.state = 1530;
      this.symbolicName();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  stopDatabase() {
    let localctx = new StopDatabaseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 162, _CypherParser.RULE_stopDatabase);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1532;
      this.match(_CypherParser.STOP);
      this.state = 1533;
      this.match(_CypherParser.SP);
      this.state = 1534;
      this.match(_CypherParser.DATABASE);
      this.state = 1535;
      this.match(_CypherParser.SP);
      this.state = 1536;
      this.symbolicName();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  ifNotExists() {
    let localctx = new IfNotExistsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 164, _CypherParser.RULE_ifNotExists);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1538;
      this.match(_CypherParser.IF);
      this.state = 1539;
      this.match(_CypherParser.SP);
      this.state = 1540;
      this.match(_CypherParser.NOT);
      this.state = 1541;
      this.match(_CypherParser.SP);
      this.state = 1542;
      this.match(_CypherParser.EXISTS);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  ifExists() {
    let localctx = new IfExistsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 166, _CypherParser.RULE_ifExists);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1544;
      this.match(_CypherParser.IF);
      this.state = 1545;
      this.match(_CypherParser.SP);
      this.state = 1546;
      this.match(_CypherParser.EXISTS);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  orReplace() {
    let localctx = new OrReplaceContext(this, this._ctx, this.state);
    this.enterRule(localctx, 168, _CypherParser.RULE_orReplace);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1548;
      this.match(_CypherParser.OR);
      this.state = 1549;
      this.match(_CypherParser.SP);
      this.state = 1550;
      this.match(_CypherParser.REPLACE);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  setPassword() {
    let localctx = new SetPasswordContext(this, this._ctx, this.state);
    this.enterRule(localctx, 170, _CypherParser.RULE_setPassword);
    try {
      this.state = 1569;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 146, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 1552;
          this.match(_CypherParser.SET);
          this.state = 1553;
          this.match(_CypherParser.SP);
          this.state = 1554;
          this.match(_CypherParser.PASSWORD);
          this.state = 1555;
          this.match(_CypherParser.SP);
          this.state = 1558;
          this._errHandler.sync(this);
          switch (this._input.LA(1)) {
            case _CypherParser.CYPHER:
            case _CypherParser.EXPLAIN:
            case _CypherParser.PROFILE:
            case _CypherParser.USING:
            case _CypherParser.PERIODIC:
            case _CypherParser.COMMIT:
            case _CypherParser.UNION:
            case _CypherParser.ALL:
            case _CypherParser.CREATE:
            case _CypherParser.DROP:
            case _CypherParser.INDEX:
            case _CypherParser.ON:
            case _CypherParser.CONSTRAINT:
            case _CypherParser.ASSERT:
            case _CypherParser.IS:
            case _CypherParser.UNIQUE:
            case _CypherParser.EXISTS:
            case _CypherParser.LOAD:
            case _CypherParser.CSV:
            case _CypherParser.WITH:
            case _CypherParser.HEADERS:
            case _CypherParser.FROM:
            case _CypherParser.AS:
            case _CypherParser.FIELDTERMINATOR:
            case _CypherParser.OPTIONAL:
            case _CypherParser.MATCH:
            case _CypherParser.UNWIND:
            case _CypherParser.MERGE:
            case _CypherParser.SET:
            case _CypherParser.DETACH:
            case _CypherParser.DELETE:
            case _CypherParser.REMOVE:
            case _CypherParser.FOREACH:
            case _CypherParser.IN:
            case _CypherParser.DISTINCT:
            case _CypherParser.RETURN:
            case _CypherParser.ORDER:
            case _CypherParser.BY:
            case _CypherParser.L_SKIP:
            case _CypherParser.LIMIT:
            case _CypherParser.ASCENDING:
            case _CypherParser.ASC:
            case _CypherParser.DESCENDING:
            case _CypherParser.DESC:
            case _CypherParser.JOIN:
            case _CypherParser.SCAN:
            case _CypherParser.START:
            case _CypherParser.NODE:
            case _CypherParser.RELATIONSHIP:
            case _CypherParser.REL:
            case _CypherParser.WHERE:
            case _CypherParser.SHORTESTPATH:
            case _CypherParser.ALLSHORTESTPATHS:
            case _CypherParser.OR:
            case _CypherParser.XOR:
            case _CypherParser.AND:
            case _CypherParser.NOT:
            case _CypherParser.STARTS:
            case _CypherParser.ENDS:
            case _CypherParser.CONTAINS:
            case _CypherParser.NULL:
            case _CypherParser.COUNT:
            case _CypherParser.FILTER:
            case _CypherParser.EXTRACT:
            case _CypherParser.ANY:
            case _CypherParser.NONE:
            case _CypherParser.SINGLE:
            case _CypherParser.TRUE:
            case _CypherParser.FALSE:
            case _CypherParser.REDUCE:
            case _CypherParser.CASE:
            case _CypherParser.ELSE:
            case _CypherParser.END:
            case _CypherParser.WHEN:
            case _CypherParser.THEN:
            case _CypherParser.CALL:
            case _CypherParser.YIELD:
            case _CypherParser.KEY:
            case _CypherParser.CATALOG:
            case _CypherParser.SHOW:
            case _CypherParser.DEFAULT:
            case _CypherParser.DBMS:
            case _CypherParser.DATABASE:
            case _CypherParser.DATABASES:
            case _CypherParser.GRAPH:
            case _CypherParser.GRAPHS:
            case _CypherParser.REPLACE:
            case _CypherParser.IF:
            case _CypherParser.STOP:
            case _CypherParser.ROLE:
            case _CypherParser.ROLES:
            case _CypherParser.USER:
            case _CypherParser.USERS:
            case _CypherParser.POPULATED:
            case _CypherParser.PASSWORD:
            case _CypherParser.CHANGE:
            case _CypherParser.REQUIRED:
            case _CypherParser.STATUS:
            case _CypherParser.ACTIVE:
            case _CypherParser.SUSPENDED:
            case _CypherParser.ALTER:
            case _CypherParser.CURRENT:
            case _CypherParser.TO:
            case _CypherParser.PRIVILEGES:
            case _CypherParser.GRANT:
            case _CypherParser.DENY:
            case _CypherParser.REVOKE:
            case _CypherParser.RELATIONSHIPS:
            case _CypherParser.NODES:
            case _CypherParser.ELEMENT:
            case _CypherParser.ELEMENTS:
            case _CypherParser.COPY:
            case _CypherParser.OF:
            case _CypherParser.TRAVERSE:
            case _CypherParser.READ:
            case _CypherParser.WRITE:
            case _CypherParser.ACCESS:
            case _CypherParser.INDEXES:
            case _CypherParser.MANAGEMENT:
            case _CypherParser.NEW:
            case _CypherParser.LABEL:
            case _CypherParser.LABELS:
            case _CypherParser.NAME:
            case _CypherParser.NAMES:
            case _CypherParser.TYPE:
            case _CypherParser.TYPES:
            case _CypherParser.PROPERTY:
            case _CypherParser.CONSTRAINTS:
            case _CypherParser.ASSIGN:
            case _CypherParser.BTREE:
            case _CypherParser.EXIST:
            case _CypherParser.FOR:
            case _CypherParser.OPTIONS:
            case _CypherParser.EXECUTE:
            case _CypherParser.DEFINED:
            case _CypherParser.FUNCTION:
            case _CypherParser.FUNCTIONS:
            case _CypherParser.BOOSTED:
            case _CypherParser.PROCEDURE:
            case _CypherParser.PROCEDURES:
            case _CypherParser.ADMIN:
            case _CypherParser.ADMINISTRATOR:
            case _CypherParser.BRIEF:
            case _CypherParser.VERBOSE:
            case _CypherParser.OUTPUT:
            case _CypherParser.HexLetter:
            case _CypherParser.UnescapedSymbolicName:
            case _CypherParser.EscapedSymbolicName:
              this.state = 1556;
              this.password();
              break;
            case _CypherParser.T__13:
            case _CypherParser.T__33:
              this.state = 1557;
              this.parameter();
              break;
            default:
              throw new es_default.error.NoViableAltException(this);
          }
          this.state = 1562;
          this._errHandler.sync(this);
          var la_ = this._interp.adaptivePredict(this._input, 145, this._ctx);
          if (la_ === 1) {
            this.state = 1560;
            this.match(_CypherParser.SP);
            this.state = 1561;
            this.passwordStatus();
          }
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 1564;
          this.match(_CypherParser.SET);
          this.state = 1565;
          this.match(_CypherParser.SP);
          this.state = 1566;
          this.match(_CypherParser.PASSWORD);
          this.state = 1567;
          this.match(_CypherParser.SP);
          this.state = 1568;
          this.passwordStatus();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  passwordStatus() {
    let localctx = new PasswordStatusContext(this, this._ctx, this.state);
    this.enterRule(localctx, 172, _CypherParser.RULE_passwordStatus);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1571;
      this.match(_CypherParser.CHANGE);
      this.state = 1572;
      this.match(_CypherParser.SP);
      this.state = 1575;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.NOT) {
        this.state = 1573;
        this.match(_CypherParser.NOT);
        this.state = 1574;
        this.match(_CypherParser.SP);
      }
      this.state = 1577;
      this.match(_CypherParser.REQUIRED);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  setStatus() {
    let localctx = new SetStatusContext(this, this._ctx, this.state);
    this.enterRule(localctx, 174, _CypherParser.RULE_setStatus);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1579;
      this.match(_CypherParser.SET);
      this.state = 1580;
      this.match(_CypherParser.SP);
      this.state = 1581;
      this.match(_CypherParser.STATUS);
      this.state = 1582;
      this.match(_CypherParser.SP);
      this.state = 1583;
      this.userStatus();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  userStatus() {
    let localctx = new UserStatusContext(this, this._ctx, this.state);
    this.enterRule(localctx, 176, _CypherParser.RULE_userStatus);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1585;
      _la = this._input.LA(1);
      if (!(_la === _CypherParser.ACTIVE || _la === _CypherParser.SUSPENDED)) {
        this._errHandler.recoverInline(this);
      } else {
        this._errHandler.reportMatch(this);
        this.consume();
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  createUniqueConstraint() {
    let localctx = new CreateUniqueConstraintContext(this, this._ctx, this.state);
    this.enterRule(localctx, 178, _CypherParser.RULE_createUniqueConstraint);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1587;
      this.match(_CypherParser.CREATE);
      this.state = 1588;
      this.match(_CypherParser.SP);
      this.state = 1589;
      this.uniqueConstraint();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  createNodeKeyConstraint() {
    let localctx = new CreateNodeKeyConstraintContext(this, this._ctx, this.state);
    this.enterRule(localctx, 180, _CypherParser.RULE_createNodeKeyConstraint);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1591;
      this.match(_CypherParser.CREATE);
      this.state = 1592;
      this.match(_CypherParser.SP);
      this.state = 1593;
      this.nodeKeyConstraint();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  createNodePropertyExistenceConstraint() {
    let localctx = new CreateNodePropertyExistenceConstraintContext(this, this._ctx, this.state);
    this.enterRule(localctx, 182, _CypherParser.RULE_createNodePropertyExistenceConstraint);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1595;
      this.match(_CypherParser.CREATE);
      this.state = 1596;
      this.match(_CypherParser.SP);
      this.state = 1597;
      this.nodePropertyExistenceConstraint();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  createRelationshipPropertyExistenceConstraint() {
    let localctx = new CreateRelationshipPropertyExistenceConstraintContext(this, this._ctx, this.state);
    this.enterRule(localctx, 184, _CypherParser.RULE_createRelationshipPropertyExistenceConstraint);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1599;
      this.match(_CypherParser.CREATE);
      this.state = 1600;
      this.match(_CypherParser.SP);
      this.state = 1601;
      this.relationshipPropertyExistenceConstraint();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  createIndex() {
    let localctx = new CreateIndexContext(this, this._ctx, this.state);
    this.enterRule(localctx, 186, _CypherParser.RULE_createIndex);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1603;
      this.match(_CypherParser.CREATE);
      this.state = 1604;
      this.match(_CypherParser.SP);
      this.state = 1605;
      this.index();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  dropUniqueConstraint() {
    let localctx = new DropUniqueConstraintContext(this, this._ctx, this.state);
    this.enterRule(localctx, 188, _CypherParser.RULE_dropUniqueConstraint);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1607;
      this.match(_CypherParser.DROP);
      this.state = 1608;
      this.match(_CypherParser.SP);
      this.state = 1609;
      this.uniqueConstraint();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  dropNodeKeyConstraint() {
    let localctx = new DropNodeKeyConstraintContext(this, this._ctx, this.state);
    this.enterRule(localctx, 190, _CypherParser.RULE_dropNodeKeyConstraint);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1611;
      this.match(_CypherParser.DROP);
      this.state = 1612;
      this.match(_CypherParser.SP);
      this.state = 1613;
      this.nodeKeyConstraint();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  dropNodePropertyExistenceConstraint() {
    let localctx = new DropNodePropertyExistenceConstraintContext(this, this._ctx, this.state);
    this.enterRule(localctx, 192, _CypherParser.RULE_dropNodePropertyExistenceConstraint);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1615;
      this.match(_CypherParser.DROP);
      this.state = 1616;
      this.match(_CypherParser.SP);
      this.state = 1617;
      this.nodePropertyExistenceConstraint();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  dropRelationshipPropertyExistenceConstraint() {
    let localctx = new DropRelationshipPropertyExistenceConstraintContext(this, this._ctx, this.state);
    this.enterRule(localctx, 194, _CypherParser.RULE_dropRelationshipPropertyExistenceConstraint);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1619;
      this.match(_CypherParser.DROP);
      this.state = 1620;
      this.match(_CypherParser.SP);
      this.state = 1621;
      this.relationshipPropertyExistenceConstraint();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  dropIndex() {
    let localctx = new DropIndexContext(this, this._ctx, this.state);
    this.enterRule(localctx, 196, _CypherParser.RULE_dropIndex);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1623;
      this.match(_CypherParser.DROP);
      this.state = 1624;
      this.match(_CypherParser.SP);
      this.state = 1625;
      this.index();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  index() {
    let localctx = new IndexContext(this, this._ctx, this.state);
    this.enterRule(localctx, 198, _CypherParser.RULE_index);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1627;
      this.match(_CypherParser.INDEX);
      this.state = 1628;
      this.match(_CypherParser.SP);
      this.state = 1629;
      this.match(_CypherParser.ON);
      this.state = 1631;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1630;
        this.match(_CypherParser.SP);
      }
      this.state = 1633;
      this.nodeLabel();
      this.state = 1635;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1634;
        this.match(_CypherParser.SP);
      }
      this.state = 1637;
      this.match(_CypherParser.T__19);
      this.state = 1639;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1638;
        this.match(_CypherParser.SP);
      }
      this.state = 1641;
      this.propertyKeys();
      this.state = 1643;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1642;
        this.match(_CypherParser.SP);
      }
      this.state = 1645;
      this.match(_CypherParser.T__20);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  uniqueConstraint() {
    let localctx = new UniqueConstraintContext(this, this._ctx, this.state);
    this.enterRule(localctx, 200, _CypherParser.RULE_uniqueConstraint);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1647;
      this.match(_CypherParser.CONSTRAINT);
      this.state = 1648;
      this.match(_CypherParser.SP);
      this.state = 1649;
      this.match(_CypherParser.ON);
      this.state = 1651;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1650;
        this.match(_CypherParser.SP);
      }
      this.state = 1653;
      this.match(_CypherParser.T__19);
      this.state = 1655;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1654;
        this.match(_CypherParser.SP);
      }
      this.state = 1657;
      this.variable();
      this.state = 1658;
      this.nodeLabel();
      this.state = 1660;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1659;
        this.match(_CypherParser.SP);
      }
      this.state = 1662;
      this.match(_CypherParser.T__20);
      this.state = 1664;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1663;
        this.match(_CypherParser.SP);
      }
      this.state = 1666;
      this.match(_CypherParser.ASSERT);
      this.state = 1667;
      this.match(_CypherParser.SP);
      this.state = 1668;
      this.propertyExpression();
      this.state = 1669;
      this.match(_CypherParser.SP);
      this.state = 1670;
      this.match(_CypherParser.IS);
      this.state = 1671;
      this.match(_CypherParser.SP);
      this.state = 1672;
      this.match(_CypherParser.UNIQUE);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  nodeKeyConstraint() {
    let localctx = new NodeKeyConstraintContext(this, this._ctx, this.state);
    this.enterRule(localctx, 202, _CypherParser.RULE_nodeKeyConstraint);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1674;
      this.match(_CypherParser.CONSTRAINT);
      this.state = 1675;
      this.match(_CypherParser.SP);
      this.state = 1676;
      this.match(_CypherParser.ON);
      this.state = 1678;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1677;
        this.match(_CypherParser.SP);
      }
      this.state = 1680;
      this.match(_CypherParser.T__19);
      this.state = 1682;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1681;
        this.match(_CypherParser.SP);
      }
      this.state = 1684;
      this.variable();
      this.state = 1685;
      this.nodeLabel();
      this.state = 1687;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1686;
        this.match(_CypherParser.SP);
      }
      this.state = 1689;
      this.match(_CypherParser.T__20);
      this.state = 1691;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1690;
        this.match(_CypherParser.SP);
      }
      this.state = 1693;
      this.match(_CypherParser.ASSERT);
      this.state = 1694;
      this.match(_CypherParser.SP);
      this.state = 1695;
      this.match(_CypherParser.T__19);
      this.state = 1697;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1696;
        this.match(_CypherParser.SP);
      }
      this.state = 1699;
      this.propertyExpressions();
      this.state = 1701;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1700;
        this.match(_CypherParser.SP);
      }
      this.state = 1703;
      this.match(_CypherParser.T__20);
      this.state = 1704;
      this.match(_CypherParser.SP);
      this.state = 1705;
      this.match(_CypherParser.IS);
      this.state = 1706;
      this.match(_CypherParser.SP);
      this.state = 1707;
      this.match(_CypherParser.NODE);
      this.state = 1708;
      this.match(_CypherParser.SP);
      this.state = 1709;
      this.match(_CypherParser.KEY);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  nodePropertyExistenceConstraint() {
    let localctx = new NodePropertyExistenceConstraintContext(this, this._ctx, this.state);
    this.enterRule(localctx, 204, _CypherParser.RULE_nodePropertyExistenceConstraint);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1711;
      this.match(_CypherParser.CONSTRAINT);
      this.state = 1712;
      this.match(_CypherParser.SP);
      this.state = 1713;
      this.match(_CypherParser.ON);
      this.state = 1715;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1714;
        this.match(_CypherParser.SP);
      }
      this.state = 1717;
      this.match(_CypherParser.T__19);
      this.state = 1718;
      this.variable();
      this.state = 1719;
      this.nodeLabel();
      this.state = 1720;
      this.match(_CypherParser.T__20);
      this.state = 1722;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1721;
        this.match(_CypherParser.SP);
      }
      this.state = 1724;
      this.match(_CypherParser.ASSERT);
      this.state = 1725;
      this.match(_CypherParser.SP);
      this.state = 1726;
      this.match(_CypherParser.EXISTS);
      this.state = 1728;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1727;
        this.match(_CypherParser.SP);
      }
      this.state = 1730;
      this.match(_CypherParser.T__19);
      this.state = 1731;
      this.propertyExpression();
      this.state = 1732;
      this.match(_CypherParser.T__20);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  relationshipPropertyExistenceConstraint() {
    let localctx = new RelationshipPropertyExistenceConstraintContext(this, this._ctx, this.state);
    this.enterRule(localctx, 206, _CypherParser.RULE_relationshipPropertyExistenceConstraint);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1734;
      this.match(_CypherParser.CONSTRAINT);
      this.state = 1735;
      this.match(_CypherParser.SP);
      this.state = 1736;
      this.match(_CypherParser.ON);
      this.state = 1738;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1737;
        this.match(_CypherParser.SP);
      }
      this.state = 1740;
      this.relationshipPatternSyntax();
      this.state = 1742;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1741;
        this.match(_CypherParser.SP);
      }
      this.state = 1744;
      this.match(_CypherParser.ASSERT);
      this.state = 1745;
      this.match(_CypherParser.SP);
      this.state = 1746;
      this.match(_CypherParser.EXISTS);
      this.state = 1748;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1747;
        this.match(_CypherParser.SP);
      }
      this.state = 1750;
      this.match(_CypherParser.T__19);
      this.state = 1751;
      this.propertyExpression();
      this.state = 1752;
      this.match(_CypherParser.T__20);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  relationshipPatternSyntax() {
    let localctx = new RelationshipPatternSyntaxContext(this, this._ctx, this.state);
    this.enterRule(localctx, 208, _CypherParser.RULE_relationshipPatternSyntax);
    var _la = 0;
    try {
      this.state = 1807;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 174, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 1754;
          this.match(_CypherParser.T__19);
          this.state = 1756;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1755;
            this.match(_CypherParser.SP);
          }
          this.state = 1758;
          this.match(_CypherParser.T__20);
          this.state = 1759;
          this.dash();
          this.state = 1760;
          this.match(_CypherParser.T__16);
          this.state = 1761;
          this.variable();
          this.state = 1762;
          this.relType();
          this.state = 1763;
          this.match(_CypherParser.T__17);
          this.state = 1764;
          this.dash();
          this.state = 1765;
          this.match(_CypherParser.T__19);
          this.state = 1767;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1766;
            this.match(_CypherParser.SP);
          }
          this.state = 1769;
          this.match(_CypherParser.T__20);
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 1771;
          this.match(_CypherParser.T__19);
          this.state = 1773;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1772;
            this.match(_CypherParser.SP);
          }
          this.state = 1775;
          this.match(_CypherParser.T__20);
          this.state = 1776;
          this.dash();
          this.state = 1777;
          this.match(_CypherParser.T__16);
          this.state = 1778;
          this.variable();
          this.state = 1779;
          this.relType();
          this.state = 1780;
          this.match(_CypherParser.T__17);
          this.state = 1781;
          this.dash();
          this.state = 1782;
          this.rightArrowHead();
          this.state = 1783;
          this.match(_CypherParser.T__19);
          this.state = 1785;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1784;
            this.match(_CypherParser.SP);
          }
          this.state = 1787;
          this.match(_CypherParser.T__20);
          break;
        case 3:
          this.enterOuterAlt(localctx, 3);
          this.state = 1789;
          this.match(_CypherParser.T__19);
          this.state = 1791;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1790;
            this.match(_CypherParser.SP);
          }
          this.state = 1793;
          this.match(_CypherParser.T__20);
          this.state = 1794;
          this.leftArrowHead();
          this.state = 1795;
          this.dash();
          this.state = 1796;
          this.match(_CypherParser.T__16);
          this.state = 1797;
          this.variable();
          this.state = 1798;
          this.relType();
          this.state = 1799;
          this.match(_CypherParser.T__17);
          this.state = 1800;
          this.dash();
          this.state = 1801;
          this.match(_CypherParser.T__19);
          this.state = 1803;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1802;
            this.match(_CypherParser.SP);
          }
          this.state = 1805;
          this.match(_CypherParser.T__20);
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  loadCSVClause() {
    let localctx = new LoadCSVClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 210, _CypherParser.RULE_loadCSVClause);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1809;
      this.match(_CypherParser.LOAD);
      this.state = 1810;
      this.match(_CypherParser.SP);
      this.state = 1811;
      this.match(_CypherParser.CSV);
      this.state = 1812;
      this.match(_CypherParser.SP);
      this.state = 1817;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.WITH) {
        this.state = 1813;
        this.match(_CypherParser.WITH);
        this.state = 1814;
        this.match(_CypherParser.SP);
        this.state = 1815;
        this.match(_CypherParser.HEADERS);
        this.state = 1816;
        this.match(_CypherParser.SP);
      }
      this.state = 1819;
      this.match(_CypherParser.FROM);
      this.state = 1820;
      this.match(_CypherParser.SP);
      this.state = 1821;
      this.expression();
      this.state = 1822;
      this.match(_CypherParser.SP);
      this.state = 1823;
      this.match(_CypherParser.AS);
      this.state = 1824;
      this.match(_CypherParser.SP);
      this.state = 1825;
      this.variable();
      this.state = 1826;
      this.match(_CypherParser.SP);
      this.state = 1830;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.FIELDTERMINATOR) {
        this.state = 1827;
        this.match(_CypherParser.FIELDTERMINATOR);
        this.state = 1828;
        this.match(_CypherParser.SP);
        this.state = 1829;
        this.match(_CypherParser.StringLiteral);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  matchClause() {
    let localctx = new MatchClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 212, _CypherParser.RULE_matchClause);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1834;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.OPTIONAL) {
        this.state = 1832;
        this.match(_CypherParser.OPTIONAL);
        this.state = 1833;
        this.match(_CypherParser.SP);
      }
      this.state = 1836;
      this.match(_CypherParser.MATCH);
      this.state = 1838;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1837;
        this.match(_CypherParser.SP);
      }
      this.state = 1840;
      this.pattern();
      this.state = 1844;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 179, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 1841;
          this.hint();
        }
        this.state = 1846;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 179, this._ctx);
      }
      this.state = 1851;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 181, this._ctx);
      if (la_ === 1) {
        this.state = 1848;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 1847;
          this.match(_CypherParser.SP);
        }
        this.state = 1850;
        this.where();
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  unwindClause() {
    let localctx = new UnwindClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 214, _CypherParser.RULE_unwindClause);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1853;
      this.match(_CypherParser.UNWIND);
      this.state = 1855;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1854;
        this.match(_CypherParser.SP);
      }
      this.state = 1857;
      this.expression();
      this.state = 1858;
      this.match(_CypherParser.SP);
      this.state = 1859;
      this.match(_CypherParser.AS);
      this.state = 1860;
      this.match(_CypherParser.SP);
      this.state = 1861;
      this.variable();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  mergeClause() {
    let localctx = new MergeClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 216, _CypherParser.RULE_mergeClause);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1863;
      this.match(_CypherParser.MERGE);
      this.state = 1865;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1864;
        this.match(_CypherParser.SP);
      }
      this.state = 1867;
      this.patternPart();
      this.state = 1872;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 184, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 1868;
          this.match(_CypherParser.SP);
          this.state = 1869;
          this.mergeAction();
        }
        this.state = 1874;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 184, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  mergeAction() {
    let localctx = new MergeActionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 218, _CypherParser.RULE_mergeAction);
    try {
      this.state = 1885;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 185, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 1875;
          this.match(_CypherParser.ON);
          this.state = 1876;
          this.match(_CypherParser.SP);
          this.state = 1877;
          this.match(_CypherParser.MATCH);
          this.state = 1878;
          this.match(_CypherParser.SP);
          this.state = 1879;
          this.setClause();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 1880;
          this.match(_CypherParser.ON);
          this.state = 1881;
          this.match(_CypherParser.SP);
          this.state = 1882;
          this.match(_CypherParser.CREATE);
          this.state = 1883;
          this.match(_CypherParser.SP);
          this.state = 1884;
          this.setClause();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  createClause() {
    let localctx = new CreateClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 220, _CypherParser.RULE_createClause);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1887;
      this.match(_CypherParser.CREATE);
      this.state = 1889;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1888;
        this.match(_CypherParser.SP);
      }
      this.state = 1891;
      this.pattern();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  createUniqueClause() {
    let localctx = new CreateUniqueClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 222, _CypherParser.RULE_createUniqueClause);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1893;
      this.match(_CypherParser.CREATE);
      this.state = 1894;
      this.match(_CypherParser.SP);
      this.state = 1895;
      this.match(_CypherParser.UNIQUE);
      this.state = 1897;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1896;
        this.match(_CypherParser.SP);
      }
      this.state = 1899;
      this.pattern();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  setClause() {
    let localctx = new SetClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 224, _CypherParser.RULE_setClause);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1901;
      this.match(_CypherParser.SET);
      this.state = 1903;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1902;
        this.match(_CypherParser.SP);
      }
      this.state = 1905;
      this.setItem();
      this.state = 1916;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 191, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 1907;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1906;
            this.match(_CypherParser.SP);
          }
          this.state = 1909;
          this.match(_CypherParser.T__14);
          this.state = 1911;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1910;
            this.match(_CypherParser.SP);
          }
          this.state = 1913;
          this.setItem();
        }
        this.state = 1918;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 191, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  setItem() {
    let localctx = new SetItemContext(this, this._ctx, this.state);
    this.enterRule(localctx, 226, _CypherParser.RULE_setItem);
    var _la = 0;
    try {
      this.state = 1955;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 199, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 1919;
          this.propertyExpression();
          this.state = 1921;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1920;
            this.match(_CypherParser.SP);
          }
          this.state = 1923;
          this.match(_CypherParser.T__11);
          this.state = 1925;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1924;
            this.match(_CypherParser.SP);
          }
          this.state = 1927;
          this.expression();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 1929;
          this.variable();
          this.state = 1931;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1930;
            this.match(_CypherParser.SP);
          }
          this.state = 1933;
          this.match(_CypherParser.T__11);
          this.state = 1935;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1934;
            this.match(_CypherParser.SP);
          }
          this.state = 1937;
          this.expression();
          break;
        case 3:
          this.enterOuterAlt(localctx, 3);
          this.state = 1939;
          this.variable();
          this.state = 1941;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1940;
            this.match(_CypherParser.SP);
          }
          this.state = 1943;
          this.match(_CypherParser.T__21);
          this.state = 1945;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1944;
            this.match(_CypherParser.SP);
          }
          this.state = 1947;
          this.expression();
          break;
        case 4:
          this.enterOuterAlt(localctx, 4);
          this.state = 1949;
          this.variable();
          this.state = 1951;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1950;
            this.match(_CypherParser.SP);
          }
          this.state = 1953;
          this.nodeLabels();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  deleteClause() {
    let localctx = new DeleteClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 228, _CypherParser.RULE_deleteClause);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1959;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.DETACH) {
        this.state = 1957;
        this.match(_CypherParser.DETACH);
        this.state = 1958;
        this.match(_CypherParser.SP);
      }
      this.state = 1961;
      this.match(_CypherParser.DELETE);
      this.state = 1963;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 1962;
        this.match(_CypherParser.SP);
      }
      this.state = 1965;
      this.expression();
      this.state = 1976;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 204, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 1967;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1966;
            this.match(_CypherParser.SP);
          }
          this.state = 1969;
          this.match(_CypherParser.T__14);
          this.state = 1971;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1970;
            this.match(_CypherParser.SP);
          }
          this.state = 1973;
          this.expression();
        }
        this.state = 1978;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 204, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  removeClause() {
    let localctx = new RemoveClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 230, _CypherParser.RULE_removeClause);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 1979;
      this.match(_CypherParser.REMOVE);
      this.state = 1980;
      this.match(_CypherParser.SP);
      this.state = 1981;
      this.removeItem();
      this.state = 1992;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 207, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 1983;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1982;
            this.match(_CypherParser.SP);
          }
          this.state = 1985;
          this.match(_CypherParser.T__14);
          this.state = 1987;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 1986;
            this.match(_CypherParser.SP);
          }
          this.state = 1989;
          this.removeItem();
        }
        this.state = 1994;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 207, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  removeItem() {
    let localctx = new RemoveItemContext(this, this._ctx, this.state);
    this.enterRule(localctx, 232, _CypherParser.RULE_removeItem);
    try {
      this.state = 1999;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 208, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 1995;
          this.variable();
          this.state = 1996;
          this.nodeLabels();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 1998;
          this.propertyExpression();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  foreachClause() {
    let localctx = new ForeachClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 234, _CypherParser.RULE_foreachClause);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2001;
      this.match(_CypherParser.FOREACH);
      this.state = 2003;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2002;
        this.match(_CypherParser.SP);
      }
      this.state = 2005;
      this.match(_CypherParser.T__19);
      this.state = 2007;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2006;
        this.match(_CypherParser.SP);
      }
      this.state = 2009;
      this.variable();
      this.state = 2010;
      this.match(_CypherParser.SP);
      this.state = 2011;
      this.match(_CypherParser.IN);
      this.state = 2012;
      this.match(_CypherParser.SP);
      this.state = 2013;
      this.expression();
      this.state = 2015;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2014;
        this.match(_CypherParser.SP);
      }
      this.state = 2017;
      this.match(_CypherParser.T__22);
      this.state = 2020;
      this._errHandler.sync(this);
      var _alt = 1;
      do {
        switch (_alt) {
          case 1:
            this.state = 2018;
            this.match(_CypherParser.SP);
            this.state = 2019;
            this.clause();
            break;
          default:
            throw new es_default.error.NoViableAltException(this);
        }
        this.state = 2022;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 212, this._ctx);
      } while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER);
      this.state = 2025;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2024;
        this.match(_CypherParser.SP);
      }
      this.state = 2027;
      this.match(_CypherParser.T__20);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  withClause() {
    let localctx = new WithClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 236, _CypherParser.RULE_withClause);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2029;
      this.match(_CypherParser.WITH);
      this.state = 2034;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 215, this._ctx);
      if (la_ === 1) {
        this.state = 2031;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 2030;
          this.match(_CypherParser.SP);
        }
        this.state = 2033;
        this.match(_CypherParser.DISTINCT);
      }
      this.state = 2036;
      this.match(_CypherParser.SP);
      this.state = 2037;
      this.returnBody();
      this.state = 2042;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 217, this._ctx);
      if (la_ === 1) {
        this.state = 2039;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 2038;
          this.match(_CypherParser.SP);
        }
        this.state = 2041;
        this.where();
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  returnClause() {
    let localctx = new ReturnClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 238, _CypherParser.RULE_returnClause);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2044;
      this.match(_CypherParser.RETURN);
      this.state = 2049;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 219, this._ctx);
      if (la_ === 1) {
        this.state = 2046;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 2045;
          this.match(_CypherParser.SP);
        }
        this.state = 2048;
        this.match(_CypherParser.DISTINCT);
      }
      this.state = 2052;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2051;
        this.match(_CypherParser.SP);
      }
      this.state = 2054;
      this.returnBody();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  returnBody() {
    let localctx = new ReturnBodyContext(this, this._ctx, this.state);
    this.enterRule(localctx, 240, _CypherParser.RULE_returnBody);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2056;
      this.returnItems();
      this.state = 2059;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 221, this._ctx);
      if (la_ === 1) {
        this.state = 2057;
        this.match(_CypherParser.SP);
        this.state = 2058;
        this.order();
      }
      this.state = 2063;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 222, this._ctx);
      if (la_ === 1) {
        this.state = 2061;
        this.match(_CypherParser.SP);
        this.state = 2062;
        this.skip();
      }
      this.state = 2067;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 223, this._ctx);
      if (la_ === 1) {
        this.state = 2065;
        this.match(_CypherParser.SP);
        this.state = 2066;
        this.limit();
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  func() {
    let localctx = new FuncContext(this, this._ctx, this.state);
    this.enterRule(localctx, 242, _CypherParser.RULE_func);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2069;
      this.procedureInvocation();
      this.state = 2071;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 224, this._ctx);
      if (la_ === 1) {
        this.state = 2070;
        this.match(_CypherParser.SP);
      }
      this.state = 2074;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.YIELD) {
        this.state = 2073;
        this.procedureResults();
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  returnItems() {
    let localctx = new ReturnItemsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 244, _CypherParser.RULE_returnItems);
    var _la = 0;
    try {
      this.state = 2105;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 232, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 2076;
          this.match(_CypherParser.T__18);
          this.state = 2087;
          this._errHandler.sync(this);
          var _alt = this._interp.adaptivePredict(this._input, 228, this._ctx);
          while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
            if (_alt === 1) {
              this.state = 2078;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 2077;
                this.match(_CypherParser.SP);
              }
              this.state = 2080;
              this.match(_CypherParser.T__14);
              this.state = 2082;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 2081;
                this.match(_CypherParser.SP);
              }
              this.state = 2084;
              this.returnItem();
            }
            this.state = 2089;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input, 228, this._ctx);
          }
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 2090;
          this.returnItem();
          this.state = 2101;
          this._errHandler.sync(this);
          var _alt = this._interp.adaptivePredict(this._input, 231, this._ctx);
          while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
            if (_alt === 1) {
              this.state = 2092;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 2091;
                this.match(_CypherParser.SP);
              }
              this.state = 2094;
              this.match(_CypherParser.T__14);
              this.state = 2096;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 2095;
                this.match(_CypherParser.SP);
              }
              this.state = 2098;
              this.returnItem();
            }
            this.state = 2103;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input, 231, this._ctx);
          }
          break;
        case 3:
          this.enterOuterAlt(localctx, 3);
          this.state = 2104;
          this.func();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  returnItem() {
    let localctx = new ReturnItemContext(this, this._ctx, this.state);
    this.enterRule(localctx, 246, _CypherParser.RULE_returnItem);
    try {
      this.state = 2114;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 233, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 2107;
          this.expression();
          this.state = 2108;
          this.match(_CypherParser.SP);
          this.state = 2109;
          this.match(_CypherParser.AS);
          this.state = 2110;
          this.match(_CypherParser.SP);
          this.state = 2111;
          this.variable();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 2113;
          this.expression();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  call() {
    let localctx = new CallContext(this, this._ctx, this.state);
    this.enterRule(localctx, 248, _CypherParser.RULE_call);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2116;
      this.match(_CypherParser.CALL);
      this.state = 2117;
      this.match(_CypherParser.SP);
      this.state = 2118;
      this.procedureInvocation();
      this.state = 2120;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 234, this._ctx);
      if (la_ === 1) {
        this.state = 2119;
        this.match(_CypherParser.SP);
      }
      this.state = 2123;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.YIELD) {
        this.state = 2122;
        this.procedureResults();
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  procedureInvocation() {
    let localctx = new ProcedureInvocationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 250, _CypherParser.RULE_procedureInvocation);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2125;
      this.procedureInvocationBody();
      this.state = 2127;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 236, this._ctx);
      if (la_ === 1) {
        this.state = 2126;
        this.match(_CypherParser.SP);
      }
      this.state = 2130;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.T__19) {
        this.state = 2129;
        this.procedureArguments();
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  procedureInvocationBody() {
    let localctx = new ProcedureInvocationBodyContext(this, this._ctx, this.state);
    this.enterRule(localctx, 252, _CypherParser.RULE_procedureInvocationBody);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2132;
      this.namespace();
      this.state = 2133;
      this.procedureName();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  procedureArguments() {
    let localctx = new ProcedureArgumentsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 254, _CypherParser.RULE_procedureArguments);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2135;
      this.match(_CypherParser.T__19);
      this.state = 2137;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 238, this._ctx);
      if (la_ === 1) {
        this.state = 2136;
        this.match(_CypherParser.SP);
      }
      this.state = 2140;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if ((_la & ~31) == 0 && (1 << _la & (1 << _CypherParser.T__2 | 1 << _CypherParser.T__12 | 1 << _CypherParser.T__13 | 1 << _CypherParser.T__16 | 1 << _CypherParser.T__19)) !== 0 || (_la - 34 & ~31) == 0 && (1 << _la - 34 & (1 << _CypherParser.T__33 - 34 | 1 << _CypherParser.CYPHER - 34 | 1 << _CypherParser.EXPLAIN - 34 | 1 << _CypherParser.PROFILE - 34 | 1 << _CypherParser.USING - 34 | 1 << _CypherParser.PERIODIC - 34 | 1 << _CypherParser.COMMIT - 34 | 1 << _CypherParser.UNION - 34 | 1 << _CypherParser.ALL - 34 | 1 << _CypherParser.CREATE - 34 | 1 << _CypherParser.DROP - 34 | 1 << _CypherParser.INDEX - 34 | 1 << _CypherParser.ON - 34)) !== 0 || (_la - 66 & ~31) == 0 && (1 << _la - 66 & (1 << _CypherParser.CONSTRAINT - 66 | 1 << _CypherParser.ASSERT - 66 | 1 << _CypherParser.IS - 66 | 1 << _CypherParser.UNIQUE - 66 | 1 << _CypherParser.EXISTS - 66 | 1 << _CypherParser.LOAD - 66 | 1 << _CypherParser.CSV - 66 | 1 << _CypherParser.WITH - 66 | 1 << _CypherParser.HEADERS - 66 | 1 << _CypherParser.FROM - 66 | 1 << _CypherParser.AS - 66 | 1 << _CypherParser.FIELDTERMINATOR - 66 | 1 << _CypherParser.OPTIONAL - 66 | 1 << _CypherParser.MATCH - 66 | 1 << _CypherParser.UNWIND - 66 | 1 << _CypherParser.MERGE - 66 | 1 << _CypherParser.SET - 66 | 1 << _CypherParser.DETACH - 66 | 1 << _CypherParser.DELETE - 66 | 1 << _CypherParser.REMOVE - 66 | 1 << _CypherParser.FOREACH - 66 | 1 << _CypherParser.IN - 66 | 1 << _CypherParser.DISTINCT - 66 | 1 << _CypherParser.RETURN - 66 | 1 << _CypherParser.ORDER - 66 | 1 << _CypherParser.BY - 66 | 1 << _CypherParser.L_SKIP - 66 | 1 << _CypherParser.LIMIT - 66 | 1 << _CypherParser.ASCENDING - 66 | 1 << _CypherParser.ASC - 66 | 1 << _CypherParser.DESCENDING - 66 | 1 << _CypherParser.DESC - 66)) !== 0 || (_la - 98 & ~31) == 0 && (1 << _la - 98 & (1 << _CypherParser.JOIN - 98 | 1 << _CypherParser.SCAN - 98 | 1 << _CypherParser.START - 98 | 1 << _CypherParser.NODE - 98 | 1 << _CypherParser.RELATIONSHIP - 98 | 1 << _CypherParser.REL - 98 | 1 << _CypherParser.WHERE - 98 | 1 << _CypherParser.SHORTESTPATH - 98 | 1 << _CypherParser.ALLSHORTESTPATHS - 98 | 1 << _CypherParser.OR - 98 | 1 << _CypherParser.XOR - 98 | 1 << _CypherParser.AND - 98 | 1 << _CypherParser.NOT - 98 | 1 << _CypherParser.STARTS - 98 | 1 << _CypherParser.ENDS - 98 | 1 << _CypherParser.CONTAINS - 98 | 1 << _CypherParser.NULL - 98 | 1 << _CypherParser.COUNT - 98 | 1 << _CypherParser.FILTER - 98 | 1 << _CypherParser.EXTRACT - 98 | 1 << _CypherParser.ANY - 98 | 1 << _CypherParser.NONE - 98 | 1 << _CypherParser.SINGLE - 98 | 1 << _CypherParser.TRUE - 98 | 1 << _CypherParser.FALSE - 98 | 1 << _CypherParser.REDUCE - 98 | 1 << _CypherParser.CASE - 98 | 1 << _CypherParser.ELSE - 98 | 1 << _CypherParser.END - 98 | 1 << _CypherParser.WHEN - 98 | 1 << _CypherParser.THEN - 98 | 1 << _CypherParser.CALL - 98)) !== 0 || (_la - 130 & ~31) == 0 && (1 << _la - 130 & (1 << _CypherParser.YIELD - 130 | 1 << _CypherParser.KEY - 130 | 1 << _CypherParser.CATALOG - 130 | 1 << _CypherParser.SHOW - 130 | 1 << _CypherParser.DEFAULT - 130 | 1 << _CypherParser.DBMS - 130 | 1 << _CypherParser.DATABASE - 130 | 1 << _CypherParser.DATABASES - 130 | 1 << _CypherParser.GRAPH - 130 | 1 << _CypherParser.GRAPHS - 130 | 1 << _CypherParser.REPLACE - 130 | 1 << _CypherParser.IF - 130 | 1 << _CypherParser.STOP - 130 | 1 << _CypherParser.ROLE - 130 | 1 << _CypherParser.ROLES - 130 | 1 << _CypherParser.USER - 130 | 1 << _CypherParser.USERS - 130 | 1 << _CypherParser.POPULATED - 130 | 1 << _CypherParser.PASSWORD - 130 | 1 << _CypherParser.CHANGE - 130 | 1 << _CypherParser.REQUIRED - 130 | 1 << _CypherParser.STATUS - 130 | 1 << _CypherParser.ACTIVE - 130 | 1 << _CypherParser.SUSPENDED - 130 | 1 << _CypherParser.ALTER - 130 | 1 << _CypherParser.CURRENT - 130 | 1 << _CypherParser.TO - 130 | 1 << _CypherParser.PRIVILEGES - 130 | 1 << _CypherParser.GRANT - 130 | 1 << _CypherParser.DENY - 130 | 1 << _CypherParser.REVOKE - 130 | 1 << _CypherParser.RELATIONSHIPS - 130)) !== 0 || (_la - 162 & ~31) == 0 && (1 << _la - 162 & (1 << _CypherParser.NODES - 162 | 1 << _CypherParser.ELEMENT - 162 | 1 << _CypherParser.ELEMENTS - 162 | 1 << _CypherParser.COPY - 162 | 1 << _CypherParser.OF - 162 | 1 << _CypherParser.TRAVERSE - 162 | 1 << _CypherParser.READ - 162 | 1 << _CypherParser.WRITE - 162 | 1 << _CypherParser.ACCESS - 162 | 1 << _CypherParser.INDEXES - 162 | 1 << _CypherParser.MANAGEMENT - 162 | 1 << _CypherParser.NEW - 162 | 1 << _CypherParser.LABEL - 162 | 1 << _CypherParser.LABELS - 162 | 1 << _CypherParser.NAME - 162 | 1 << _CypherParser.NAMES - 162 | 1 << _CypherParser.TYPE - 162 | 1 << _CypherParser.TYPES - 162 | 1 << _CypherParser.PROPERTY - 162 | 1 << _CypherParser.CONSTRAINTS - 162 | 1 << _CypherParser.ASSIGN - 162 | 1 << _CypherParser.BTREE - 162 | 1 << _CypherParser.EXIST - 162 | 1 << _CypherParser.FOR - 162 | 1 << _CypherParser.OPTIONS - 162 | 1 << _CypherParser.EXECUTE - 162 | 1 << _CypherParser.DEFINED - 162 | 1 << _CypherParser.FUNCTION - 162 | 1 << _CypherParser.FUNCTIONS - 162 | 1 << _CypherParser.BOOSTED - 162 | 1 << _CypherParser.PROCEDURE - 162 | 1 << _CypherParser.PROCEDURES - 162)) !== 0 || (_la - 194 & ~31) == 0 && (1 << _la - 194 & (1 << _CypherParser.ADMIN - 194 | 1 << _CypherParser.ADMINISTRATOR - 194 | 1 << _CypherParser.BRIEF - 194 | 1 << _CypherParser.VERBOSE - 194 | 1 << _CypherParser.OUTPUT - 194 | 1 << _CypherParser.StringLiteral - 194 | 1 << _CypherParser.HexInteger - 194 | 1 << _CypherParser.DecimalInteger - 194 | 1 << _CypherParser.OctalInteger - 194 | 1 << _CypherParser.HexLetter - 194 | 1 << _CypherParser.ExponentDecimalReal - 194 | 1 << _CypherParser.RegularDecimalReal - 194 | 1 << _CypherParser.UnescapedSymbolicName - 194 | 1 << _CypherParser.EscapedSymbolicName - 194)) !== 0) {
        this.state = 2139;
        this.expression();
      }
      this.state = 2152;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 242, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 2143;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2142;
            this.match(_CypherParser.SP);
          }
          this.state = 2145;
          this.match(_CypherParser.T__14);
          this.state = 2147;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2146;
            this.match(_CypherParser.SP);
          }
          this.state = 2149;
          this.expression();
        }
        this.state = 2154;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 242, this._ctx);
      }
      this.state = 2156;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2155;
        this.match(_CypherParser.SP);
      }
      this.state = 2158;
      this.match(_CypherParser.T__20);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  procedureResults() {
    let localctx = new ProcedureResultsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 256, _CypherParser.RULE_procedureResults);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2160;
      this.match(_CypherParser.YIELD);
      this.state = 2161;
      this.match(_CypherParser.SP);
      this.state = 2162;
      this.procedureResult();
      this.state = 2173;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 246, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 2164;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2163;
            this.match(_CypherParser.SP);
          }
          this.state = 2166;
          this.match(_CypherParser.T__14);
          this.state = 2168;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2167;
            this.match(_CypherParser.SP);
          }
          this.state = 2170;
          this.procedureResult();
        }
        this.state = 2175;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 246, this._ctx);
      }
      this.state = 2178;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 247, this._ctx);
      if (la_ === 1) {
        this.state = 2176;
        this.match(_CypherParser.SP);
        this.state = 2177;
        this.where();
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  procedureResult() {
    let localctx = new ProcedureResultContext(this, this._ctx, this.state);
    this.enterRule(localctx, 258, _CypherParser.RULE_procedureResult);
    try {
      this.state = 2182;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 248, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 2180;
          this.aliasedProcedureResult();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 2181;
          this.simpleProcedureResult();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  aliasedProcedureResult() {
    let localctx = new AliasedProcedureResultContext(this, this._ctx, this.state);
    this.enterRule(localctx, 260, _CypherParser.RULE_aliasedProcedureResult);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2184;
      this.procedureOutput();
      this.state = 2185;
      this.match(_CypherParser.SP);
      this.state = 2186;
      this.match(_CypherParser.AS);
      this.state = 2187;
      this.match(_CypherParser.SP);
      this.state = 2188;
      this.variable();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  simpleProcedureResult() {
    let localctx = new SimpleProcedureResultContext(this, this._ctx, this.state);
    this.enterRule(localctx, 262, _CypherParser.RULE_simpleProcedureResult);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2190;
      this.procedureOutput();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  procedureOutput() {
    let localctx = new ProcedureOutputContext(this, this._ctx, this.state);
    this.enterRule(localctx, 264, _CypherParser.RULE_procedureOutput);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2192;
      this.symbolicName();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  order() {
    let localctx = new OrderContext(this, this._ctx, this.state);
    this.enterRule(localctx, 266, _CypherParser.RULE_order);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2194;
      this.match(_CypherParser.ORDER);
      this.state = 2195;
      this.match(_CypherParser.SP);
      this.state = 2196;
      this.match(_CypherParser.BY);
      this.state = 2197;
      this.match(_CypherParser.SP);
      this.state = 2198;
      this.sortItem();
      this.state = 2209;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 251, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 2200;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2199;
            this.match(_CypherParser.SP);
          }
          this.state = 2202;
          this.match(_CypherParser.T__14);
          this.state = 2204;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2203;
            this.match(_CypherParser.SP);
          }
          this.state = 2206;
          this.sortItem();
        }
        this.state = 2211;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 251, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  skip() {
    let localctx = new SkipContext(this, this._ctx, this.state);
    this.enterRule(localctx, 268, _CypherParser.RULE_skip);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2212;
      this.match(_CypherParser.L_SKIP);
      this.state = 2213;
      this.match(_CypherParser.SP);
      this.state = 2214;
      this.expression();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  limit() {
    let localctx = new LimitContext(this, this._ctx, this.state);
    this.enterRule(localctx, 270, _CypherParser.RULE_limit);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2216;
      this.match(_CypherParser.LIMIT);
      this.state = 2217;
      this.match(_CypherParser.SP);
      this.state = 2218;
      this.expression();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  sortItem() {
    let localctx = new SortItemContext(this, this._ctx, this.state);
    this.enterRule(localctx, 272, _CypherParser.RULE_sortItem);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2220;
      this.expression();
      this.state = 2228;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 254, this._ctx);
      if (la_ === 1) {
        this.state = 2222;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 2221;
          this.match(_CypherParser.SP);
        }
        this.state = 2224;
        _la = this._input.LA(1);
        if (!((_la - 94 & ~31) == 0 && (1 << _la - 94 & (1 << _CypherParser.ASCENDING - 94 | 1 << _CypherParser.ASC - 94 | 1 << _CypherParser.DESCENDING - 94 | 1 << _CypherParser.DESC - 94)) !== 0)) {
          this._errHandler.recoverInline(this);
        } else {
          this._errHandler.reportMatch(this);
          this.consume();
        }
        this.state = 2226;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input, 253, this._ctx);
        if (la_ === 1) {
          this.state = 2225;
          this.match(_CypherParser.SP);
        }
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  hint() {
    let localctx = new HintContext(this, this._ctx, this.state);
    this.enterRule(localctx, 274, _CypherParser.RULE_hint);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2231;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2230;
        this.match(_CypherParser.SP);
      }
      this.state = 2279;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 262, this._ctx);
      switch (la_) {
        case 1:
          this.state = 2233;
          this.match(_CypherParser.USING);
          this.state = 2234;
          this.match(_CypherParser.SP);
          this.state = 2235;
          this.match(_CypherParser.INDEX);
          this.state = 2236;
          this.match(_CypherParser.SP);
          this.state = 2237;
          this.variable();
          this.state = 2238;
          this.nodeLabel();
          this.state = 2240;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2239;
            this.match(_CypherParser.SP);
          }
          this.state = 2242;
          this.match(_CypherParser.T__19);
          this.state = 2244;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2243;
            this.match(_CypherParser.SP);
          }
          this.state = 2246;
          this.propertyKeys();
          this.state = 2248;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2247;
            this.match(_CypherParser.SP);
          }
          this.state = 2250;
          this.match(_CypherParser.T__20);
          break;
        case 2:
          this.state = 2252;
          this.match(_CypherParser.USING);
          this.state = 2253;
          this.match(_CypherParser.SP);
          this.state = 2254;
          this.match(_CypherParser.JOIN);
          this.state = 2255;
          this.match(_CypherParser.SP);
          this.state = 2256;
          this.match(_CypherParser.ON);
          this.state = 2257;
          this.match(_CypherParser.SP);
          this.state = 2258;
          this.variable();
          this.state = 2269;
          this._errHandler.sync(this);
          var _alt = this._interp.adaptivePredict(this._input, 261, this._ctx);
          while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
            if (_alt === 1) {
              this.state = 2260;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 2259;
                this.match(_CypherParser.SP);
              }
              this.state = 2262;
              this.match(_CypherParser.T__14);
              this.state = 2264;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 2263;
                this.match(_CypherParser.SP);
              }
              this.state = 2266;
              this.variable();
            }
            this.state = 2271;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input, 261, this._ctx);
          }
          break;
        case 3:
          this.state = 2272;
          this.match(_CypherParser.USING);
          this.state = 2273;
          this.match(_CypherParser.SP);
          this.state = 2274;
          this.match(_CypherParser.SCAN);
          this.state = 2275;
          this.match(_CypherParser.SP);
          this.state = 2276;
          this.variable();
          this.state = 2277;
          this.nodeLabel();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  startClause() {
    let localctx = new StartClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 276, _CypherParser.RULE_startClause);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2281;
      this.match(_CypherParser.START);
      this.state = 2282;
      this.match(_CypherParser.SP);
      this.state = 2283;
      this.startPoint();
      this.state = 2294;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 265, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 2285;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2284;
            this.match(_CypherParser.SP);
          }
          this.state = 2287;
          this.match(_CypherParser.T__14);
          this.state = 2289;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2288;
            this.match(_CypherParser.SP);
          }
          this.state = 2291;
          this.startPoint();
        }
        this.state = 2296;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 265, this._ctx);
      }
      this.state = 2298;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.WHERE) {
        this.state = 2297;
        this.where();
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  startPoint() {
    let localctx = new StartPointContext(this, this._ctx, this.state);
    this.enterRule(localctx, 278, _CypherParser.RULE_startPoint);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2300;
      this.variable();
      this.state = 2302;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2301;
        this.match(_CypherParser.SP);
      }
      this.state = 2304;
      this.match(_CypherParser.T__11);
      this.state = 2306;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2305;
        this.match(_CypherParser.SP);
      }
      this.state = 2308;
      this.lookup();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  lookup() {
    let localctx = new LookupContext(this, this._ctx, this.state);
    this.enterRule(localctx, 280, _CypherParser.RULE_lookup);
    try {
      this.state = 2312;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.NODE:
          this.enterOuterAlt(localctx, 1);
          this.state = 2310;
          this.nodeLookup();
          break;
        case _CypherParser.RELATIONSHIP:
        case _CypherParser.REL:
          this.enterOuterAlt(localctx, 2);
          this.state = 2311;
          this.relationshipLookup();
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  nodeLookup() {
    let localctx = new NodeLookupContext(this, this._ctx, this.state);
    this.enterRule(localctx, 282, _CypherParser.RULE_nodeLookup);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2314;
      this.match(_CypherParser.NODE);
      this.state = 2316;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2315;
        this.match(_CypherParser.SP);
      }
      this.state = 2321;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 271, this._ctx);
      switch (la_) {
        case 1:
          this.state = 2318;
          this.identifiedIndexLookup();
          break;
        case 2:
          this.state = 2319;
          this.indexQuery();
          break;
        case 3:
          this.state = 2320;
          this.idLookup();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  relationshipLookup() {
    let localctx = new RelationshipLookupContext(this, this._ctx, this.state);
    this.enterRule(localctx, 284, _CypherParser.RULE_relationshipLookup);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2323;
      _la = this._input.LA(1);
      if (!(_la === _CypherParser.RELATIONSHIP || _la === _CypherParser.REL)) {
        this._errHandler.recoverInline(this);
      } else {
        this._errHandler.reportMatch(this);
        this.consume();
      }
      this.state = 2327;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 272, this._ctx);
      switch (la_) {
        case 1:
          this.state = 2324;
          this.identifiedIndexLookup();
          break;
        case 2:
          this.state = 2325;
          this.indexQuery();
          break;
        case 3:
          this.state = 2326;
          this.idLookup();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  identifiedIndexLookup() {
    let localctx = new IdentifiedIndexLookupContext(this, this._ctx, this.state);
    this.enterRule(localctx, 286, _CypherParser.RULE_identifiedIndexLookup);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2329;
      this.match(_CypherParser.T__1);
      this.state = 2330;
      this.symbolicName();
      this.state = 2331;
      this.match(_CypherParser.T__19);
      this.state = 2332;
      this.symbolicName();
      this.state = 2333;
      this.match(_CypherParser.T__11);
      this.state = 2336;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.StringLiteral:
          this.state = 2334;
          this.match(_CypherParser.StringLiteral);
          break;
        case _CypherParser.T__13:
        case _CypherParser.T__33:
          this.state = 2335;
          this.parameter();
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
      this.state = 2338;
      this.match(_CypherParser.T__20);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  indexQuery() {
    let localctx = new IndexQueryContext(this, this._ctx, this.state);
    this.enterRule(localctx, 288, _CypherParser.RULE_indexQuery);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2340;
      this.match(_CypherParser.T__1);
      this.state = 2341;
      this.symbolicName();
      this.state = 2342;
      this.match(_CypherParser.T__19);
      this.state = 2345;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.StringLiteral:
          this.state = 2343;
          this.match(_CypherParser.StringLiteral);
          break;
        case _CypherParser.T__13:
        case _CypherParser.T__33:
          this.state = 2344;
          this.parameter();
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
      this.state = 2347;
      this.match(_CypherParser.T__20);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  idLookup() {
    let localctx = new IdLookupContext(this, this._ctx, this.state);
    this.enterRule(localctx, 290, _CypherParser.RULE_idLookup);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2349;
      this.match(_CypherParser.T__19);
      this.state = 2353;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.HexInteger:
        case _CypherParser.DecimalInteger:
        case _CypherParser.OctalInteger:
          this.state = 2350;
          this.literalIds();
          break;
        case _CypherParser.T__13:
        case _CypherParser.T__33:
          this.state = 2351;
          this.parameter();
          break;
        case _CypherParser.T__18:
          this.state = 2352;
          this.match(_CypherParser.T__18);
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
      this.state = 2355;
      this.match(_CypherParser.T__20);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  literalIds() {
    let localctx = new LiteralIdsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 292, _CypherParser.RULE_literalIds);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2357;
      this.integerLiteral();
      this.state = 2368;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      while (_la === _CypherParser.T__14 || _la === _CypherParser.SP) {
        this.state = 2359;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 2358;
          this.match(_CypherParser.SP);
        }
        this.state = 2361;
        this.match(_CypherParser.T__14);
        this.state = 2363;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 2362;
          this.match(_CypherParser.SP);
        }
        this.state = 2365;
        this.integerLiteral();
        this.state = 2370;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  where() {
    let localctx = new WhereContext(this, this._ctx, this.state);
    this.enterRule(localctx, 294, _CypherParser.RULE_where);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2371;
      this.match(_CypherParser.WHERE);
      this.state = 2372;
      this.match(_CypherParser.SP);
      this.state = 2373;
      this.expression();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  pattern() {
    let localctx = new PatternContext(this, this._ctx, this.state);
    this.enterRule(localctx, 296, _CypherParser.RULE_pattern);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2375;
      this.patternPart();
      this.state = 2386;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 281, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 2377;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2376;
            this.match(_CypherParser.SP);
          }
          this.state = 2379;
          this.match(_CypherParser.T__14);
          this.state = 2381;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2380;
            this.match(_CypherParser.SP);
          }
          this.state = 2383;
          this.patternPart();
        }
        this.state = 2388;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 281, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  patternPart() {
    let localctx = new PatternPartContext(this, this._ctx, this.state);
    this.enterRule(localctx, 298, _CypherParser.RULE_patternPart);
    var _la = 0;
    try {
      this.state = 2400;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 284, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 2389;
          this.variable();
          this.state = 2391;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2390;
            this.match(_CypherParser.SP);
          }
          this.state = 2393;
          this.match(_CypherParser.T__11);
          this.state = 2395;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2394;
            this.match(_CypherParser.SP);
          }
          this.state = 2397;
          this.anonymousPatternPart();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 2399;
          this.anonymousPatternPart();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  anonymousPatternPart() {
    let localctx = new AnonymousPatternPartContext(this, this._ctx, this.state);
    this.enterRule(localctx, 300, _CypherParser.RULE_anonymousPatternPart);
    try {
      this.state = 2404;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.SHORTESTPATH:
        case _CypherParser.ALLSHORTESTPATHS:
          this.enterOuterAlt(localctx, 1);
          this.state = 2402;
          this.shortestPathPatternFunction();
          break;
        case _CypherParser.T__19:
          this.enterOuterAlt(localctx, 2);
          this.state = 2403;
          this.patternElement();
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  patternElement() {
    let localctx = new PatternElementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 302, _CypherParser.RULE_patternElement);
    var _la = 0;
    try {
      this.state = 2420;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 288, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 2406;
          this.nodePattern();
          this.state = 2413;
          this._errHandler.sync(this);
          var _alt = this._interp.adaptivePredict(this._input, 287, this._ctx);
          while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
            if (_alt === 1) {
              this.state = 2408;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 2407;
                this.match(_CypherParser.SP);
              }
              this.state = 2410;
              this.patternElementChain();
            }
            this.state = 2415;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input, 287, this._ctx);
          }
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 2416;
          this.match(_CypherParser.T__19);
          this.state = 2417;
          this.patternElement();
          this.state = 2418;
          this.match(_CypherParser.T__20);
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  nodePattern() {
    let localctx = new NodePatternContext(this, this._ctx, this.state);
    this.enterRule(localctx, 304, _CypherParser.RULE_nodePattern);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2422;
      this.match(_CypherParser.T__19);
      this.state = 2424;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2423;
        this.match(_CypherParser.SP);
      }
      this.state = 2430;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if ((_la - 54 & ~31) == 0 && (1 << _la - 54 & (1 << _CypherParser.CYPHER - 54 | 1 << _CypherParser.EXPLAIN - 54 | 1 << _CypherParser.PROFILE - 54 | 1 << _CypherParser.USING - 54 | 1 << _CypherParser.PERIODIC - 54 | 1 << _CypherParser.COMMIT - 54 | 1 << _CypherParser.UNION - 54 | 1 << _CypherParser.ALL - 54 | 1 << _CypherParser.CREATE - 54 | 1 << _CypherParser.DROP - 54 | 1 << _CypherParser.INDEX - 54 | 1 << _CypherParser.ON - 54 | 1 << _CypherParser.CONSTRAINT - 54 | 1 << _CypherParser.ASSERT - 54 | 1 << _CypherParser.IS - 54 | 1 << _CypherParser.UNIQUE - 54 | 1 << _CypherParser.EXISTS - 54 | 1 << _CypherParser.LOAD - 54 | 1 << _CypherParser.CSV - 54 | 1 << _CypherParser.WITH - 54 | 1 << _CypherParser.HEADERS - 54 | 1 << _CypherParser.FROM - 54 | 1 << _CypherParser.AS - 54 | 1 << _CypherParser.FIELDTERMINATOR - 54 | 1 << _CypherParser.OPTIONAL - 54 | 1 << _CypherParser.MATCH - 54 | 1 << _CypherParser.UNWIND - 54 | 1 << _CypherParser.MERGE - 54 | 1 << _CypherParser.SET - 54 | 1 << _CypherParser.DETACH - 54 | 1 << _CypherParser.DELETE - 54 | 1 << _CypherParser.REMOVE - 54)) !== 0 || (_la - 86 & ~31) == 0 && (1 << _la - 86 & (1 << _CypherParser.FOREACH - 86 | 1 << _CypherParser.IN - 86 | 1 << _CypherParser.DISTINCT - 86 | 1 << _CypherParser.RETURN - 86 | 1 << _CypherParser.ORDER - 86 | 1 << _CypherParser.BY - 86 | 1 << _CypherParser.L_SKIP - 86 | 1 << _CypherParser.LIMIT - 86 | 1 << _CypherParser.ASCENDING - 86 | 1 << _CypherParser.ASC - 86 | 1 << _CypherParser.DESCENDING - 86 | 1 << _CypherParser.DESC - 86 | 1 << _CypherParser.JOIN - 86 | 1 << _CypherParser.SCAN - 86 | 1 << _CypherParser.START - 86 | 1 << _CypherParser.NODE - 86 | 1 << _CypherParser.RELATIONSHIP - 86 | 1 << _CypherParser.REL - 86 | 1 << _CypherParser.WHERE - 86 | 1 << _CypherParser.SHORTESTPATH - 86 | 1 << _CypherParser.ALLSHORTESTPATHS - 86 | 1 << _CypherParser.OR - 86 | 1 << _CypherParser.XOR - 86 | 1 << _CypherParser.AND - 86 | 1 << _CypherParser.NOT - 86 | 1 << _CypherParser.STARTS - 86 | 1 << _CypherParser.ENDS - 86 | 1 << _CypherParser.CONTAINS - 86 | 1 << _CypherParser.NULL - 86 | 1 << _CypherParser.COUNT - 86 | 1 << _CypherParser.FILTER - 86 | 1 << _CypherParser.EXTRACT - 86)) !== 0 || (_la - 118 & ~31) == 0 && (1 << _la - 118 & (1 << _CypherParser.ANY - 118 | 1 << _CypherParser.NONE - 118 | 1 << _CypherParser.SINGLE - 118 | 1 << _CypherParser.TRUE - 118 | 1 << _CypherParser.FALSE - 118 | 1 << _CypherParser.REDUCE - 118 | 1 << _CypherParser.CASE - 118 | 1 << _CypherParser.ELSE - 118 | 1 << _CypherParser.END - 118 | 1 << _CypherParser.WHEN - 118 | 1 << _CypherParser.THEN - 118 | 1 << _CypherParser.CALL - 118 | 1 << _CypherParser.YIELD - 118 | 1 << _CypherParser.KEY - 118 | 1 << _CypherParser.CATALOG - 118 | 1 << _CypherParser.SHOW - 118 | 1 << _CypherParser.DEFAULT - 118 | 1 << _CypherParser.DBMS - 118 | 1 << _CypherParser.DATABASE - 118 | 1 << _CypherParser.DATABASES - 118 | 1 << _CypherParser.GRAPH - 118 | 1 << _CypherParser.GRAPHS - 118 | 1 << _CypherParser.REPLACE - 118 | 1 << _CypherParser.IF - 118 | 1 << _CypherParser.STOP - 118 | 1 << _CypherParser.ROLE - 118 | 1 << _CypherParser.ROLES - 118 | 1 << _CypherParser.USER - 118 | 1 << _CypherParser.USERS - 118 | 1 << _CypherParser.POPULATED - 118 | 1 << _CypherParser.PASSWORD - 118 | 1 << _CypherParser.CHANGE - 118)) !== 0 || (_la - 150 & ~31) == 0 && (1 << _la - 150 & (1 << _CypherParser.REQUIRED - 150 | 1 << _CypherParser.STATUS - 150 | 1 << _CypherParser.ACTIVE - 150 | 1 << _CypherParser.SUSPENDED - 150 | 1 << _CypherParser.ALTER - 150 | 1 << _CypherParser.CURRENT - 150 | 1 << _CypherParser.TO - 150 | 1 << _CypherParser.PRIVILEGES - 150 | 1 << _CypherParser.GRANT - 150 | 1 << _CypherParser.DENY - 150 | 1 << _CypherParser.REVOKE - 150 | 1 << _CypherParser.RELATIONSHIPS - 150 | 1 << _CypherParser.NODES - 150 | 1 << _CypherParser.ELEMENT - 150 | 1 << _CypherParser.ELEMENTS - 150 | 1 << _CypherParser.COPY - 150 | 1 << _CypherParser.OF - 150 | 1 << _CypherParser.TRAVERSE - 150 | 1 << _CypherParser.READ - 150 | 1 << _CypherParser.WRITE - 150 | 1 << _CypherParser.ACCESS - 150 | 1 << _CypherParser.INDEXES - 150 | 1 << _CypherParser.MANAGEMENT - 150 | 1 << _CypherParser.NEW - 150 | 1 << _CypherParser.LABEL - 150 | 1 << _CypherParser.LABELS - 150 | 1 << _CypherParser.NAME - 150 | 1 << _CypherParser.NAMES - 150 | 1 << _CypherParser.TYPE - 150 | 1 << _CypherParser.TYPES - 150 | 1 << _CypherParser.PROPERTY - 150 | 1 << _CypherParser.CONSTRAINTS - 150)) !== 0 || (_la - 182 & ~31) == 0 && (1 << _la - 182 & (1 << _CypherParser.ASSIGN - 182 | 1 << _CypherParser.BTREE - 182 | 1 << _CypherParser.EXIST - 182 | 1 << _CypherParser.FOR - 182 | 1 << _CypherParser.OPTIONS - 182 | 1 << _CypherParser.EXECUTE - 182 | 1 << _CypherParser.DEFINED - 182 | 1 << _CypherParser.FUNCTION - 182 | 1 << _CypherParser.FUNCTIONS - 182 | 1 << _CypherParser.BOOSTED - 182 | 1 << _CypherParser.PROCEDURE - 182 | 1 << _CypherParser.PROCEDURES - 182 | 1 << _CypherParser.ADMIN - 182 | 1 << _CypherParser.ADMINISTRATOR - 182 | 1 << _CypherParser.BRIEF - 182 | 1 << _CypherParser.VERBOSE - 182 | 1 << _CypherParser.OUTPUT - 182 | 1 << _CypherParser.HexLetter - 182)) !== 0 || _la === _CypherParser.UnescapedSymbolicName || _la === _CypherParser.EscapedSymbolicName) {
        this.state = 2426;
        this.variable();
        this.state = 2428;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 2427;
          this.match(_CypherParser.SP);
        }
      }
      this.state = 2436;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.T__1) {
        this.state = 2432;
        this.nodeLabels();
        this.state = 2434;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 2433;
          this.match(_CypherParser.SP);
        }
      }
      this.state = 2442;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.T__13 || _la === _CypherParser.T__33) {
        this.state = 2438;
        this.properties();
        this.state = 2440;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 2439;
          this.match(_CypherParser.SP);
        }
      }
      this.state = 2444;
      this.match(_CypherParser.T__20);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  patternElementChain() {
    let localctx = new PatternElementChainContext(this, this._ctx, this.state);
    this.enterRule(localctx, 306, _CypherParser.RULE_patternElementChain);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2446;
      this.relationshipPattern();
      this.state = 2448;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2447;
        this.match(_CypherParser.SP);
      }
      this.state = 2450;
      this.nodePattern();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  relationshipPattern() {
    let localctx = new RelationshipPatternContext(this, this._ctx, this.state);
    this.enterRule(localctx, 308, _CypherParser.RULE_relationshipPattern);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2452;
      this.relationshipPatternStart();
      this.state = 2454;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 297, this._ctx);
      if (la_ === 1) {
        this.state = 2453;
        this.match(_CypherParser.SP);
      }
      this.state = 2457;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.T__16) {
        this.state = 2456;
        this.relationshipDetail();
      }
      this.state = 2460;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2459;
        this.match(_CypherParser.SP);
      }
      this.state = 2462;
      this.relationshipPatternEnd();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  relationshipPatternStart() {
    let localctx = new RelationshipPatternStartContext(this, this._ctx, this.state);
    this.enterRule(localctx, 310, _CypherParser.RULE_relationshipPatternStart);
    var _la = 0;
    try {
      this.state = 2471;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.T__29:
        case _CypherParser.T__34:
        case _CypherParser.T__35:
        case _CypherParser.T__36:
        case _CypherParser.T__37:
          this.enterOuterAlt(localctx, 1);
          this.state = 2464;
          this.leftArrowHead();
          this.state = 2466;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2465;
            this.match(_CypherParser.SP);
          }
          this.state = 2468;
          this.dash();
          break;
        case _CypherParser.T__2:
        case _CypherParser.T__42:
        case _CypherParser.T__43:
        case _CypherParser.T__44:
        case _CypherParser.T__45:
        case _CypherParser.T__46:
        case _CypherParser.T__47:
        case _CypherParser.T__48:
        case _CypherParser.T__49:
        case _CypherParser.T__50:
        case _CypherParser.T__51:
        case _CypherParser.T__52:
          this.enterOuterAlt(localctx, 2);
          this.state = 2470;
          this.dash();
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  relationshipPatternEnd() {
    let localctx = new RelationshipPatternEndContext(this, this._ctx, this.state);
    this.enterRule(localctx, 312, _CypherParser.RULE_relationshipPatternEnd);
    var _la = 0;
    try {
      this.state = 2480;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 303, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 2473;
          this.dash();
          this.state = 2475;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2474;
            this.match(_CypherParser.SP);
          }
          this.state = 2477;
          this.rightArrowHead();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 2479;
          this.dash();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  relationshipDetail() {
    let localctx = new RelationshipDetailContext(this, this._ctx, this.state);
    this.enterRule(localctx, 314, _CypherParser.RULE_relationshipDetail);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2482;
      this.match(_CypherParser.T__16);
      this.state = 2484;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2483;
        this.match(_CypherParser.SP);
      }
      this.state = 2490;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if ((_la - 54 & ~31) == 0 && (1 << _la - 54 & (1 << _CypherParser.CYPHER - 54 | 1 << _CypherParser.EXPLAIN - 54 | 1 << _CypherParser.PROFILE - 54 | 1 << _CypherParser.USING - 54 | 1 << _CypherParser.PERIODIC - 54 | 1 << _CypherParser.COMMIT - 54 | 1 << _CypherParser.UNION - 54 | 1 << _CypherParser.ALL - 54 | 1 << _CypherParser.CREATE - 54 | 1 << _CypherParser.DROP - 54 | 1 << _CypherParser.INDEX - 54 | 1 << _CypherParser.ON - 54 | 1 << _CypherParser.CONSTRAINT - 54 | 1 << _CypherParser.ASSERT - 54 | 1 << _CypherParser.IS - 54 | 1 << _CypherParser.UNIQUE - 54 | 1 << _CypherParser.EXISTS - 54 | 1 << _CypherParser.LOAD - 54 | 1 << _CypherParser.CSV - 54 | 1 << _CypherParser.WITH - 54 | 1 << _CypherParser.HEADERS - 54 | 1 << _CypherParser.FROM - 54 | 1 << _CypherParser.AS - 54 | 1 << _CypherParser.FIELDTERMINATOR - 54 | 1 << _CypherParser.OPTIONAL - 54 | 1 << _CypherParser.MATCH - 54 | 1 << _CypherParser.UNWIND - 54 | 1 << _CypherParser.MERGE - 54 | 1 << _CypherParser.SET - 54 | 1 << _CypherParser.DETACH - 54 | 1 << _CypherParser.DELETE - 54 | 1 << _CypherParser.REMOVE - 54)) !== 0 || (_la - 86 & ~31) == 0 && (1 << _la - 86 & (1 << _CypherParser.FOREACH - 86 | 1 << _CypherParser.IN - 86 | 1 << _CypherParser.DISTINCT - 86 | 1 << _CypherParser.RETURN - 86 | 1 << _CypherParser.ORDER - 86 | 1 << _CypherParser.BY - 86 | 1 << _CypherParser.L_SKIP - 86 | 1 << _CypherParser.LIMIT - 86 | 1 << _CypherParser.ASCENDING - 86 | 1 << _CypherParser.ASC - 86 | 1 << _CypherParser.DESCENDING - 86 | 1 << _CypherParser.DESC - 86 | 1 << _CypherParser.JOIN - 86 | 1 << _CypherParser.SCAN - 86 | 1 << _CypherParser.START - 86 | 1 << _CypherParser.NODE - 86 | 1 << _CypherParser.RELATIONSHIP - 86 | 1 << _CypherParser.REL - 86 | 1 << _CypherParser.WHERE - 86 | 1 << _CypherParser.SHORTESTPATH - 86 | 1 << _CypherParser.ALLSHORTESTPATHS - 86 | 1 << _CypherParser.OR - 86 | 1 << _CypherParser.XOR - 86 | 1 << _CypherParser.AND - 86 | 1 << _CypherParser.NOT - 86 | 1 << _CypherParser.STARTS - 86 | 1 << _CypherParser.ENDS - 86 | 1 << _CypherParser.CONTAINS - 86 | 1 << _CypherParser.NULL - 86 | 1 << _CypherParser.COUNT - 86 | 1 << _CypherParser.FILTER - 86 | 1 << _CypherParser.EXTRACT - 86)) !== 0 || (_la - 118 & ~31) == 0 && (1 << _la - 118 & (1 << _CypherParser.ANY - 118 | 1 << _CypherParser.NONE - 118 | 1 << _CypherParser.SINGLE - 118 | 1 << _CypherParser.TRUE - 118 | 1 << _CypherParser.FALSE - 118 | 1 << _CypherParser.REDUCE - 118 | 1 << _CypherParser.CASE - 118 | 1 << _CypherParser.ELSE - 118 | 1 << _CypherParser.END - 118 | 1 << _CypherParser.WHEN - 118 | 1 << _CypherParser.THEN - 118 | 1 << _CypherParser.CALL - 118 | 1 << _CypherParser.YIELD - 118 | 1 << _CypherParser.KEY - 118 | 1 << _CypherParser.CATALOG - 118 | 1 << _CypherParser.SHOW - 118 | 1 << _CypherParser.DEFAULT - 118 | 1 << _CypherParser.DBMS - 118 | 1 << _CypherParser.DATABASE - 118 | 1 << _CypherParser.DATABASES - 118 | 1 << _CypherParser.GRAPH - 118 | 1 << _CypherParser.GRAPHS - 118 | 1 << _CypherParser.REPLACE - 118 | 1 << _CypherParser.IF - 118 | 1 << _CypherParser.STOP - 118 | 1 << _CypherParser.ROLE - 118 | 1 << _CypherParser.ROLES - 118 | 1 << _CypherParser.USER - 118 | 1 << _CypherParser.USERS - 118 | 1 << _CypherParser.POPULATED - 118 | 1 << _CypherParser.PASSWORD - 118 | 1 << _CypherParser.CHANGE - 118)) !== 0 || (_la - 150 & ~31) == 0 && (1 << _la - 150 & (1 << _CypherParser.REQUIRED - 150 | 1 << _CypherParser.STATUS - 150 | 1 << _CypherParser.ACTIVE - 150 | 1 << _CypherParser.SUSPENDED - 150 | 1 << _CypherParser.ALTER - 150 | 1 << _CypherParser.CURRENT - 150 | 1 << _CypherParser.TO - 150 | 1 << _CypherParser.PRIVILEGES - 150 | 1 << _CypherParser.GRANT - 150 | 1 << _CypherParser.DENY - 150 | 1 << _CypherParser.REVOKE - 150 | 1 << _CypherParser.RELATIONSHIPS - 150 | 1 << _CypherParser.NODES - 150 | 1 << _CypherParser.ELEMENT - 150 | 1 << _CypherParser.ELEMENTS - 150 | 1 << _CypherParser.COPY - 150 | 1 << _CypherParser.OF - 150 | 1 << _CypherParser.TRAVERSE - 150 | 1 << _CypherParser.READ - 150 | 1 << _CypherParser.WRITE - 150 | 1 << _CypherParser.ACCESS - 150 | 1 << _CypherParser.INDEXES - 150 | 1 << _CypherParser.MANAGEMENT - 150 | 1 << _CypherParser.NEW - 150 | 1 << _CypherParser.LABEL - 150 | 1 << _CypherParser.LABELS - 150 | 1 << _CypherParser.NAME - 150 | 1 << _CypherParser.NAMES - 150 | 1 << _CypherParser.TYPE - 150 | 1 << _CypherParser.TYPES - 150 | 1 << _CypherParser.PROPERTY - 150 | 1 << _CypherParser.CONSTRAINTS - 150)) !== 0 || (_la - 182 & ~31) == 0 && (1 << _la - 182 & (1 << _CypherParser.ASSIGN - 182 | 1 << _CypherParser.BTREE - 182 | 1 << _CypherParser.EXIST - 182 | 1 << _CypherParser.FOR - 182 | 1 << _CypherParser.OPTIONS - 182 | 1 << _CypherParser.EXECUTE - 182 | 1 << _CypherParser.DEFINED - 182 | 1 << _CypherParser.FUNCTION - 182 | 1 << _CypherParser.FUNCTIONS - 182 | 1 << _CypherParser.BOOSTED - 182 | 1 << _CypherParser.PROCEDURE - 182 | 1 << _CypherParser.PROCEDURES - 182 | 1 << _CypherParser.ADMIN - 182 | 1 << _CypherParser.ADMINISTRATOR - 182 | 1 << _CypherParser.BRIEF - 182 | 1 << _CypherParser.VERBOSE - 182 | 1 << _CypherParser.OUTPUT - 182 | 1 << _CypherParser.HexLetter - 182)) !== 0 || _la === _CypherParser.UnescapedSymbolicName || _la === _CypherParser.EscapedSymbolicName) {
        this.state = 2486;
        this.variable();
        this.state = 2488;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 2487;
          this.match(_CypherParser.SP);
        }
      }
      this.state = 2496;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.T__1) {
        this.state = 2492;
        this.relationshipTypes();
        this.state = 2494;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 2493;
          this.match(_CypherParser.SP);
        }
      }
      this.state = 2499;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.T__18) {
        this.state = 2498;
        this.rangeLiteral();
      }
      this.state = 2505;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.T__13 || _la === _CypherParser.T__33) {
        this.state = 2501;
        this.properties();
        this.state = 2503;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 2502;
          this.match(_CypherParser.SP);
        }
      }
      this.state = 2507;
      this.match(_CypherParser.T__17);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  properties() {
    let localctx = new PropertiesContext(this, this._ctx, this.state);
    this.enterRule(localctx, 316, _CypherParser.RULE_properties);
    try {
      this.state = 2511;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 312, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 2509;
          this.mapLiteral();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 2510;
          this.parameter();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  relType() {
    let localctx = new RelTypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 318, _CypherParser.RULE_relType);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2513;
      this.match(_CypherParser.T__1);
      this.state = 2515;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2514;
        this.match(_CypherParser.SP);
      }
      this.state = 2517;
      this.relTypeName();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  relationshipTypes() {
    let localctx = new RelationshipTypesContext(this, this._ctx, this.state);
    this.enterRule(localctx, 320, _CypherParser.RULE_relationshipTypes);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2519;
      this.relationshipType();
      this.state = 2527;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 315, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 2521;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2520;
            this.match(_CypherParser.SP);
          }
          this.state = 2523;
          this.match(_CypherParser.T__22);
          this.state = 2524;
          this.relationshipTypeOptionalColon();
        }
        this.state = 2529;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 315, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  relationshipType() {
    let localctx = new RelationshipTypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 322, _CypherParser.RULE_relationshipType);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2530;
      this.match(_CypherParser.T__1);
      this.state = 2531;
      this.relTypeName();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  relationshipTypeOptionalColon() {
    let localctx = new RelationshipTypeOptionalColonContext(this, this._ctx, this.state);
    this.enterRule(localctx, 324, _CypherParser.RULE_relationshipTypeOptionalColon);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2534;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.T__1) {
        this.state = 2533;
        this.match(_CypherParser.T__1);
      }
      this.state = 2536;
      this.relTypeName();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  nodeLabels() {
    let localctx = new NodeLabelsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 326, _CypherParser.RULE_nodeLabels);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2538;
      this.nodeLabel();
      this.state = 2545;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 318, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 2540;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2539;
            this.match(_CypherParser.SP);
          }
          this.state = 2542;
          this.nodeLabel();
        }
        this.state = 2547;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 318, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  nodeLabel() {
    let localctx = new NodeLabelContext(this, this._ctx, this.state);
    this.enterRule(localctx, 328, _CypherParser.RULE_nodeLabel);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2548;
      this.match(_CypherParser.T__1);
      this.state = 2549;
      this.labelName();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  rangeLiteral() {
    let localctx = new RangeLiteralContext(this, this._ctx, this.state);
    this.enterRule(localctx, 330, _CypherParser.RULE_rangeLiteral);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2551;
      this.match(_CypherParser.T__18);
      this.state = 2553;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2552;
        this.match(_CypherParser.SP);
      }
      this.state = 2559;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if ((_la - 202 & ~31) == 0 && (1 << _la - 202 & (1 << _CypherParser.HexInteger - 202 | 1 << _CypherParser.DecimalInteger - 202 | 1 << _CypherParser.OctalInteger - 202)) !== 0) {
        this.state = 2555;
        this.integerLiteral();
        this.state = 2557;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 2556;
          this.match(_CypherParser.SP);
        }
      }
      this.state = 2571;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.T__23) {
        this.state = 2561;
        this.match(_CypherParser.T__23);
        this.state = 2563;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 2562;
          this.match(_CypherParser.SP);
        }
        this.state = 2569;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if ((_la - 202 & ~31) == 0 && (1 << _la - 202 & (1 << _CypherParser.HexInteger - 202 | 1 << _CypherParser.DecimalInteger - 202 | 1 << _CypherParser.OctalInteger - 202)) !== 0) {
          this.state = 2565;
          this.integerLiteral();
          this.state = 2567;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2566;
            this.match(_CypherParser.SP);
          }
        }
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  labelName() {
    let localctx = new LabelNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 332, _CypherParser.RULE_labelName);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2573;
      this.symbolicName();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  relTypeName() {
    let localctx = new RelTypeNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 334, _CypherParser.RULE_relTypeName);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2575;
      this.symbolicName();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  expression() {
    let localctx = new ExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 336, _CypherParser.RULE_expression);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2577;
      this.orExpression();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  orExpression() {
    let localctx = new OrExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 338, _CypherParser.RULE_orExpression);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2579;
      this.xorExpression();
      this.state = 2586;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 326, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 2580;
          this.match(_CypherParser.SP);
          this.state = 2581;
          this.match(_CypherParser.OR);
          this.state = 2582;
          this.match(_CypherParser.SP);
          this.state = 2583;
          this.xorExpression();
        }
        this.state = 2588;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 326, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  xorExpression() {
    let localctx = new XorExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 340, _CypherParser.RULE_xorExpression);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2589;
      this.andExpression();
      this.state = 2596;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 327, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 2590;
          this.match(_CypherParser.SP);
          this.state = 2591;
          this.match(_CypherParser.XOR);
          this.state = 2592;
          this.match(_CypherParser.SP);
          this.state = 2593;
          this.andExpression();
        }
        this.state = 2598;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 327, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  andExpression() {
    let localctx = new AndExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 342, _CypherParser.RULE_andExpression);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2599;
      this.notExpression();
      this.state = 2606;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 328, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 2600;
          this.match(_CypherParser.SP);
          this.state = 2601;
          this.match(_CypherParser.AND);
          this.state = 2602;
          this.match(_CypherParser.SP);
          this.state = 2603;
          this.notExpression();
        }
        this.state = 2608;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 328, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  notExpression() {
    let localctx = new NotExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 344, _CypherParser.RULE_notExpression);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2615;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 330, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 2609;
          this.match(_CypherParser.NOT);
          this.state = 2611;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2610;
            this.match(_CypherParser.SP);
          }
        }
        this.state = 2617;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 330, this._ctx);
      }
      this.state = 2618;
      this.comparisonExpression();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  comparisonExpression() {
    let localctx = new ComparisonExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 346, _CypherParser.RULE_comparisonExpression);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2620;
      this.addOrSubtractExpression();
      this.state = 2627;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 332, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 2622;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2621;
            this.match(_CypherParser.SP);
          }
          this.state = 2624;
          this.partialComparisonExpression();
        }
        this.state = 2629;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 332, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  addOrSubtractExpression() {
    let localctx = new AddOrSubtractExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 348, _CypherParser.RULE_addOrSubtractExpression);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2630;
      this.multiplyDivideModuloExpression();
      this.state = 2649;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 338, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 2647;
          this._errHandler.sync(this);
          var la_ = this._interp.adaptivePredict(this._input, 337, this._ctx);
          switch (la_) {
            case 1:
              this.state = 2632;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 2631;
                this.match(_CypherParser.SP);
              }
              this.state = 2634;
              this.match(_CypherParser.T__12);
              this.state = 2636;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 2635;
                this.match(_CypherParser.SP);
              }
              this.state = 2638;
              this.multiplyDivideModuloExpression();
              break;
            case 2:
              this.state = 2640;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 2639;
                this.match(_CypherParser.SP);
              }
              this.state = 2642;
              this.match(_CypherParser.T__2);
              this.state = 2644;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 2643;
                this.match(_CypherParser.SP);
              }
              this.state = 2646;
              this.multiplyDivideModuloExpression();
              break;
          }
        }
        this.state = 2651;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 338, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  multiplyDivideModuloExpression() {
    let localctx = new MultiplyDivideModuloExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 350, _CypherParser.RULE_multiplyDivideModuloExpression);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2652;
      this.powerOfExpression();
      this.state = 2679;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 346, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 2677;
          this._errHandler.sync(this);
          var la_ = this._interp.adaptivePredict(this._input, 345, this._ctx);
          switch (la_) {
            case 1:
              this.state = 2654;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 2653;
                this.match(_CypherParser.SP);
              }
              this.state = 2656;
              this.match(_CypherParser.T__18);
              this.state = 2658;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 2657;
                this.match(_CypherParser.SP);
              }
              this.state = 2660;
              this.powerOfExpression();
              break;
            case 2:
              this.state = 2662;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 2661;
                this.match(_CypherParser.SP);
              }
              this.state = 2664;
              this.match(_CypherParser.T__5);
              this.state = 2666;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 2665;
                this.match(_CypherParser.SP);
              }
              this.state = 2668;
              this.powerOfExpression();
              break;
            case 3:
              this.state = 2670;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 2669;
                this.match(_CypherParser.SP);
              }
              this.state = 2672;
              this.match(_CypherParser.T__24);
              this.state = 2674;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 2673;
                this.match(_CypherParser.SP);
              }
              this.state = 2676;
              this.powerOfExpression();
              break;
          }
        }
        this.state = 2681;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 346, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  powerOfExpression() {
    let localctx = new PowerOfExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 352, _CypherParser.RULE_powerOfExpression);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2682;
      this.unaryAddOrSubtractExpression();
      this.state = 2693;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 349, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 2684;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2683;
            this.match(_CypherParser.SP);
          }
          this.state = 2686;
          this.match(_CypherParser.T__25);
          this.state = 2688;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2687;
            this.match(_CypherParser.SP);
          }
          this.state = 2690;
          this.unaryAddOrSubtractExpression();
        }
        this.state = 2695;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 349, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  unaryAddOrSubtractExpression() {
    let localctx = new UnaryAddOrSubtractExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 354, _CypherParser.RULE_unaryAddOrSubtractExpression);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2702;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      while (_la === _CypherParser.T__2 || _la === _CypherParser.T__12) {
        this.state = 2696;
        _la = this._input.LA(1);
        if (!(_la === _CypherParser.T__2 || _la === _CypherParser.T__12)) {
          this._errHandler.recoverInline(this);
        } else {
          this._errHandler.reportMatch(this);
          this.consume();
        }
        this.state = 2698;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 2697;
          this.match(_CypherParser.SP);
        }
        this.state = 2704;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
      }
      this.state = 2705;
      this.stringListNullOperatorExpression();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  stringListNullOperatorExpression() {
    let localctx = new StringListNullOperatorExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 356, _CypherParser.RULE_stringListNullOperatorExpression);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2707;
      this.propertyOrLabelsExpression();
      this.state = 2761;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 360, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 2759;
          this._errHandler.sync(this);
          var la_ = this._interp.adaptivePredict(this._input, 359, this._ctx);
          switch (la_) {
            case 1:
              this.state = 2709;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 2708;
                this.match(_CypherParser.SP);
              }
              this.state = 2711;
              this.match(_CypherParser.T__16);
              this.state = 2712;
              this.expression();
              this.state = 2713;
              this.match(_CypherParser.T__17);
              break;
            case 2:
              this.state = 2716;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 2715;
                this.match(_CypherParser.SP);
              }
              this.state = 2718;
              this.match(_CypherParser.T__16);
              this.state = 2720;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if ((_la & ~31) == 0 && (1 << _la & (1 << _CypherParser.T__2 | 1 << _CypherParser.T__12 | 1 << _CypherParser.T__13 | 1 << _CypherParser.T__16 | 1 << _CypherParser.T__19)) !== 0 || (_la - 34 & ~31) == 0 && (1 << _la - 34 & (1 << _CypherParser.T__33 - 34 | 1 << _CypherParser.CYPHER - 34 | 1 << _CypherParser.EXPLAIN - 34 | 1 << _CypherParser.PROFILE - 34 | 1 << _CypherParser.USING - 34 | 1 << _CypherParser.PERIODIC - 34 | 1 << _CypherParser.COMMIT - 34 | 1 << _CypherParser.UNION - 34 | 1 << _CypherParser.ALL - 34 | 1 << _CypherParser.CREATE - 34 | 1 << _CypherParser.DROP - 34 | 1 << _CypherParser.INDEX - 34 | 1 << _CypherParser.ON - 34)) !== 0 || (_la - 66 & ~31) == 0 && (1 << _la - 66 & (1 << _CypherParser.CONSTRAINT - 66 | 1 << _CypherParser.ASSERT - 66 | 1 << _CypherParser.IS - 66 | 1 << _CypherParser.UNIQUE - 66 | 1 << _CypherParser.EXISTS - 66 | 1 << _CypherParser.LOAD - 66 | 1 << _CypherParser.CSV - 66 | 1 << _CypherParser.WITH - 66 | 1 << _CypherParser.HEADERS - 66 | 1 << _CypherParser.FROM - 66 | 1 << _CypherParser.AS - 66 | 1 << _CypherParser.FIELDTERMINATOR - 66 | 1 << _CypherParser.OPTIONAL - 66 | 1 << _CypherParser.MATCH - 66 | 1 << _CypherParser.UNWIND - 66 | 1 << _CypherParser.MERGE - 66 | 1 << _CypherParser.SET - 66 | 1 << _CypherParser.DETACH - 66 | 1 << _CypherParser.DELETE - 66 | 1 << _CypherParser.REMOVE - 66 | 1 << _CypherParser.FOREACH - 66 | 1 << _CypherParser.IN - 66 | 1 << _CypherParser.DISTINCT - 66 | 1 << _CypherParser.RETURN - 66 | 1 << _CypherParser.ORDER - 66 | 1 << _CypherParser.BY - 66 | 1 << _CypherParser.L_SKIP - 66 | 1 << _CypherParser.LIMIT - 66 | 1 << _CypherParser.ASCENDING - 66 | 1 << _CypherParser.ASC - 66 | 1 << _CypherParser.DESCENDING - 66 | 1 << _CypherParser.DESC - 66)) !== 0 || (_la - 98 & ~31) == 0 && (1 << _la - 98 & (1 << _CypherParser.JOIN - 98 | 1 << _CypherParser.SCAN - 98 | 1 << _CypherParser.START - 98 | 1 << _CypherParser.NODE - 98 | 1 << _CypherParser.RELATIONSHIP - 98 | 1 << _CypherParser.REL - 98 | 1 << _CypherParser.WHERE - 98 | 1 << _CypherParser.SHORTESTPATH - 98 | 1 << _CypherParser.ALLSHORTESTPATHS - 98 | 1 << _CypherParser.OR - 98 | 1 << _CypherParser.XOR - 98 | 1 << _CypherParser.AND - 98 | 1 << _CypherParser.NOT - 98 | 1 << _CypherParser.STARTS - 98 | 1 << _CypherParser.ENDS - 98 | 1 << _CypherParser.CONTAINS - 98 | 1 << _CypherParser.NULL - 98 | 1 << _CypherParser.COUNT - 98 | 1 << _CypherParser.FILTER - 98 | 1 << _CypherParser.EXTRACT - 98 | 1 << _CypherParser.ANY - 98 | 1 << _CypherParser.NONE - 98 | 1 << _CypherParser.SINGLE - 98 | 1 << _CypherParser.TRUE - 98 | 1 << _CypherParser.FALSE - 98 | 1 << _CypherParser.REDUCE - 98 | 1 << _CypherParser.CASE - 98 | 1 << _CypherParser.ELSE - 98 | 1 << _CypherParser.END - 98 | 1 << _CypherParser.WHEN - 98 | 1 << _CypherParser.THEN - 98 | 1 << _CypherParser.CALL - 98)) !== 0 || (_la - 130 & ~31) == 0 && (1 << _la - 130 & (1 << _CypherParser.YIELD - 130 | 1 << _CypherParser.KEY - 130 | 1 << _CypherParser.CATALOG - 130 | 1 << _CypherParser.SHOW - 130 | 1 << _CypherParser.DEFAULT - 130 | 1 << _CypherParser.DBMS - 130 | 1 << _CypherParser.DATABASE - 130 | 1 << _CypherParser.DATABASES - 130 | 1 << _CypherParser.GRAPH - 130 | 1 << _CypherParser.GRAPHS - 130 | 1 << _CypherParser.REPLACE - 130 | 1 << _CypherParser.IF - 130 | 1 << _CypherParser.STOP - 130 | 1 << _CypherParser.ROLE - 130 | 1 << _CypherParser.ROLES - 130 | 1 << _CypherParser.USER - 130 | 1 << _CypherParser.USERS - 130 | 1 << _CypherParser.POPULATED - 130 | 1 << _CypherParser.PASSWORD - 130 | 1 << _CypherParser.CHANGE - 130 | 1 << _CypherParser.REQUIRED - 130 | 1 << _CypherParser.STATUS - 130 | 1 << _CypherParser.ACTIVE - 130 | 1 << _CypherParser.SUSPENDED - 130 | 1 << _CypherParser.ALTER - 130 | 1 << _CypherParser.CURRENT - 130 | 1 << _CypherParser.TO - 130 | 1 << _CypherParser.PRIVILEGES - 130 | 1 << _CypherParser.GRANT - 130 | 1 << _CypherParser.DENY - 130 | 1 << _CypherParser.REVOKE - 130 | 1 << _CypherParser.RELATIONSHIPS - 130)) !== 0 || (_la - 162 & ~31) == 0 && (1 << _la - 162 & (1 << _CypherParser.NODES - 162 | 1 << _CypherParser.ELEMENT - 162 | 1 << _CypherParser.ELEMENTS - 162 | 1 << _CypherParser.COPY - 162 | 1 << _CypherParser.OF - 162 | 1 << _CypherParser.TRAVERSE - 162 | 1 << _CypherParser.READ - 162 | 1 << _CypherParser.WRITE - 162 | 1 << _CypherParser.ACCESS - 162 | 1 << _CypherParser.INDEXES - 162 | 1 << _CypherParser.MANAGEMENT - 162 | 1 << _CypherParser.NEW - 162 | 1 << _CypherParser.LABEL - 162 | 1 << _CypherParser.LABELS - 162 | 1 << _CypherParser.NAME - 162 | 1 << _CypherParser.NAMES - 162 | 1 << _CypherParser.TYPE - 162 | 1 << _CypherParser.TYPES - 162 | 1 << _CypherParser.PROPERTY - 162 | 1 << _CypherParser.CONSTRAINTS - 162 | 1 << _CypherParser.ASSIGN - 162 | 1 << _CypherParser.BTREE - 162 | 1 << _CypherParser.EXIST - 162 | 1 << _CypherParser.FOR - 162 | 1 << _CypherParser.OPTIONS - 162 | 1 << _CypherParser.EXECUTE - 162 | 1 << _CypherParser.DEFINED - 162 | 1 << _CypherParser.FUNCTION - 162 | 1 << _CypherParser.FUNCTIONS - 162 | 1 << _CypherParser.BOOSTED - 162 | 1 << _CypherParser.PROCEDURE - 162 | 1 << _CypherParser.PROCEDURES - 162)) !== 0 || (_la - 194 & ~31) == 0 && (1 << _la - 194 & (1 << _CypherParser.ADMIN - 194 | 1 << _CypherParser.ADMINISTRATOR - 194 | 1 << _CypherParser.BRIEF - 194 | 1 << _CypherParser.VERBOSE - 194 | 1 << _CypherParser.OUTPUT - 194 | 1 << _CypherParser.StringLiteral - 194 | 1 << _CypherParser.HexInteger - 194 | 1 << _CypherParser.DecimalInteger - 194 | 1 << _CypherParser.OctalInteger - 194 | 1 << _CypherParser.HexLetter - 194 | 1 << _CypherParser.ExponentDecimalReal - 194 | 1 << _CypherParser.RegularDecimalReal - 194 | 1 << _CypherParser.UnescapedSymbolicName - 194 | 1 << _CypherParser.EscapedSymbolicName - 194)) !== 0) {
                this.state = 2719;
                this.expression();
              }
              this.state = 2722;
              this.match(_CypherParser.T__23);
              this.state = 2724;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if ((_la & ~31) == 0 && (1 << _la & (1 << _CypherParser.T__2 | 1 << _CypherParser.T__12 | 1 << _CypherParser.T__13 | 1 << _CypherParser.T__16 | 1 << _CypherParser.T__19)) !== 0 || (_la - 34 & ~31) == 0 && (1 << _la - 34 & (1 << _CypherParser.T__33 - 34 | 1 << _CypherParser.CYPHER - 34 | 1 << _CypherParser.EXPLAIN - 34 | 1 << _CypherParser.PROFILE - 34 | 1 << _CypherParser.USING - 34 | 1 << _CypherParser.PERIODIC - 34 | 1 << _CypherParser.COMMIT - 34 | 1 << _CypherParser.UNION - 34 | 1 << _CypherParser.ALL - 34 | 1 << _CypherParser.CREATE - 34 | 1 << _CypherParser.DROP - 34 | 1 << _CypherParser.INDEX - 34 | 1 << _CypherParser.ON - 34)) !== 0 || (_la - 66 & ~31) == 0 && (1 << _la - 66 & (1 << _CypherParser.CONSTRAINT - 66 | 1 << _CypherParser.ASSERT - 66 | 1 << _CypherParser.IS - 66 | 1 << _CypherParser.UNIQUE - 66 | 1 << _CypherParser.EXISTS - 66 | 1 << _CypherParser.LOAD - 66 | 1 << _CypherParser.CSV - 66 | 1 << _CypherParser.WITH - 66 | 1 << _CypherParser.HEADERS - 66 | 1 << _CypherParser.FROM - 66 | 1 << _CypherParser.AS - 66 | 1 << _CypherParser.FIELDTERMINATOR - 66 | 1 << _CypherParser.OPTIONAL - 66 | 1 << _CypherParser.MATCH - 66 | 1 << _CypherParser.UNWIND - 66 | 1 << _CypherParser.MERGE - 66 | 1 << _CypherParser.SET - 66 | 1 << _CypherParser.DETACH - 66 | 1 << _CypherParser.DELETE - 66 | 1 << _CypherParser.REMOVE - 66 | 1 << _CypherParser.FOREACH - 66 | 1 << _CypherParser.IN - 66 | 1 << _CypherParser.DISTINCT - 66 | 1 << _CypherParser.RETURN - 66 | 1 << _CypherParser.ORDER - 66 | 1 << _CypherParser.BY - 66 | 1 << _CypherParser.L_SKIP - 66 | 1 << _CypherParser.LIMIT - 66 | 1 << _CypherParser.ASCENDING - 66 | 1 << _CypherParser.ASC - 66 | 1 << _CypherParser.DESCENDING - 66 | 1 << _CypherParser.DESC - 66)) !== 0 || (_la - 98 & ~31) == 0 && (1 << _la - 98 & (1 << _CypherParser.JOIN - 98 | 1 << _CypherParser.SCAN - 98 | 1 << _CypherParser.START - 98 | 1 << _CypherParser.NODE - 98 | 1 << _CypherParser.RELATIONSHIP - 98 | 1 << _CypherParser.REL - 98 | 1 << _CypherParser.WHERE - 98 | 1 << _CypherParser.SHORTESTPATH - 98 | 1 << _CypherParser.ALLSHORTESTPATHS - 98 | 1 << _CypherParser.OR - 98 | 1 << _CypherParser.XOR - 98 | 1 << _CypherParser.AND - 98 | 1 << _CypherParser.NOT - 98 | 1 << _CypherParser.STARTS - 98 | 1 << _CypherParser.ENDS - 98 | 1 << _CypherParser.CONTAINS - 98 | 1 << _CypherParser.NULL - 98 | 1 << _CypherParser.COUNT - 98 | 1 << _CypherParser.FILTER - 98 | 1 << _CypherParser.EXTRACT - 98 | 1 << _CypherParser.ANY - 98 | 1 << _CypherParser.NONE - 98 | 1 << _CypherParser.SINGLE - 98 | 1 << _CypherParser.TRUE - 98 | 1 << _CypherParser.FALSE - 98 | 1 << _CypherParser.REDUCE - 98 | 1 << _CypherParser.CASE - 98 | 1 << _CypherParser.ELSE - 98 | 1 << _CypherParser.END - 98 | 1 << _CypherParser.WHEN - 98 | 1 << _CypherParser.THEN - 98 | 1 << _CypherParser.CALL - 98)) !== 0 || (_la - 130 & ~31) == 0 && (1 << _la - 130 & (1 << _CypherParser.YIELD - 130 | 1 << _CypherParser.KEY - 130 | 1 << _CypherParser.CATALOG - 130 | 1 << _CypherParser.SHOW - 130 | 1 << _CypherParser.DEFAULT - 130 | 1 << _CypherParser.DBMS - 130 | 1 << _CypherParser.DATABASE - 130 | 1 << _CypherParser.DATABASES - 130 | 1 << _CypherParser.GRAPH - 130 | 1 << _CypherParser.GRAPHS - 130 | 1 << _CypherParser.REPLACE - 130 | 1 << _CypherParser.IF - 130 | 1 << _CypherParser.STOP - 130 | 1 << _CypherParser.ROLE - 130 | 1 << _CypherParser.ROLES - 130 | 1 << _CypherParser.USER - 130 | 1 << _CypherParser.USERS - 130 | 1 << _CypherParser.POPULATED - 130 | 1 << _CypherParser.PASSWORD - 130 | 1 << _CypherParser.CHANGE - 130 | 1 << _CypherParser.REQUIRED - 130 | 1 << _CypherParser.STATUS - 130 | 1 << _CypherParser.ACTIVE - 130 | 1 << _CypherParser.SUSPENDED - 130 | 1 << _CypherParser.ALTER - 130 | 1 << _CypherParser.CURRENT - 130 | 1 << _CypherParser.TO - 130 | 1 << _CypherParser.PRIVILEGES - 130 | 1 << _CypherParser.GRANT - 130 | 1 << _CypherParser.DENY - 130 | 1 << _CypherParser.REVOKE - 130 | 1 << _CypherParser.RELATIONSHIPS - 130)) !== 0 || (_la - 162 & ~31) == 0 && (1 << _la - 162 & (1 << _CypherParser.NODES - 162 | 1 << _CypherParser.ELEMENT - 162 | 1 << _CypherParser.ELEMENTS - 162 | 1 << _CypherParser.COPY - 162 | 1 << _CypherParser.OF - 162 | 1 << _CypherParser.TRAVERSE - 162 | 1 << _CypherParser.READ - 162 | 1 << _CypherParser.WRITE - 162 | 1 << _CypherParser.ACCESS - 162 | 1 << _CypherParser.INDEXES - 162 | 1 << _CypherParser.MANAGEMENT - 162 | 1 << _CypherParser.NEW - 162 | 1 << _CypherParser.LABEL - 162 | 1 << _CypherParser.LABELS - 162 | 1 << _CypherParser.NAME - 162 | 1 << _CypherParser.NAMES - 162 | 1 << _CypherParser.TYPE - 162 | 1 << _CypherParser.TYPES - 162 | 1 << _CypherParser.PROPERTY - 162 | 1 << _CypherParser.CONSTRAINTS - 162 | 1 << _CypherParser.ASSIGN - 162 | 1 << _CypherParser.BTREE - 162 | 1 << _CypherParser.EXIST - 162 | 1 << _CypherParser.FOR - 162 | 1 << _CypherParser.OPTIONS - 162 | 1 << _CypherParser.EXECUTE - 162 | 1 << _CypherParser.DEFINED - 162 | 1 << _CypherParser.FUNCTION - 162 | 1 << _CypherParser.FUNCTIONS - 162 | 1 << _CypherParser.BOOSTED - 162 | 1 << _CypherParser.PROCEDURE - 162 | 1 << _CypherParser.PROCEDURES - 162)) !== 0 || (_la - 194 & ~31) == 0 && (1 << _la - 194 & (1 << _CypherParser.ADMIN - 194 | 1 << _CypherParser.ADMINISTRATOR - 194 | 1 << _CypherParser.BRIEF - 194 | 1 << _CypherParser.VERBOSE - 194 | 1 << _CypherParser.OUTPUT - 194 | 1 << _CypherParser.StringLiteral - 194 | 1 << _CypherParser.HexInteger - 194 | 1 << _CypherParser.DecimalInteger - 194 | 1 << _CypherParser.OctalInteger - 194 | 1 << _CypherParser.HexLetter - 194 | 1 << _CypherParser.ExponentDecimalReal - 194 | 1 << _CypherParser.RegularDecimalReal - 194 | 1 << _CypherParser.UnescapedSymbolicName - 194 | 1 << _CypherParser.EscapedSymbolicName - 194)) !== 0) {
                this.state = 2723;
                this.expression();
              }
              this.state = 2726;
              this.match(_CypherParser.T__17);
              break;
            case 3:
              this.state = 2743;
              this._errHandler.sync(this);
              var la_ = this._interp.adaptivePredict(this._input, 357, this._ctx);
              switch (la_) {
                case 1:
                  this.state = 2728;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                  if (_la === _CypherParser.SP) {
                    this.state = 2727;
                    this.match(_CypherParser.SP);
                  }
                  this.state = 2730;
                  this.match(_CypherParser.T__26);
                  break;
                case 2:
                  this.state = 2731;
                  this.match(_CypherParser.SP);
                  this.state = 2732;
                  this.match(_CypherParser.IN);
                  break;
                case 3:
                  this.state = 2733;
                  this.match(_CypherParser.SP);
                  this.state = 2734;
                  this.match(_CypherParser.STARTS);
                  this.state = 2735;
                  this.match(_CypherParser.SP);
                  this.state = 2736;
                  this.match(_CypherParser.WITH);
                  break;
                case 4:
                  this.state = 2737;
                  this.match(_CypherParser.SP);
                  this.state = 2738;
                  this.match(_CypherParser.ENDS);
                  this.state = 2739;
                  this.match(_CypherParser.SP);
                  this.state = 2740;
                  this.match(_CypherParser.WITH);
                  break;
                case 5:
                  this.state = 2741;
                  this.match(_CypherParser.SP);
                  this.state = 2742;
                  this.match(_CypherParser.CONTAINS);
                  break;
              }
              this.state = 2746;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _CypherParser.SP) {
                this.state = 2745;
                this.match(_CypherParser.SP);
              }
              this.state = 2748;
              this.propertyOrLabelsExpression();
              break;
            case 4:
              this.state = 2749;
              this.match(_CypherParser.SP);
              this.state = 2750;
              this.match(_CypherParser.IS);
              this.state = 2751;
              this.match(_CypherParser.SP);
              this.state = 2752;
              this.match(_CypherParser.NULL);
              break;
            case 5:
              this.state = 2753;
              this.match(_CypherParser.SP);
              this.state = 2754;
              this.match(_CypherParser.IS);
              this.state = 2755;
              this.match(_CypherParser.SP);
              this.state = 2756;
              this.match(_CypherParser.NOT);
              this.state = 2757;
              this.match(_CypherParser.SP);
              this.state = 2758;
              this.match(_CypherParser.NULL);
              break;
          }
        }
        this.state = 2763;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 360, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  propertyOrLabelsExpression() {
    let localctx = new PropertyOrLabelsExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 358, _CypherParser.RULE_propertyOrLabelsExpression);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2764;
      this.atom();
      this.state = 2774;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 363, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 2766;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2765;
            this.match(_CypherParser.SP);
          }
          this.state = 2770;
          this._errHandler.sync(this);
          switch (this._input.LA(1)) {
            case _CypherParser.T__6:
              this.state = 2768;
              this.propertyLookup();
              break;
            case _CypherParser.T__1:
              this.state = 2769;
              this.nodeLabels();
              break;
            default:
              throw new es_default.error.NoViableAltException(this);
          }
        }
        this.state = 2776;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 363, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  filterFunction() {
    let localctx = new FilterFunctionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 360, _CypherParser.RULE_filterFunction);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2777;
      this.filterFunctionName();
      this.state = 2779;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2778;
        this.match(_CypherParser.SP);
      }
      this.state = 2781;
      this.match(_CypherParser.T__19);
      this.state = 2783;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2782;
        this.match(_CypherParser.SP);
      }
      this.state = 2785;
      this.filterExpression();
      this.state = 2787;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2786;
        this.match(_CypherParser.SP);
      }
      this.state = 2789;
      this.match(_CypherParser.T__20);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  filterFunctionName() {
    let localctx = new FilterFunctionNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 362, _CypherParser.RULE_filterFunctionName);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2791;
      this.match(_CypherParser.FILTER);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  existsFunction() {
    let localctx = new ExistsFunctionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 364, _CypherParser.RULE_existsFunction);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2793;
      this.existsFunctionName();
      this.state = 2795;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2794;
        this.match(_CypherParser.SP);
      }
      this.state = 2797;
      this.match(_CypherParser.T__19);
      this.state = 2799;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2798;
        this.match(_CypherParser.SP);
      }
      this.state = 2801;
      this.expression();
      this.state = 2803;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2802;
        this.match(_CypherParser.SP);
      }
      this.state = 2805;
      this.match(_CypherParser.T__20);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  existsFunctionName() {
    let localctx = new ExistsFunctionNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 366, _CypherParser.RULE_existsFunctionName);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2807;
      this.match(_CypherParser.EXISTS);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  allFunction() {
    let localctx = new AllFunctionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 368, _CypherParser.RULE_allFunction);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2809;
      this.allFunctionName();
      this.state = 2811;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2810;
        this.match(_CypherParser.SP);
      }
      this.state = 2813;
      this.match(_CypherParser.T__19);
      this.state = 2815;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2814;
        this.match(_CypherParser.SP);
      }
      this.state = 2817;
      this.filterExpression();
      this.state = 2819;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2818;
        this.match(_CypherParser.SP);
      }
      this.state = 2821;
      this.match(_CypherParser.T__20);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  allFunctionName() {
    let localctx = new AllFunctionNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 370, _CypherParser.RULE_allFunctionName);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2823;
      this.match(_CypherParser.ALL);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  anyFunction() {
    let localctx = new AnyFunctionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 372, _CypherParser.RULE_anyFunction);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2825;
      this.anyFunctionName();
      this.state = 2827;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2826;
        this.match(_CypherParser.SP);
      }
      this.state = 2829;
      this.match(_CypherParser.T__19);
      this.state = 2831;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2830;
        this.match(_CypherParser.SP);
      }
      this.state = 2833;
      this.filterExpression();
      this.state = 2835;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2834;
        this.match(_CypherParser.SP);
      }
      this.state = 2837;
      this.match(_CypherParser.T__20);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  anyFunctionName() {
    let localctx = new AnyFunctionNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 374, _CypherParser.RULE_anyFunctionName);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2839;
      this.match(_CypherParser.ANY);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  noneFunction() {
    let localctx = new NoneFunctionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 376, _CypherParser.RULE_noneFunction);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2841;
      this.noneFunctionName();
      this.state = 2843;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2842;
        this.match(_CypherParser.SP);
      }
      this.state = 2845;
      this.match(_CypherParser.T__19);
      this.state = 2847;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2846;
        this.match(_CypherParser.SP);
      }
      this.state = 2849;
      this.filterExpression();
      this.state = 2851;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2850;
        this.match(_CypherParser.SP);
      }
      this.state = 2853;
      this.match(_CypherParser.T__20);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  noneFunctionName() {
    let localctx = new NoneFunctionNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 378, _CypherParser.RULE_noneFunctionName);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2855;
      this.match(_CypherParser.NONE);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  singleFunction() {
    let localctx = new SingleFunctionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 380, _CypherParser.RULE_singleFunction);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2857;
      this.singleFunctionName();
      this.state = 2859;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2858;
        this.match(_CypherParser.SP);
      }
      this.state = 2861;
      this.match(_CypherParser.T__19);
      this.state = 2863;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2862;
        this.match(_CypherParser.SP);
      }
      this.state = 2865;
      this.filterExpression();
      this.state = 2867;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2866;
        this.match(_CypherParser.SP);
      }
      this.state = 2869;
      this.match(_CypherParser.T__20);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  singleFunctionName() {
    let localctx = new SingleFunctionNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 382, _CypherParser.RULE_singleFunctionName);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2871;
      this.match(_CypherParser.SINGLE);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  extractFunction() {
    let localctx = new ExtractFunctionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 384, _CypherParser.RULE_extractFunction);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2873;
      this.extractFunctionName();
      this.state = 2875;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2874;
        this.match(_CypherParser.SP);
      }
      this.state = 2877;
      this.match(_CypherParser.T__19);
      this.state = 2879;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2878;
        this.match(_CypherParser.SP);
      }
      this.state = 2881;
      this.filterExpression();
      this.state = 2890;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 386, this._ctx);
      if (la_ === 1) {
        this.state = 2883;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 2882;
          this.match(_CypherParser.SP);
        }
        this.state = 2885;
        this.match(_CypherParser.T__22);
        this.state = 2887;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 2886;
          this.match(_CypherParser.SP);
        }
        this.state = 2889;
        this.expression();
      }
      this.state = 2893;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2892;
        this.match(_CypherParser.SP);
      }
      this.state = 2895;
      this.match(_CypherParser.T__20);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  extractFunctionName() {
    let localctx = new ExtractFunctionNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 386, _CypherParser.RULE_extractFunctionName);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2897;
      this.match(_CypherParser.EXTRACT);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  reduceFunction() {
    let localctx = new ReduceFunctionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 388, _CypherParser.RULE_reduceFunction);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2899;
      this.reduceFunctionName();
      this.state = 2901;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2900;
        this.match(_CypherParser.SP);
      }
      this.state = 2903;
      this.match(_CypherParser.T__19);
      this.state = 2905;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2904;
        this.match(_CypherParser.SP);
      }
      this.state = 2907;
      this.variable();
      this.state = 2909;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2908;
        this.match(_CypherParser.SP);
      }
      this.state = 2911;
      this.match(_CypherParser.T__11);
      this.state = 2913;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2912;
        this.match(_CypherParser.SP);
      }
      this.state = 2915;
      this.expression();
      this.state = 2917;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2916;
        this.match(_CypherParser.SP);
      }
      this.state = 2919;
      this.match(_CypherParser.T__14);
      this.state = 2921;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2920;
        this.match(_CypherParser.SP);
      }
      this.state = 2923;
      this.idInColl();
      this.state = 2925;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2924;
        this.match(_CypherParser.SP);
      }
      this.state = 2927;
      this.match(_CypherParser.T__22);
      this.state = 2929;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2928;
        this.match(_CypherParser.SP);
      }
      this.state = 2931;
      this.expression();
      this.state = 2933;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 2932;
        this.match(_CypherParser.SP);
      }
      this.state = 2935;
      this.match(_CypherParser.T__20);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  reduceFunctionName() {
    let localctx = new ReduceFunctionNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 390, _CypherParser.RULE_reduceFunctionName);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2937;
      this.match(_CypherParser.REDUCE);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  shortestPathPatternFunction() {
    let localctx = new ShortestPathPatternFunctionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 392, _CypherParser.RULE_shortestPathPatternFunction);
    var _la = 0;
    try {
      this.state = 2967;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.SHORTESTPATH:
          this.enterOuterAlt(localctx, 1);
          this.state = 2939;
          this.shortestPathFunctionName();
          this.state = 2941;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2940;
            this.match(_CypherParser.SP);
          }
          this.state = 2943;
          this.match(_CypherParser.T__19);
          this.state = 2945;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2944;
            this.match(_CypherParser.SP);
          }
          this.state = 2947;
          this.patternElement();
          this.state = 2949;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2948;
            this.match(_CypherParser.SP);
          }
          this.state = 2951;
          this.match(_CypherParser.T__20);
          break;
        case _CypherParser.ALLSHORTESTPATHS:
          this.enterOuterAlt(localctx, 2);
          this.state = 2953;
          this.allShortestPathFunctionName();
          this.state = 2955;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2954;
            this.match(_CypherParser.SP);
          }
          this.state = 2957;
          this.match(_CypherParser.T__19);
          this.state = 2959;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2958;
            this.match(_CypherParser.SP);
          }
          this.state = 2961;
          this.patternElement();
          this.state = 2963;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2962;
            this.match(_CypherParser.SP);
          }
          this.state = 2965;
          this.match(_CypherParser.T__20);
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  shortestPathFunctionName() {
    let localctx = new ShortestPathFunctionNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 394, _CypherParser.RULE_shortestPathFunctionName);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2969;
      this.match(_CypherParser.SHORTESTPATH);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  allShortestPathFunctionName() {
    let localctx = new AllShortestPathFunctionNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 396, _CypherParser.RULE_allShortestPathFunctionName);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 2971;
      this.match(_CypherParser.ALLSHORTESTPATHS);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  atom() {
    let localctx = new AtomContext(this, this._ctx, this.state);
    this.enterRule(localctx, 398, _CypherParser.RULE_atom);
    var _la = 0;
    try {
      this.state = 3004;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 407, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 2973;
          this.literal();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 2974;
          this.parameter();
          break;
        case 3:
          this.enterOuterAlt(localctx, 3);
          this.state = 2975;
          this.caseExpression();
          break;
        case 4:
          this.enterOuterAlt(localctx, 4);
          this.state = 2976;
          this.match(_CypherParser.COUNT);
          this.state = 2978;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2977;
            this.match(_CypherParser.SP);
          }
          this.state = 2980;
          this.match(_CypherParser.T__19);
          this.state = 2982;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2981;
            this.match(_CypherParser.SP);
          }
          this.state = 2984;
          this.match(_CypherParser.T__18);
          this.state = 2986;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 2985;
            this.match(_CypherParser.SP);
          }
          this.state = 2988;
          this.match(_CypherParser.T__20);
          break;
        case 5:
          this.enterOuterAlt(localctx, 5);
          this.state = 2989;
          this.listComprehension();
          break;
        case 6:
          this.enterOuterAlt(localctx, 6);
          this.state = 2990;
          this.patternComprehension();
          break;
        case 7:
          this.enterOuterAlt(localctx, 7);
          this.state = 2991;
          this.filterFunction();
          break;
        case 8:
          this.enterOuterAlt(localctx, 8);
          this.state = 2992;
          this.extractFunction();
          break;
        case 9:
          this.enterOuterAlt(localctx, 9);
          this.state = 2993;
          this.reduceFunction();
          break;
        case 10:
          this.enterOuterAlt(localctx, 10);
          this.state = 2994;
          this.allFunction();
          break;
        case 11:
          this.enterOuterAlt(localctx, 11);
          this.state = 2995;
          this.anyFunction();
          break;
        case 12:
          this.enterOuterAlt(localctx, 12);
          this.state = 2996;
          this.noneFunction();
          break;
        case 13:
          this.enterOuterAlt(localctx, 13);
          this.state = 2997;
          this.singleFunction();
          break;
        case 14:
          this.enterOuterAlt(localctx, 14);
          this.state = 2998;
          this.existsFunction();
          break;
        case 15:
          this.enterOuterAlt(localctx, 15);
          this.state = 2999;
          this.shortestPathPatternFunction();
          break;
        case 16:
          this.enterOuterAlt(localctx, 16);
          this.state = 3e3;
          this.relationshipsPattern();
          break;
        case 17:
          this.enterOuterAlt(localctx, 17);
          this.state = 3001;
          this.parenthesizedExpression();
          break;
        case 18:
          this.enterOuterAlt(localctx, 18);
          this.state = 3002;
          this.functionInvocation();
          break;
        case 19:
          this.enterOuterAlt(localctx, 19);
          this.state = 3003;
          this.variable();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  literal() {
    let localctx = new LiteralContext(this, this._ctx, this.state);
    this.enterRule(localctx, 400, _CypherParser.RULE_literal);
    try {
      this.state = 3013;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 408, this._ctx);
      switch (la_) {
        case 1:
          this.enterOuterAlt(localctx, 1);
          this.state = 3006;
          this.numberLiteral();
          break;
        case 2:
          this.enterOuterAlt(localctx, 2);
          this.state = 3007;
          this.stringLiteral();
          break;
        case 3:
          this.enterOuterAlt(localctx, 3);
          this.state = 3008;
          this.booleanLiteral();
          break;
        case 4:
          this.enterOuterAlt(localctx, 4);
          this.state = 3009;
          this.match(_CypherParser.NULL);
          break;
        case 5:
          this.enterOuterAlt(localctx, 5);
          this.state = 3010;
          this.mapLiteral();
          break;
        case 6:
          this.enterOuterAlt(localctx, 6);
          this.state = 3011;
          this.listLiteral();
          break;
        case 7:
          this.enterOuterAlt(localctx, 7);
          this.state = 3012;
          this.mapProjection();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  stringLiteral() {
    let localctx = new StringLiteralContext(this, this._ctx, this.state);
    this.enterRule(localctx, 402, _CypherParser.RULE_stringLiteral);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3015;
      this.match(_CypherParser.StringLiteral);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  booleanLiteral() {
    let localctx = new BooleanLiteralContext(this, this._ctx, this.state);
    this.enterRule(localctx, 404, _CypherParser.RULE_booleanLiteral);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3017;
      _la = this._input.LA(1);
      if (!(_la === _CypherParser.TRUE || _la === _CypherParser.FALSE)) {
        this._errHandler.recoverInline(this);
      } else {
        this._errHandler.reportMatch(this);
        this.consume();
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  listLiteral() {
    let localctx = new ListLiteralContext(this, this._ctx, this.state);
    this.enterRule(localctx, 406, _CypherParser.RULE_listLiteral);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3019;
      this.match(_CypherParser.T__16);
      this.state = 3021;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 3020;
        this.match(_CypherParser.SP);
      }
      this.state = 3040;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if ((_la & ~31) == 0 && (1 << _la & (1 << _CypherParser.T__2 | 1 << _CypherParser.T__12 | 1 << _CypherParser.T__13 | 1 << _CypherParser.T__16 | 1 << _CypherParser.T__19)) !== 0 || (_la - 34 & ~31) == 0 && (1 << _la - 34 & (1 << _CypherParser.T__33 - 34 | 1 << _CypherParser.CYPHER - 34 | 1 << _CypherParser.EXPLAIN - 34 | 1 << _CypherParser.PROFILE - 34 | 1 << _CypherParser.USING - 34 | 1 << _CypherParser.PERIODIC - 34 | 1 << _CypherParser.COMMIT - 34 | 1 << _CypherParser.UNION - 34 | 1 << _CypherParser.ALL - 34 | 1 << _CypherParser.CREATE - 34 | 1 << _CypherParser.DROP - 34 | 1 << _CypherParser.INDEX - 34 | 1 << _CypherParser.ON - 34)) !== 0 || (_la - 66 & ~31) == 0 && (1 << _la - 66 & (1 << _CypherParser.CONSTRAINT - 66 | 1 << _CypherParser.ASSERT - 66 | 1 << _CypherParser.IS - 66 | 1 << _CypherParser.UNIQUE - 66 | 1 << _CypherParser.EXISTS - 66 | 1 << _CypherParser.LOAD - 66 | 1 << _CypherParser.CSV - 66 | 1 << _CypherParser.WITH - 66 | 1 << _CypherParser.HEADERS - 66 | 1 << _CypherParser.FROM - 66 | 1 << _CypherParser.AS - 66 | 1 << _CypherParser.FIELDTERMINATOR - 66 | 1 << _CypherParser.OPTIONAL - 66 | 1 << _CypherParser.MATCH - 66 | 1 << _CypherParser.UNWIND - 66 | 1 << _CypherParser.MERGE - 66 | 1 << _CypherParser.SET - 66 | 1 << _CypherParser.DETACH - 66 | 1 << _CypherParser.DELETE - 66 | 1 << _CypherParser.REMOVE - 66 | 1 << _CypherParser.FOREACH - 66 | 1 << _CypherParser.IN - 66 | 1 << _CypherParser.DISTINCT - 66 | 1 << _CypherParser.RETURN - 66 | 1 << _CypherParser.ORDER - 66 | 1 << _CypherParser.BY - 66 | 1 << _CypherParser.L_SKIP - 66 | 1 << _CypherParser.LIMIT - 66 | 1 << _CypherParser.ASCENDING - 66 | 1 << _CypherParser.ASC - 66 | 1 << _CypherParser.DESCENDING - 66 | 1 << _CypherParser.DESC - 66)) !== 0 || (_la - 98 & ~31) == 0 && (1 << _la - 98 & (1 << _CypherParser.JOIN - 98 | 1 << _CypherParser.SCAN - 98 | 1 << _CypherParser.START - 98 | 1 << _CypherParser.NODE - 98 | 1 << _CypherParser.RELATIONSHIP - 98 | 1 << _CypherParser.REL - 98 | 1 << _CypherParser.WHERE - 98 | 1 << _CypherParser.SHORTESTPATH - 98 | 1 << _CypherParser.ALLSHORTESTPATHS - 98 | 1 << _CypherParser.OR - 98 | 1 << _CypherParser.XOR - 98 | 1 << _CypherParser.AND - 98 | 1 << _CypherParser.NOT - 98 | 1 << _CypherParser.STARTS - 98 | 1 << _CypherParser.ENDS - 98 | 1 << _CypherParser.CONTAINS - 98 | 1 << _CypherParser.NULL - 98 | 1 << _CypherParser.COUNT - 98 | 1 << _CypherParser.FILTER - 98 | 1 << _CypherParser.EXTRACT - 98 | 1 << _CypherParser.ANY - 98 | 1 << _CypherParser.NONE - 98 | 1 << _CypherParser.SINGLE - 98 | 1 << _CypherParser.TRUE - 98 | 1 << _CypherParser.FALSE - 98 | 1 << _CypherParser.REDUCE - 98 | 1 << _CypherParser.CASE - 98 | 1 << _CypherParser.ELSE - 98 | 1 << _CypherParser.END - 98 | 1 << _CypherParser.WHEN - 98 | 1 << _CypherParser.THEN - 98 | 1 << _CypherParser.CALL - 98)) !== 0 || (_la - 130 & ~31) == 0 && (1 << _la - 130 & (1 << _CypherParser.YIELD - 130 | 1 << _CypherParser.KEY - 130 | 1 << _CypherParser.CATALOG - 130 | 1 << _CypherParser.SHOW - 130 | 1 << _CypherParser.DEFAULT - 130 | 1 << _CypherParser.DBMS - 130 | 1 << _CypherParser.DATABASE - 130 | 1 << _CypherParser.DATABASES - 130 | 1 << _CypherParser.GRAPH - 130 | 1 << _CypherParser.GRAPHS - 130 | 1 << _CypherParser.REPLACE - 130 | 1 << _CypherParser.IF - 130 | 1 << _CypherParser.STOP - 130 | 1 << _CypherParser.ROLE - 130 | 1 << _CypherParser.ROLES - 130 | 1 << _CypherParser.USER - 130 | 1 << _CypherParser.USERS - 130 | 1 << _CypherParser.POPULATED - 130 | 1 << _CypherParser.PASSWORD - 130 | 1 << _CypherParser.CHANGE - 130 | 1 << _CypherParser.REQUIRED - 130 | 1 << _CypherParser.STATUS - 130 | 1 << _CypherParser.ACTIVE - 130 | 1 << _CypherParser.SUSPENDED - 130 | 1 << _CypherParser.ALTER - 130 | 1 << _CypherParser.CURRENT - 130 | 1 << _CypherParser.TO - 130 | 1 << _CypherParser.PRIVILEGES - 130 | 1 << _CypherParser.GRANT - 130 | 1 << _CypherParser.DENY - 130 | 1 << _CypherParser.REVOKE - 130 | 1 << _CypherParser.RELATIONSHIPS - 130)) !== 0 || (_la - 162 & ~31) == 0 && (1 << _la - 162 & (1 << _CypherParser.NODES - 162 | 1 << _CypherParser.ELEMENT - 162 | 1 << _CypherParser.ELEMENTS - 162 | 1 << _CypherParser.COPY - 162 | 1 << _CypherParser.OF - 162 | 1 << _CypherParser.TRAVERSE - 162 | 1 << _CypherParser.READ - 162 | 1 << _CypherParser.WRITE - 162 | 1 << _CypherParser.ACCESS - 162 | 1 << _CypherParser.INDEXES - 162 | 1 << _CypherParser.MANAGEMENT - 162 | 1 << _CypherParser.NEW - 162 | 1 << _CypherParser.LABEL - 162 | 1 << _CypherParser.LABELS - 162 | 1 << _CypherParser.NAME - 162 | 1 << _CypherParser.NAMES - 162 | 1 << _CypherParser.TYPE - 162 | 1 << _CypherParser.TYPES - 162 | 1 << _CypherParser.PROPERTY - 162 | 1 << _CypherParser.CONSTRAINTS - 162 | 1 << _CypherParser.ASSIGN - 162 | 1 << _CypherParser.BTREE - 162 | 1 << _CypherParser.EXIST - 162 | 1 << _CypherParser.FOR - 162 | 1 << _CypherParser.OPTIONS - 162 | 1 << _CypherParser.EXECUTE - 162 | 1 << _CypherParser.DEFINED - 162 | 1 << _CypherParser.FUNCTION - 162 | 1 << _CypherParser.FUNCTIONS - 162 | 1 << _CypherParser.BOOSTED - 162 | 1 << _CypherParser.PROCEDURE - 162 | 1 << _CypherParser.PROCEDURES - 162)) !== 0 || (_la - 194 & ~31) == 0 && (1 << _la - 194 & (1 << _CypherParser.ADMIN - 194 | 1 << _CypherParser.ADMINISTRATOR - 194 | 1 << _CypherParser.BRIEF - 194 | 1 << _CypherParser.VERBOSE - 194 | 1 << _CypherParser.OUTPUT - 194 | 1 << _CypherParser.StringLiteral - 194 | 1 << _CypherParser.HexInteger - 194 | 1 << _CypherParser.DecimalInteger - 194 | 1 << _CypherParser.OctalInteger - 194 | 1 << _CypherParser.HexLetter - 194 | 1 << _CypherParser.ExponentDecimalReal - 194 | 1 << _CypherParser.RegularDecimalReal - 194 | 1 << _CypherParser.UnescapedSymbolicName - 194 | 1 << _CypherParser.EscapedSymbolicName - 194)) !== 0) {
        this.state = 3023;
        this.expression();
        this.state = 3025;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 3024;
          this.match(_CypherParser.SP);
        }
        this.state = 3037;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === _CypherParser.T__14) {
          this.state = 3027;
          this.match(_CypherParser.T__14);
          this.state = 3029;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 3028;
            this.match(_CypherParser.SP);
          }
          this.state = 3031;
          this.expression();
          this.state = 3033;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 3032;
            this.match(_CypherParser.SP);
          }
          this.state = 3039;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
      }
      this.state = 3042;
      this.match(_CypherParser.T__17);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  partialComparisonExpression() {
    let localctx = new PartialComparisonExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 408, _CypherParser.RULE_partialComparisonExpression);
    var _la = 0;
    try {
      this.state = 3079;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.T__11:
          this.enterOuterAlt(localctx, 1);
          this.state = 3044;
          this.match(_CypherParser.T__11);
          this.state = 3046;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 3045;
            this.match(_CypherParser.SP);
          }
          this.state = 3048;
          this.addOrSubtractExpression();
          break;
        case _CypherParser.T__27:
          this.enterOuterAlt(localctx, 2);
          this.state = 3049;
          this.match(_CypherParser.T__27);
          this.state = 3051;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 3050;
            this.match(_CypherParser.SP);
          }
          this.state = 3053;
          this.addOrSubtractExpression();
          break;
        case _CypherParser.T__28:
          this.enterOuterAlt(localctx, 3);
          this.state = 3054;
          this.match(_CypherParser.T__28);
          this.state = 3056;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 3055;
            this.match(_CypherParser.SP);
          }
          this.state = 3058;
          this.addOrSubtractExpression();
          break;
        case _CypherParser.T__29:
          this.enterOuterAlt(localctx, 4);
          this.state = 3059;
          this.match(_CypherParser.T__29);
          this.state = 3061;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 3060;
            this.match(_CypherParser.SP);
          }
          this.state = 3063;
          this.addOrSubtractExpression();
          break;
        case _CypherParser.T__30:
          this.enterOuterAlt(localctx, 5);
          this.state = 3064;
          this.match(_CypherParser.T__30);
          this.state = 3066;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 3065;
            this.match(_CypherParser.SP);
          }
          this.state = 3068;
          this.addOrSubtractExpression();
          break;
        case _CypherParser.T__31:
          this.enterOuterAlt(localctx, 6);
          this.state = 3069;
          this.match(_CypherParser.T__31);
          this.state = 3071;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 3070;
            this.match(_CypherParser.SP);
          }
          this.state = 3073;
          this.addOrSubtractExpression();
          break;
        case _CypherParser.T__32:
          this.enterOuterAlt(localctx, 7);
          this.state = 3074;
          this.match(_CypherParser.T__32);
          this.state = 3076;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 3075;
            this.match(_CypherParser.SP);
          }
          this.state = 3078;
          this.addOrSubtractExpression();
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  parenthesizedExpression() {
    let localctx = new ParenthesizedExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 410, _CypherParser.RULE_parenthesizedExpression);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3081;
      this.match(_CypherParser.T__19);
      this.state = 3083;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 3082;
        this.match(_CypherParser.SP);
      }
      this.state = 3085;
      this.expression();
      this.state = 3087;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 3086;
        this.match(_CypherParser.SP);
      }
      this.state = 3089;
      this.match(_CypherParser.T__20);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  relationshipsPattern() {
    let localctx = new RelationshipsPatternContext(this, this._ctx, this.state);
    this.enterRule(localctx, 412, _CypherParser.RULE_relationshipsPattern);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3091;
      this.nodePattern();
      this.state = 3096;
      this._errHandler.sync(this);
      var _alt = 1;
      do {
        switch (_alt) {
          case 1:
            this.state = 3093;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _CypherParser.SP) {
              this.state = 3092;
              this.match(_CypherParser.SP);
            }
            this.state = 3095;
            this.patternElementChain();
            break;
          default:
            throw new es_default.error.NoViableAltException(this);
        }
        this.state = 3098;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 426, this._ctx);
      } while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  filterExpression() {
    let localctx = new FilterExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 414, _CypherParser.RULE_filterExpression);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3100;
      this.idInColl();
      this.state = 3105;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 428, this._ctx);
      if (la_ === 1) {
        this.state = 3102;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 3101;
          this.match(_CypherParser.SP);
        }
        this.state = 3104;
        this.where();
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  idInColl() {
    let localctx = new IdInCollContext(this, this._ctx, this.state);
    this.enterRule(localctx, 416, _CypherParser.RULE_idInColl);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3107;
      this.variable();
      this.state = 3108;
      this.match(_CypherParser.SP);
      this.state = 3109;
      this.match(_CypherParser.IN);
      this.state = 3110;
      this.match(_CypherParser.SP);
      this.state = 3111;
      this.expression();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  functionInvocation() {
    let localctx = new FunctionInvocationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 418, _CypherParser.RULE_functionInvocation);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3113;
      this.functionInvocationBody();
      this.state = 3115;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 3114;
        this.match(_CypherParser.SP);
      }
      this.state = 3117;
      this.match(_CypherParser.T__19);
      this.state = 3119;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 3118;
        this.match(_CypherParser.SP);
      }
      this.state = 3125;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 432, this._ctx);
      if (la_ === 1) {
        this.state = 3121;
        this.match(_CypherParser.DISTINCT);
        this.state = 3123;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 3122;
          this.match(_CypherParser.SP);
        }
      }
      this.state = 3144;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if ((_la & ~31) == 0 && (1 << _la & (1 << _CypherParser.T__2 | 1 << _CypherParser.T__12 | 1 << _CypherParser.T__13 | 1 << _CypherParser.T__16 | 1 << _CypherParser.T__19)) !== 0 || (_la - 34 & ~31) == 0 && (1 << _la - 34 & (1 << _CypherParser.T__33 - 34 | 1 << _CypherParser.CYPHER - 34 | 1 << _CypherParser.EXPLAIN - 34 | 1 << _CypherParser.PROFILE - 34 | 1 << _CypherParser.USING - 34 | 1 << _CypherParser.PERIODIC - 34 | 1 << _CypherParser.COMMIT - 34 | 1 << _CypherParser.UNION - 34 | 1 << _CypherParser.ALL - 34 | 1 << _CypherParser.CREATE - 34 | 1 << _CypherParser.DROP - 34 | 1 << _CypherParser.INDEX - 34 | 1 << _CypherParser.ON - 34)) !== 0 || (_la - 66 & ~31) == 0 && (1 << _la - 66 & (1 << _CypherParser.CONSTRAINT - 66 | 1 << _CypherParser.ASSERT - 66 | 1 << _CypherParser.IS - 66 | 1 << _CypherParser.UNIQUE - 66 | 1 << _CypherParser.EXISTS - 66 | 1 << _CypherParser.LOAD - 66 | 1 << _CypherParser.CSV - 66 | 1 << _CypherParser.WITH - 66 | 1 << _CypherParser.HEADERS - 66 | 1 << _CypherParser.FROM - 66 | 1 << _CypherParser.AS - 66 | 1 << _CypherParser.FIELDTERMINATOR - 66 | 1 << _CypherParser.OPTIONAL - 66 | 1 << _CypherParser.MATCH - 66 | 1 << _CypherParser.UNWIND - 66 | 1 << _CypherParser.MERGE - 66 | 1 << _CypherParser.SET - 66 | 1 << _CypherParser.DETACH - 66 | 1 << _CypherParser.DELETE - 66 | 1 << _CypherParser.REMOVE - 66 | 1 << _CypherParser.FOREACH - 66 | 1 << _CypherParser.IN - 66 | 1 << _CypherParser.DISTINCT - 66 | 1 << _CypherParser.RETURN - 66 | 1 << _CypherParser.ORDER - 66 | 1 << _CypherParser.BY - 66 | 1 << _CypherParser.L_SKIP - 66 | 1 << _CypherParser.LIMIT - 66 | 1 << _CypherParser.ASCENDING - 66 | 1 << _CypherParser.ASC - 66 | 1 << _CypherParser.DESCENDING - 66 | 1 << _CypherParser.DESC - 66)) !== 0 || (_la - 98 & ~31) == 0 && (1 << _la - 98 & (1 << _CypherParser.JOIN - 98 | 1 << _CypherParser.SCAN - 98 | 1 << _CypherParser.START - 98 | 1 << _CypherParser.NODE - 98 | 1 << _CypherParser.RELATIONSHIP - 98 | 1 << _CypherParser.REL - 98 | 1 << _CypherParser.WHERE - 98 | 1 << _CypherParser.SHORTESTPATH - 98 | 1 << _CypherParser.ALLSHORTESTPATHS - 98 | 1 << _CypherParser.OR - 98 | 1 << _CypherParser.XOR - 98 | 1 << _CypherParser.AND - 98 | 1 << _CypherParser.NOT - 98 | 1 << _CypherParser.STARTS - 98 | 1 << _CypherParser.ENDS - 98 | 1 << _CypherParser.CONTAINS - 98 | 1 << _CypherParser.NULL - 98 | 1 << _CypherParser.COUNT - 98 | 1 << _CypherParser.FILTER - 98 | 1 << _CypherParser.EXTRACT - 98 | 1 << _CypherParser.ANY - 98 | 1 << _CypherParser.NONE - 98 | 1 << _CypherParser.SINGLE - 98 | 1 << _CypherParser.TRUE - 98 | 1 << _CypherParser.FALSE - 98 | 1 << _CypherParser.REDUCE - 98 | 1 << _CypherParser.CASE - 98 | 1 << _CypherParser.ELSE - 98 | 1 << _CypherParser.END - 98 | 1 << _CypherParser.WHEN - 98 | 1 << _CypherParser.THEN - 98 | 1 << _CypherParser.CALL - 98)) !== 0 || (_la - 130 & ~31) == 0 && (1 << _la - 130 & (1 << _CypherParser.YIELD - 130 | 1 << _CypherParser.KEY - 130 | 1 << _CypherParser.CATALOG - 130 | 1 << _CypherParser.SHOW - 130 | 1 << _CypherParser.DEFAULT - 130 | 1 << _CypherParser.DBMS - 130 | 1 << _CypherParser.DATABASE - 130 | 1 << _CypherParser.DATABASES - 130 | 1 << _CypherParser.GRAPH - 130 | 1 << _CypherParser.GRAPHS - 130 | 1 << _CypherParser.REPLACE - 130 | 1 << _CypherParser.IF - 130 | 1 << _CypherParser.STOP - 130 | 1 << _CypherParser.ROLE - 130 | 1 << _CypherParser.ROLES - 130 | 1 << _CypherParser.USER - 130 | 1 << _CypherParser.USERS - 130 | 1 << _CypherParser.POPULATED - 130 | 1 << _CypherParser.PASSWORD - 130 | 1 << _CypherParser.CHANGE - 130 | 1 << _CypherParser.REQUIRED - 130 | 1 << _CypherParser.STATUS - 130 | 1 << _CypherParser.ACTIVE - 130 | 1 << _CypherParser.SUSPENDED - 130 | 1 << _CypherParser.ALTER - 130 | 1 << _CypherParser.CURRENT - 130 | 1 << _CypherParser.TO - 130 | 1 << _CypherParser.PRIVILEGES - 130 | 1 << _CypherParser.GRANT - 130 | 1 << _CypherParser.DENY - 130 | 1 << _CypherParser.REVOKE - 130 | 1 << _CypherParser.RELATIONSHIPS - 130)) !== 0 || (_la - 162 & ~31) == 0 && (1 << _la - 162 & (1 << _CypherParser.NODES - 162 | 1 << _CypherParser.ELEMENT - 162 | 1 << _CypherParser.ELEMENTS - 162 | 1 << _CypherParser.COPY - 162 | 1 << _CypherParser.OF - 162 | 1 << _CypherParser.TRAVERSE - 162 | 1 << _CypherParser.READ - 162 | 1 << _CypherParser.WRITE - 162 | 1 << _CypherParser.ACCESS - 162 | 1 << _CypherParser.INDEXES - 162 | 1 << _CypherParser.MANAGEMENT - 162 | 1 << _CypherParser.NEW - 162 | 1 << _CypherParser.LABEL - 162 | 1 << _CypherParser.LABELS - 162 | 1 << _CypherParser.NAME - 162 | 1 << _CypherParser.NAMES - 162 | 1 << _CypherParser.TYPE - 162 | 1 << _CypherParser.TYPES - 162 | 1 << _CypherParser.PROPERTY - 162 | 1 << _CypherParser.CONSTRAINTS - 162 | 1 << _CypherParser.ASSIGN - 162 | 1 << _CypherParser.BTREE - 162 | 1 << _CypherParser.EXIST - 162 | 1 << _CypherParser.FOR - 162 | 1 << _CypherParser.OPTIONS - 162 | 1 << _CypherParser.EXECUTE - 162 | 1 << _CypherParser.DEFINED - 162 | 1 << _CypherParser.FUNCTION - 162 | 1 << _CypherParser.FUNCTIONS - 162 | 1 << _CypherParser.BOOSTED - 162 | 1 << _CypherParser.PROCEDURE - 162 | 1 << _CypherParser.PROCEDURES - 162)) !== 0 || (_la - 194 & ~31) == 0 && (1 << _la - 194 & (1 << _CypherParser.ADMIN - 194 | 1 << _CypherParser.ADMINISTRATOR - 194 | 1 << _CypherParser.BRIEF - 194 | 1 << _CypherParser.VERBOSE - 194 | 1 << _CypherParser.OUTPUT - 194 | 1 << _CypherParser.StringLiteral - 194 | 1 << _CypherParser.HexInteger - 194 | 1 << _CypherParser.DecimalInteger - 194 | 1 << _CypherParser.OctalInteger - 194 | 1 << _CypherParser.HexLetter - 194 | 1 << _CypherParser.ExponentDecimalReal - 194 | 1 << _CypherParser.RegularDecimalReal - 194 | 1 << _CypherParser.UnescapedSymbolicName - 194 | 1 << _CypherParser.EscapedSymbolicName - 194)) !== 0) {
        this.state = 3127;
        this.expression();
        this.state = 3129;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 3128;
          this.match(_CypherParser.SP);
        }
        this.state = 3141;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === _CypherParser.T__14) {
          this.state = 3131;
          this.match(_CypherParser.T__14);
          this.state = 3133;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 3132;
            this.match(_CypherParser.SP);
          }
          this.state = 3135;
          this.expression();
          this.state = 3137;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 3136;
            this.match(_CypherParser.SP);
          }
          this.state = 3143;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
      }
      this.state = 3146;
      this.match(_CypherParser.T__20);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  functionInvocationBody() {
    let localctx = new FunctionInvocationBodyContext(this, this._ctx, this.state);
    this.enterRule(localctx, 420, _CypherParser.RULE_functionInvocationBody);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3148;
      this.namespace();
      this.state = 3149;
      this.functionName();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  functionName() {
    let localctx = new FunctionNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 422, _CypherParser.RULE_functionName);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3151;
      _la = this._input.LA(1);
      if (!(_la === _CypherParser.COUNT || _la === _CypherParser.UnescapedSymbolicName || _la === _CypherParser.EscapedSymbolicName)) {
        this._errHandler.recoverInline(this);
      } else {
        this._errHandler.reportMatch(this);
        this.consume();
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  procedureName() {
    let localctx = new ProcedureNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 424, _CypherParser.RULE_procedureName);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3153;
      this.symbolicName();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  listComprehension() {
    let localctx = new ListComprehensionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 426, _CypherParser.RULE_listComprehension);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3155;
      this.match(_CypherParser.T__16);
      this.state = 3157;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 3156;
        this.match(_CypherParser.SP);
      }
      this.state = 3159;
      this.filterExpression();
      this.state = 3168;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 441, this._ctx);
      if (la_ === 1) {
        this.state = 3161;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 3160;
          this.match(_CypherParser.SP);
        }
        this.state = 3163;
        this.match(_CypherParser.T__22);
        this.state = 3165;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 3164;
          this.match(_CypherParser.SP);
        }
        this.state = 3167;
        this.expression();
      }
      this.state = 3171;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 3170;
        this.match(_CypherParser.SP);
      }
      this.state = 3173;
      this.match(_CypherParser.T__17);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  patternComprehension() {
    let localctx = new PatternComprehensionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 428, _CypherParser.RULE_patternComprehension);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3175;
      this.match(_CypherParser.T__16);
      this.state = 3177;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 3176;
        this.match(_CypherParser.SP);
      }
      this.state = 3187;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if ((_la - 54 & ~31) == 0 && (1 << _la - 54 & (1 << _CypherParser.CYPHER - 54 | 1 << _CypherParser.EXPLAIN - 54 | 1 << _CypherParser.PROFILE - 54 | 1 << _CypherParser.USING - 54 | 1 << _CypherParser.PERIODIC - 54 | 1 << _CypherParser.COMMIT - 54 | 1 << _CypherParser.UNION - 54 | 1 << _CypherParser.ALL - 54 | 1 << _CypherParser.CREATE - 54 | 1 << _CypherParser.DROP - 54 | 1 << _CypherParser.INDEX - 54 | 1 << _CypherParser.ON - 54 | 1 << _CypherParser.CONSTRAINT - 54 | 1 << _CypherParser.ASSERT - 54 | 1 << _CypherParser.IS - 54 | 1 << _CypherParser.UNIQUE - 54 | 1 << _CypherParser.EXISTS - 54 | 1 << _CypherParser.LOAD - 54 | 1 << _CypherParser.CSV - 54 | 1 << _CypherParser.WITH - 54 | 1 << _CypherParser.HEADERS - 54 | 1 << _CypherParser.FROM - 54 | 1 << _CypherParser.AS - 54 | 1 << _CypherParser.FIELDTERMINATOR - 54 | 1 << _CypherParser.OPTIONAL - 54 | 1 << _CypherParser.MATCH - 54 | 1 << _CypherParser.UNWIND - 54 | 1 << _CypherParser.MERGE - 54 | 1 << _CypherParser.SET - 54 | 1 << _CypherParser.DETACH - 54 | 1 << _CypherParser.DELETE - 54 | 1 << _CypherParser.REMOVE - 54)) !== 0 || (_la - 86 & ~31) == 0 && (1 << _la - 86 & (1 << _CypherParser.FOREACH - 86 | 1 << _CypherParser.IN - 86 | 1 << _CypherParser.DISTINCT - 86 | 1 << _CypherParser.RETURN - 86 | 1 << _CypherParser.ORDER - 86 | 1 << _CypherParser.BY - 86 | 1 << _CypherParser.L_SKIP - 86 | 1 << _CypherParser.LIMIT - 86 | 1 << _CypherParser.ASCENDING - 86 | 1 << _CypherParser.ASC - 86 | 1 << _CypherParser.DESCENDING - 86 | 1 << _CypherParser.DESC - 86 | 1 << _CypherParser.JOIN - 86 | 1 << _CypherParser.SCAN - 86 | 1 << _CypherParser.START - 86 | 1 << _CypherParser.NODE - 86 | 1 << _CypherParser.RELATIONSHIP - 86 | 1 << _CypherParser.REL - 86 | 1 << _CypherParser.WHERE - 86 | 1 << _CypherParser.SHORTESTPATH - 86 | 1 << _CypherParser.ALLSHORTESTPATHS - 86 | 1 << _CypherParser.OR - 86 | 1 << _CypherParser.XOR - 86 | 1 << _CypherParser.AND - 86 | 1 << _CypherParser.NOT - 86 | 1 << _CypherParser.STARTS - 86 | 1 << _CypherParser.ENDS - 86 | 1 << _CypherParser.CONTAINS - 86 | 1 << _CypherParser.NULL - 86 | 1 << _CypherParser.COUNT - 86 | 1 << _CypherParser.FILTER - 86 | 1 << _CypherParser.EXTRACT - 86)) !== 0 || (_la - 118 & ~31) == 0 && (1 << _la - 118 & (1 << _CypherParser.ANY - 118 | 1 << _CypherParser.NONE - 118 | 1 << _CypherParser.SINGLE - 118 | 1 << _CypherParser.TRUE - 118 | 1 << _CypherParser.FALSE - 118 | 1 << _CypherParser.REDUCE - 118 | 1 << _CypherParser.CASE - 118 | 1 << _CypherParser.ELSE - 118 | 1 << _CypherParser.END - 118 | 1 << _CypherParser.WHEN - 118 | 1 << _CypherParser.THEN - 118 | 1 << _CypherParser.CALL - 118 | 1 << _CypherParser.YIELD - 118 | 1 << _CypherParser.KEY - 118 | 1 << _CypherParser.CATALOG - 118 | 1 << _CypherParser.SHOW - 118 | 1 << _CypherParser.DEFAULT - 118 | 1 << _CypherParser.DBMS - 118 | 1 << _CypherParser.DATABASE - 118 | 1 << _CypherParser.DATABASES - 118 | 1 << _CypherParser.GRAPH - 118 | 1 << _CypherParser.GRAPHS - 118 | 1 << _CypherParser.REPLACE - 118 | 1 << _CypherParser.IF - 118 | 1 << _CypherParser.STOP - 118 | 1 << _CypherParser.ROLE - 118 | 1 << _CypherParser.ROLES - 118 | 1 << _CypherParser.USER - 118 | 1 << _CypherParser.USERS - 118 | 1 << _CypherParser.POPULATED - 118 | 1 << _CypherParser.PASSWORD - 118 | 1 << _CypherParser.CHANGE - 118)) !== 0 || (_la - 150 & ~31) == 0 && (1 << _la - 150 & (1 << _CypherParser.REQUIRED - 150 | 1 << _CypherParser.STATUS - 150 | 1 << _CypherParser.ACTIVE - 150 | 1 << _CypherParser.SUSPENDED - 150 | 1 << _CypherParser.ALTER - 150 | 1 << _CypherParser.CURRENT - 150 | 1 << _CypherParser.TO - 150 | 1 << _CypherParser.PRIVILEGES - 150 | 1 << _CypherParser.GRANT - 150 | 1 << _CypherParser.DENY - 150 | 1 << _CypherParser.REVOKE - 150 | 1 << _CypherParser.RELATIONSHIPS - 150 | 1 << _CypherParser.NODES - 150 | 1 << _CypherParser.ELEMENT - 150 | 1 << _CypherParser.ELEMENTS - 150 | 1 << _CypherParser.COPY - 150 | 1 << _CypherParser.OF - 150 | 1 << _CypherParser.TRAVERSE - 150 | 1 << _CypherParser.READ - 150 | 1 << _CypherParser.WRITE - 150 | 1 << _CypherParser.ACCESS - 150 | 1 << _CypherParser.INDEXES - 150 | 1 << _CypherParser.MANAGEMENT - 150 | 1 << _CypherParser.NEW - 150 | 1 << _CypherParser.LABEL - 150 | 1 << _CypherParser.LABELS - 150 | 1 << _CypherParser.NAME - 150 | 1 << _CypherParser.NAMES - 150 | 1 << _CypherParser.TYPE - 150 | 1 << _CypherParser.TYPES - 150 | 1 << _CypherParser.PROPERTY - 150 | 1 << _CypherParser.CONSTRAINTS - 150)) !== 0 || (_la - 182 & ~31) == 0 && (1 << _la - 182 & (1 << _CypherParser.ASSIGN - 182 | 1 << _CypherParser.BTREE - 182 | 1 << _CypherParser.EXIST - 182 | 1 << _CypherParser.FOR - 182 | 1 << _CypherParser.OPTIONS - 182 | 1 << _CypherParser.EXECUTE - 182 | 1 << _CypherParser.DEFINED - 182 | 1 << _CypherParser.FUNCTION - 182 | 1 << _CypherParser.FUNCTIONS - 182 | 1 << _CypherParser.BOOSTED - 182 | 1 << _CypherParser.PROCEDURE - 182 | 1 << _CypherParser.PROCEDURES - 182 | 1 << _CypherParser.ADMIN - 182 | 1 << _CypherParser.ADMINISTRATOR - 182 | 1 << _CypherParser.BRIEF - 182 | 1 << _CypherParser.VERBOSE - 182 | 1 << _CypherParser.OUTPUT - 182 | 1 << _CypherParser.HexLetter - 182)) !== 0 || _la === _CypherParser.UnescapedSymbolicName || _la === _CypherParser.EscapedSymbolicName) {
        this.state = 3179;
        this.variable();
        this.state = 3181;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 3180;
          this.match(_CypherParser.SP);
        }
        this.state = 3183;
        this.match(_CypherParser.T__11);
        this.state = 3185;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 3184;
          this.match(_CypherParser.SP);
        }
      }
      this.state = 3189;
      this.relationshipsPattern();
      this.state = 3191;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 3190;
        this.match(_CypherParser.SP);
      }
      this.state = 3201;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.WHERE) {
        this.state = 3193;
        this.match(_CypherParser.WHERE);
        this.state = 3195;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 3194;
          this.match(_CypherParser.SP);
        }
        this.state = 3197;
        this.expression();
        this.state = 3199;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 3198;
          this.match(_CypherParser.SP);
        }
      }
      this.state = 3203;
      this.match(_CypherParser.T__22);
      this.state = 3205;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 3204;
        this.match(_CypherParser.SP);
      }
      this.state = 3207;
      this.expression();
      this.state = 3209;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 3208;
        this.match(_CypherParser.SP);
      }
      this.state = 3211;
      this.match(_CypherParser.T__17);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  propertyLookup() {
    let localctx = new PropertyLookupContext(this, this._ctx, this.state);
    this.enterRule(localctx, 430, _CypherParser.RULE_propertyLookup);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3213;
      this.match(_CypherParser.T__6);
      this.state = 3215;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 3214;
        this.match(_CypherParser.SP);
      }
      this.state = 3217;
      this.propertyKeyName();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  caseExpression() {
    let localctx = new CaseExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 432, _CypherParser.RULE_caseExpression);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3241;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 459, this._ctx);
      switch (la_) {
        case 1:
          this.state = 3219;
          this.match(_CypherParser.CASE);
          this.state = 3224;
          this._errHandler.sync(this);
          var _alt = 1;
          do {
            switch (_alt) {
              case 1:
                this.state = 3221;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _CypherParser.SP) {
                  this.state = 3220;
                  this.match(_CypherParser.SP);
                }
                this.state = 3223;
                this.caseAlternatives();
                break;
              default:
                throw new es_default.error.NoViableAltException(this);
            }
            this.state = 3226;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input, 455, this._ctx);
          } while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER);
          break;
        case 2:
          this.state = 3228;
          this.match(_CypherParser.CASE);
          this.state = 3230;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 3229;
            this.match(_CypherParser.SP);
          }
          this.state = 3232;
          this.expression();
          this.state = 3237;
          this._errHandler.sync(this);
          var _alt = 1;
          do {
            switch (_alt) {
              case 1:
                this.state = 3234;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _CypherParser.SP) {
                  this.state = 3233;
                  this.match(_CypherParser.SP);
                }
                this.state = 3236;
                this.caseAlternatives();
                break;
              default:
                throw new es_default.error.NoViableAltException(this);
            }
            this.state = 3239;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input, 458, this._ctx);
          } while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER);
          break;
      }
      this.state = 3251;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 462, this._ctx);
      if (la_ === 1) {
        this.state = 3244;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 3243;
          this.match(_CypherParser.SP);
        }
        this.state = 3246;
        this.match(_CypherParser.ELSE);
        this.state = 3248;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 3247;
          this.match(_CypherParser.SP);
        }
        this.state = 3250;
        this.expression();
      }
      this.state = 3254;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 3253;
        this.match(_CypherParser.SP);
      }
      this.state = 3256;
      this.match(_CypherParser.END);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  caseAlternatives() {
    let localctx = new CaseAlternativesContext(this, this._ctx, this.state);
    this.enterRule(localctx, 434, _CypherParser.RULE_caseAlternatives);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3258;
      this.match(_CypherParser.WHEN);
      this.state = 3260;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 3259;
        this.match(_CypherParser.SP);
      }
      this.state = 3262;
      this.expression();
      this.state = 3264;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 3263;
        this.match(_CypherParser.SP);
      }
      this.state = 3266;
      this.match(_CypherParser.THEN);
      this.state = 3268;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 3267;
        this.match(_CypherParser.SP);
      }
      this.state = 3270;
      this.expression();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  variable() {
    let localctx = new VariableContext(this, this._ctx, this.state);
    this.enterRule(localctx, 436, _CypherParser.RULE_variable);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3272;
      this.symbolicName();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  numberLiteral() {
    let localctx = new NumberLiteralContext(this, this._ctx, this.state);
    this.enterRule(localctx, 438, _CypherParser.RULE_numberLiteral);
    try {
      this.state = 3276;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.ExponentDecimalReal:
        case _CypherParser.RegularDecimalReal:
          this.enterOuterAlt(localctx, 1);
          this.state = 3274;
          this.doubleLiteral();
          break;
        case _CypherParser.HexInteger:
        case _CypherParser.DecimalInteger:
        case _CypherParser.OctalInteger:
          this.enterOuterAlt(localctx, 2);
          this.state = 3275;
          this.integerLiteral();
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  mapLiteral() {
    let localctx = new MapLiteralContext(this, this._ctx, this.state);
    this.enterRule(localctx, 440, _CypherParser.RULE_mapLiteral);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3278;
      this.match(_CypherParser.T__13);
      this.state = 3280;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 3279;
        this.match(_CypherParser.SP);
      }
      this.state = 3299;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if ((_la - 54 & ~31) == 0 && (1 << _la - 54 & (1 << _CypherParser.CYPHER - 54 | 1 << _CypherParser.EXPLAIN - 54 | 1 << _CypherParser.PROFILE - 54 | 1 << _CypherParser.USING - 54 | 1 << _CypherParser.PERIODIC - 54 | 1 << _CypherParser.COMMIT - 54 | 1 << _CypherParser.UNION - 54 | 1 << _CypherParser.ALL - 54 | 1 << _CypherParser.CREATE - 54 | 1 << _CypherParser.DROP - 54 | 1 << _CypherParser.INDEX - 54 | 1 << _CypherParser.ON - 54 | 1 << _CypherParser.CONSTRAINT - 54 | 1 << _CypherParser.ASSERT - 54 | 1 << _CypherParser.IS - 54 | 1 << _CypherParser.UNIQUE - 54 | 1 << _CypherParser.EXISTS - 54 | 1 << _CypherParser.LOAD - 54 | 1 << _CypherParser.CSV - 54 | 1 << _CypherParser.WITH - 54 | 1 << _CypherParser.HEADERS - 54 | 1 << _CypherParser.FROM - 54 | 1 << _CypherParser.AS - 54 | 1 << _CypherParser.FIELDTERMINATOR - 54 | 1 << _CypherParser.OPTIONAL - 54 | 1 << _CypherParser.MATCH - 54 | 1 << _CypherParser.UNWIND - 54 | 1 << _CypherParser.MERGE - 54 | 1 << _CypherParser.SET - 54 | 1 << _CypherParser.DETACH - 54 | 1 << _CypherParser.DELETE - 54 | 1 << _CypherParser.REMOVE - 54)) !== 0 || (_la - 86 & ~31) == 0 && (1 << _la - 86 & (1 << _CypherParser.FOREACH - 86 | 1 << _CypherParser.IN - 86 | 1 << _CypherParser.DISTINCT - 86 | 1 << _CypherParser.RETURN - 86 | 1 << _CypherParser.ORDER - 86 | 1 << _CypherParser.BY - 86 | 1 << _CypherParser.L_SKIP - 86 | 1 << _CypherParser.LIMIT - 86 | 1 << _CypherParser.ASCENDING - 86 | 1 << _CypherParser.ASC - 86 | 1 << _CypherParser.DESCENDING - 86 | 1 << _CypherParser.DESC - 86 | 1 << _CypherParser.JOIN - 86 | 1 << _CypherParser.SCAN - 86 | 1 << _CypherParser.START - 86 | 1 << _CypherParser.NODE - 86 | 1 << _CypherParser.RELATIONSHIP - 86 | 1 << _CypherParser.REL - 86 | 1 << _CypherParser.WHERE - 86 | 1 << _CypherParser.SHORTESTPATH - 86 | 1 << _CypherParser.ALLSHORTESTPATHS - 86 | 1 << _CypherParser.OR - 86 | 1 << _CypherParser.XOR - 86 | 1 << _CypherParser.AND - 86 | 1 << _CypherParser.NOT - 86 | 1 << _CypherParser.STARTS - 86 | 1 << _CypherParser.ENDS - 86 | 1 << _CypherParser.CONTAINS - 86 | 1 << _CypherParser.NULL - 86 | 1 << _CypherParser.COUNT - 86 | 1 << _CypherParser.FILTER - 86 | 1 << _CypherParser.EXTRACT - 86)) !== 0 || (_la - 118 & ~31) == 0 && (1 << _la - 118 & (1 << _CypherParser.ANY - 118 | 1 << _CypherParser.NONE - 118 | 1 << _CypherParser.SINGLE - 118 | 1 << _CypherParser.TRUE - 118 | 1 << _CypherParser.FALSE - 118 | 1 << _CypherParser.REDUCE - 118 | 1 << _CypherParser.CASE - 118 | 1 << _CypherParser.ELSE - 118 | 1 << _CypherParser.END - 118 | 1 << _CypherParser.WHEN - 118 | 1 << _CypherParser.THEN - 118 | 1 << _CypherParser.CALL - 118 | 1 << _CypherParser.YIELD - 118 | 1 << _CypherParser.KEY - 118 | 1 << _CypherParser.CATALOG - 118 | 1 << _CypherParser.SHOW - 118 | 1 << _CypherParser.DEFAULT - 118 | 1 << _CypherParser.DBMS - 118 | 1 << _CypherParser.DATABASE - 118 | 1 << _CypherParser.DATABASES - 118 | 1 << _CypherParser.GRAPH - 118 | 1 << _CypherParser.GRAPHS - 118 | 1 << _CypherParser.REPLACE - 118 | 1 << _CypherParser.IF - 118 | 1 << _CypherParser.STOP - 118 | 1 << _CypherParser.ROLE - 118 | 1 << _CypherParser.ROLES - 118 | 1 << _CypherParser.USER - 118 | 1 << _CypherParser.USERS - 118 | 1 << _CypherParser.POPULATED - 118 | 1 << _CypherParser.PASSWORD - 118 | 1 << _CypherParser.CHANGE - 118)) !== 0 || (_la - 150 & ~31) == 0 && (1 << _la - 150 & (1 << _CypherParser.REQUIRED - 150 | 1 << _CypherParser.STATUS - 150 | 1 << _CypherParser.ACTIVE - 150 | 1 << _CypherParser.SUSPENDED - 150 | 1 << _CypherParser.ALTER - 150 | 1 << _CypherParser.CURRENT - 150 | 1 << _CypherParser.TO - 150 | 1 << _CypherParser.PRIVILEGES - 150 | 1 << _CypherParser.GRANT - 150 | 1 << _CypherParser.DENY - 150 | 1 << _CypherParser.REVOKE - 150 | 1 << _CypherParser.RELATIONSHIPS - 150 | 1 << _CypherParser.NODES - 150 | 1 << _CypherParser.ELEMENT - 150 | 1 << _CypherParser.ELEMENTS - 150 | 1 << _CypherParser.COPY - 150 | 1 << _CypherParser.OF - 150 | 1 << _CypherParser.TRAVERSE - 150 | 1 << _CypherParser.READ - 150 | 1 << _CypherParser.WRITE - 150 | 1 << _CypherParser.ACCESS - 150 | 1 << _CypherParser.INDEXES - 150 | 1 << _CypherParser.MANAGEMENT - 150 | 1 << _CypherParser.NEW - 150 | 1 << _CypherParser.LABEL - 150 | 1 << _CypherParser.LABELS - 150 | 1 << _CypherParser.NAME - 150 | 1 << _CypherParser.NAMES - 150 | 1 << _CypherParser.TYPE - 150 | 1 << _CypherParser.TYPES - 150 | 1 << _CypherParser.PROPERTY - 150 | 1 << _CypherParser.CONSTRAINTS - 150)) !== 0 || (_la - 182 & ~31) == 0 && (1 << _la - 182 & (1 << _CypherParser.ASSIGN - 182 | 1 << _CypherParser.BTREE - 182 | 1 << _CypherParser.EXIST - 182 | 1 << _CypherParser.FOR - 182 | 1 << _CypherParser.OPTIONS - 182 | 1 << _CypherParser.EXECUTE - 182 | 1 << _CypherParser.DEFINED - 182 | 1 << _CypherParser.FUNCTION - 182 | 1 << _CypherParser.FUNCTIONS - 182 | 1 << _CypherParser.BOOSTED - 182 | 1 << _CypherParser.PROCEDURE - 182 | 1 << _CypherParser.PROCEDURES - 182 | 1 << _CypherParser.ADMIN - 182 | 1 << _CypherParser.ADMINISTRATOR - 182 | 1 << _CypherParser.BRIEF - 182 | 1 << _CypherParser.VERBOSE - 182 | 1 << _CypherParser.OUTPUT - 182 | 1 << _CypherParser.HexLetter - 182)) !== 0 || _la === _CypherParser.UnescapedSymbolicName || _la === _CypherParser.EscapedSymbolicName) {
        this.state = 3282;
        this.literalEntry();
        this.state = 3284;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _CypherParser.SP) {
          this.state = 3283;
          this.match(_CypherParser.SP);
        }
        this.state = 3296;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === _CypherParser.T__14) {
          this.state = 3286;
          this.match(_CypherParser.T__14);
          this.state = 3288;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 3287;
            this.match(_CypherParser.SP);
          }
          this.state = 3290;
          this.literalEntry();
          this.state = 3292;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 3291;
            this.match(_CypherParser.SP);
          }
          this.state = 3298;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
      }
      this.state = 3301;
      this.match(_CypherParser.T__15);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  mapProjection() {
    let localctx = new MapProjectionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 442, _CypherParser.RULE_mapProjection);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3303;
      this.variable();
      this.state = 3305;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 3304;
        this.match(_CypherParser.SP);
      }
      this.state = 3307;
      this.match(_CypherParser.T__13);
      this.state = 3309;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 475, this._ctx);
      if (la_ === 1) {
        this.state = 3308;
        this.match(_CypherParser.SP);
      }
      this.state = 3312;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.T__6 || (_la - 54 & ~31) == 0 && (1 << _la - 54 & (1 << _CypherParser.CYPHER - 54 | 1 << _CypherParser.EXPLAIN - 54 | 1 << _CypherParser.PROFILE - 54 | 1 << _CypherParser.USING - 54 | 1 << _CypherParser.PERIODIC - 54 | 1 << _CypherParser.COMMIT - 54 | 1 << _CypherParser.UNION - 54 | 1 << _CypherParser.ALL - 54 | 1 << _CypherParser.CREATE - 54 | 1 << _CypherParser.DROP - 54 | 1 << _CypherParser.INDEX - 54 | 1 << _CypherParser.ON - 54 | 1 << _CypherParser.CONSTRAINT - 54 | 1 << _CypherParser.ASSERT - 54 | 1 << _CypherParser.IS - 54 | 1 << _CypherParser.UNIQUE - 54 | 1 << _CypherParser.EXISTS - 54 | 1 << _CypherParser.LOAD - 54 | 1 << _CypherParser.CSV - 54 | 1 << _CypherParser.WITH - 54 | 1 << _CypherParser.HEADERS - 54 | 1 << _CypherParser.FROM - 54 | 1 << _CypherParser.AS - 54 | 1 << _CypherParser.FIELDTERMINATOR - 54 | 1 << _CypherParser.OPTIONAL - 54 | 1 << _CypherParser.MATCH - 54 | 1 << _CypherParser.UNWIND - 54 | 1 << _CypherParser.MERGE - 54 | 1 << _CypherParser.SET - 54 | 1 << _CypherParser.DETACH - 54 | 1 << _CypherParser.DELETE - 54 | 1 << _CypherParser.REMOVE - 54)) !== 0 || (_la - 86 & ~31) == 0 && (1 << _la - 86 & (1 << _CypherParser.FOREACH - 86 | 1 << _CypherParser.IN - 86 | 1 << _CypherParser.DISTINCT - 86 | 1 << _CypherParser.RETURN - 86 | 1 << _CypherParser.ORDER - 86 | 1 << _CypherParser.BY - 86 | 1 << _CypherParser.L_SKIP - 86 | 1 << _CypherParser.LIMIT - 86 | 1 << _CypherParser.ASCENDING - 86 | 1 << _CypherParser.ASC - 86 | 1 << _CypherParser.DESCENDING - 86 | 1 << _CypherParser.DESC - 86 | 1 << _CypherParser.JOIN - 86 | 1 << _CypherParser.SCAN - 86 | 1 << _CypherParser.START - 86 | 1 << _CypherParser.NODE - 86 | 1 << _CypherParser.RELATIONSHIP - 86 | 1 << _CypherParser.REL - 86 | 1 << _CypherParser.WHERE - 86 | 1 << _CypherParser.SHORTESTPATH - 86 | 1 << _CypherParser.ALLSHORTESTPATHS - 86 | 1 << _CypherParser.OR - 86 | 1 << _CypherParser.XOR - 86 | 1 << _CypherParser.AND - 86 | 1 << _CypherParser.NOT - 86 | 1 << _CypherParser.STARTS - 86 | 1 << _CypherParser.ENDS - 86 | 1 << _CypherParser.CONTAINS - 86 | 1 << _CypherParser.NULL - 86 | 1 << _CypherParser.COUNT - 86 | 1 << _CypherParser.FILTER - 86 | 1 << _CypherParser.EXTRACT - 86)) !== 0 || (_la - 118 & ~31) == 0 && (1 << _la - 118 & (1 << _CypherParser.ANY - 118 | 1 << _CypherParser.NONE - 118 | 1 << _CypherParser.SINGLE - 118 | 1 << _CypherParser.TRUE - 118 | 1 << _CypherParser.FALSE - 118 | 1 << _CypherParser.REDUCE - 118 | 1 << _CypherParser.CASE - 118 | 1 << _CypherParser.ELSE - 118 | 1 << _CypherParser.END - 118 | 1 << _CypherParser.WHEN - 118 | 1 << _CypherParser.THEN - 118 | 1 << _CypherParser.CALL - 118 | 1 << _CypherParser.YIELD - 118 | 1 << _CypherParser.KEY - 118 | 1 << _CypherParser.CATALOG - 118 | 1 << _CypherParser.SHOW - 118 | 1 << _CypherParser.DEFAULT - 118 | 1 << _CypherParser.DBMS - 118 | 1 << _CypherParser.DATABASE - 118 | 1 << _CypherParser.DATABASES - 118 | 1 << _CypherParser.GRAPH - 118 | 1 << _CypherParser.GRAPHS - 118 | 1 << _CypherParser.REPLACE - 118 | 1 << _CypherParser.IF - 118 | 1 << _CypherParser.STOP - 118 | 1 << _CypherParser.ROLE - 118 | 1 << _CypherParser.ROLES - 118 | 1 << _CypherParser.USER - 118 | 1 << _CypherParser.USERS - 118 | 1 << _CypherParser.POPULATED - 118 | 1 << _CypherParser.PASSWORD - 118 | 1 << _CypherParser.CHANGE - 118)) !== 0 || (_la - 150 & ~31) == 0 && (1 << _la - 150 & (1 << _CypherParser.REQUIRED - 150 | 1 << _CypherParser.STATUS - 150 | 1 << _CypherParser.ACTIVE - 150 | 1 << _CypherParser.SUSPENDED - 150 | 1 << _CypherParser.ALTER - 150 | 1 << _CypherParser.CURRENT - 150 | 1 << _CypherParser.TO - 150 | 1 << _CypherParser.PRIVILEGES - 150 | 1 << _CypherParser.GRANT - 150 | 1 << _CypherParser.DENY - 150 | 1 << _CypherParser.REVOKE - 150 | 1 << _CypherParser.RELATIONSHIPS - 150 | 1 << _CypherParser.NODES - 150 | 1 << _CypherParser.ELEMENT - 150 | 1 << _CypherParser.ELEMENTS - 150 | 1 << _CypherParser.COPY - 150 | 1 << _CypherParser.OF - 150 | 1 << _CypherParser.TRAVERSE - 150 | 1 << _CypherParser.READ - 150 | 1 << _CypherParser.WRITE - 150 | 1 << _CypherParser.ACCESS - 150 | 1 << _CypherParser.INDEXES - 150 | 1 << _CypherParser.MANAGEMENT - 150 | 1 << _CypherParser.NEW - 150 | 1 << _CypherParser.LABEL - 150 | 1 << _CypherParser.LABELS - 150 | 1 << _CypherParser.NAME - 150 | 1 << _CypherParser.NAMES - 150 | 1 << _CypherParser.TYPE - 150 | 1 << _CypherParser.TYPES - 150 | 1 << _CypherParser.PROPERTY - 150 | 1 << _CypherParser.CONSTRAINTS - 150)) !== 0 || (_la - 182 & ~31) == 0 && (1 << _la - 182 & (1 << _CypherParser.ASSIGN - 182 | 1 << _CypherParser.BTREE - 182 | 1 << _CypherParser.EXIST - 182 | 1 << _CypherParser.FOR - 182 | 1 << _CypherParser.OPTIONS - 182 | 1 << _CypherParser.EXECUTE - 182 | 1 << _CypherParser.DEFINED - 182 | 1 << _CypherParser.FUNCTION - 182 | 1 << _CypherParser.FUNCTIONS - 182 | 1 << _CypherParser.BOOSTED - 182 | 1 << _CypherParser.PROCEDURE - 182 | 1 << _CypherParser.PROCEDURES - 182 | 1 << _CypherParser.ADMIN - 182 | 1 << _CypherParser.ADMINISTRATOR - 182 | 1 << _CypherParser.BRIEF - 182 | 1 << _CypherParser.VERBOSE - 182 | 1 << _CypherParser.OUTPUT - 182 | 1 << _CypherParser.HexLetter - 182)) !== 0 || _la === _CypherParser.UnescapedSymbolicName || _la === _CypherParser.EscapedSymbolicName) {
        this.state = 3311;
        this.mapProjectionVariants();
      }
      this.state = 3324;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 479, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 3315;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 3314;
            this.match(_CypherParser.SP);
          }
          this.state = 3317;
          this.match(_CypherParser.T__14);
          this.state = 3319;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 3318;
            this.match(_CypherParser.SP);
          }
          this.state = 3321;
          this.mapProjectionVariants();
        }
        this.state = 3326;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 479, this._ctx);
      }
      this.state = 3328;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 3327;
        this.match(_CypherParser.SP);
      }
      this.state = 3330;
      this.match(_CypherParser.T__15);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  mapProjectionVariants() {
    let localctx = new MapProjectionVariantsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 444, _CypherParser.RULE_mapProjectionVariants);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3336;
      this._errHandler.sync(this);
      var la_ = this._interp.adaptivePredict(this._input, 481, this._ctx);
      switch (la_) {
        case 1:
          this.state = 3332;
          this.literalEntry();
          break;
        case 2:
          this.state = 3333;
          this.propertySelector();
          break;
        case 3:
          this.state = 3334;
          this.variableSelector();
          break;
        case 4:
          this.state = 3335;
          this.allPropertiesSelector();
          break;
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  literalEntry() {
    let localctx = new LiteralEntryContext(this, this._ctx, this.state);
    this.enterRule(localctx, 446, _CypherParser.RULE_literalEntry);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3338;
      this.propertyKeyName();
      this.state = 3340;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 3339;
        this.match(_CypherParser.SP);
      }
      this.state = 3342;
      this.match(_CypherParser.T__1);
      this.state = 3344;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 3343;
        this.match(_CypherParser.SP);
      }
      this.state = 3346;
      this.expression();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  propertySelector() {
    let localctx = new PropertySelectorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 448, _CypherParser.RULE_propertySelector);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3348;
      this.match(_CypherParser.T__6);
      this.state = 3349;
      this.variable();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  variableSelector() {
    let localctx = new VariableSelectorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 450, _CypherParser.RULE_variableSelector);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3351;
      this.variable();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  allPropertiesSelector() {
    let localctx = new AllPropertiesSelectorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 452, _CypherParser.RULE_allPropertiesSelector);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3353;
      this.match(_CypherParser.T__6);
      this.state = 3354;
      this.match(_CypherParser.T__18);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  parameter() {
    let localctx = new ParameterContext(this, this._ctx, this.state);
    this.enterRule(localctx, 454, _CypherParser.RULE_parameter);
    try {
      this.state = 3358;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.T__13:
          this.enterOuterAlt(localctx, 1);
          this.state = 3356;
          this.legacyParameter();
          break;
        case _CypherParser.T__33:
          this.enterOuterAlt(localctx, 2);
          this.state = 3357;
          this.newParameter();
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  legacyParameter() {
    let localctx = new LegacyParameterContext(this, this._ctx, this.state);
    this.enterRule(localctx, 456, _CypherParser.RULE_legacyParameter);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3360;
      this.match(_CypherParser.T__13);
      this.state = 3362;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 3361;
        this.match(_CypherParser.SP);
      }
      this.state = 3364;
      this.parameterName();
      this.state = 3366;
      this._errHandler.sync(this);
      _la = this._input.LA(1);
      if (_la === _CypherParser.SP) {
        this.state = 3365;
        this.match(_CypherParser.SP);
      }
      this.state = 3368;
      this.match(_CypherParser.T__15);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  newParameter() {
    let localctx = new NewParameterContext(this, this._ctx, this.state);
    this.enterRule(localctx, 458, _CypherParser.RULE_newParameter);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3370;
      this.match(_CypherParser.T__33);
      this.state = 3371;
      this.parameterName();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  parameterName() {
    let localctx = new ParameterNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 460, _CypherParser.RULE_parameterName);
    try {
      this.state = 3375;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.CYPHER:
        case _CypherParser.EXPLAIN:
        case _CypherParser.PROFILE:
        case _CypherParser.USING:
        case _CypherParser.PERIODIC:
        case _CypherParser.COMMIT:
        case _CypherParser.UNION:
        case _CypherParser.ALL:
        case _CypherParser.CREATE:
        case _CypherParser.DROP:
        case _CypherParser.INDEX:
        case _CypherParser.ON:
        case _CypherParser.CONSTRAINT:
        case _CypherParser.ASSERT:
        case _CypherParser.IS:
        case _CypherParser.UNIQUE:
        case _CypherParser.EXISTS:
        case _CypherParser.LOAD:
        case _CypherParser.CSV:
        case _CypherParser.WITH:
        case _CypherParser.HEADERS:
        case _CypherParser.FROM:
        case _CypherParser.AS:
        case _CypherParser.FIELDTERMINATOR:
        case _CypherParser.OPTIONAL:
        case _CypherParser.MATCH:
        case _CypherParser.UNWIND:
        case _CypherParser.MERGE:
        case _CypherParser.SET:
        case _CypherParser.DETACH:
        case _CypherParser.DELETE:
        case _CypherParser.REMOVE:
        case _CypherParser.FOREACH:
        case _CypherParser.IN:
        case _CypherParser.DISTINCT:
        case _CypherParser.RETURN:
        case _CypherParser.ORDER:
        case _CypherParser.BY:
        case _CypherParser.L_SKIP:
        case _CypherParser.LIMIT:
        case _CypherParser.ASCENDING:
        case _CypherParser.ASC:
        case _CypherParser.DESCENDING:
        case _CypherParser.DESC:
        case _CypherParser.JOIN:
        case _CypherParser.SCAN:
        case _CypherParser.START:
        case _CypherParser.NODE:
        case _CypherParser.RELATIONSHIP:
        case _CypherParser.REL:
        case _CypherParser.WHERE:
        case _CypherParser.SHORTESTPATH:
        case _CypherParser.ALLSHORTESTPATHS:
        case _CypherParser.OR:
        case _CypherParser.XOR:
        case _CypherParser.AND:
        case _CypherParser.NOT:
        case _CypherParser.STARTS:
        case _CypherParser.ENDS:
        case _CypherParser.CONTAINS:
        case _CypherParser.NULL:
        case _CypherParser.COUNT:
        case _CypherParser.FILTER:
        case _CypherParser.EXTRACT:
        case _CypherParser.ANY:
        case _CypherParser.NONE:
        case _CypherParser.SINGLE:
        case _CypherParser.TRUE:
        case _CypherParser.FALSE:
        case _CypherParser.REDUCE:
        case _CypherParser.CASE:
        case _CypherParser.ELSE:
        case _CypherParser.END:
        case _CypherParser.WHEN:
        case _CypherParser.THEN:
        case _CypherParser.CALL:
        case _CypherParser.YIELD:
        case _CypherParser.KEY:
        case _CypherParser.CATALOG:
        case _CypherParser.SHOW:
        case _CypherParser.DEFAULT:
        case _CypherParser.DBMS:
        case _CypherParser.DATABASE:
        case _CypherParser.DATABASES:
        case _CypherParser.GRAPH:
        case _CypherParser.GRAPHS:
        case _CypherParser.REPLACE:
        case _CypherParser.IF:
        case _CypherParser.STOP:
        case _CypherParser.ROLE:
        case _CypherParser.ROLES:
        case _CypherParser.USER:
        case _CypherParser.USERS:
        case _CypherParser.POPULATED:
        case _CypherParser.PASSWORD:
        case _CypherParser.CHANGE:
        case _CypherParser.REQUIRED:
        case _CypherParser.STATUS:
        case _CypherParser.ACTIVE:
        case _CypherParser.SUSPENDED:
        case _CypherParser.ALTER:
        case _CypherParser.CURRENT:
        case _CypherParser.TO:
        case _CypherParser.PRIVILEGES:
        case _CypherParser.GRANT:
        case _CypherParser.DENY:
        case _CypherParser.REVOKE:
        case _CypherParser.RELATIONSHIPS:
        case _CypherParser.NODES:
        case _CypherParser.ELEMENT:
        case _CypherParser.ELEMENTS:
        case _CypherParser.COPY:
        case _CypherParser.OF:
        case _CypherParser.TRAVERSE:
        case _CypherParser.READ:
        case _CypherParser.WRITE:
        case _CypherParser.ACCESS:
        case _CypherParser.INDEXES:
        case _CypherParser.MANAGEMENT:
        case _CypherParser.NEW:
        case _CypherParser.LABEL:
        case _CypherParser.LABELS:
        case _CypherParser.NAME:
        case _CypherParser.NAMES:
        case _CypherParser.TYPE:
        case _CypherParser.TYPES:
        case _CypherParser.PROPERTY:
        case _CypherParser.CONSTRAINTS:
        case _CypherParser.ASSIGN:
        case _CypherParser.BTREE:
        case _CypherParser.EXIST:
        case _CypherParser.FOR:
        case _CypherParser.OPTIONS:
        case _CypherParser.EXECUTE:
        case _CypherParser.DEFINED:
        case _CypherParser.FUNCTION:
        case _CypherParser.FUNCTIONS:
        case _CypherParser.BOOSTED:
        case _CypherParser.PROCEDURE:
        case _CypherParser.PROCEDURES:
        case _CypherParser.ADMIN:
        case _CypherParser.ADMINISTRATOR:
        case _CypherParser.BRIEF:
        case _CypherParser.VERBOSE:
        case _CypherParser.OUTPUT:
        case _CypherParser.HexLetter:
        case _CypherParser.UnescapedSymbolicName:
        case _CypherParser.EscapedSymbolicName:
          this.enterOuterAlt(localctx, 1);
          this.state = 3373;
          this.symbolicName();
          break;
        case _CypherParser.DecimalInteger:
          this.enterOuterAlt(localctx, 2);
          this.state = 3374;
          this.match(_CypherParser.DecimalInteger);
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  propertyExpressions() {
    let localctx = new PropertyExpressionsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 462, _CypherParser.RULE_propertyExpressions);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3377;
      this.propertyExpression();
      this.state = 3388;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 490, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 3379;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 3378;
            this.match(_CypherParser.SP);
          }
          this.state = 3381;
          this.match(_CypherParser.T__14);
          this.state = 3383;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 3382;
            this.match(_CypherParser.SP);
          }
          this.state = 3385;
          this.propertyExpression();
        }
        this.state = 3390;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 490, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  propertyExpression() {
    let localctx = new PropertyExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 464, _CypherParser.RULE_propertyExpression);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3391;
      this.atom();
      this.state = 3396;
      this._errHandler.sync(this);
      var _alt = 1;
      do {
        switch (_alt) {
          case 1:
            this.state = 3393;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _CypherParser.SP) {
              this.state = 3392;
              this.match(_CypherParser.SP);
            }
            this.state = 3395;
            this.propertyLookup();
            break;
          default:
            throw new es_default.error.NoViableAltException(this);
        }
        this.state = 3398;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 492, this._ctx);
      } while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER);
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  propertyKeys() {
    let localctx = new PropertyKeysContext(this, this._ctx, this.state);
    this.enterRule(localctx, 466, _CypherParser.RULE_propertyKeys);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3400;
      this.propertyKeyName();
      this.state = 3411;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 495, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 3402;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 3401;
            this.match(_CypherParser.SP);
          }
          this.state = 3404;
          this.match(_CypherParser.T__14);
          this.state = 3406;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          if (_la === _CypherParser.SP) {
            this.state = 3405;
            this.match(_CypherParser.SP);
          }
          this.state = 3408;
          this.propertyKeyName();
        }
        this.state = 3413;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 495, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  propertyKeyName() {
    let localctx = new PropertyKeyNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 468, _CypherParser.RULE_propertyKeyName);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3414;
      this.symbolicName();
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  integerLiteral() {
    let localctx = new IntegerLiteralContext(this, this._ctx, this.state);
    this.enterRule(localctx, 470, _CypherParser.RULE_integerLiteral);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3416;
      _la = this._input.LA(1);
      if (!((_la - 202 & ~31) == 0 && (1 << _la - 202 & (1 << _CypherParser.HexInteger - 202 | 1 << _CypherParser.DecimalInteger - 202 | 1 << _CypherParser.OctalInteger - 202)) !== 0)) {
        this._errHandler.recoverInline(this);
      } else {
        this._errHandler.reportMatch(this);
        this.consume();
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  doubleLiteral() {
    let localctx = new DoubleLiteralContext(this, this._ctx, this.state);
    this.enterRule(localctx, 472, _CypherParser.RULE_doubleLiteral);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3418;
      _la = this._input.LA(1);
      if (!(_la === _CypherParser.ExponentDecimalReal || _la === _CypherParser.RegularDecimalReal)) {
        this._errHandler.recoverInline(this);
      } else {
        this._errHandler.reportMatch(this);
        this.consume();
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  namespace() {
    let localctx = new NamespaceContext(this, this._ctx, this.state);
    this.enterRule(localctx, 474, _CypherParser.RULE_namespace);
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3425;
      this._errHandler.sync(this);
      var _alt = this._interp.adaptivePredict(this._input, 496, this._ctx);
      while (_alt != 2 && _alt != es_default.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 3420;
          this.symbolicName();
          this.state = 3421;
          this.match(_CypherParser.T__6);
        }
        this.state = 3427;
        this._errHandler.sync(this);
        _alt = this._interp.adaptivePredict(this._input, 496, this._ctx);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  leftArrowHead() {
    let localctx = new LeftArrowHeadContext(this, this._ctx, this.state);
    this.enterRule(localctx, 476, _CypherParser.RULE_leftArrowHead);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3428;
      _la = this._input.LA(1);
      if (!((_la - 30 & ~31) == 0 && (1 << _la - 30 & (1 << _CypherParser.T__29 - 30 | 1 << _CypherParser.T__34 - 30 | 1 << _CypherParser.T__35 - 30 | 1 << _CypherParser.T__36 - 30 | 1 << _CypherParser.T__37 - 30)) !== 0)) {
        this._errHandler.recoverInline(this);
      } else {
        this._errHandler.reportMatch(this);
        this.consume();
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  rightArrowHead() {
    let localctx = new RightArrowHeadContext(this, this._ctx, this.state);
    this.enterRule(localctx, 478, _CypherParser.RULE_rightArrowHead);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3430;
      _la = this._input.LA(1);
      if (!((_la - 31 & ~31) == 0 && (1 << _la - 31 & (1 << _CypherParser.T__30 - 31 | 1 << _CypherParser.T__38 - 31 | 1 << _CypherParser.T__39 - 31 | 1 << _CypherParser.T__40 - 31 | 1 << _CypherParser.T__41 - 31)) !== 0)) {
        this._errHandler.recoverInline(this);
      } else {
        this._errHandler.reportMatch(this);
        this.consume();
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  dash() {
    let localctx = new DashContext(this, this._ctx, this.state);
    this.enterRule(localctx, 480, _CypherParser.RULE_dash);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3432;
      _la = this._input.LA(1);
      if (!(_la === _CypherParser.T__2 || (_la - 43 & ~31) == 0 && (1 << _la - 43 & (1 << _CypherParser.T__42 - 43 | 1 << _CypherParser.T__43 - 43 | 1 << _CypherParser.T__44 - 43 | 1 << _CypherParser.T__45 - 43 | 1 << _CypherParser.T__46 - 43 | 1 << _CypherParser.T__47 - 43 | 1 << _CypherParser.T__48 - 43 | 1 << _CypherParser.T__49 - 43 | 1 << _CypherParser.T__50 - 43 | 1 << _CypherParser.T__51 - 43 | 1 << _CypherParser.T__52 - 43)) !== 0)) {
        this._errHandler.recoverInline(this);
      } else {
        this._errHandler.reportMatch(this);
        this.consume();
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  symbolicName() {
    let localctx = new SymbolicNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 482, _CypherParser.RULE_symbolicName);
    try {
      this.state = 3438;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _CypherParser.CYPHER:
        case _CypherParser.EXPLAIN:
        case _CypherParser.PROFILE:
        case _CypherParser.USING:
        case _CypherParser.PERIODIC:
        case _CypherParser.COMMIT:
        case _CypherParser.UNION:
        case _CypherParser.ALL:
        case _CypherParser.CREATE:
        case _CypherParser.DROP:
        case _CypherParser.INDEX:
        case _CypherParser.ON:
        case _CypherParser.CONSTRAINT:
        case _CypherParser.ASSERT:
        case _CypherParser.IS:
        case _CypherParser.UNIQUE:
        case _CypherParser.EXISTS:
        case _CypherParser.LOAD:
        case _CypherParser.CSV:
        case _CypherParser.WITH:
        case _CypherParser.HEADERS:
        case _CypherParser.FROM:
        case _CypherParser.AS:
        case _CypherParser.FIELDTERMINATOR:
        case _CypherParser.OPTIONAL:
        case _CypherParser.MATCH:
        case _CypherParser.UNWIND:
        case _CypherParser.MERGE:
        case _CypherParser.SET:
        case _CypherParser.DETACH:
        case _CypherParser.DELETE:
        case _CypherParser.REMOVE:
        case _CypherParser.FOREACH:
        case _CypherParser.IN:
        case _CypherParser.DISTINCT:
        case _CypherParser.RETURN:
        case _CypherParser.ORDER:
        case _CypherParser.BY:
        case _CypherParser.L_SKIP:
        case _CypherParser.LIMIT:
        case _CypherParser.ASCENDING:
        case _CypherParser.ASC:
        case _CypherParser.DESCENDING:
        case _CypherParser.DESC:
        case _CypherParser.JOIN:
        case _CypherParser.SCAN:
        case _CypherParser.START:
        case _CypherParser.NODE:
        case _CypherParser.RELATIONSHIP:
        case _CypherParser.REL:
        case _CypherParser.WHERE:
        case _CypherParser.SHORTESTPATH:
        case _CypherParser.ALLSHORTESTPATHS:
        case _CypherParser.OR:
        case _CypherParser.XOR:
        case _CypherParser.AND:
        case _CypherParser.NOT:
        case _CypherParser.STARTS:
        case _CypherParser.ENDS:
        case _CypherParser.CONTAINS:
        case _CypherParser.NULL:
        case _CypherParser.COUNT:
        case _CypherParser.FILTER:
        case _CypherParser.EXTRACT:
        case _CypherParser.ANY:
        case _CypherParser.NONE:
        case _CypherParser.SINGLE:
        case _CypherParser.TRUE:
        case _CypherParser.FALSE:
        case _CypherParser.REDUCE:
        case _CypherParser.CASE:
        case _CypherParser.ELSE:
        case _CypherParser.END:
        case _CypherParser.WHEN:
        case _CypherParser.THEN:
        case _CypherParser.CALL:
        case _CypherParser.YIELD:
        case _CypherParser.KEY:
        case _CypherParser.CATALOG:
        case _CypherParser.SHOW:
        case _CypherParser.DEFAULT:
        case _CypherParser.DBMS:
        case _CypherParser.DATABASE:
        case _CypherParser.DATABASES:
        case _CypherParser.GRAPH:
        case _CypherParser.GRAPHS:
        case _CypherParser.REPLACE:
        case _CypherParser.IF:
        case _CypherParser.STOP:
        case _CypherParser.ROLE:
        case _CypherParser.ROLES:
        case _CypherParser.USER:
        case _CypherParser.USERS:
        case _CypherParser.POPULATED:
        case _CypherParser.PASSWORD:
        case _CypherParser.CHANGE:
        case _CypherParser.REQUIRED:
        case _CypherParser.STATUS:
        case _CypherParser.ACTIVE:
        case _CypherParser.SUSPENDED:
        case _CypherParser.ALTER:
        case _CypherParser.CURRENT:
        case _CypherParser.TO:
        case _CypherParser.PRIVILEGES:
        case _CypherParser.GRANT:
        case _CypherParser.DENY:
        case _CypherParser.REVOKE:
        case _CypherParser.RELATIONSHIPS:
        case _CypherParser.NODES:
        case _CypherParser.ELEMENT:
        case _CypherParser.ELEMENTS:
        case _CypherParser.COPY:
        case _CypherParser.OF:
        case _CypherParser.TRAVERSE:
        case _CypherParser.READ:
        case _CypherParser.WRITE:
        case _CypherParser.ACCESS:
        case _CypherParser.INDEXES:
        case _CypherParser.MANAGEMENT:
        case _CypherParser.NEW:
        case _CypherParser.LABEL:
        case _CypherParser.LABELS:
        case _CypherParser.NAME:
        case _CypherParser.NAMES:
        case _CypherParser.TYPE:
        case _CypherParser.TYPES:
        case _CypherParser.PROPERTY:
        case _CypherParser.CONSTRAINTS:
        case _CypherParser.ASSIGN:
        case _CypherParser.BTREE:
        case _CypherParser.EXIST:
        case _CypherParser.FOR:
        case _CypherParser.OPTIONS:
        case _CypherParser.EXECUTE:
        case _CypherParser.DEFINED:
        case _CypherParser.FUNCTION:
        case _CypherParser.FUNCTIONS:
        case _CypherParser.BOOSTED:
        case _CypherParser.PROCEDURE:
        case _CypherParser.PROCEDURES:
        case _CypherParser.ADMIN:
        case _CypherParser.ADMINISTRATOR:
        case _CypherParser.BRIEF:
        case _CypherParser.VERBOSE:
        case _CypherParser.OUTPUT:
          this.enterOuterAlt(localctx, 1);
          this.state = 3434;
          this.keyword();
          break;
        case _CypherParser.UnescapedSymbolicName:
          this.enterOuterAlt(localctx, 2);
          this.state = 3435;
          this.match(_CypherParser.UnescapedSymbolicName);
          break;
        case _CypherParser.EscapedSymbolicName:
          this.enterOuterAlt(localctx, 3);
          this.state = 3436;
          this.match(_CypherParser.EscapedSymbolicName);
          break;
        case _CypherParser.HexLetter:
          this.enterOuterAlt(localctx, 4);
          this.state = 3437;
          this.match(_CypherParser.HexLetter);
          break;
        default:
          throw new es_default.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
  keyword() {
    let localctx = new KeywordContext(this, this._ctx, this.state);
    this.enterRule(localctx, 484, _CypherParser.RULE_keyword);
    var _la = 0;
    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 3440;
      _la = this._input.LA(1);
      if (!((_la - 54 & ~31) == 0 && (1 << _la - 54 & (1 << _CypherParser.CYPHER - 54 | 1 << _CypherParser.EXPLAIN - 54 | 1 << _CypherParser.PROFILE - 54 | 1 << _CypherParser.USING - 54 | 1 << _CypherParser.PERIODIC - 54 | 1 << _CypherParser.COMMIT - 54 | 1 << _CypherParser.UNION - 54 | 1 << _CypherParser.ALL - 54 | 1 << _CypherParser.CREATE - 54 | 1 << _CypherParser.DROP - 54 | 1 << _CypherParser.INDEX - 54 | 1 << _CypherParser.ON - 54 | 1 << _CypherParser.CONSTRAINT - 54 | 1 << _CypherParser.ASSERT - 54 | 1 << _CypherParser.IS - 54 | 1 << _CypherParser.UNIQUE - 54 | 1 << _CypherParser.EXISTS - 54 | 1 << _CypherParser.LOAD - 54 | 1 << _CypherParser.CSV - 54 | 1 << _CypherParser.WITH - 54 | 1 << _CypherParser.HEADERS - 54 | 1 << _CypherParser.FROM - 54 | 1 << _CypherParser.AS - 54 | 1 << _CypherParser.FIELDTERMINATOR - 54 | 1 << _CypherParser.OPTIONAL - 54 | 1 << _CypherParser.MATCH - 54 | 1 << _CypherParser.UNWIND - 54 | 1 << _CypherParser.MERGE - 54 | 1 << _CypherParser.SET - 54 | 1 << _CypherParser.DETACH - 54 | 1 << _CypherParser.DELETE - 54 | 1 << _CypherParser.REMOVE - 54)) !== 0 || (_la - 86 & ~31) == 0 && (1 << _la - 86 & (1 << _CypherParser.FOREACH - 86 | 1 << _CypherParser.IN - 86 | 1 << _CypherParser.DISTINCT - 86 | 1 << _CypherParser.RETURN - 86 | 1 << _CypherParser.ORDER - 86 | 1 << _CypherParser.BY - 86 | 1 << _CypherParser.L_SKIP - 86 | 1 << _CypherParser.LIMIT - 86 | 1 << _CypherParser.ASCENDING - 86 | 1 << _CypherParser.ASC - 86 | 1 << _CypherParser.DESCENDING - 86 | 1 << _CypherParser.DESC - 86 | 1 << _CypherParser.JOIN - 86 | 1 << _CypherParser.SCAN - 86 | 1 << _CypherParser.START - 86 | 1 << _CypherParser.NODE - 86 | 1 << _CypherParser.RELATIONSHIP - 86 | 1 << _CypherParser.REL - 86 | 1 << _CypherParser.WHERE - 86 | 1 << _CypherParser.SHORTESTPATH - 86 | 1 << _CypherParser.ALLSHORTESTPATHS - 86 | 1 << _CypherParser.OR - 86 | 1 << _CypherParser.XOR - 86 | 1 << _CypherParser.AND - 86 | 1 << _CypherParser.NOT - 86 | 1 << _CypherParser.STARTS - 86 | 1 << _CypherParser.ENDS - 86 | 1 << _CypherParser.CONTAINS - 86 | 1 << _CypherParser.NULL - 86 | 1 << _CypherParser.COUNT - 86 | 1 << _CypherParser.FILTER - 86 | 1 << _CypherParser.EXTRACT - 86)) !== 0 || (_la - 118 & ~31) == 0 && (1 << _la - 118 & (1 << _CypherParser.ANY - 118 | 1 << _CypherParser.NONE - 118 | 1 << _CypherParser.SINGLE - 118 | 1 << _CypherParser.TRUE - 118 | 1 << _CypherParser.FALSE - 118 | 1 << _CypherParser.REDUCE - 118 | 1 << _CypherParser.CASE - 118 | 1 << _CypherParser.ELSE - 118 | 1 << _CypherParser.END - 118 | 1 << _CypherParser.WHEN - 118 | 1 << _CypherParser.THEN - 118 | 1 << _CypherParser.CALL - 118 | 1 << _CypherParser.YIELD - 118 | 1 << _CypherParser.KEY - 118 | 1 << _CypherParser.CATALOG - 118 | 1 << _CypherParser.SHOW - 118 | 1 << _CypherParser.DEFAULT - 118 | 1 << _CypherParser.DBMS - 118 | 1 << _CypherParser.DATABASE - 118 | 1 << _CypherParser.DATABASES - 118 | 1 << _CypherParser.GRAPH - 118 | 1 << _CypherParser.GRAPHS - 118 | 1 << _CypherParser.REPLACE - 118 | 1 << _CypherParser.IF - 118 | 1 << _CypherParser.STOP - 118 | 1 << _CypherParser.ROLE - 118 | 1 << _CypherParser.ROLES - 118 | 1 << _CypherParser.USER - 118 | 1 << _CypherParser.USERS - 118 | 1 << _CypherParser.POPULATED - 118 | 1 << _CypherParser.PASSWORD - 118 | 1 << _CypherParser.CHANGE - 118)) !== 0 || (_la - 150 & ~31) == 0 && (1 << _la - 150 & (1 << _CypherParser.REQUIRED - 150 | 1 << _CypherParser.STATUS - 150 | 1 << _CypherParser.ACTIVE - 150 | 1 << _CypherParser.SUSPENDED - 150 | 1 << _CypherParser.ALTER - 150 | 1 << _CypherParser.CURRENT - 150 | 1 << _CypherParser.TO - 150 | 1 << _CypherParser.PRIVILEGES - 150 | 1 << _CypherParser.GRANT - 150 | 1 << _CypherParser.DENY - 150 | 1 << _CypherParser.REVOKE - 150 | 1 << _CypherParser.RELATIONSHIPS - 150 | 1 << _CypherParser.NODES - 150 | 1 << _CypherParser.ELEMENT - 150 | 1 << _CypherParser.ELEMENTS - 150 | 1 << _CypherParser.COPY - 150 | 1 << _CypherParser.OF - 150 | 1 << _CypherParser.TRAVERSE - 150 | 1 << _CypherParser.READ - 150 | 1 << _CypherParser.WRITE - 150 | 1 << _CypherParser.ACCESS - 150 | 1 << _CypherParser.INDEXES - 150 | 1 << _CypherParser.MANAGEMENT - 150 | 1 << _CypherParser.NEW - 150 | 1 << _CypherParser.LABEL - 150 | 1 << _CypherParser.LABELS - 150 | 1 << _CypherParser.NAME - 150 | 1 << _CypherParser.NAMES - 150 | 1 << _CypherParser.TYPE - 150 | 1 << _CypherParser.TYPES - 150 | 1 << _CypherParser.PROPERTY - 150 | 1 << _CypherParser.CONSTRAINTS - 150)) !== 0 || (_la - 182 & ~31) == 0 && (1 << _la - 182 & (1 << _CypherParser.ASSIGN - 182 | 1 << _CypherParser.BTREE - 182 | 1 << _CypherParser.EXIST - 182 | 1 << _CypherParser.FOR - 182 | 1 << _CypherParser.OPTIONS - 182 | 1 << _CypherParser.EXECUTE - 182 | 1 << _CypherParser.DEFINED - 182 | 1 << _CypherParser.FUNCTION - 182 | 1 << _CypherParser.FUNCTIONS - 182 | 1 << _CypherParser.BOOSTED - 182 | 1 << _CypherParser.PROCEDURE - 182 | 1 << _CypherParser.PROCEDURES - 182 | 1 << _CypherParser.ADMIN - 182 | 1 << _CypherParser.ADMINISTRATOR - 182 | 1 << _CypherParser.BRIEF - 182 | 1 << _CypherParser.VERBOSE - 182 | 1 << _CypherParser.OUTPUT - 182)) !== 0)) {
        this._errHandler.recoverInline(this);
      } else {
        this._errHandler.reportMatch(this);
        this.consume();
      }
    } catch (re) {
      if (re instanceof es_default.error.RecognitionException) {
        localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return localctx;
  }
};
_defineProperty(CypherParser, "grammarFileName", "Cypher.g4");
_defineProperty(CypherParser, "literalNames", [null, "';'", "':'", "'-'", "'=>'", "'://'", "'/'", "'.'", "'@'", "'#'", "'?'", "'&'", "'='", "'+'", "'{'", "','", "'}'", "'['", "']'", "'*'", "'('", "')'", "'+='", "'|'", "'..'", "'%'", "'^'", "'=~'", "'<>'", "'!='", "'<'", "'>'", "'<='", "'>='", "'$'", "'\\u27E8'", "'\\u3008'", "'\\uFE64'", "'\\uFF1C'", "'\\u27E9'", "'\\u3009'", "'\\uFE65'", "'\\uFF1E'", "'\\u00AD'", "'\\u2010'", "'\\u2011'", "'\\u2012'", "'\\u2013'", "'\\u2014'", "'\\u2015'", "'\\u2212'", "'\\uFE58'", "'\\uFE63'", "'\\uFF0D'", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "'0'"]);
_defineProperty(CypherParser, "symbolicNames", [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "CYPHER", "EXPLAIN", "PROFILE", "USING", "PERIODIC", "COMMIT", "UNION", "ALL", "CREATE", "DROP", "INDEX", "ON", "CONSTRAINT", "ASSERT", "IS", "UNIQUE", "EXISTS", "LOAD", "CSV", "WITH", "HEADERS", "FROM", "AS", "FIELDTERMINATOR", "OPTIONAL", "MATCH", "UNWIND", "MERGE", "SET", "DETACH", "DELETE", "REMOVE", "FOREACH", "IN", "DISTINCT", "RETURN", "ORDER", "BY", "L_SKIP", "LIMIT", "ASCENDING", "ASC", "DESCENDING", "DESC", "JOIN", "SCAN", "START", "NODE", "RELATIONSHIP", "REL", "WHERE", "SHORTESTPATH", "ALLSHORTESTPATHS", "OR", "XOR", "AND", "NOT", "STARTS", "ENDS", "CONTAINS", "NULL", "COUNT", "FILTER", "EXTRACT", "ANY", "NONE", "SINGLE", "TRUE", "FALSE", "REDUCE", "CASE", "ELSE", "END", "WHEN", "THEN", "CALL", "YIELD", "KEY", "CATALOG", "SHOW", "DEFAULT", "DBMS", "DATABASE", "DATABASES", "GRAPH", "GRAPHS", "REPLACE", "IF", "STOP", "ROLE", "ROLES", "USER", "USERS", "POPULATED", "PASSWORD", "CHANGE", "REQUIRED", "STATUS", "ACTIVE", "SUSPENDED", "ALTER", "CURRENT", "TO", "PRIVILEGES", "GRANT", "DENY", "REVOKE", "RELATIONSHIPS", "NODES", "ELEMENT", "ELEMENTS", "COPY", "OF", "TRAVERSE", "READ", "WRITE", "ACCESS", "INDEXES", "MANAGEMENT", "NEW", "LABEL", "LABELS", "NAME", "NAMES", "TYPE", "TYPES", "PROPERTY", "CONSTRAINTS", "ASSIGN", "BTREE", "EXIST", "FOR", "OPTIONS", "EXECUTE", "DEFINED", "FUNCTION", "FUNCTIONS", "BOOSTED", "PROCEDURE", "PROCEDURES", "ADMIN", "ADMINISTRATOR", "BRIEF", "VERBOSE", "OUTPUT", "StringLiteral", "UrlHex", "EscapedChar", "HexInteger", "DecimalInteger", "OctalInteger", "HexLetter", "HexDigit", "Digit", "NonZeroDigit", "NonZeroOctDigit", "OctDigit", "ZeroDigit", "ExponentDecimalReal", "RegularDecimalReal", "UnescapedSymbolicName", "IdentifierStart", "IdentifierPart", "EscapedSymbolicName", "SP", "WHITESPACE", "Comment", "ERROR_TOKEN"]);
_defineProperty(CypherParser, "ruleNames", ["cypher", "cypherPart", "cypherConsoleCommand", "cypherConsoleCommandName", "cypherConsoleCommandParameters", "cypherConsoleCommandParameter", "arrowExpression", "url", "uri", "scheme", "host", "hostname", "hostnumber", "port", "path", "user", "login", "password", "frag", "urlQuery", "search", "searchparameter", "string", "urlDigits", "json", "obj", "pair", "array", "value", "keyValueLiteral", "commandPath", "subCommand", "cypherQuery", "queryOptions", "anyCypherOption", "cypherOption", "versionNumber", "explain", "profile", "configurationOption", "statement", "query", "regularQuery", "bulkImportQuery", "singleQuery", "periodicCommitHint", "loadCSVQuery", "union", "clause", "command", "systemCommand", "multidatabaseCommand", "userCommand", "privilegeCommand", "showRoles", "createRole", "copyRole", "dropRole", "showUsers", "createUser", "dropUser", "alterUser", "showPrivileges", "grantPrivilege", "denyPrivilege", "revokePrivilege", "revokePart", "databaseScope", "graphScope", "roles", "grantableGraphPrivileges", "revokeableGraphPrivileges", "datasbasePrivilege", "dbmsPrivilege", "elementScope", "propertiesList", "propertyScope", "showDatabase", "createDatabase", "dropDatabase", "startDatabase", "stopDatabase", "ifNotExists", "ifExists", "orReplace", "setPassword", "passwordStatus", "setStatus", "userStatus", "createUniqueConstraint", "createNodeKeyConstraint", "createNodePropertyExistenceConstraint", "createRelationshipPropertyExistenceConstraint", "createIndex", "dropUniqueConstraint", "dropNodeKeyConstraint", "dropNodePropertyExistenceConstraint", "dropRelationshipPropertyExistenceConstraint", "dropIndex", "index", "uniqueConstraint", "nodeKeyConstraint", "nodePropertyExistenceConstraint", "relationshipPropertyExistenceConstraint", "relationshipPatternSyntax", "loadCSVClause", "matchClause", "unwindClause", "mergeClause", "mergeAction", "createClause", "createUniqueClause", "setClause", "setItem", "deleteClause", "removeClause", "removeItem", "foreachClause", "withClause", "returnClause", "returnBody", "func", "returnItems", "returnItem", "call", "procedureInvocation", "procedureInvocationBody", "procedureArguments", "procedureResults", "procedureResult", "aliasedProcedureResult", "simpleProcedureResult", "procedureOutput", "order", "skip", "limit", "sortItem", "hint", "startClause", "startPoint", "lookup", "nodeLookup", "relationshipLookup", "identifiedIndexLookup", "indexQuery", "idLookup", "literalIds", "where", "pattern", "patternPart", "anonymousPatternPart", "patternElement", "nodePattern", "patternElementChain", "relationshipPattern", "relationshipPatternStart", "relationshipPatternEnd", "relationshipDetail", "properties", "relType", "relationshipTypes", "relationshipType", "relationshipTypeOptionalColon", "nodeLabels", "nodeLabel", "rangeLiteral", "labelName", "relTypeName", "expression", "orExpression", "xorExpression", "andExpression", "notExpression", "comparisonExpression", "addOrSubtractExpression", "multiplyDivideModuloExpression", "powerOfExpression", "unaryAddOrSubtractExpression", "stringListNullOperatorExpression", "propertyOrLabelsExpression", "filterFunction", "filterFunctionName", "existsFunction", "existsFunctionName", "allFunction", "allFunctionName", "anyFunction", "anyFunctionName", "noneFunction", "noneFunctionName", "singleFunction", "singleFunctionName", "extractFunction", "extractFunctionName", "reduceFunction", "reduceFunctionName", "shortestPathPatternFunction", "shortestPathFunctionName", "allShortestPathFunctionName", "atom", "literal", "stringLiteral", "booleanLiteral", "listLiteral", "partialComparisonExpression", "parenthesizedExpression", "relationshipsPattern", "filterExpression", "idInColl", "functionInvocation", "functionInvocationBody", "functionName", "procedureName", "listComprehension", "patternComprehension", "propertyLookup", "caseExpression", "caseAlternatives", "variable", "numberLiteral", "mapLiteral", "mapProjection", "mapProjectionVariants", "literalEntry", "propertySelector", "variableSelector", "allPropertiesSelector", "parameter", "legacyParameter", "newParameter", "parameterName", "propertyExpressions", "propertyExpression", "propertyKeys", "propertyKeyName", "integerLiteral", "doubleLiteral", "namespace", "leftArrowHead", "rightArrowHead", "dash", "symbolicName", "keyword"]);
CypherParser.EOF = es_default.Token.EOF;
CypherParser.T__0 = 1;
CypherParser.T__1 = 2;
CypherParser.T__2 = 3;
CypherParser.T__3 = 4;
CypherParser.T__4 = 5;
CypherParser.T__5 = 6;
CypherParser.T__6 = 7;
CypherParser.T__7 = 8;
CypherParser.T__8 = 9;
CypherParser.T__9 = 10;
CypherParser.T__10 = 11;
CypherParser.T__11 = 12;
CypherParser.T__12 = 13;
CypherParser.T__13 = 14;
CypherParser.T__14 = 15;
CypherParser.T__15 = 16;
CypherParser.T__16 = 17;
CypherParser.T__17 = 18;
CypherParser.T__18 = 19;
CypherParser.T__19 = 20;
CypherParser.T__20 = 21;
CypherParser.T__21 = 22;
CypherParser.T__22 = 23;
CypherParser.T__23 = 24;
CypherParser.T__24 = 25;
CypherParser.T__25 = 26;
CypherParser.T__26 = 27;
CypherParser.T__27 = 28;
CypherParser.T__28 = 29;
CypherParser.T__29 = 30;
CypherParser.T__30 = 31;
CypherParser.T__31 = 32;
CypherParser.T__32 = 33;
CypherParser.T__33 = 34;
CypherParser.T__34 = 35;
CypherParser.T__35 = 36;
CypherParser.T__36 = 37;
CypherParser.T__37 = 38;
CypherParser.T__38 = 39;
CypherParser.T__39 = 40;
CypherParser.T__40 = 41;
CypherParser.T__41 = 42;
CypherParser.T__42 = 43;
CypherParser.T__43 = 44;
CypherParser.T__44 = 45;
CypherParser.T__45 = 46;
CypherParser.T__46 = 47;
CypherParser.T__47 = 48;
CypherParser.T__48 = 49;
CypherParser.T__49 = 50;
CypherParser.T__50 = 51;
CypherParser.T__51 = 52;
CypherParser.T__52 = 53;
CypherParser.CYPHER = 54;
CypherParser.EXPLAIN = 55;
CypherParser.PROFILE = 56;
CypherParser.USING = 57;
CypherParser.PERIODIC = 58;
CypherParser.COMMIT = 59;
CypherParser.UNION = 60;
CypherParser.ALL = 61;
CypherParser.CREATE = 62;
CypherParser.DROP = 63;
CypherParser.INDEX = 64;
CypherParser.ON = 65;
CypherParser.CONSTRAINT = 66;
CypherParser.ASSERT = 67;
CypherParser.IS = 68;
CypherParser.UNIQUE = 69;
CypherParser.EXISTS = 70;
CypherParser.LOAD = 71;
CypherParser.CSV = 72;
CypherParser.WITH = 73;
CypherParser.HEADERS = 74;
CypherParser.FROM = 75;
CypherParser.AS = 76;
CypherParser.FIELDTERMINATOR = 77;
CypherParser.OPTIONAL = 78;
CypherParser.MATCH = 79;
CypherParser.UNWIND = 80;
CypherParser.MERGE = 81;
CypherParser.SET = 82;
CypherParser.DETACH = 83;
CypherParser.DELETE = 84;
CypherParser.REMOVE = 85;
CypherParser.FOREACH = 86;
CypherParser.IN = 87;
CypherParser.DISTINCT = 88;
CypherParser.RETURN = 89;
CypherParser.ORDER = 90;
CypherParser.BY = 91;
CypherParser.L_SKIP = 92;
CypherParser.LIMIT = 93;
CypherParser.ASCENDING = 94;
CypherParser.ASC = 95;
CypherParser.DESCENDING = 96;
CypherParser.DESC = 97;
CypherParser.JOIN = 98;
CypherParser.SCAN = 99;
CypherParser.START = 100;
CypherParser.NODE = 101;
CypherParser.RELATIONSHIP = 102;
CypherParser.REL = 103;
CypherParser.WHERE = 104;
CypherParser.SHORTESTPATH = 105;
CypherParser.ALLSHORTESTPATHS = 106;
CypherParser.OR = 107;
CypherParser.XOR = 108;
CypherParser.AND = 109;
CypherParser.NOT = 110;
CypherParser.STARTS = 111;
CypherParser.ENDS = 112;
CypherParser.CONTAINS = 113;
CypherParser.NULL = 114;
CypherParser.COUNT = 115;
CypherParser.FILTER = 116;
CypherParser.EXTRACT = 117;
CypherParser.ANY = 118;
CypherParser.NONE = 119;
CypherParser.SINGLE = 120;
CypherParser.TRUE = 121;
CypherParser.FALSE = 122;
CypherParser.REDUCE = 123;
CypherParser.CASE = 124;
CypherParser.ELSE = 125;
CypherParser.END = 126;
CypherParser.WHEN = 127;
CypherParser.THEN = 128;
CypherParser.CALL = 129;
CypherParser.YIELD = 130;
CypherParser.KEY = 131;
CypherParser.CATALOG = 132;
CypherParser.SHOW = 133;
CypherParser.DEFAULT = 134;
CypherParser.DBMS = 135;
CypherParser.DATABASE = 136;
CypherParser.DATABASES = 137;
CypherParser.GRAPH = 138;
CypherParser.GRAPHS = 139;
CypherParser.REPLACE = 140;
CypherParser.IF = 141;
CypherParser.STOP = 142;
CypherParser.ROLE = 143;
CypherParser.ROLES = 144;
CypherParser.USER = 145;
CypherParser.USERS = 146;
CypherParser.POPULATED = 147;
CypherParser.PASSWORD = 148;
CypherParser.CHANGE = 149;
CypherParser.REQUIRED = 150;
CypherParser.STATUS = 151;
CypherParser.ACTIVE = 152;
CypherParser.SUSPENDED = 153;
CypherParser.ALTER = 154;
CypherParser.CURRENT = 155;
CypherParser.TO = 156;
CypherParser.PRIVILEGES = 157;
CypherParser.GRANT = 158;
CypherParser.DENY = 159;
CypherParser.REVOKE = 160;
CypherParser.RELATIONSHIPS = 161;
CypherParser.NODES = 162;
CypherParser.ELEMENT = 163;
CypherParser.ELEMENTS = 164;
CypherParser.COPY = 165;
CypherParser.OF = 166;
CypherParser.TRAVERSE = 167;
CypherParser.READ = 168;
CypherParser.WRITE = 169;
CypherParser.ACCESS = 170;
CypherParser.INDEXES = 171;
CypherParser.MANAGEMENT = 172;
CypherParser.NEW = 173;
CypherParser.LABEL = 174;
CypherParser.LABELS = 175;
CypherParser.NAME = 176;
CypherParser.NAMES = 177;
CypherParser.TYPE = 178;
CypherParser.TYPES = 179;
CypherParser.PROPERTY = 180;
CypherParser.CONSTRAINTS = 181;
CypherParser.ASSIGN = 182;
CypherParser.BTREE = 183;
CypherParser.EXIST = 184;
CypherParser.FOR = 185;
CypherParser.OPTIONS = 186;
CypherParser.EXECUTE = 187;
CypherParser.DEFINED = 188;
CypherParser.FUNCTION = 189;
CypherParser.FUNCTIONS = 190;
CypherParser.BOOSTED = 191;
CypherParser.PROCEDURE = 192;
CypherParser.PROCEDURES = 193;
CypherParser.ADMIN = 194;
CypherParser.ADMINISTRATOR = 195;
CypherParser.BRIEF = 196;
CypherParser.VERBOSE = 197;
CypherParser.OUTPUT = 198;
CypherParser.StringLiteral = 199;
CypherParser.UrlHex = 200;
CypherParser.EscapedChar = 201;
CypherParser.HexInteger = 202;
CypherParser.DecimalInteger = 203;
CypherParser.OctalInteger = 204;
CypherParser.HexLetter = 205;
CypherParser.HexDigit = 206;
CypherParser.Digit = 207;
CypherParser.NonZeroDigit = 208;
CypherParser.NonZeroOctDigit = 209;
CypherParser.OctDigit = 210;
CypherParser.ZeroDigit = 211;
CypherParser.ExponentDecimalReal = 212;
CypherParser.RegularDecimalReal = 213;
CypherParser.UnescapedSymbolicName = 214;
CypherParser.IdentifierStart = 215;
CypherParser.IdentifierPart = 216;
CypherParser.EscapedSymbolicName = 217;
CypherParser.SP = 218;
CypherParser.WHITESPACE = 219;
CypherParser.Comment = 220;
CypherParser.ERROR_TOKEN = 221;
CypherParser.RULE_cypher = 0;
CypherParser.RULE_cypherPart = 1;
CypherParser.RULE_cypherConsoleCommand = 2;
CypherParser.RULE_cypherConsoleCommandName = 3;
CypherParser.RULE_cypherConsoleCommandParameters = 4;
CypherParser.RULE_cypherConsoleCommandParameter = 5;
CypherParser.RULE_arrowExpression = 6;
CypherParser.RULE_url = 7;
CypherParser.RULE_uri = 8;
CypherParser.RULE_scheme = 9;
CypherParser.RULE_host = 10;
CypherParser.RULE_hostname = 11;
CypherParser.RULE_hostnumber = 12;
CypherParser.RULE_port = 13;
CypherParser.RULE_path = 14;
CypherParser.RULE_user = 15;
CypherParser.RULE_login = 16;
CypherParser.RULE_password = 17;
CypherParser.RULE_frag = 18;
CypherParser.RULE_urlQuery = 19;
CypherParser.RULE_search = 20;
CypherParser.RULE_searchparameter = 21;
CypherParser.RULE_string = 22;
CypherParser.RULE_urlDigits = 23;
CypherParser.RULE_json = 24;
CypherParser.RULE_obj = 25;
CypherParser.RULE_pair = 26;
CypherParser.RULE_array = 27;
CypherParser.RULE_value = 28;
CypherParser.RULE_keyValueLiteral = 29;
CypherParser.RULE_commandPath = 30;
CypherParser.RULE_subCommand = 31;
CypherParser.RULE_cypherQuery = 32;
CypherParser.RULE_queryOptions = 33;
CypherParser.RULE_anyCypherOption = 34;
CypherParser.RULE_cypherOption = 35;
CypherParser.RULE_versionNumber = 36;
CypherParser.RULE_explain = 37;
CypherParser.RULE_profile = 38;
CypherParser.RULE_configurationOption = 39;
CypherParser.RULE_statement = 40;
CypherParser.RULE_query = 41;
CypherParser.RULE_regularQuery = 42;
CypherParser.RULE_bulkImportQuery = 43;
CypherParser.RULE_singleQuery = 44;
CypherParser.RULE_periodicCommitHint = 45;
CypherParser.RULE_loadCSVQuery = 46;
CypherParser.RULE_union = 47;
CypherParser.RULE_clause = 48;
CypherParser.RULE_command = 49;
CypherParser.RULE_systemCommand = 50;
CypherParser.RULE_multidatabaseCommand = 51;
CypherParser.RULE_userCommand = 52;
CypherParser.RULE_privilegeCommand = 53;
CypherParser.RULE_showRoles = 54;
CypherParser.RULE_createRole = 55;
CypherParser.RULE_copyRole = 56;
CypherParser.RULE_dropRole = 57;
CypherParser.RULE_showUsers = 58;
CypherParser.RULE_createUser = 59;
CypherParser.RULE_dropUser = 60;
CypherParser.RULE_alterUser = 61;
CypherParser.RULE_showPrivileges = 62;
CypherParser.RULE_grantPrivilege = 63;
CypherParser.RULE_denyPrivilege = 64;
CypherParser.RULE_revokePrivilege = 65;
CypherParser.RULE_revokePart = 66;
CypherParser.RULE_databaseScope = 67;
CypherParser.RULE_graphScope = 68;
CypherParser.RULE_roles = 69;
CypherParser.RULE_grantableGraphPrivileges = 70;
CypherParser.RULE_revokeableGraphPrivileges = 71;
CypherParser.RULE_datasbasePrivilege = 72;
CypherParser.RULE_dbmsPrivilege = 73;
CypherParser.RULE_elementScope = 74;
CypherParser.RULE_propertiesList = 75;
CypherParser.RULE_propertyScope = 76;
CypherParser.RULE_showDatabase = 77;
CypherParser.RULE_createDatabase = 78;
CypherParser.RULE_dropDatabase = 79;
CypherParser.RULE_startDatabase = 80;
CypherParser.RULE_stopDatabase = 81;
CypherParser.RULE_ifNotExists = 82;
CypherParser.RULE_ifExists = 83;
CypherParser.RULE_orReplace = 84;
CypherParser.RULE_setPassword = 85;
CypherParser.RULE_passwordStatus = 86;
CypherParser.RULE_setStatus = 87;
CypherParser.RULE_userStatus = 88;
CypherParser.RULE_createUniqueConstraint = 89;
CypherParser.RULE_createNodeKeyConstraint = 90;
CypherParser.RULE_createNodePropertyExistenceConstraint = 91;
CypherParser.RULE_createRelationshipPropertyExistenceConstraint = 92;
CypherParser.RULE_createIndex = 93;
CypherParser.RULE_dropUniqueConstraint = 94;
CypherParser.RULE_dropNodeKeyConstraint = 95;
CypherParser.RULE_dropNodePropertyExistenceConstraint = 96;
CypherParser.RULE_dropRelationshipPropertyExistenceConstraint = 97;
CypherParser.RULE_dropIndex = 98;
CypherParser.RULE_index = 99;
CypherParser.RULE_uniqueConstraint = 100;
CypherParser.RULE_nodeKeyConstraint = 101;
CypherParser.RULE_nodePropertyExistenceConstraint = 102;
CypherParser.RULE_relationshipPropertyExistenceConstraint = 103;
CypherParser.RULE_relationshipPatternSyntax = 104;
CypherParser.RULE_loadCSVClause = 105;
CypherParser.RULE_matchClause = 106;
CypherParser.RULE_unwindClause = 107;
CypherParser.RULE_mergeClause = 108;
CypherParser.RULE_mergeAction = 109;
CypherParser.RULE_createClause = 110;
CypherParser.RULE_createUniqueClause = 111;
CypherParser.RULE_setClause = 112;
CypherParser.RULE_setItem = 113;
CypherParser.RULE_deleteClause = 114;
CypherParser.RULE_removeClause = 115;
CypherParser.RULE_removeItem = 116;
CypherParser.RULE_foreachClause = 117;
CypherParser.RULE_withClause = 118;
CypherParser.RULE_returnClause = 119;
CypherParser.RULE_returnBody = 120;
CypherParser.RULE_func = 121;
CypherParser.RULE_returnItems = 122;
CypherParser.RULE_returnItem = 123;
CypherParser.RULE_call = 124;
CypherParser.RULE_procedureInvocation = 125;
CypherParser.RULE_procedureInvocationBody = 126;
CypherParser.RULE_procedureArguments = 127;
CypherParser.RULE_procedureResults = 128;
CypherParser.RULE_procedureResult = 129;
CypherParser.RULE_aliasedProcedureResult = 130;
CypherParser.RULE_simpleProcedureResult = 131;
CypherParser.RULE_procedureOutput = 132;
CypherParser.RULE_order = 133;
CypherParser.RULE_skip = 134;
CypherParser.RULE_limit = 135;
CypherParser.RULE_sortItem = 136;
CypherParser.RULE_hint = 137;
CypherParser.RULE_startClause = 138;
CypherParser.RULE_startPoint = 139;
CypherParser.RULE_lookup = 140;
CypherParser.RULE_nodeLookup = 141;
CypherParser.RULE_relationshipLookup = 142;
CypherParser.RULE_identifiedIndexLookup = 143;
CypherParser.RULE_indexQuery = 144;
CypherParser.RULE_idLookup = 145;
CypherParser.RULE_literalIds = 146;
CypherParser.RULE_where = 147;
CypherParser.RULE_pattern = 148;
CypherParser.RULE_patternPart = 149;
CypherParser.RULE_anonymousPatternPart = 150;
CypherParser.RULE_patternElement = 151;
CypherParser.RULE_nodePattern = 152;
CypherParser.RULE_patternElementChain = 153;
CypherParser.RULE_relationshipPattern = 154;
CypherParser.RULE_relationshipPatternStart = 155;
CypherParser.RULE_relationshipPatternEnd = 156;
CypherParser.RULE_relationshipDetail = 157;
CypherParser.RULE_properties = 158;
CypherParser.RULE_relType = 159;
CypherParser.RULE_relationshipTypes = 160;
CypherParser.RULE_relationshipType = 161;
CypherParser.RULE_relationshipTypeOptionalColon = 162;
CypherParser.RULE_nodeLabels = 163;
CypherParser.RULE_nodeLabel = 164;
CypherParser.RULE_rangeLiteral = 165;
CypherParser.RULE_labelName = 166;
CypherParser.RULE_relTypeName = 167;
CypherParser.RULE_expression = 168;
CypherParser.RULE_orExpression = 169;
CypherParser.RULE_xorExpression = 170;
CypherParser.RULE_andExpression = 171;
CypherParser.RULE_notExpression = 172;
CypherParser.RULE_comparisonExpression = 173;
CypherParser.RULE_addOrSubtractExpression = 174;
CypherParser.RULE_multiplyDivideModuloExpression = 175;
CypherParser.RULE_powerOfExpression = 176;
CypherParser.RULE_unaryAddOrSubtractExpression = 177;
CypherParser.RULE_stringListNullOperatorExpression = 178;
CypherParser.RULE_propertyOrLabelsExpression = 179;
CypherParser.RULE_filterFunction = 180;
CypherParser.RULE_filterFunctionName = 181;
CypherParser.RULE_existsFunction = 182;
CypherParser.RULE_existsFunctionName = 183;
CypherParser.RULE_allFunction = 184;
CypherParser.RULE_allFunctionName = 185;
CypherParser.RULE_anyFunction = 186;
CypherParser.RULE_anyFunctionName = 187;
CypherParser.RULE_noneFunction = 188;
CypherParser.RULE_noneFunctionName = 189;
CypherParser.RULE_singleFunction = 190;
CypherParser.RULE_singleFunctionName = 191;
CypherParser.RULE_extractFunction = 192;
CypherParser.RULE_extractFunctionName = 193;
CypherParser.RULE_reduceFunction = 194;
CypherParser.RULE_reduceFunctionName = 195;
CypherParser.RULE_shortestPathPatternFunction = 196;
CypherParser.RULE_shortestPathFunctionName = 197;
CypherParser.RULE_allShortestPathFunctionName = 198;
CypherParser.RULE_atom = 199;
CypherParser.RULE_literal = 200;
CypherParser.RULE_stringLiteral = 201;
CypherParser.RULE_booleanLiteral = 202;
CypherParser.RULE_listLiteral = 203;
CypherParser.RULE_partialComparisonExpression = 204;
CypherParser.RULE_parenthesizedExpression = 205;
CypherParser.RULE_relationshipsPattern = 206;
CypherParser.RULE_filterExpression = 207;
CypherParser.RULE_idInColl = 208;
CypherParser.RULE_functionInvocation = 209;
CypherParser.RULE_functionInvocationBody = 210;
CypherParser.RULE_functionName = 211;
CypherParser.RULE_procedureName = 212;
CypherParser.RULE_listComprehension = 213;
CypherParser.RULE_patternComprehension = 214;
CypherParser.RULE_propertyLookup = 215;
CypherParser.RULE_caseExpression = 216;
CypherParser.RULE_caseAlternatives = 217;
CypherParser.RULE_variable = 218;
CypherParser.RULE_numberLiteral = 219;
CypherParser.RULE_mapLiteral = 220;
CypherParser.RULE_mapProjection = 221;
CypherParser.RULE_mapProjectionVariants = 222;
CypherParser.RULE_literalEntry = 223;
CypherParser.RULE_propertySelector = 224;
CypherParser.RULE_variableSelector = 225;
CypherParser.RULE_allPropertiesSelector = 226;
CypherParser.RULE_parameter = 227;
CypherParser.RULE_legacyParameter = 228;
CypherParser.RULE_newParameter = 229;
CypherParser.RULE_parameterName = 230;
CypherParser.RULE_propertyExpressions = 231;
CypherParser.RULE_propertyExpression = 232;
CypherParser.RULE_propertyKeys = 233;
CypherParser.RULE_propertyKeyName = 234;
CypherParser.RULE_integerLiteral = 235;
CypherParser.RULE_doubleLiteral = 236;
CypherParser.RULE_namespace = 237;
CypherParser.RULE_leftArrowHead = 238;
CypherParser.RULE_rightArrowHead = 239;
CypherParser.RULE_dash = 240;
CypherParser.RULE_symbolicName = 241;
CypherParser.RULE_keyword = 242;
var CypherContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "cypherPart", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(CypherPartContext);
      } else {
        return this.getTypedRuleContext(CypherPartContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_cypher;
  }
  EOF() {
    return this.getToken(CypherParser.EOF, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCypher(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCypher(this);
    }
  }
};
var CypherPartContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_cypherPart;
  }
  cypherQuery() {
    return this.getTypedRuleContext(CypherQueryContext, 0);
  }
  cypherConsoleCommand() {
    return this.getTypedRuleContext(CypherConsoleCommandContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCypherPart(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCypherPart(this);
    }
  }
};
var CypherConsoleCommandContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_cypherConsoleCommand;
  }
  cypherConsoleCommandName() {
    return this.getTypedRuleContext(CypherConsoleCommandNameContext, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  cypherConsoleCommandParameters() {
    return this.getTypedRuleContext(CypherConsoleCommandParametersContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCypherConsoleCommand(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCypherConsoleCommand(this);
    }
  }
};
var CypherConsoleCommandNameContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "symbolicName", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(SymbolicNameContext);
      } else {
        return this.getTypedRuleContext(SymbolicNameContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_cypherConsoleCommandName;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCypherConsoleCommandName(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCypherConsoleCommandName(this);
    }
  }
};
var CypherConsoleCommandParametersContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "cypherConsoleCommandParameter", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(CypherConsoleCommandParameterContext);
      } else {
        return this.getTypedRuleContext(CypherConsoleCommandParameterContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_cypherConsoleCommandParameters;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCypherConsoleCommandParameters(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCypherConsoleCommandParameters(this);
    }
  }
};
var CypherConsoleCommandParameterContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_cypherConsoleCommandParameter;
  }
  url() {
    return this.getTypedRuleContext(UrlContext, 0);
  }
  json() {
    return this.getTypedRuleContext(JsonContext, 0);
  }
  arrowExpression() {
    return this.getTypedRuleContext(ArrowExpressionContext, 0);
  }
  mapLiteral() {
    return this.getTypedRuleContext(MapLiteralContext, 0);
  }
  keyValueLiteral() {
    return this.getTypedRuleContext(KeyValueLiteralContext, 0);
  }
  stringLiteral() {
    return this.getTypedRuleContext(StringLiteralContext, 0);
  }
  numberLiteral() {
    return this.getTypedRuleContext(NumberLiteralContext, 0);
  }
  booleanLiteral() {
    return this.getTypedRuleContext(BooleanLiteralContext, 0);
  }
  subCommand() {
    return this.getTypedRuleContext(SubCommandContext, 0);
  }
  commandPath() {
    return this.getTypedRuleContext(CommandPathContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCypherConsoleCommandParameter(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCypherConsoleCommandParameter(this);
    }
  }
};
var ArrowExpressionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_arrowExpression;
  }
  symbolicName() {
    return this.getTypedRuleContext(SymbolicNameContext, 0);
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterArrowExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitArrowExpression(this);
    }
  }
};
var UrlContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_url;
  }
  uri() {
    return this.getTypedRuleContext(UriContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterUrl(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitUrl(this);
    }
  }
};
var UriContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_uri;
  }
  scheme() {
    return this.getTypedRuleContext(SchemeContext, 0);
  }
  host() {
    return this.getTypedRuleContext(HostContext, 0);
  }
  login() {
    return this.getTypedRuleContext(LoginContext, 0);
  }
  port() {
    return this.getTypedRuleContext(PortContext, 0);
  }
  path() {
    return this.getTypedRuleContext(PathContext, 0);
  }
  urlQuery() {
    return this.getTypedRuleContext(UrlQueryContext, 0);
  }
  frag() {
    return this.getTypedRuleContext(FragContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterUri(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitUri(this);
    }
  }
};
var SchemeContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_scheme;
  }
  string() {
    return this.getTypedRuleContext(StringContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterScheme(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitScheme(this);
    }
  }
};
var HostContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_host;
  }
  hostname() {
    return this.getTypedRuleContext(HostnameContext, 0);
  }
  hostnumber() {
    return this.getTypedRuleContext(HostnumberContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterHost(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitHost(this);
    }
  }
};
var HostnameContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "string", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(StringContext);
      } else {
        return this.getTypedRuleContext(StringContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_hostname;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterHostname(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitHostname(this);
    }
  }
};
var HostnumberContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "urlDigits", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(UrlDigitsContext);
      } else {
        return this.getTypedRuleContext(UrlDigitsContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_hostnumber;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterHostnumber(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitHostnumber(this);
    }
  }
};
var PortContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_port;
  }
  urlDigits() {
    return this.getTypedRuleContext(UrlDigitsContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterPort(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitPort(this);
    }
  }
};
var PathContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "string", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(StringContext);
      } else {
        return this.getTypedRuleContext(StringContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_path;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterPath(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitPath(this);
    }
  }
};
var UserContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_user;
  }
  string() {
    return this.getTypedRuleContext(StringContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterUser(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitUser(this);
    }
  }
};
var LoginContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_login;
  }
  user() {
    return this.getTypedRuleContext(UserContext, 0);
  }
  password() {
    return this.getTypedRuleContext(PasswordContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterLogin(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitLogin(this);
    }
  }
};
var PasswordContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_password;
  }
  string() {
    return this.getTypedRuleContext(StringContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterPassword(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitPassword(this);
    }
  }
};
var FragContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_frag;
  }
  string() {
    return this.getTypedRuleContext(StringContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterFrag(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitFrag(this);
    }
  }
};
var UrlQueryContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_urlQuery;
  }
  search() {
    return this.getTypedRuleContext(SearchContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterUrlQuery(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitUrlQuery(this);
    }
  }
};
var SearchContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "searchparameter", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(SearchparameterContext);
      } else {
        return this.getTypedRuleContext(SearchparameterContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_search;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterSearch(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitSearch(this);
    }
  }
};
var SearchparameterContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "string", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(StringContext);
      } else {
        return this.getTypedRuleContext(StringContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_searchparameter;
  }
  urlDigits() {
    return this.getTypedRuleContext(UrlDigitsContext, 0);
  }
  UrlHex() {
    return this.getToken(CypherParser.UrlHex, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterSearchparameter(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitSearchparameter(this);
    }
  }
};
var StringContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "symbolicName", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(SymbolicNameContext);
      } else {
        return this.getTypedRuleContext(SymbolicNameContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_string;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterString(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitString(this);
    }
  }
};
var UrlDigitsContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "integerLiteral", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(IntegerLiteralContext);
      } else {
        return this.getTypedRuleContext(IntegerLiteralContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_urlDigits;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterUrlDigits(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitUrlDigits(this);
    }
  }
};
var JsonContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_json;
  }
  value() {
    return this.getTypedRuleContext(ValueContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterJson(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitJson(this);
    }
  }
};
var ObjContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "pair", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(PairContext);
      } else {
        return this.getTypedRuleContext(PairContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_obj;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterObj(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitObj(this);
    }
  }
};
var PairContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_pair;
  }
  stringLiteral() {
    return this.getTypedRuleContext(StringLiteralContext, 0);
  }
  value() {
    return this.getTypedRuleContext(ValueContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterPair(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitPair(this);
    }
  }
};
var ArrayContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "value", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(ValueContext);
      } else {
        return this.getTypedRuleContext(ValueContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_array;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterArray(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitArray(this);
    }
  }
};
var ValueContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_value;
  }
  stringLiteral() {
    return this.getTypedRuleContext(StringLiteralContext, 0);
  }
  numberLiteral() {
    return this.getTypedRuleContext(NumberLiteralContext, 0);
  }
  obj() {
    return this.getTypedRuleContext(ObjContext, 0);
  }
  array() {
    return this.getTypedRuleContext(ArrayContext, 0);
  }
  booleanLiteral() {
    return this.getTypedRuleContext(BooleanLiteralContext, 0);
  }
  NULL() {
    return this.getToken(CypherParser.NULL, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterValue(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitValue(this);
    }
  }
};
var KeyValueLiteralContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_keyValueLiteral;
  }
  variable() {
    return this.getTypedRuleContext(VariableContext, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  StringLiteral() {
    return this.getToken(CypherParser.StringLiteral, 0);
  }
  numberLiteral() {
    return this.getTypedRuleContext(NumberLiteralContext, 0);
  }
  booleanLiteral() {
    return this.getTypedRuleContext(BooleanLiteralContext, 0);
  }
  symbolicName() {
    return this.getTypedRuleContext(SymbolicNameContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterKeyValueLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitKeyValueLiteral(this);
    }
  }
};
var CommandPathContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "symbolicName", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(SymbolicNameContext);
      } else {
        return this.getTypedRuleContext(SymbolicNameContext, i2);
      }
    });
    _defineProperty(this, "numberLiteral", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(NumberLiteralContext);
      } else {
        return this.getTypedRuleContext(NumberLiteralContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_commandPath;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCommandPath(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCommandPath(this);
    }
  }
};
var SubCommandContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "symbolicName", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(SymbolicNameContext);
      } else {
        return this.getTypedRuleContext(SymbolicNameContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_subCommand;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterSubCommand(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitSubCommand(this);
    }
  }
};
var CypherQueryContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_cypherQuery;
  }
  queryOptions() {
    return this.getTypedRuleContext(QueryOptionsContext, 0);
  }
  statement() {
    return this.getTypedRuleContext(StatementContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCypherQuery(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCypherQuery(this);
    }
  }
};
var QueryOptionsContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "anyCypherOption", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(AnyCypherOptionContext);
      } else {
        return this.getTypedRuleContext(AnyCypherOptionContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_queryOptions;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterQueryOptions(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitQueryOptions(this);
    }
  }
};
var AnyCypherOptionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_anyCypherOption;
  }
  cypherOption() {
    return this.getTypedRuleContext(CypherOptionContext, 0);
  }
  explain() {
    return this.getTypedRuleContext(ExplainContext, 0);
  }
  profile() {
    return this.getTypedRuleContext(ProfileContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterAnyCypherOption(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitAnyCypherOption(this);
    }
  }
};
var CypherOptionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    _defineProperty(this, "configurationOption", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(ConfigurationOptionContext);
      } else {
        return this.getTypedRuleContext(ConfigurationOptionContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_cypherOption;
  }
  CYPHER() {
    return this.getToken(CypherParser.CYPHER, 0);
  }
  versionNumber() {
    return this.getTypedRuleContext(VersionNumberContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCypherOption(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCypherOption(this);
    }
  }
};
var VersionNumberContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_versionNumber;
  }
  RegularDecimalReal() {
    return this.getToken(CypherParser.RegularDecimalReal, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterVersionNumber(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitVersionNumber(this);
    }
  }
};
var ExplainContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_explain;
  }
  EXPLAIN() {
    return this.getToken(CypherParser.EXPLAIN, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterExplain(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitExplain(this);
    }
  }
};
var ProfileContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_profile;
  }
  PROFILE() {
    return this.getToken(CypherParser.PROFILE, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterProfile(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitProfile(this);
    }
  }
};
var ConfigurationOptionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "symbolicName", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(SymbolicNameContext);
      } else {
        return this.getTypedRuleContext(SymbolicNameContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_configurationOption;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterConfigurationOption(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitConfigurationOption(this);
    }
  }
};
var StatementContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_statement;
  }
  command() {
    return this.getTypedRuleContext(CommandContext, 0);
  }
  query() {
    return this.getTypedRuleContext(QueryContext, 0);
  }
  systemCommand() {
    return this.getTypedRuleContext(SystemCommandContext, 0);
  }
  CATALOG() {
    return this.getToken(CypherParser.CATALOG, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterStatement(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitStatement(this);
    }
  }
};
var QueryContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_query;
  }
  regularQuery() {
    return this.getTypedRuleContext(RegularQueryContext, 0);
  }
  bulkImportQuery() {
    return this.getTypedRuleContext(BulkImportQueryContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterQuery(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitQuery(this);
    }
  }
};
var RegularQueryContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "union", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(UnionContext);
      } else {
        return this.getTypedRuleContext(UnionContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_regularQuery;
  }
  singleQuery() {
    return this.getTypedRuleContext(SingleQueryContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterRegularQuery(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitRegularQuery(this);
    }
  }
};
var BulkImportQueryContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_bulkImportQuery;
  }
  periodicCommitHint() {
    return this.getTypedRuleContext(PeriodicCommitHintContext, 0);
  }
  loadCSVQuery() {
    return this.getTypedRuleContext(LoadCSVQueryContext, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterBulkImportQuery(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitBulkImportQuery(this);
    }
  }
};
var SingleQueryContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "clause", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(ClauseContext);
      } else {
        return this.getTypedRuleContext(ClauseContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_singleQuery;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterSingleQuery(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitSingleQuery(this);
    }
  }
};
var PeriodicCommitHintContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_periodicCommitHint;
  }
  USING() {
    return this.getToken(CypherParser.USING, 0);
  }
  PERIODIC() {
    return this.getToken(CypherParser.PERIODIC, 0);
  }
  COMMIT() {
    return this.getToken(CypherParser.COMMIT, 0);
  }
  integerLiteral() {
    return this.getTypedRuleContext(IntegerLiteralContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterPeriodicCommitHint(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitPeriodicCommitHint(this);
    }
  }
};
var LoadCSVQueryContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "clause", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(ClauseContext);
      } else {
        return this.getTypedRuleContext(ClauseContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_loadCSVQuery;
  }
  loadCSVClause() {
    return this.getTypedRuleContext(LoadCSVClauseContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterLoadCSVQuery(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitLoadCSVQuery(this);
    }
  }
};
var UnionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_union;
  }
  UNION() {
    return this.getToken(CypherParser.UNION, 0);
  }
  ALL() {
    return this.getToken(CypherParser.ALL, 0);
  }
  singleQuery() {
    return this.getTypedRuleContext(SingleQueryContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterUnion(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitUnion(this);
    }
  }
};
var ClauseContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_clause;
  }
  loadCSVClause() {
    return this.getTypedRuleContext(LoadCSVClauseContext, 0);
  }
  startClause() {
    return this.getTypedRuleContext(StartClauseContext, 0);
  }
  matchClause() {
    return this.getTypedRuleContext(MatchClauseContext, 0);
  }
  unwindClause() {
    return this.getTypedRuleContext(UnwindClauseContext, 0);
  }
  mergeClause() {
    return this.getTypedRuleContext(MergeClauseContext, 0);
  }
  createClause() {
    return this.getTypedRuleContext(CreateClauseContext, 0);
  }
  createUniqueClause() {
    return this.getTypedRuleContext(CreateUniqueClauseContext, 0);
  }
  setClause() {
    return this.getTypedRuleContext(SetClauseContext, 0);
  }
  deleteClause() {
    return this.getTypedRuleContext(DeleteClauseContext, 0);
  }
  removeClause() {
    return this.getTypedRuleContext(RemoveClauseContext, 0);
  }
  foreachClause() {
    return this.getTypedRuleContext(ForeachClauseContext, 0);
  }
  withClause() {
    return this.getTypedRuleContext(WithClauseContext, 0);
  }
  returnClause() {
    return this.getTypedRuleContext(ReturnClauseContext, 0);
  }
  call() {
    return this.getTypedRuleContext(CallContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterClause(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitClause(this);
    }
  }
};
var CommandContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_command;
  }
  createIndex() {
    return this.getTypedRuleContext(CreateIndexContext, 0);
  }
  dropIndex() {
    return this.getTypedRuleContext(DropIndexContext, 0);
  }
  createUniqueConstraint() {
    return this.getTypedRuleContext(CreateUniqueConstraintContext, 0);
  }
  dropUniqueConstraint() {
    return this.getTypedRuleContext(DropUniqueConstraintContext, 0);
  }
  createNodeKeyConstraint() {
    return this.getTypedRuleContext(CreateNodeKeyConstraintContext, 0);
  }
  dropNodeKeyConstraint() {
    return this.getTypedRuleContext(DropNodeKeyConstraintContext, 0);
  }
  createNodePropertyExistenceConstraint() {
    return this.getTypedRuleContext(CreateNodePropertyExistenceConstraintContext, 0);
  }
  dropNodePropertyExistenceConstraint() {
    return this.getTypedRuleContext(DropNodePropertyExistenceConstraintContext, 0);
  }
  createRelationshipPropertyExistenceConstraint() {
    return this.getTypedRuleContext(CreateRelationshipPropertyExistenceConstraintContext, 0);
  }
  dropRelationshipPropertyExistenceConstraint() {
    return this.getTypedRuleContext(DropRelationshipPropertyExistenceConstraintContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCommand(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCommand(this);
    }
  }
};
var SystemCommandContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_systemCommand;
  }
  multidatabaseCommand() {
    return this.getTypedRuleContext(MultidatabaseCommandContext, 0);
  }
  userCommand() {
    return this.getTypedRuleContext(UserCommandContext, 0);
  }
  privilegeCommand() {
    return this.getTypedRuleContext(PrivilegeCommandContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterSystemCommand(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitSystemCommand(this);
    }
  }
};
var MultidatabaseCommandContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_multidatabaseCommand;
  }
  showDatabase() {
    return this.getTypedRuleContext(ShowDatabaseContext, 0);
  }
  createDatabase() {
    return this.getTypedRuleContext(CreateDatabaseContext, 0);
  }
  dropDatabase() {
    return this.getTypedRuleContext(DropDatabaseContext, 0);
  }
  startDatabase() {
    return this.getTypedRuleContext(StartDatabaseContext, 0);
  }
  stopDatabase() {
    return this.getTypedRuleContext(StopDatabaseContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterMultidatabaseCommand(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitMultidatabaseCommand(this);
    }
  }
};
var UserCommandContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_userCommand;
  }
  showRoles() {
    return this.getTypedRuleContext(ShowRolesContext, 0);
  }
  createRole() {
    return this.getTypedRuleContext(CreateRoleContext, 0);
  }
  dropRole() {
    return this.getTypedRuleContext(DropRoleContext, 0);
  }
  showUsers() {
    return this.getTypedRuleContext(ShowUsersContext, 0);
  }
  createUser() {
    return this.getTypedRuleContext(CreateUserContext, 0);
  }
  dropUser() {
    return this.getTypedRuleContext(DropUserContext, 0);
  }
  alterUser() {
    return this.getTypedRuleContext(AlterUserContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterUserCommand(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitUserCommand(this);
    }
  }
};
var PrivilegeCommandContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_privilegeCommand;
  }
  showPrivileges() {
    return this.getTypedRuleContext(ShowPrivilegesContext, 0);
  }
  grantPrivilege() {
    return this.getTypedRuleContext(GrantPrivilegeContext, 0);
  }
  denyPrivilege() {
    return this.getTypedRuleContext(DenyPrivilegeContext, 0);
  }
  revokePrivilege() {
    return this.getTypedRuleContext(RevokePrivilegeContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterPrivilegeCommand(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitPrivilegeCommand(this);
    }
  }
};
var ShowRolesContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_showRoles;
  }
  SHOW() {
    return this.getToken(CypherParser.SHOW, 0);
  }
  ROLES() {
    return this.getToken(CypherParser.ROLES, 0);
  }
  ALL() {
    return this.getToken(CypherParser.ALL, 0);
  }
  WITH() {
    return this.getToken(CypherParser.WITH, 0);
  }
  USERS() {
    return this.getToken(CypherParser.USERS, 0);
  }
  POPULATED() {
    return this.getToken(CypherParser.POPULATED, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterShowRoles(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitShowRoles(this);
    }
  }
};
var CreateRoleContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_createRole;
  }
  CREATE() {
    return this.getToken(CypherParser.CREATE, 0);
  }
  ROLE() {
    return this.getToken(CypherParser.ROLE, 0);
  }
  symbolicName() {
    return this.getTypedRuleContext(SymbolicNameContext, 0);
  }
  ifNotExists() {
    return this.getTypedRuleContext(IfNotExistsContext, 0);
  }
  copyRole() {
    return this.getTypedRuleContext(CopyRoleContext, 0);
  }
  orReplace() {
    return this.getTypedRuleContext(OrReplaceContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCreateRole(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCreateRole(this);
    }
  }
};
var CopyRoleContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_copyRole;
  }
  AS() {
    return this.getToken(CypherParser.AS, 0);
  }
  COPY() {
    return this.getToken(CypherParser.COPY, 0);
  }
  OF() {
    return this.getToken(CypherParser.OF, 0);
  }
  symbolicName() {
    return this.getTypedRuleContext(SymbolicNameContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCopyRole(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCopyRole(this);
    }
  }
};
var DropRoleContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_dropRole;
  }
  DROP() {
    return this.getToken(CypherParser.DROP, 0);
  }
  ROLE() {
    return this.getToken(CypherParser.ROLE, 0);
  }
  symbolicName() {
    return this.getTypedRuleContext(SymbolicNameContext, 0);
  }
  IF() {
    return this.getToken(CypherParser.IF, 0);
  }
  EXISTS() {
    return this.getToken(CypherParser.EXISTS, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterDropRole(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitDropRole(this);
    }
  }
};
var ShowUsersContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_showUsers;
  }
  SHOW() {
    return this.getToken(CypherParser.SHOW, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  USERS() {
    return this.getToken(CypherParser.USERS, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterShowUsers(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitShowUsers(this);
    }
  }
};
var CreateUserContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_createUser;
  }
  CREATE() {
    return this.getToken(CypherParser.CREATE, 0);
  }
  USER() {
    return this.getToken(CypherParser.USER, 0);
  }
  user() {
    return this.getTypedRuleContext(UserContext, 0);
  }
  setPassword() {
    return this.getTypedRuleContext(SetPasswordContext, 0);
  }
  ifNotExists() {
    return this.getTypedRuleContext(IfNotExistsContext, 0);
  }
  setStatus() {
    return this.getTypedRuleContext(SetStatusContext, 0);
  }
  orReplace() {
    return this.getTypedRuleContext(OrReplaceContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCreateUser(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCreateUser(this);
    }
  }
};
var DropUserContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_dropUser;
  }
  DROP() {
    return this.getToken(CypherParser.DROP, 0);
  }
  USER() {
    return this.getToken(CypherParser.USER, 0);
  }
  user() {
    return this.getTypedRuleContext(UserContext, 0);
  }
  ifExists() {
    return this.getTypedRuleContext(IfExistsContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterDropUser(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitDropUser(this);
    }
  }
};
var AlterUserContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    _defineProperty(this, "password", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(PasswordContext);
      } else {
        return this.getTypedRuleContext(PasswordContext, i2);
      }
    });
    _defineProperty(this, "parameter", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(ParameterContext);
      } else {
        return this.getTypedRuleContext(ParameterContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_alterUser;
  }
  ALTER() {
    return this.getToken(CypherParser.ALTER, 0);
  }
  CURRENT() {
    return this.getToken(CypherParser.CURRENT, 0);
  }
  USER() {
    return this.getToken(CypherParser.USER, 0);
  }
  SET() {
    return this.getToken(CypherParser.SET, 0);
  }
  PASSWORD() {
    return this.getToken(CypherParser.PASSWORD, 0);
  }
  FROM() {
    return this.getToken(CypherParser.FROM, 0);
  }
  TO() {
    return this.getToken(CypherParser.TO, 0);
  }
  user() {
    return this.getTypedRuleContext(UserContext, 0);
  }
  setPassword() {
    return this.getTypedRuleContext(SetPasswordContext, 0);
  }
  setStatus() {
    return this.getTypedRuleContext(SetStatusContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterAlterUser(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitAlterUser(this);
    }
  }
};
var ShowPrivilegesContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_showPrivileges;
  }
  SHOW() {
    return this.getToken(CypherParser.SHOW, 0);
  }
  PRIVILEGES() {
    return this.getToken(CypherParser.PRIVILEGES, 0);
  }
  ALL() {
    return this.getToken(CypherParser.ALL, 0);
  }
  ROLE() {
    return this.getToken(CypherParser.ROLE, 0);
  }
  symbolicName() {
    return this.getTypedRuleContext(SymbolicNameContext, 0);
  }
  USER() {
    return this.getToken(CypherParser.USER, 0);
  }
  user() {
    return this.getTypedRuleContext(UserContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterShowPrivileges(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitShowPrivileges(this);
    }
  }
};
var GrantPrivilegeContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_grantPrivilege;
  }
  GRANT() {
    return this.getToken(CypherParser.GRANT, 0);
  }
  ROLE() {
    return this.getToken(CypherParser.ROLE, 0);
  }
  roles() {
    return this.getTypedRuleContext(RolesContext, 0);
  }
  TO() {
    return this.getToken(CypherParser.TO, 0);
  }
  user() {
    return this.getTypedRuleContext(UserContext, 0);
  }
  datasbasePrivilege() {
    return this.getTypedRuleContext(DatasbasePrivilegeContext, 0);
  }
  ON() {
    return this.getToken(CypherParser.ON, 0);
  }
  databaseScope() {
    return this.getTypedRuleContext(DatabaseScopeContext, 0);
  }
  grantableGraphPrivileges() {
    return this.getTypedRuleContext(GrantableGraphPrivilegesContext, 0);
  }
  graphScope() {
    return this.getTypedRuleContext(GraphScopeContext, 0);
  }
  elementScope() {
    return this.getTypedRuleContext(ElementScopeContext, 0);
  }
  dbmsPrivilege() {
    return this.getTypedRuleContext(DbmsPrivilegeContext, 0);
  }
  DBMS() {
    return this.getToken(CypherParser.DBMS, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterGrantPrivilege(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitGrantPrivilege(this);
    }
  }
};
var DenyPrivilegeContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_denyPrivilege;
  }
  DENY() {
    return this.getToken(CypherParser.DENY, 0);
  }
  ROLE() {
    return this.getToken(CypherParser.ROLE, 0);
  }
  roles() {
    return this.getTypedRuleContext(RolesContext, 0);
  }
  TO() {
    return this.getToken(CypherParser.TO, 0);
  }
  user() {
    return this.getTypedRuleContext(UserContext, 0);
  }
  datasbasePrivilege() {
    return this.getTypedRuleContext(DatasbasePrivilegeContext, 0);
  }
  ON() {
    return this.getToken(CypherParser.ON, 0);
  }
  databaseScope() {
    return this.getTypedRuleContext(DatabaseScopeContext, 0);
  }
  grantableGraphPrivileges() {
    return this.getTypedRuleContext(GrantableGraphPrivilegesContext, 0);
  }
  graphScope() {
    return this.getTypedRuleContext(GraphScopeContext, 0);
  }
  elementScope() {
    return this.getTypedRuleContext(ElementScopeContext, 0);
  }
  dbmsPrivilege() {
    return this.getTypedRuleContext(DbmsPrivilegeContext, 0);
  }
  DBMS() {
    return this.getToken(CypherParser.DBMS, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterDenyPrivilege(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitDenyPrivilege(this);
    }
  }
};
var RevokePrivilegeContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_revokePrivilege;
  }
  REVOKE() {
    return this.getToken(CypherParser.REVOKE, 0);
  }
  ROLE() {
    return this.getToken(CypherParser.ROLE, 0);
  }
  roles() {
    return this.getTypedRuleContext(RolesContext, 0);
  }
  FROM() {
    return this.getToken(CypherParser.FROM, 0);
  }
  user() {
    return this.getTypedRuleContext(UserContext, 0);
  }
  revokePart() {
    return this.getTypedRuleContext(RevokePartContext, 0);
  }
  GRANT() {
    return this.getToken(CypherParser.GRANT, 0);
  }
  DENY() {
    return this.getToken(CypherParser.DENY, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterRevokePrivilege(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitRevokePrivilege(this);
    }
  }
};
var RevokePartContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_revokePart;
  }
  datasbasePrivilege() {
    return this.getTypedRuleContext(DatasbasePrivilegeContext, 0);
  }
  ON() {
    return this.getToken(CypherParser.ON, 0);
  }
  databaseScope() {
    return this.getTypedRuleContext(DatabaseScopeContext, 0);
  }
  revokeableGraphPrivileges() {
    return this.getTypedRuleContext(RevokeableGraphPrivilegesContext, 0);
  }
  graphScope() {
    return this.getTypedRuleContext(GraphScopeContext, 0);
  }
  dbmsPrivilege() {
    return this.getTypedRuleContext(DbmsPrivilegeContext, 0);
  }
  DBMS() {
    return this.getToken(CypherParser.DBMS, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterRevokePart(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitRevokePart(this);
    }
  }
};
var DatabaseScopeContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    _defineProperty(this, "symbolicName", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(SymbolicNameContext);
      } else {
        return this.getTypedRuleContext(SymbolicNameContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_databaseScope;
  }
  DATABASE() {
    return this.getToken(CypherParser.DATABASE, 0);
  }
  DATABASES() {
    return this.getToken(CypherParser.DATABASES, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterDatabaseScope(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitDatabaseScope(this);
    }
  }
};
var GraphScopeContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    _defineProperty(this, "symbolicName", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(SymbolicNameContext);
      } else {
        return this.getTypedRuleContext(SymbolicNameContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_graphScope;
  }
  GRAPH() {
    return this.getToken(CypherParser.GRAPH, 0);
  }
  GRAPHS() {
    return this.getToken(CypherParser.GRAPHS, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterGraphScope(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitGraphScope(this);
    }
  }
};
var RolesContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "symbolicName", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(SymbolicNameContext);
      } else {
        return this.getTypedRuleContext(SymbolicNameContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_roles;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterRoles(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitRoles(this);
    }
  }
};
var GrantableGraphPrivilegesContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_grantableGraphPrivileges;
  }
  revokeableGraphPrivileges() {
    return this.getTypedRuleContext(RevokeableGraphPrivilegesContext, 0);
  }
  MATCH() {
    return this.getToken(CypherParser.MATCH, 0);
  }
  propertiesList() {
    return this.getTypedRuleContext(PropertiesListContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterGrantableGraphPrivileges(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitGrantableGraphPrivileges(this);
    }
  }
};
var RevokeableGraphPrivilegesContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_revokeableGraphPrivileges;
  }
  TRAVERSE() {
    return this.getToken(CypherParser.TRAVERSE, 0);
  }
  READ() {
    return this.getToken(CypherParser.READ, 0);
  }
  propertiesList() {
    return this.getTypedRuleContext(PropertiesListContext, 0);
  }
  WRITE() {
    return this.getToken(CypherParser.WRITE, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterRevokeableGraphPrivileges(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitRevokeableGraphPrivileges(this);
    }
  }
};
var DatasbasePrivilegeContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_datasbasePrivilege;
  }
  ACCESS() {
    return this.getToken(CypherParser.ACCESS, 0);
  }
  START() {
    return this.getToken(CypherParser.START, 0);
  }
  STOP() {
    return this.getToken(CypherParser.STOP, 0);
  }
  CREATE() {
    return this.getToken(CypherParser.CREATE, 0);
  }
  INDEX() {
    return this.getToken(CypherParser.INDEX, 0);
  }
  INDEXES() {
    return this.getToken(CypherParser.INDEXES, 0);
  }
  DROP() {
    return this.getToken(CypherParser.DROP, 0);
  }
  MANAGEMENT() {
    return this.getToken(CypherParser.MANAGEMENT, 0);
  }
  CONSTRAINT() {
    return this.getToken(CypherParser.CONSTRAINT, 0);
  }
  CONSTRAINTS() {
    return this.getToken(CypherParser.CONSTRAINTS, 0);
  }
  NEW() {
    return this.getToken(CypherParser.NEW, 0);
  }
  LABEL() {
    return this.getToken(CypherParser.LABEL, 0);
  }
  LABELS() {
    return this.getToken(CypherParser.LABELS, 0);
  }
  NODE() {
    return this.getToken(CypherParser.NODE, 0);
  }
  TYPE() {
    return this.getToken(CypherParser.TYPE, 0);
  }
  TYPES() {
    return this.getToken(CypherParser.TYPES, 0);
  }
  RELATIONSHIP() {
    return this.getToken(CypherParser.RELATIONSHIP, 0);
  }
  NAME() {
    return this.getToken(CypherParser.NAME, 0);
  }
  NAMES() {
    return this.getToken(CypherParser.NAMES, 0);
  }
  PROPERTY() {
    return this.getToken(CypherParser.PROPERTY, 0);
  }
  ALL() {
    return this.getToken(CypherParser.ALL, 0);
  }
  PRIVILEGES() {
    return this.getToken(CypherParser.PRIVILEGES, 0);
  }
  DATABASE() {
    return this.getToken(CypherParser.DATABASE, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterDatasbasePrivilege(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitDatasbasePrivilege(this);
    }
  }
};
var DbmsPrivilegeContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_dbmsPrivilege;
  }
  ROLE() {
    return this.getToken(CypherParser.ROLE, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  MANAGEMENT() {
    return this.getToken(CypherParser.MANAGEMENT, 0);
  }
  CREATE() {
    return this.getToken(CypherParser.CREATE, 0);
  }
  DROP() {
    return this.getToken(CypherParser.DROP, 0);
  }
  ASSIGN() {
    return this.getToken(CypherParser.ASSIGN, 0);
  }
  REMOVE() {
    return this.getToken(CypherParser.REMOVE, 0);
  }
  SHOW() {
    return this.getToken(CypherParser.SHOW, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterDbmsPrivilege(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitDbmsPrivilege(this);
    }
  }
};
var ElementScopeContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_elementScope;
  }
  propertiesList() {
    return this.getTypedRuleContext(PropertiesListContext, 0);
  }
  RELATIONSHIP() {
    return this.getToken(CypherParser.RELATIONSHIP, 0);
  }
  RELATIONSHIPS() {
    return this.getToken(CypherParser.RELATIONSHIPS, 0);
  }
  propertyScope() {
    return this.getTypedRuleContext(PropertyScopeContext, 0);
  }
  NODE() {
    return this.getToken(CypherParser.NODE, 0);
  }
  NODES() {
    return this.getToken(CypherParser.NODES, 0);
  }
  ELEMENT() {
    return this.getToken(CypherParser.ELEMENT, 0);
  }
  ELEMENTS() {
    return this.getToken(CypherParser.ELEMENTS, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterElementScope(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitElementScope(this);
    }
  }
};
var PropertiesListContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "symbolicName", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(SymbolicNameContext);
      } else {
        return this.getTypedRuleContext(SymbolicNameContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_propertiesList;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterPropertiesList(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitPropertiesList(this);
    }
  }
};
var PropertyScopeContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_propertyScope;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterPropertyScope(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitPropertyScope(this);
    }
  }
};
var ShowDatabaseContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_showDatabase;
  }
  SHOW() {
    return this.getToken(CypherParser.SHOW, 0);
  }
  DATABASE() {
    return this.getToken(CypherParser.DATABASE, 0);
  }
  DEFAULT() {
    return this.getToken(CypherParser.DEFAULT, 0);
  }
  DATABASES() {
    return this.getToken(CypherParser.DATABASES, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterShowDatabase(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitShowDatabase(this);
    }
  }
};
var CreateDatabaseContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_createDatabase;
  }
  CREATE() {
    return this.getToken(CypherParser.CREATE, 0);
  }
  DATABASE() {
    return this.getToken(CypherParser.DATABASE, 0);
  }
  symbolicName() {
    return this.getTypedRuleContext(SymbolicNameContext, 0);
  }
  ifNotExists() {
    return this.getTypedRuleContext(IfNotExistsContext, 0);
  }
  orReplace() {
    return this.getTypedRuleContext(OrReplaceContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCreateDatabase(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCreateDatabase(this);
    }
  }
};
var DropDatabaseContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_dropDatabase;
  }
  DROP() {
    return this.getToken(CypherParser.DROP, 0);
  }
  DATABASE() {
    return this.getToken(CypherParser.DATABASE, 0);
  }
  symbolicName() {
    return this.getTypedRuleContext(SymbolicNameContext, 0);
  }
  ifExists() {
    return this.getTypedRuleContext(IfExistsContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterDropDatabase(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitDropDatabase(this);
    }
  }
};
var StartDatabaseContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_startDatabase;
  }
  START() {
    return this.getToken(CypherParser.START, 0);
  }
  DATABASE() {
    return this.getToken(CypherParser.DATABASE, 0);
  }
  symbolicName() {
    return this.getTypedRuleContext(SymbolicNameContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterStartDatabase(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitStartDatabase(this);
    }
  }
};
var StopDatabaseContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_stopDatabase;
  }
  STOP() {
    return this.getToken(CypherParser.STOP, 0);
  }
  DATABASE() {
    return this.getToken(CypherParser.DATABASE, 0);
  }
  symbolicName() {
    return this.getTypedRuleContext(SymbolicNameContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterStopDatabase(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitStopDatabase(this);
    }
  }
};
var IfNotExistsContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_ifNotExists;
  }
  IF() {
    return this.getToken(CypherParser.IF, 0);
  }
  NOT() {
    return this.getToken(CypherParser.NOT, 0);
  }
  EXISTS() {
    return this.getToken(CypherParser.EXISTS, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterIfNotExists(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitIfNotExists(this);
    }
  }
};
var IfExistsContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_ifExists;
  }
  IF() {
    return this.getToken(CypherParser.IF, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  EXISTS() {
    return this.getToken(CypherParser.EXISTS, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterIfExists(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitIfExists(this);
    }
  }
};
var OrReplaceContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_orReplace;
  }
  OR() {
    return this.getToken(CypherParser.OR, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  REPLACE() {
    return this.getToken(CypherParser.REPLACE, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterOrReplace(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitOrReplace(this);
    }
  }
};
var SetPasswordContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_setPassword;
  }
  SET() {
    return this.getToken(CypherParser.SET, 0);
  }
  PASSWORD() {
    return this.getToken(CypherParser.PASSWORD, 0);
  }
  password() {
    return this.getTypedRuleContext(PasswordContext, 0);
  }
  parameter() {
    return this.getTypedRuleContext(ParameterContext, 0);
  }
  passwordStatus() {
    return this.getTypedRuleContext(PasswordStatusContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterSetPassword(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitSetPassword(this);
    }
  }
};
var PasswordStatusContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_passwordStatus;
  }
  CHANGE() {
    return this.getToken(CypherParser.CHANGE, 0);
  }
  REQUIRED() {
    return this.getToken(CypherParser.REQUIRED, 0);
  }
  NOT() {
    return this.getToken(CypherParser.NOT, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterPasswordStatus(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitPasswordStatus(this);
    }
  }
};
var SetStatusContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_setStatus;
  }
  SET() {
    return this.getToken(CypherParser.SET, 0);
  }
  STATUS() {
    return this.getToken(CypherParser.STATUS, 0);
  }
  userStatus() {
    return this.getTypedRuleContext(UserStatusContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterSetStatus(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitSetStatus(this);
    }
  }
};
var UserStatusContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_userStatus;
  }
  ACTIVE() {
    return this.getToken(CypherParser.ACTIVE, 0);
  }
  SUSPENDED() {
    return this.getToken(CypherParser.SUSPENDED, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterUserStatus(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitUserStatus(this);
    }
  }
};
var CreateUniqueConstraintContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_createUniqueConstraint;
  }
  CREATE() {
    return this.getToken(CypherParser.CREATE, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  uniqueConstraint() {
    return this.getTypedRuleContext(UniqueConstraintContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCreateUniqueConstraint(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCreateUniqueConstraint(this);
    }
  }
};
var CreateNodeKeyConstraintContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_createNodeKeyConstraint;
  }
  CREATE() {
    return this.getToken(CypherParser.CREATE, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  nodeKeyConstraint() {
    return this.getTypedRuleContext(NodeKeyConstraintContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCreateNodeKeyConstraint(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCreateNodeKeyConstraint(this);
    }
  }
};
var CreateNodePropertyExistenceConstraintContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_createNodePropertyExistenceConstraint;
  }
  CREATE() {
    return this.getToken(CypherParser.CREATE, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  nodePropertyExistenceConstraint() {
    return this.getTypedRuleContext(NodePropertyExistenceConstraintContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCreateNodePropertyExistenceConstraint(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCreateNodePropertyExistenceConstraint(this);
    }
  }
};
var CreateRelationshipPropertyExistenceConstraintContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_createRelationshipPropertyExistenceConstraint;
  }
  CREATE() {
    return this.getToken(CypherParser.CREATE, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  relationshipPropertyExistenceConstraint() {
    return this.getTypedRuleContext(RelationshipPropertyExistenceConstraintContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCreateRelationshipPropertyExistenceConstraint(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCreateRelationshipPropertyExistenceConstraint(this);
    }
  }
};
var CreateIndexContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_createIndex;
  }
  CREATE() {
    return this.getToken(CypherParser.CREATE, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  index() {
    return this.getTypedRuleContext(IndexContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCreateIndex(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCreateIndex(this);
    }
  }
};
var DropUniqueConstraintContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_dropUniqueConstraint;
  }
  DROP() {
    return this.getToken(CypherParser.DROP, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  uniqueConstraint() {
    return this.getTypedRuleContext(UniqueConstraintContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterDropUniqueConstraint(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitDropUniqueConstraint(this);
    }
  }
};
var DropNodeKeyConstraintContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_dropNodeKeyConstraint;
  }
  DROP() {
    return this.getToken(CypherParser.DROP, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  nodeKeyConstraint() {
    return this.getTypedRuleContext(NodeKeyConstraintContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterDropNodeKeyConstraint(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitDropNodeKeyConstraint(this);
    }
  }
};
var DropNodePropertyExistenceConstraintContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_dropNodePropertyExistenceConstraint;
  }
  DROP() {
    return this.getToken(CypherParser.DROP, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  nodePropertyExistenceConstraint() {
    return this.getTypedRuleContext(NodePropertyExistenceConstraintContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterDropNodePropertyExistenceConstraint(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitDropNodePropertyExistenceConstraint(this);
    }
  }
};
var DropRelationshipPropertyExistenceConstraintContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_dropRelationshipPropertyExistenceConstraint;
  }
  DROP() {
    return this.getToken(CypherParser.DROP, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  relationshipPropertyExistenceConstraint() {
    return this.getTypedRuleContext(RelationshipPropertyExistenceConstraintContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterDropRelationshipPropertyExistenceConstraint(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitDropRelationshipPropertyExistenceConstraint(this);
    }
  }
};
var DropIndexContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_dropIndex;
  }
  DROP() {
    return this.getToken(CypherParser.DROP, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  index() {
    return this.getTypedRuleContext(IndexContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterDropIndex(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitDropIndex(this);
    }
  }
};
var IndexContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_index;
  }
  INDEX() {
    return this.getToken(CypherParser.INDEX, 0);
  }
  ON() {
    return this.getToken(CypherParser.ON, 0);
  }
  nodeLabel() {
    return this.getTypedRuleContext(NodeLabelContext, 0);
  }
  propertyKeys() {
    return this.getTypedRuleContext(PropertyKeysContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterIndex(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitIndex(this);
    }
  }
};
var UniqueConstraintContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_uniqueConstraint;
  }
  CONSTRAINT() {
    return this.getToken(CypherParser.CONSTRAINT, 0);
  }
  ON() {
    return this.getToken(CypherParser.ON, 0);
  }
  variable() {
    return this.getTypedRuleContext(VariableContext, 0);
  }
  nodeLabel() {
    return this.getTypedRuleContext(NodeLabelContext, 0);
  }
  ASSERT() {
    return this.getToken(CypherParser.ASSERT, 0);
  }
  propertyExpression() {
    return this.getTypedRuleContext(PropertyExpressionContext, 0);
  }
  IS() {
    return this.getToken(CypherParser.IS, 0);
  }
  UNIQUE() {
    return this.getToken(CypherParser.UNIQUE, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterUniqueConstraint(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitUniqueConstraint(this);
    }
  }
};
var NodeKeyConstraintContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_nodeKeyConstraint;
  }
  CONSTRAINT() {
    return this.getToken(CypherParser.CONSTRAINT, 0);
  }
  ON() {
    return this.getToken(CypherParser.ON, 0);
  }
  variable() {
    return this.getTypedRuleContext(VariableContext, 0);
  }
  nodeLabel() {
    return this.getTypedRuleContext(NodeLabelContext, 0);
  }
  ASSERT() {
    return this.getToken(CypherParser.ASSERT, 0);
  }
  propertyExpressions() {
    return this.getTypedRuleContext(PropertyExpressionsContext, 0);
  }
  IS() {
    return this.getToken(CypherParser.IS, 0);
  }
  NODE() {
    return this.getToken(CypherParser.NODE, 0);
  }
  KEY() {
    return this.getToken(CypherParser.KEY, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterNodeKeyConstraint(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitNodeKeyConstraint(this);
    }
  }
};
var NodePropertyExistenceConstraintContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_nodePropertyExistenceConstraint;
  }
  CONSTRAINT() {
    return this.getToken(CypherParser.CONSTRAINT, 0);
  }
  ON() {
    return this.getToken(CypherParser.ON, 0);
  }
  variable() {
    return this.getTypedRuleContext(VariableContext, 0);
  }
  nodeLabel() {
    return this.getTypedRuleContext(NodeLabelContext, 0);
  }
  ASSERT() {
    return this.getToken(CypherParser.ASSERT, 0);
  }
  EXISTS() {
    return this.getToken(CypherParser.EXISTS, 0);
  }
  propertyExpression() {
    return this.getTypedRuleContext(PropertyExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterNodePropertyExistenceConstraint(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitNodePropertyExistenceConstraint(this);
    }
  }
};
var RelationshipPropertyExistenceConstraintContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_relationshipPropertyExistenceConstraint;
  }
  CONSTRAINT() {
    return this.getToken(CypherParser.CONSTRAINT, 0);
  }
  ON() {
    return this.getToken(CypherParser.ON, 0);
  }
  relationshipPatternSyntax() {
    return this.getTypedRuleContext(RelationshipPatternSyntaxContext, 0);
  }
  ASSERT() {
    return this.getToken(CypherParser.ASSERT, 0);
  }
  EXISTS() {
    return this.getToken(CypherParser.EXISTS, 0);
  }
  propertyExpression() {
    return this.getTypedRuleContext(PropertyExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterRelationshipPropertyExistenceConstraint(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitRelationshipPropertyExistenceConstraint(this);
    }
  }
};
var RelationshipPatternSyntaxContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "dash", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(DashContext);
      } else {
        return this.getTypedRuleContext(DashContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_relationshipPatternSyntax;
  }
  variable() {
    return this.getTypedRuleContext(VariableContext, 0);
  }
  relType() {
    return this.getTypedRuleContext(RelTypeContext, 0);
  }
  rightArrowHead() {
    return this.getTypedRuleContext(RightArrowHeadContext, 0);
  }
  leftArrowHead() {
    return this.getTypedRuleContext(LeftArrowHeadContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterRelationshipPatternSyntax(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitRelationshipPatternSyntax(this);
    }
  }
};
var LoadCSVClauseContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_loadCSVClause;
  }
  LOAD() {
    return this.getToken(CypherParser.LOAD, 0);
  }
  CSV() {
    return this.getToken(CypherParser.CSV, 0);
  }
  FROM() {
    return this.getToken(CypherParser.FROM, 0);
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  AS() {
    return this.getToken(CypherParser.AS, 0);
  }
  variable() {
    return this.getTypedRuleContext(VariableContext, 0);
  }
  WITH() {
    return this.getToken(CypherParser.WITH, 0);
  }
  HEADERS() {
    return this.getToken(CypherParser.HEADERS, 0);
  }
  FIELDTERMINATOR() {
    return this.getToken(CypherParser.FIELDTERMINATOR, 0);
  }
  StringLiteral() {
    return this.getToken(CypherParser.StringLiteral, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterLoadCSVClause(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitLoadCSVClause(this);
    }
  }
};
var MatchClauseContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    _defineProperty(this, "hint", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(HintContext);
      } else {
        return this.getTypedRuleContext(HintContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_matchClause;
  }
  MATCH() {
    return this.getToken(CypherParser.MATCH, 0);
  }
  pattern() {
    return this.getTypedRuleContext(PatternContext, 0);
  }
  OPTIONAL() {
    return this.getToken(CypherParser.OPTIONAL, 0);
  }
  where() {
    return this.getTypedRuleContext(WhereContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterMatchClause(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitMatchClause(this);
    }
  }
};
var UnwindClauseContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_unwindClause;
  }
  UNWIND() {
    return this.getToken(CypherParser.UNWIND, 0);
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  AS() {
    return this.getToken(CypherParser.AS, 0);
  }
  variable() {
    return this.getTypedRuleContext(VariableContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterUnwindClause(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitUnwindClause(this);
    }
  }
};
var MergeClauseContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    _defineProperty(this, "mergeAction", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(MergeActionContext);
      } else {
        return this.getTypedRuleContext(MergeActionContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_mergeClause;
  }
  MERGE() {
    return this.getToken(CypherParser.MERGE, 0);
  }
  patternPart() {
    return this.getTypedRuleContext(PatternPartContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterMergeClause(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitMergeClause(this);
    }
  }
};
var MergeActionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_mergeAction;
  }
  ON() {
    return this.getToken(CypherParser.ON, 0);
  }
  MATCH() {
    return this.getToken(CypherParser.MATCH, 0);
  }
  setClause() {
    return this.getTypedRuleContext(SetClauseContext, 0);
  }
  CREATE() {
    return this.getToken(CypherParser.CREATE, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterMergeAction(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitMergeAction(this);
    }
  }
};
var CreateClauseContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_createClause;
  }
  CREATE() {
    return this.getToken(CypherParser.CREATE, 0);
  }
  pattern() {
    return this.getTypedRuleContext(PatternContext, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCreateClause(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCreateClause(this);
    }
  }
};
var CreateUniqueClauseContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_createUniqueClause;
  }
  CREATE() {
    return this.getToken(CypherParser.CREATE, 0);
  }
  UNIQUE() {
    return this.getToken(CypherParser.UNIQUE, 0);
  }
  pattern() {
    return this.getTypedRuleContext(PatternContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCreateUniqueClause(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCreateUniqueClause(this);
    }
  }
};
var SetClauseContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "setItem", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(SetItemContext);
      } else {
        return this.getTypedRuleContext(SetItemContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_setClause;
  }
  SET() {
    return this.getToken(CypherParser.SET, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterSetClause(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitSetClause(this);
    }
  }
};
var SetItemContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_setItem;
  }
  propertyExpression() {
    return this.getTypedRuleContext(PropertyExpressionContext, 0);
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  variable() {
    return this.getTypedRuleContext(VariableContext, 0);
  }
  nodeLabels() {
    return this.getTypedRuleContext(NodeLabelsContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterSetItem(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitSetItem(this);
    }
  }
};
var DeleteClauseContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "expression", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(ExpressionContext);
      } else {
        return this.getTypedRuleContext(ExpressionContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_deleteClause;
  }
  DELETE() {
    return this.getToken(CypherParser.DELETE, 0);
  }
  DETACH() {
    return this.getToken(CypherParser.DETACH, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterDeleteClause(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitDeleteClause(this);
    }
  }
};
var RemoveClauseContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    _defineProperty(this, "removeItem", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(RemoveItemContext);
      } else {
        return this.getTypedRuleContext(RemoveItemContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_removeClause;
  }
  REMOVE() {
    return this.getToken(CypherParser.REMOVE, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterRemoveClause(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitRemoveClause(this);
    }
  }
};
var RemoveItemContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_removeItem;
  }
  variable() {
    return this.getTypedRuleContext(VariableContext, 0);
  }
  nodeLabels() {
    return this.getTypedRuleContext(NodeLabelsContext, 0);
  }
  propertyExpression() {
    return this.getTypedRuleContext(PropertyExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterRemoveItem(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitRemoveItem(this);
    }
  }
};
var ForeachClauseContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    _defineProperty(this, "clause", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(ClauseContext);
      } else {
        return this.getTypedRuleContext(ClauseContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_foreachClause;
  }
  FOREACH() {
    return this.getToken(CypherParser.FOREACH, 0);
  }
  variable() {
    return this.getTypedRuleContext(VariableContext, 0);
  }
  IN() {
    return this.getToken(CypherParser.IN, 0);
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterForeachClause(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitForeachClause(this);
    }
  }
};
var WithClauseContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_withClause;
  }
  WITH() {
    return this.getToken(CypherParser.WITH, 0);
  }
  returnBody() {
    return this.getTypedRuleContext(ReturnBodyContext, 0);
  }
  DISTINCT() {
    return this.getToken(CypherParser.DISTINCT, 0);
  }
  where() {
    return this.getTypedRuleContext(WhereContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterWithClause(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitWithClause(this);
    }
  }
};
var ReturnClauseContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_returnClause;
  }
  RETURN() {
    return this.getToken(CypherParser.RETURN, 0);
  }
  returnBody() {
    return this.getTypedRuleContext(ReturnBodyContext, 0);
  }
  DISTINCT() {
    return this.getToken(CypherParser.DISTINCT, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterReturnClause(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitReturnClause(this);
    }
  }
};
var ReturnBodyContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_returnBody;
  }
  returnItems() {
    return this.getTypedRuleContext(ReturnItemsContext, 0);
  }
  order() {
    return this.getTypedRuleContext(OrderContext, 0);
  }
  skip() {
    return this.getTypedRuleContext(SkipContext, 0);
  }
  limit() {
    return this.getTypedRuleContext(LimitContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterReturnBody(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitReturnBody(this);
    }
  }
};
var FuncContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_func;
  }
  procedureInvocation() {
    return this.getTypedRuleContext(ProcedureInvocationContext, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  procedureResults() {
    return this.getTypedRuleContext(ProcedureResultsContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterFunc(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitFunc(this);
    }
  }
};
var ReturnItemsContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "returnItem", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(ReturnItemContext);
      } else {
        return this.getTypedRuleContext(ReturnItemContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_returnItems;
  }
  func() {
    return this.getTypedRuleContext(FuncContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterReturnItems(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitReturnItems(this);
    }
  }
};
var ReturnItemContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_returnItem;
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  AS() {
    return this.getToken(CypherParser.AS, 0);
  }
  variable() {
    return this.getTypedRuleContext(VariableContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterReturnItem(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitReturnItem(this);
    }
  }
};
var CallContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_call;
  }
  CALL() {
    return this.getToken(CypherParser.CALL, 0);
  }
  procedureInvocation() {
    return this.getTypedRuleContext(ProcedureInvocationContext, 0);
  }
  procedureResults() {
    return this.getTypedRuleContext(ProcedureResultsContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCall(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCall(this);
    }
  }
};
var ProcedureInvocationContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_procedureInvocation;
  }
  procedureInvocationBody() {
    return this.getTypedRuleContext(ProcedureInvocationBodyContext, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  procedureArguments() {
    return this.getTypedRuleContext(ProcedureArgumentsContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterProcedureInvocation(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitProcedureInvocation(this);
    }
  }
};
var ProcedureInvocationBodyContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_procedureInvocationBody;
  }
  namespace() {
    return this.getTypedRuleContext(NamespaceContext, 0);
  }
  procedureName() {
    return this.getTypedRuleContext(ProcedureNameContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterProcedureInvocationBody(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitProcedureInvocationBody(this);
    }
  }
};
var ProcedureArgumentsContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    _defineProperty(this, "expression", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(ExpressionContext);
      } else {
        return this.getTypedRuleContext(ExpressionContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_procedureArguments;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterProcedureArguments(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitProcedureArguments(this);
    }
  }
};
var ProcedureResultsContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    _defineProperty(this, "procedureResult", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(ProcedureResultContext);
      } else {
        return this.getTypedRuleContext(ProcedureResultContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_procedureResults;
  }
  YIELD() {
    return this.getToken(CypherParser.YIELD, 0);
  }
  where() {
    return this.getTypedRuleContext(WhereContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterProcedureResults(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitProcedureResults(this);
    }
  }
};
var ProcedureResultContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_procedureResult;
  }
  aliasedProcedureResult() {
    return this.getTypedRuleContext(AliasedProcedureResultContext, 0);
  }
  simpleProcedureResult() {
    return this.getTypedRuleContext(SimpleProcedureResultContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterProcedureResult(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitProcedureResult(this);
    }
  }
};
var AliasedProcedureResultContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_aliasedProcedureResult;
  }
  procedureOutput() {
    return this.getTypedRuleContext(ProcedureOutputContext, 0);
  }
  AS() {
    return this.getToken(CypherParser.AS, 0);
  }
  variable() {
    return this.getTypedRuleContext(VariableContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterAliasedProcedureResult(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitAliasedProcedureResult(this);
    }
  }
};
var SimpleProcedureResultContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_simpleProcedureResult;
  }
  procedureOutput() {
    return this.getTypedRuleContext(ProcedureOutputContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterSimpleProcedureResult(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitSimpleProcedureResult(this);
    }
  }
};
var ProcedureOutputContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_procedureOutput;
  }
  symbolicName() {
    return this.getTypedRuleContext(SymbolicNameContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterProcedureOutput(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitProcedureOutput(this);
    }
  }
};
var OrderContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    _defineProperty(this, "sortItem", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(SortItemContext);
      } else {
        return this.getTypedRuleContext(SortItemContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_order;
  }
  ORDER() {
    return this.getToken(CypherParser.ORDER, 0);
  }
  BY() {
    return this.getToken(CypherParser.BY, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterOrder(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitOrder(this);
    }
  }
};
var SkipContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_skip;
  }
  L_SKIP() {
    return this.getToken(CypherParser.L_SKIP, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterSkip(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitSkip(this);
    }
  }
};
var LimitContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_limit;
  }
  LIMIT() {
    return this.getToken(CypherParser.LIMIT, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterLimit(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitLimit(this);
    }
  }
};
var SortItemContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_sortItem;
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  ASCENDING() {
    return this.getToken(CypherParser.ASCENDING, 0);
  }
  ASC() {
    return this.getToken(CypherParser.ASC, 0);
  }
  DESCENDING() {
    return this.getToken(CypherParser.DESCENDING, 0);
  }
  DESC() {
    return this.getToken(CypherParser.DESC, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterSortItem(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitSortItem(this);
    }
  }
};
var HintContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    _defineProperty(this, "variable", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(VariableContext);
      } else {
        return this.getTypedRuleContext(VariableContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_hint;
  }
  USING() {
    return this.getToken(CypherParser.USING, 0);
  }
  INDEX() {
    return this.getToken(CypherParser.INDEX, 0);
  }
  nodeLabel() {
    return this.getTypedRuleContext(NodeLabelContext, 0);
  }
  propertyKeys() {
    return this.getTypedRuleContext(PropertyKeysContext, 0);
  }
  JOIN() {
    return this.getToken(CypherParser.JOIN, 0);
  }
  ON() {
    return this.getToken(CypherParser.ON, 0);
  }
  SCAN() {
    return this.getToken(CypherParser.SCAN, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterHint(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitHint(this);
    }
  }
};
var StartClauseContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    _defineProperty(this, "startPoint", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(StartPointContext);
      } else {
        return this.getTypedRuleContext(StartPointContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_startClause;
  }
  START() {
    return this.getToken(CypherParser.START, 0);
  }
  where() {
    return this.getTypedRuleContext(WhereContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterStartClause(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitStartClause(this);
    }
  }
};
var StartPointContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_startPoint;
  }
  variable() {
    return this.getTypedRuleContext(VariableContext, 0);
  }
  lookup() {
    return this.getTypedRuleContext(LookupContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterStartPoint(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitStartPoint(this);
    }
  }
};
var LookupContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_lookup;
  }
  nodeLookup() {
    return this.getTypedRuleContext(NodeLookupContext, 0);
  }
  relationshipLookup() {
    return this.getTypedRuleContext(RelationshipLookupContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterLookup(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitLookup(this);
    }
  }
};
var NodeLookupContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_nodeLookup;
  }
  NODE() {
    return this.getToken(CypherParser.NODE, 0);
  }
  identifiedIndexLookup() {
    return this.getTypedRuleContext(IdentifiedIndexLookupContext, 0);
  }
  indexQuery() {
    return this.getTypedRuleContext(IndexQueryContext, 0);
  }
  idLookup() {
    return this.getTypedRuleContext(IdLookupContext, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterNodeLookup(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitNodeLookup(this);
    }
  }
};
var RelationshipLookupContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_relationshipLookup;
  }
  RELATIONSHIP() {
    return this.getToken(CypherParser.RELATIONSHIP, 0);
  }
  REL() {
    return this.getToken(CypherParser.REL, 0);
  }
  identifiedIndexLookup() {
    return this.getTypedRuleContext(IdentifiedIndexLookupContext, 0);
  }
  indexQuery() {
    return this.getTypedRuleContext(IndexQueryContext, 0);
  }
  idLookup() {
    return this.getTypedRuleContext(IdLookupContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterRelationshipLookup(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitRelationshipLookup(this);
    }
  }
};
var IdentifiedIndexLookupContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "symbolicName", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(SymbolicNameContext);
      } else {
        return this.getTypedRuleContext(SymbolicNameContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_identifiedIndexLookup;
  }
  StringLiteral() {
    return this.getToken(CypherParser.StringLiteral, 0);
  }
  parameter() {
    return this.getTypedRuleContext(ParameterContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterIdentifiedIndexLookup(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitIdentifiedIndexLookup(this);
    }
  }
};
var IndexQueryContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_indexQuery;
  }
  symbolicName() {
    return this.getTypedRuleContext(SymbolicNameContext, 0);
  }
  StringLiteral() {
    return this.getToken(CypherParser.StringLiteral, 0);
  }
  parameter() {
    return this.getTypedRuleContext(ParameterContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterIndexQuery(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitIndexQuery(this);
    }
  }
};
var IdLookupContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_idLookup;
  }
  literalIds() {
    return this.getTypedRuleContext(LiteralIdsContext, 0);
  }
  parameter() {
    return this.getTypedRuleContext(ParameterContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterIdLookup(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitIdLookup(this);
    }
  }
};
var LiteralIdsContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "integerLiteral", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(IntegerLiteralContext);
      } else {
        return this.getTypedRuleContext(IntegerLiteralContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_literalIds;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterLiteralIds(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitLiteralIds(this);
    }
  }
};
var WhereContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_where;
  }
  WHERE() {
    return this.getToken(CypherParser.WHERE, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterWhere(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitWhere(this);
    }
  }
};
var PatternContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "patternPart", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(PatternPartContext);
      } else {
        return this.getTypedRuleContext(PatternPartContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_pattern;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterPattern(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitPattern(this);
    }
  }
};
var PatternPartContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_patternPart;
  }
  variable() {
    return this.getTypedRuleContext(VariableContext, 0);
  }
  anonymousPatternPart() {
    return this.getTypedRuleContext(AnonymousPatternPartContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterPatternPart(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitPatternPart(this);
    }
  }
};
var AnonymousPatternPartContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_anonymousPatternPart;
  }
  shortestPathPatternFunction() {
    return this.getTypedRuleContext(ShortestPathPatternFunctionContext, 0);
  }
  patternElement() {
    return this.getTypedRuleContext(PatternElementContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterAnonymousPatternPart(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitAnonymousPatternPart(this);
    }
  }
};
var PatternElementContext = class _PatternElementContext extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "patternElementChain", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(PatternElementChainContext);
      } else {
        return this.getTypedRuleContext(PatternElementChainContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_patternElement;
  }
  nodePattern() {
    return this.getTypedRuleContext(NodePatternContext, 0);
  }
  patternElement() {
    return this.getTypedRuleContext(_PatternElementContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterPatternElement(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitPatternElement(this);
    }
  }
};
var NodePatternContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_nodePattern;
  }
  variable() {
    return this.getTypedRuleContext(VariableContext, 0);
  }
  nodeLabels() {
    return this.getTypedRuleContext(NodeLabelsContext, 0);
  }
  properties() {
    return this.getTypedRuleContext(PropertiesContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterNodePattern(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitNodePattern(this);
    }
  }
};
var PatternElementChainContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_patternElementChain;
  }
  relationshipPattern() {
    return this.getTypedRuleContext(RelationshipPatternContext, 0);
  }
  nodePattern() {
    return this.getTypedRuleContext(NodePatternContext, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterPatternElementChain(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitPatternElementChain(this);
    }
  }
};
var RelationshipPatternContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_relationshipPattern;
  }
  relationshipPatternStart() {
    return this.getTypedRuleContext(RelationshipPatternStartContext, 0);
  }
  relationshipPatternEnd() {
    return this.getTypedRuleContext(RelationshipPatternEndContext, 0);
  }
  relationshipDetail() {
    return this.getTypedRuleContext(RelationshipDetailContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterRelationshipPattern(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitRelationshipPattern(this);
    }
  }
};
var RelationshipPatternStartContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_relationshipPatternStart;
  }
  leftArrowHead() {
    return this.getTypedRuleContext(LeftArrowHeadContext, 0);
  }
  dash() {
    return this.getTypedRuleContext(DashContext, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterRelationshipPatternStart(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitRelationshipPatternStart(this);
    }
  }
};
var RelationshipPatternEndContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_relationshipPatternEnd;
  }
  dash() {
    return this.getTypedRuleContext(DashContext, 0);
  }
  rightArrowHead() {
    return this.getTypedRuleContext(RightArrowHeadContext, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterRelationshipPatternEnd(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitRelationshipPatternEnd(this);
    }
  }
};
var RelationshipDetailContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_relationshipDetail;
  }
  variable() {
    return this.getTypedRuleContext(VariableContext, 0);
  }
  relationshipTypes() {
    return this.getTypedRuleContext(RelationshipTypesContext, 0);
  }
  rangeLiteral() {
    return this.getTypedRuleContext(RangeLiteralContext, 0);
  }
  properties() {
    return this.getTypedRuleContext(PropertiesContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterRelationshipDetail(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitRelationshipDetail(this);
    }
  }
};
var PropertiesContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_properties;
  }
  mapLiteral() {
    return this.getTypedRuleContext(MapLiteralContext, 0);
  }
  parameter() {
    return this.getTypedRuleContext(ParameterContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterProperties(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitProperties(this);
    }
  }
};
var RelTypeContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_relType;
  }
  relTypeName() {
    return this.getTypedRuleContext(RelTypeNameContext, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterRelType(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitRelType(this);
    }
  }
};
var RelationshipTypesContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "relationshipTypeOptionalColon", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(RelationshipTypeOptionalColonContext);
      } else {
        return this.getTypedRuleContext(RelationshipTypeOptionalColonContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_relationshipTypes;
  }
  relationshipType() {
    return this.getTypedRuleContext(RelationshipTypeContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterRelationshipTypes(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitRelationshipTypes(this);
    }
  }
};
var RelationshipTypeContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_relationshipType;
  }
  relTypeName() {
    return this.getTypedRuleContext(RelTypeNameContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterRelationshipType(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitRelationshipType(this);
    }
  }
};
var RelationshipTypeOptionalColonContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_relationshipTypeOptionalColon;
  }
  relTypeName() {
    return this.getTypedRuleContext(RelTypeNameContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterRelationshipTypeOptionalColon(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitRelationshipTypeOptionalColon(this);
    }
  }
};
var NodeLabelsContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "nodeLabel", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(NodeLabelContext);
      } else {
        return this.getTypedRuleContext(NodeLabelContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_nodeLabels;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterNodeLabels(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitNodeLabels(this);
    }
  }
};
var NodeLabelContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_nodeLabel;
  }
  labelName() {
    return this.getTypedRuleContext(LabelNameContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterNodeLabel(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitNodeLabel(this);
    }
  }
};
var RangeLiteralContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    _defineProperty(this, "integerLiteral", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(IntegerLiteralContext);
      } else {
        return this.getTypedRuleContext(IntegerLiteralContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_rangeLiteral;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterRangeLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitRangeLiteral(this);
    }
  }
};
var LabelNameContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_labelName;
  }
  symbolicName() {
    return this.getTypedRuleContext(SymbolicNameContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterLabelName(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitLabelName(this);
    }
  }
};
var RelTypeNameContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_relTypeName;
  }
  symbolicName() {
    return this.getTypedRuleContext(SymbolicNameContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterRelTypeName(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitRelTypeName(this);
    }
  }
};
var ExpressionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_expression;
  }
  orExpression() {
    return this.getTypedRuleContext(OrExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitExpression(this);
    }
  }
};
var OrExpressionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "xorExpression", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(XorExpressionContext);
      } else {
        return this.getTypedRuleContext(XorExpressionContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    _defineProperty(this, "OR", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.OR);
      } else {
        return this.getToken(CypherParser.OR, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_orExpression;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterOrExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitOrExpression(this);
    }
  }
};
var XorExpressionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "andExpression", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(AndExpressionContext);
      } else {
        return this.getTypedRuleContext(AndExpressionContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    _defineProperty(this, "XOR", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.XOR);
      } else {
        return this.getToken(CypherParser.XOR, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_xorExpression;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterXorExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitXorExpression(this);
    }
  }
};
var AndExpressionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "notExpression", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(NotExpressionContext);
      } else {
        return this.getTypedRuleContext(NotExpressionContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    _defineProperty(this, "AND", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.AND);
      } else {
        return this.getToken(CypherParser.AND, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_andExpression;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterAndExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitAndExpression(this);
    }
  }
};
var NotExpressionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "NOT", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.NOT);
      } else {
        return this.getToken(CypherParser.NOT, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_notExpression;
  }
  comparisonExpression() {
    return this.getTypedRuleContext(ComparisonExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterNotExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitNotExpression(this);
    }
  }
};
var ComparisonExpressionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "partialComparisonExpression", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(PartialComparisonExpressionContext);
      } else {
        return this.getTypedRuleContext(PartialComparisonExpressionContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_comparisonExpression;
  }
  addOrSubtractExpression() {
    return this.getTypedRuleContext(AddOrSubtractExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterComparisonExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitComparisonExpression(this);
    }
  }
};
var AddOrSubtractExpressionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "multiplyDivideModuloExpression", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(MultiplyDivideModuloExpressionContext);
      } else {
        return this.getTypedRuleContext(MultiplyDivideModuloExpressionContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_addOrSubtractExpression;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterAddOrSubtractExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitAddOrSubtractExpression(this);
    }
  }
};
var MultiplyDivideModuloExpressionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "powerOfExpression", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(PowerOfExpressionContext);
      } else {
        return this.getTypedRuleContext(PowerOfExpressionContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_multiplyDivideModuloExpression;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterMultiplyDivideModuloExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitMultiplyDivideModuloExpression(this);
    }
  }
};
var PowerOfExpressionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "unaryAddOrSubtractExpression", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(UnaryAddOrSubtractExpressionContext);
      } else {
        return this.getTypedRuleContext(UnaryAddOrSubtractExpressionContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_powerOfExpression;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterPowerOfExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitPowerOfExpression(this);
    }
  }
};
var UnaryAddOrSubtractExpressionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_unaryAddOrSubtractExpression;
  }
  stringListNullOperatorExpression() {
    return this.getTypedRuleContext(StringListNullOperatorExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterUnaryAddOrSubtractExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitUnaryAddOrSubtractExpression(this);
    }
  }
};
var StringListNullOperatorExpressionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "propertyOrLabelsExpression", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(PropertyOrLabelsExpressionContext);
      } else {
        return this.getTypedRuleContext(PropertyOrLabelsExpressionContext, i2);
      }
    });
    _defineProperty(this, "expression", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(ExpressionContext);
      } else {
        return this.getTypedRuleContext(ExpressionContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    _defineProperty(this, "IS", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.IS);
      } else {
        return this.getToken(CypherParser.IS, i2);
      }
    });
    _defineProperty(this, "NULL", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.NULL);
      } else {
        return this.getToken(CypherParser.NULL, i2);
      }
    });
    _defineProperty(this, "NOT", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.NOT);
      } else {
        return this.getToken(CypherParser.NOT, i2);
      }
    });
    _defineProperty(this, "IN", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.IN);
      } else {
        return this.getToken(CypherParser.IN, i2);
      }
    });
    _defineProperty(this, "STARTS", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.STARTS);
      } else {
        return this.getToken(CypherParser.STARTS, i2);
      }
    });
    _defineProperty(this, "WITH", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.WITH);
      } else {
        return this.getToken(CypherParser.WITH, i2);
      }
    });
    _defineProperty(this, "ENDS", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.ENDS);
      } else {
        return this.getToken(CypherParser.ENDS, i2);
      }
    });
    _defineProperty(this, "CONTAINS", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.CONTAINS);
      } else {
        return this.getToken(CypherParser.CONTAINS, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_stringListNullOperatorExpression;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterStringListNullOperatorExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitStringListNullOperatorExpression(this);
    }
  }
};
var PropertyOrLabelsExpressionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "propertyLookup", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(PropertyLookupContext);
      } else {
        return this.getTypedRuleContext(PropertyLookupContext, i2);
      }
    });
    _defineProperty(this, "nodeLabels", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(NodeLabelsContext);
      } else {
        return this.getTypedRuleContext(NodeLabelsContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_propertyOrLabelsExpression;
  }
  atom() {
    return this.getTypedRuleContext(AtomContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterPropertyOrLabelsExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitPropertyOrLabelsExpression(this);
    }
  }
};
var FilterFunctionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_filterFunction;
  }
  filterFunctionName() {
    return this.getTypedRuleContext(FilterFunctionNameContext, 0);
  }
  filterExpression() {
    return this.getTypedRuleContext(FilterExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterFilterFunction(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitFilterFunction(this);
    }
  }
};
var FilterFunctionNameContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_filterFunctionName;
  }
  FILTER() {
    return this.getToken(CypherParser.FILTER, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterFilterFunctionName(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitFilterFunctionName(this);
    }
  }
};
var ExistsFunctionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_existsFunction;
  }
  existsFunctionName() {
    return this.getTypedRuleContext(ExistsFunctionNameContext, 0);
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterExistsFunction(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitExistsFunction(this);
    }
  }
};
var ExistsFunctionNameContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_existsFunctionName;
  }
  EXISTS() {
    return this.getToken(CypherParser.EXISTS, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterExistsFunctionName(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitExistsFunctionName(this);
    }
  }
};
var AllFunctionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_allFunction;
  }
  allFunctionName() {
    return this.getTypedRuleContext(AllFunctionNameContext, 0);
  }
  filterExpression() {
    return this.getTypedRuleContext(FilterExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterAllFunction(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitAllFunction(this);
    }
  }
};
var AllFunctionNameContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_allFunctionName;
  }
  ALL() {
    return this.getToken(CypherParser.ALL, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterAllFunctionName(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitAllFunctionName(this);
    }
  }
};
var AnyFunctionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_anyFunction;
  }
  anyFunctionName() {
    return this.getTypedRuleContext(AnyFunctionNameContext, 0);
  }
  filterExpression() {
    return this.getTypedRuleContext(FilterExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterAnyFunction(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitAnyFunction(this);
    }
  }
};
var AnyFunctionNameContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_anyFunctionName;
  }
  ANY() {
    return this.getToken(CypherParser.ANY, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterAnyFunctionName(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitAnyFunctionName(this);
    }
  }
};
var NoneFunctionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_noneFunction;
  }
  noneFunctionName() {
    return this.getTypedRuleContext(NoneFunctionNameContext, 0);
  }
  filterExpression() {
    return this.getTypedRuleContext(FilterExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterNoneFunction(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitNoneFunction(this);
    }
  }
};
var NoneFunctionNameContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_noneFunctionName;
  }
  NONE() {
    return this.getToken(CypherParser.NONE, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterNoneFunctionName(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitNoneFunctionName(this);
    }
  }
};
var SingleFunctionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_singleFunction;
  }
  singleFunctionName() {
    return this.getTypedRuleContext(SingleFunctionNameContext, 0);
  }
  filterExpression() {
    return this.getTypedRuleContext(FilterExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterSingleFunction(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitSingleFunction(this);
    }
  }
};
var SingleFunctionNameContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_singleFunctionName;
  }
  SINGLE() {
    return this.getToken(CypherParser.SINGLE, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterSingleFunctionName(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitSingleFunctionName(this);
    }
  }
};
var ExtractFunctionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_extractFunction;
  }
  extractFunctionName() {
    return this.getTypedRuleContext(ExtractFunctionNameContext, 0);
  }
  filterExpression() {
    return this.getTypedRuleContext(FilterExpressionContext, 0);
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterExtractFunction(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitExtractFunction(this);
    }
  }
};
var ExtractFunctionNameContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_extractFunctionName;
  }
  EXTRACT() {
    return this.getToken(CypherParser.EXTRACT, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterExtractFunctionName(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitExtractFunctionName(this);
    }
  }
};
var ReduceFunctionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "expression", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(ExpressionContext);
      } else {
        return this.getTypedRuleContext(ExpressionContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_reduceFunction;
  }
  reduceFunctionName() {
    return this.getTypedRuleContext(ReduceFunctionNameContext, 0);
  }
  variable() {
    return this.getTypedRuleContext(VariableContext, 0);
  }
  idInColl() {
    return this.getTypedRuleContext(IdInCollContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterReduceFunction(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitReduceFunction(this);
    }
  }
};
var ReduceFunctionNameContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_reduceFunctionName;
  }
  REDUCE() {
    return this.getToken(CypherParser.REDUCE, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterReduceFunctionName(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitReduceFunctionName(this);
    }
  }
};
var ShortestPathPatternFunctionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_shortestPathPatternFunction;
  }
  shortestPathFunctionName() {
    return this.getTypedRuleContext(ShortestPathFunctionNameContext, 0);
  }
  patternElement() {
    return this.getTypedRuleContext(PatternElementContext, 0);
  }
  allShortestPathFunctionName() {
    return this.getTypedRuleContext(AllShortestPathFunctionNameContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterShortestPathPatternFunction(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitShortestPathPatternFunction(this);
    }
  }
};
var ShortestPathFunctionNameContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_shortestPathFunctionName;
  }
  SHORTESTPATH() {
    return this.getToken(CypherParser.SHORTESTPATH, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterShortestPathFunctionName(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitShortestPathFunctionName(this);
    }
  }
};
var AllShortestPathFunctionNameContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_allShortestPathFunctionName;
  }
  ALLSHORTESTPATHS() {
    return this.getToken(CypherParser.ALLSHORTESTPATHS, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterAllShortestPathFunctionName(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitAllShortestPathFunctionName(this);
    }
  }
};
var AtomContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_atom;
  }
  literal() {
    return this.getTypedRuleContext(LiteralContext, 0);
  }
  parameter() {
    return this.getTypedRuleContext(ParameterContext, 0);
  }
  caseExpression() {
    return this.getTypedRuleContext(CaseExpressionContext, 0);
  }
  COUNT() {
    return this.getToken(CypherParser.COUNT, 0);
  }
  listComprehension() {
    return this.getTypedRuleContext(ListComprehensionContext, 0);
  }
  patternComprehension() {
    return this.getTypedRuleContext(PatternComprehensionContext, 0);
  }
  filterFunction() {
    return this.getTypedRuleContext(FilterFunctionContext, 0);
  }
  extractFunction() {
    return this.getTypedRuleContext(ExtractFunctionContext, 0);
  }
  reduceFunction() {
    return this.getTypedRuleContext(ReduceFunctionContext, 0);
  }
  allFunction() {
    return this.getTypedRuleContext(AllFunctionContext, 0);
  }
  anyFunction() {
    return this.getTypedRuleContext(AnyFunctionContext, 0);
  }
  noneFunction() {
    return this.getTypedRuleContext(NoneFunctionContext, 0);
  }
  singleFunction() {
    return this.getTypedRuleContext(SingleFunctionContext, 0);
  }
  existsFunction() {
    return this.getTypedRuleContext(ExistsFunctionContext, 0);
  }
  shortestPathPatternFunction() {
    return this.getTypedRuleContext(ShortestPathPatternFunctionContext, 0);
  }
  relationshipsPattern() {
    return this.getTypedRuleContext(RelationshipsPatternContext, 0);
  }
  parenthesizedExpression() {
    return this.getTypedRuleContext(ParenthesizedExpressionContext, 0);
  }
  functionInvocation() {
    return this.getTypedRuleContext(FunctionInvocationContext, 0);
  }
  variable() {
    return this.getTypedRuleContext(VariableContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterAtom(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitAtom(this);
    }
  }
};
var LiteralContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_literal;
  }
  numberLiteral() {
    return this.getTypedRuleContext(NumberLiteralContext, 0);
  }
  stringLiteral() {
    return this.getTypedRuleContext(StringLiteralContext, 0);
  }
  booleanLiteral() {
    return this.getTypedRuleContext(BooleanLiteralContext, 0);
  }
  NULL() {
    return this.getToken(CypherParser.NULL, 0);
  }
  mapLiteral() {
    return this.getTypedRuleContext(MapLiteralContext, 0);
  }
  listLiteral() {
    return this.getTypedRuleContext(ListLiteralContext, 0);
  }
  mapProjection() {
    return this.getTypedRuleContext(MapProjectionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitLiteral(this);
    }
  }
};
var StringLiteralContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_stringLiteral;
  }
  StringLiteral() {
    return this.getToken(CypherParser.StringLiteral, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterStringLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitStringLiteral(this);
    }
  }
};
var BooleanLiteralContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_booleanLiteral;
  }
  TRUE() {
    return this.getToken(CypherParser.TRUE, 0);
  }
  FALSE() {
    return this.getToken(CypherParser.FALSE, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterBooleanLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitBooleanLiteral(this);
    }
  }
};
var ListLiteralContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    _defineProperty(this, "expression", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(ExpressionContext);
      } else {
        return this.getTypedRuleContext(ExpressionContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_listLiteral;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterListLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitListLiteral(this);
    }
  }
};
var PartialComparisonExpressionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_partialComparisonExpression;
  }
  addOrSubtractExpression() {
    return this.getTypedRuleContext(AddOrSubtractExpressionContext, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterPartialComparisonExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitPartialComparisonExpression(this);
    }
  }
};
var ParenthesizedExpressionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_parenthesizedExpression;
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterParenthesizedExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitParenthesizedExpression(this);
    }
  }
};
var RelationshipsPatternContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "patternElementChain", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(PatternElementChainContext);
      } else {
        return this.getTypedRuleContext(PatternElementChainContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_relationshipsPattern;
  }
  nodePattern() {
    return this.getTypedRuleContext(NodePatternContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterRelationshipsPattern(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitRelationshipsPattern(this);
    }
  }
};
var FilterExpressionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_filterExpression;
  }
  idInColl() {
    return this.getTypedRuleContext(IdInCollContext, 0);
  }
  where() {
    return this.getTypedRuleContext(WhereContext, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterFilterExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitFilterExpression(this);
    }
  }
};
var IdInCollContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_idInColl;
  }
  variable() {
    return this.getTypedRuleContext(VariableContext, 0);
  }
  IN() {
    return this.getToken(CypherParser.IN, 0);
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterIdInColl(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitIdInColl(this);
    }
  }
};
var FunctionInvocationContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    _defineProperty(this, "expression", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(ExpressionContext);
      } else {
        return this.getTypedRuleContext(ExpressionContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_functionInvocation;
  }
  functionInvocationBody() {
    return this.getTypedRuleContext(FunctionInvocationBodyContext, 0);
  }
  DISTINCT() {
    return this.getToken(CypherParser.DISTINCT, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterFunctionInvocation(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitFunctionInvocation(this);
    }
  }
};
var FunctionInvocationBodyContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_functionInvocationBody;
  }
  namespace() {
    return this.getTypedRuleContext(NamespaceContext, 0);
  }
  functionName() {
    return this.getTypedRuleContext(FunctionNameContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterFunctionInvocationBody(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitFunctionInvocationBody(this);
    }
  }
};
var FunctionNameContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_functionName;
  }
  UnescapedSymbolicName() {
    return this.getToken(CypherParser.UnescapedSymbolicName, 0);
  }
  EscapedSymbolicName() {
    return this.getToken(CypherParser.EscapedSymbolicName, 0);
  }
  COUNT() {
    return this.getToken(CypherParser.COUNT, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterFunctionName(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitFunctionName(this);
    }
  }
};
var ProcedureNameContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_procedureName;
  }
  symbolicName() {
    return this.getTypedRuleContext(SymbolicNameContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterProcedureName(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitProcedureName(this);
    }
  }
};
var ListComprehensionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_listComprehension;
  }
  filterExpression() {
    return this.getTypedRuleContext(FilterExpressionContext, 0);
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterListComprehension(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitListComprehension(this);
    }
  }
};
var PatternComprehensionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "expression", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(ExpressionContext);
      } else {
        return this.getTypedRuleContext(ExpressionContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_patternComprehension;
  }
  relationshipsPattern() {
    return this.getTypedRuleContext(RelationshipsPatternContext, 0);
  }
  variable() {
    return this.getTypedRuleContext(VariableContext, 0);
  }
  WHERE() {
    return this.getToken(CypherParser.WHERE, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterPatternComprehension(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitPatternComprehension(this);
    }
  }
};
var PropertyLookupContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_propertyLookup;
  }
  propertyKeyName() {
    return this.getTypedRuleContext(PropertyKeyNameContext, 0);
  }
  SP() {
    return this.getToken(CypherParser.SP, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterPropertyLookup(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitPropertyLookup(this);
    }
  }
};
var CaseExpressionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "expression", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(ExpressionContext);
      } else {
        return this.getTypedRuleContext(ExpressionContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    _defineProperty(this, "caseAlternatives", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(CaseAlternativesContext);
      } else {
        return this.getTypedRuleContext(CaseAlternativesContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_caseExpression;
  }
  END() {
    return this.getToken(CypherParser.END, 0);
  }
  ELSE() {
    return this.getToken(CypherParser.ELSE, 0);
  }
  CASE() {
    return this.getToken(CypherParser.CASE, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCaseExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCaseExpression(this);
    }
  }
};
var CaseAlternativesContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "expression", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(ExpressionContext);
      } else {
        return this.getTypedRuleContext(ExpressionContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_caseAlternatives;
  }
  WHEN() {
    return this.getToken(CypherParser.WHEN, 0);
  }
  THEN() {
    return this.getToken(CypherParser.THEN, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterCaseAlternatives(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitCaseAlternatives(this);
    }
  }
};
var VariableContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_variable;
  }
  symbolicName() {
    return this.getTypedRuleContext(SymbolicNameContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterVariable(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitVariable(this);
    }
  }
};
var NumberLiteralContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_numberLiteral;
  }
  doubleLiteral() {
    return this.getTypedRuleContext(DoubleLiteralContext, 0);
  }
  integerLiteral() {
    return this.getTypedRuleContext(IntegerLiteralContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterNumberLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitNumberLiteral(this);
    }
  }
};
var MapLiteralContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    _defineProperty(this, "literalEntry", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(LiteralEntryContext);
      } else {
        return this.getTypedRuleContext(LiteralEntryContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_mapLiteral;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterMapLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitMapLiteral(this);
    }
  }
};
var MapProjectionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    _defineProperty(this, "mapProjectionVariants", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(MapProjectionVariantsContext);
      } else {
        return this.getTypedRuleContext(MapProjectionVariantsContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_mapProjection;
  }
  variable() {
    return this.getTypedRuleContext(VariableContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterMapProjection(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitMapProjection(this);
    }
  }
};
var MapProjectionVariantsContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_mapProjectionVariants;
  }
  literalEntry() {
    return this.getTypedRuleContext(LiteralEntryContext, 0);
  }
  propertySelector() {
    return this.getTypedRuleContext(PropertySelectorContext, 0);
  }
  variableSelector() {
    return this.getTypedRuleContext(VariableSelectorContext, 0);
  }
  allPropertiesSelector() {
    return this.getTypedRuleContext(AllPropertiesSelectorContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterMapProjectionVariants(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitMapProjectionVariants(this);
    }
  }
};
var LiteralEntryContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_literalEntry;
  }
  propertyKeyName() {
    return this.getTypedRuleContext(PropertyKeyNameContext, 0);
  }
  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterLiteralEntry(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitLiteralEntry(this);
    }
  }
};
var PropertySelectorContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_propertySelector;
  }
  variable() {
    return this.getTypedRuleContext(VariableContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterPropertySelector(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitPropertySelector(this);
    }
  }
};
var VariableSelectorContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_variableSelector;
  }
  variable() {
    return this.getTypedRuleContext(VariableContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterVariableSelector(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitVariableSelector(this);
    }
  }
};
var AllPropertiesSelectorContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_allPropertiesSelector;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterAllPropertiesSelector(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitAllPropertiesSelector(this);
    }
  }
};
var ParameterContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_parameter;
  }
  legacyParameter() {
    return this.getTypedRuleContext(LegacyParameterContext, 0);
  }
  newParameter() {
    return this.getTypedRuleContext(NewParameterContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterParameter(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitParameter(this);
    }
  }
};
var LegacyParameterContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_legacyParameter;
  }
  parameterName() {
    return this.getTypedRuleContext(ParameterNameContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterLegacyParameter(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitLegacyParameter(this);
    }
  }
};
var NewParameterContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_newParameter;
  }
  parameterName() {
    return this.getTypedRuleContext(ParameterNameContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterNewParameter(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitNewParameter(this);
    }
  }
};
var ParameterNameContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_parameterName;
  }
  symbolicName() {
    return this.getTypedRuleContext(SymbolicNameContext, 0);
  }
  DecimalInteger() {
    return this.getToken(CypherParser.DecimalInteger, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterParameterName(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitParameterName(this);
    }
  }
};
var PropertyExpressionsContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "propertyExpression", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(PropertyExpressionContext);
      } else {
        return this.getTypedRuleContext(PropertyExpressionContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_propertyExpressions;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterPropertyExpressions(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitPropertyExpressions(this);
    }
  }
};
var PropertyExpressionContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "propertyLookup", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(PropertyLookupContext);
      } else {
        return this.getTypedRuleContext(PropertyLookupContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_propertyExpression;
  }
  atom() {
    return this.getTypedRuleContext(AtomContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterPropertyExpression(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitPropertyExpression(this);
    }
  }
};
var PropertyKeysContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "propertyKeyName", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(PropertyKeyNameContext);
      } else {
        return this.getTypedRuleContext(PropertyKeyNameContext, i2);
      }
    });
    _defineProperty(this, "SP", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTokens(CypherParser.SP);
      } else {
        return this.getToken(CypherParser.SP, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_propertyKeys;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterPropertyKeys(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitPropertyKeys(this);
    }
  }
};
var PropertyKeyNameContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_propertyKeyName;
  }
  symbolicName() {
    return this.getTypedRuleContext(SymbolicNameContext, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterPropertyKeyName(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitPropertyKeyName(this);
    }
  }
};
var IntegerLiteralContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_integerLiteral;
  }
  HexInteger() {
    return this.getToken(CypherParser.HexInteger, 0);
  }
  OctalInteger() {
    return this.getToken(CypherParser.OctalInteger, 0);
  }
  DecimalInteger() {
    return this.getToken(CypherParser.DecimalInteger, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterIntegerLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitIntegerLiteral(this);
    }
  }
};
var DoubleLiteralContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_doubleLiteral;
  }
  ExponentDecimalReal() {
    return this.getToken(CypherParser.ExponentDecimalReal, 0);
  }
  RegularDecimalReal() {
    return this.getToken(CypherParser.RegularDecimalReal, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterDoubleLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitDoubleLiteral(this);
    }
  }
};
var NamespaceContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    _defineProperty(this, "symbolicName", function(i2) {
      if (i2 === void 0) {
        i2 = null;
      }
      if (i2 === null) {
        return this.getTypedRuleContexts(SymbolicNameContext);
      } else {
        return this.getTypedRuleContext(SymbolicNameContext, i2);
      }
    });
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_namespace;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterNamespace(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitNamespace(this);
    }
  }
};
var LeftArrowHeadContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_leftArrowHead;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterLeftArrowHead(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitLeftArrowHead(this);
    }
  }
};
var RightArrowHeadContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_rightArrowHead;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterRightArrowHead(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitRightArrowHead(this);
    }
  }
};
var DashContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_dash;
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterDash(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitDash(this);
    }
  }
};
var SymbolicNameContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_symbolicName;
  }
  keyword() {
    return this.getTypedRuleContext(KeywordContext, 0);
  }
  UnescapedSymbolicName() {
    return this.getToken(CypherParser.UnescapedSymbolicName, 0);
  }
  EscapedSymbolicName() {
    return this.getToken(CypherParser.EscapedSymbolicName, 0);
  }
  HexLetter() {
    return this.getToken(CypherParser.HexLetter, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterSymbolicName(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitSymbolicName(this);
    }
  }
};
var KeywordContext = class extends es_default.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === void 0) {
      parent = null;
    }
    if (invokingState === void 0 || invokingState === null) {
      invokingState = -1;
    }
    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CypherParser.RULE_keyword;
  }
  CYPHER() {
    return this.getToken(CypherParser.CYPHER, 0);
  }
  EXPLAIN() {
    return this.getToken(CypherParser.EXPLAIN, 0);
  }
  PROFILE() {
    return this.getToken(CypherParser.PROFILE, 0);
  }
  USING() {
    return this.getToken(CypherParser.USING, 0);
  }
  PERIODIC() {
    return this.getToken(CypherParser.PERIODIC, 0);
  }
  COMMIT() {
    return this.getToken(CypherParser.COMMIT, 0);
  }
  UNION() {
    return this.getToken(CypherParser.UNION, 0);
  }
  ALL() {
    return this.getToken(CypherParser.ALL, 0);
  }
  CREATE() {
    return this.getToken(CypherParser.CREATE, 0);
  }
  DROP() {
    return this.getToken(CypherParser.DROP, 0);
  }
  INDEX() {
    return this.getToken(CypherParser.INDEX, 0);
  }
  ON() {
    return this.getToken(CypherParser.ON, 0);
  }
  CONSTRAINT() {
    return this.getToken(CypherParser.CONSTRAINT, 0);
  }
  ASSERT() {
    return this.getToken(CypherParser.ASSERT, 0);
  }
  IS() {
    return this.getToken(CypherParser.IS, 0);
  }
  UNIQUE() {
    return this.getToken(CypherParser.UNIQUE, 0);
  }
  EXISTS() {
    return this.getToken(CypherParser.EXISTS, 0);
  }
  LOAD() {
    return this.getToken(CypherParser.LOAD, 0);
  }
  CSV() {
    return this.getToken(CypherParser.CSV, 0);
  }
  WITH() {
    return this.getToken(CypherParser.WITH, 0);
  }
  HEADERS() {
    return this.getToken(CypherParser.HEADERS, 0);
  }
  FROM() {
    return this.getToken(CypherParser.FROM, 0);
  }
  AS() {
    return this.getToken(CypherParser.AS, 0);
  }
  FIELDTERMINATOR() {
    return this.getToken(CypherParser.FIELDTERMINATOR, 0);
  }
  OPTIONAL() {
    return this.getToken(CypherParser.OPTIONAL, 0);
  }
  MATCH() {
    return this.getToken(CypherParser.MATCH, 0);
  }
  UNWIND() {
    return this.getToken(CypherParser.UNWIND, 0);
  }
  MERGE() {
    return this.getToken(CypherParser.MERGE, 0);
  }
  SET() {
    return this.getToken(CypherParser.SET, 0);
  }
  DETACH() {
    return this.getToken(CypherParser.DETACH, 0);
  }
  DELETE() {
    return this.getToken(CypherParser.DELETE, 0);
  }
  REMOVE() {
    return this.getToken(CypherParser.REMOVE, 0);
  }
  FOREACH() {
    return this.getToken(CypherParser.FOREACH, 0);
  }
  IN() {
    return this.getToken(CypherParser.IN, 0);
  }
  DISTINCT() {
    return this.getToken(CypherParser.DISTINCT, 0);
  }
  RETURN() {
    return this.getToken(CypherParser.RETURN, 0);
  }
  ORDER() {
    return this.getToken(CypherParser.ORDER, 0);
  }
  BY() {
    return this.getToken(CypherParser.BY, 0);
  }
  L_SKIP() {
    return this.getToken(CypherParser.L_SKIP, 0);
  }
  LIMIT() {
    return this.getToken(CypherParser.LIMIT, 0);
  }
  ASCENDING() {
    return this.getToken(CypherParser.ASCENDING, 0);
  }
  ASC() {
    return this.getToken(CypherParser.ASC, 0);
  }
  DESCENDING() {
    return this.getToken(CypherParser.DESCENDING, 0);
  }
  DESC() {
    return this.getToken(CypherParser.DESC, 0);
  }
  JOIN() {
    return this.getToken(CypherParser.JOIN, 0);
  }
  SCAN() {
    return this.getToken(CypherParser.SCAN, 0);
  }
  START() {
    return this.getToken(CypherParser.START, 0);
  }
  NODE() {
    return this.getToken(CypherParser.NODE, 0);
  }
  RELATIONSHIP() {
    return this.getToken(CypherParser.RELATIONSHIP, 0);
  }
  REL() {
    return this.getToken(CypherParser.REL, 0);
  }
  WHERE() {
    return this.getToken(CypherParser.WHERE, 0);
  }
  SHORTESTPATH() {
    return this.getToken(CypherParser.SHORTESTPATH, 0);
  }
  ALLSHORTESTPATHS() {
    return this.getToken(CypherParser.ALLSHORTESTPATHS, 0);
  }
  OR() {
    return this.getToken(CypherParser.OR, 0);
  }
  XOR() {
    return this.getToken(CypherParser.XOR, 0);
  }
  AND() {
    return this.getToken(CypherParser.AND, 0);
  }
  NOT() {
    return this.getToken(CypherParser.NOT, 0);
  }
  STARTS() {
    return this.getToken(CypherParser.STARTS, 0);
  }
  ENDS() {
    return this.getToken(CypherParser.ENDS, 0);
  }
  CONTAINS() {
    return this.getToken(CypherParser.CONTAINS, 0);
  }
  NULL() {
    return this.getToken(CypherParser.NULL, 0);
  }
  COUNT() {
    return this.getToken(CypherParser.COUNT, 0);
  }
  FILTER() {
    return this.getToken(CypherParser.FILTER, 0);
  }
  EXTRACT() {
    return this.getToken(CypherParser.EXTRACT, 0);
  }
  ANY() {
    return this.getToken(CypherParser.ANY, 0);
  }
  NONE() {
    return this.getToken(CypherParser.NONE, 0);
  }
  SINGLE() {
    return this.getToken(CypherParser.SINGLE, 0);
  }
  TRUE() {
    return this.getToken(CypherParser.TRUE, 0);
  }
  FALSE() {
    return this.getToken(CypherParser.FALSE, 0);
  }
  REDUCE() {
    return this.getToken(CypherParser.REDUCE, 0);
  }
  CASE() {
    return this.getToken(CypherParser.CASE, 0);
  }
  ELSE() {
    return this.getToken(CypherParser.ELSE, 0);
  }
  END() {
    return this.getToken(CypherParser.END, 0);
  }
  WHEN() {
    return this.getToken(CypherParser.WHEN, 0);
  }
  THEN() {
    return this.getToken(CypherParser.THEN, 0);
  }
  CALL() {
    return this.getToken(CypherParser.CALL, 0);
  }
  YIELD() {
    return this.getToken(CypherParser.YIELD, 0);
  }
  KEY() {
    return this.getToken(CypherParser.KEY, 0);
  }
  CATALOG() {
    return this.getToken(CypherParser.CATALOG, 0);
  }
  SHOW() {
    return this.getToken(CypherParser.SHOW, 0);
  }
  DEFAULT() {
    return this.getToken(CypherParser.DEFAULT, 0);
  }
  DBMS() {
    return this.getToken(CypherParser.DBMS, 0);
  }
  DATABASE() {
    return this.getToken(CypherParser.DATABASE, 0);
  }
  DATABASES() {
    return this.getToken(CypherParser.DATABASES, 0);
  }
  GRAPH() {
    return this.getToken(CypherParser.GRAPH, 0);
  }
  GRAPHS() {
    return this.getToken(CypherParser.GRAPHS, 0);
  }
  REPLACE() {
    return this.getToken(CypherParser.REPLACE, 0);
  }
  IF() {
    return this.getToken(CypherParser.IF, 0);
  }
  STOP() {
    return this.getToken(CypherParser.STOP, 0);
  }
  ROLE() {
    return this.getToken(CypherParser.ROLE, 0);
  }
  ROLES() {
    return this.getToken(CypherParser.ROLES, 0);
  }
  USER() {
    return this.getToken(CypherParser.USER, 0);
  }
  USERS() {
    return this.getToken(CypherParser.USERS, 0);
  }
  POPULATED() {
    return this.getToken(CypherParser.POPULATED, 0);
  }
  PASSWORD() {
    return this.getToken(CypherParser.PASSWORD, 0);
  }
  CHANGE() {
    return this.getToken(CypherParser.CHANGE, 0);
  }
  REQUIRED() {
    return this.getToken(CypherParser.REQUIRED, 0);
  }
  STATUS() {
    return this.getToken(CypherParser.STATUS, 0);
  }
  ACTIVE() {
    return this.getToken(CypherParser.ACTIVE, 0);
  }
  SUSPENDED() {
    return this.getToken(CypherParser.SUSPENDED, 0);
  }
  ALTER() {
    return this.getToken(CypherParser.ALTER, 0);
  }
  CURRENT() {
    return this.getToken(CypherParser.CURRENT, 0);
  }
  TO() {
    return this.getToken(CypherParser.TO, 0);
  }
  PRIVILEGES() {
    return this.getToken(CypherParser.PRIVILEGES, 0);
  }
  GRANT() {
    return this.getToken(CypherParser.GRANT, 0);
  }
  DENY() {
    return this.getToken(CypherParser.DENY, 0);
  }
  REVOKE() {
    return this.getToken(CypherParser.REVOKE, 0);
  }
  RELATIONSHIPS() {
    return this.getToken(CypherParser.RELATIONSHIPS, 0);
  }
  NODES() {
    return this.getToken(CypherParser.NODES, 0);
  }
  ELEMENT() {
    return this.getToken(CypherParser.ELEMENT, 0);
  }
  ELEMENTS() {
    return this.getToken(CypherParser.ELEMENTS, 0);
  }
  COPY() {
    return this.getToken(CypherParser.COPY, 0);
  }
  OF() {
    return this.getToken(CypherParser.OF, 0);
  }
  TRAVERSE() {
    return this.getToken(CypherParser.TRAVERSE, 0);
  }
  READ() {
    return this.getToken(CypherParser.READ, 0);
  }
  WRITE() {
    return this.getToken(CypherParser.WRITE, 0);
  }
  ACCESS() {
    return this.getToken(CypherParser.ACCESS, 0);
  }
  INDEXES() {
    return this.getToken(CypherParser.INDEXES, 0);
  }
  MANAGEMENT() {
    return this.getToken(CypherParser.MANAGEMENT, 0);
  }
  NEW() {
    return this.getToken(CypherParser.NEW, 0);
  }
  LABEL() {
    return this.getToken(CypherParser.LABEL, 0);
  }
  LABELS() {
    return this.getToken(CypherParser.LABELS, 0);
  }
  NAME() {
    return this.getToken(CypherParser.NAME, 0);
  }
  NAMES() {
    return this.getToken(CypherParser.NAMES, 0);
  }
  TYPE() {
    return this.getToken(CypherParser.TYPE, 0);
  }
  TYPES() {
    return this.getToken(CypherParser.TYPES, 0);
  }
  PROPERTY() {
    return this.getToken(CypherParser.PROPERTY, 0);
  }
  CONSTRAINTS() {
    return this.getToken(CypherParser.CONSTRAINTS, 0);
  }
  ASSIGN() {
    return this.getToken(CypherParser.ASSIGN, 0);
  }
  BTREE() {
    return this.getToken(CypherParser.BTREE, 0);
  }
  EXIST() {
    return this.getToken(CypherParser.EXIST, 0);
  }
  FOR() {
    return this.getToken(CypherParser.FOR, 0);
  }
  OPTIONS() {
    return this.getToken(CypherParser.OPTIONS, 0);
  }
  EXECUTE() {
    return this.getToken(CypherParser.EXECUTE, 0);
  }
  DEFINED() {
    return this.getToken(CypherParser.DEFINED, 0);
  }
  FUNCTION() {
    return this.getToken(CypherParser.FUNCTION, 0);
  }
  FUNCTIONS() {
    return this.getToken(CypherParser.FUNCTIONS, 0);
  }
  BOOSTED() {
    return this.getToken(CypherParser.BOOSTED, 0);
  }
  PROCEDURE() {
    return this.getToken(CypherParser.PROCEDURE, 0);
  }
  PROCEDURES() {
    return this.getToken(CypherParser.PROCEDURES, 0);
  }
  ADMIN() {
    return this.getToken(CypherParser.ADMIN, 0);
  }
  ADMINISTRATOR() {
    return this.getToken(CypherParser.ADMINISTRATOR, 0);
  }
  BRIEF() {
    return this.getToken(CypherParser.BRIEF, 0);
  }
  VERBOSE() {
    return this.getToken(CypherParser.VERBOSE, 0);
  }
  OUTPUT() {
    return this.getToken(CypherParser.OUTPUT, 0);
  }
  enterRule(listener) {
    if (listener instanceof CypherListener) {
      listener.enterKeyword(this);
    }
  }
  exitRule(listener) {
    if (listener instanceof CypherListener) {
      listener.exitKeyword(this);
    }
  }
};
CypherParser.CypherContext = CypherContext;
CypherParser.CypherPartContext = CypherPartContext;
CypherParser.CypherConsoleCommandContext = CypherConsoleCommandContext;
CypherParser.CypherConsoleCommandNameContext = CypherConsoleCommandNameContext;
CypherParser.CypherConsoleCommandParametersContext = CypherConsoleCommandParametersContext;
CypherParser.CypherConsoleCommandParameterContext = CypherConsoleCommandParameterContext;
CypherParser.ArrowExpressionContext = ArrowExpressionContext;
CypherParser.UrlContext = UrlContext;
CypherParser.UriContext = UriContext;
CypherParser.SchemeContext = SchemeContext;
CypherParser.HostContext = HostContext;
CypherParser.HostnameContext = HostnameContext;
CypherParser.HostnumberContext = HostnumberContext;
CypherParser.PortContext = PortContext;
CypherParser.PathContext = PathContext;
CypherParser.UserContext = UserContext;
CypherParser.LoginContext = LoginContext;
CypherParser.PasswordContext = PasswordContext;
CypherParser.FragContext = FragContext;
CypherParser.UrlQueryContext = UrlQueryContext;
CypherParser.SearchContext = SearchContext;
CypherParser.SearchparameterContext = SearchparameterContext;
CypherParser.StringContext = StringContext;
CypherParser.UrlDigitsContext = UrlDigitsContext;
CypherParser.JsonContext = JsonContext;
CypherParser.ObjContext = ObjContext;
CypherParser.PairContext = PairContext;
CypherParser.ArrayContext = ArrayContext;
CypherParser.ValueContext = ValueContext;
CypherParser.KeyValueLiteralContext = KeyValueLiteralContext;
CypherParser.CommandPathContext = CommandPathContext;
CypherParser.SubCommandContext = SubCommandContext;
CypherParser.CypherQueryContext = CypherQueryContext;
CypherParser.QueryOptionsContext = QueryOptionsContext;
CypherParser.AnyCypherOptionContext = AnyCypherOptionContext;
CypherParser.CypherOptionContext = CypherOptionContext;
CypherParser.VersionNumberContext = VersionNumberContext;
CypherParser.ExplainContext = ExplainContext;
CypherParser.ProfileContext = ProfileContext;
CypherParser.ConfigurationOptionContext = ConfigurationOptionContext;
CypherParser.StatementContext = StatementContext;
CypherParser.QueryContext = QueryContext;
CypherParser.RegularQueryContext = RegularQueryContext;
CypherParser.BulkImportQueryContext = BulkImportQueryContext;
CypherParser.SingleQueryContext = SingleQueryContext;
CypherParser.PeriodicCommitHintContext = PeriodicCommitHintContext;
CypherParser.LoadCSVQueryContext = LoadCSVQueryContext;
CypherParser.UnionContext = UnionContext;
CypherParser.ClauseContext = ClauseContext;
CypherParser.CommandContext = CommandContext;
CypherParser.SystemCommandContext = SystemCommandContext;
CypherParser.MultidatabaseCommandContext = MultidatabaseCommandContext;
CypherParser.UserCommandContext = UserCommandContext;
CypherParser.PrivilegeCommandContext = PrivilegeCommandContext;
CypherParser.ShowRolesContext = ShowRolesContext;
CypherParser.CreateRoleContext = CreateRoleContext;
CypherParser.CopyRoleContext = CopyRoleContext;
CypherParser.DropRoleContext = DropRoleContext;
CypherParser.ShowUsersContext = ShowUsersContext;
CypherParser.CreateUserContext = CreateUserContext;
CypherParser.DropUserContext = DropUserContext;
CypherParser.AlterUserContext = AlterUserContext;
CypherParser.ShowPrivilegesContext = ShowPrivilegesContext;
CypherParser.GrantPrivilegeContext = GrantPrivilegeContext;
CypherParser.DenyPrivilegeContext = DenyPrivilegeContext;
CypherParser.RevokePrivilegeContext = RevokePrivilegeContext;
CypherParser.RevokePartContext = RevokePartContext;
CypherParser.DatabaseScopeContext = DatabaseScopeContext;
CypherParser.GraphScopeContext = GraphScopeContext;
CypherParser.RolesContext = RolesContext;
CypherParser.GrantableGraphPrivilegesContext = GrantableGraphPrivilegesContext;
CypherParser.RevokeableGraphPrivilegesContext = RevokeableGraphPrivilegesContext;
CypherParser.DatasbasePrivilegeContext = DatasbasePrivilegeContext;
CypherParser.DbmsPrivilegeContext = DbmsPrivilegeContext;
CypherParser.ElementScopeContext = ElementScopeContext;
CypherParser.PropertiesListContext = PropertiesListContext;
CypherParser.PropertyScopeContext = PropertyScopeContext;
CypherParser.ShowDatabaseContext = ShowDatabaseContext;
CypherParser.CreateDatabaseContext = CreateDatabaseContext;
CypherParser.DropDatabaseContext = DropDatabaseContext;
CypherParser.StartDatabaseContext = StartDatabaseContext;
CypherParser.StopDatabaseContext = StopDatabaseContext;
CypherParser.IfNotExistsContext = IfNotExistsContext;
CypherParser.IfExistsContext = IfExistsContext;
CypherParser.OrReplaceContext = OrReplaceContext;
CypherParser.SetPasswordContext = SetPasswordContext;
CypherParser.PasswordStatusContext = PasswordStatusContext;
CypherParser.SetStatusContext = SetStatusContext;
CypherParser.UserStatusContext = UserStatusContext;
CypherParser.CreateUniqueConstraintContext = CreateUniqueConstraintContext;
CypherParser.CreateNodeKeyConstraintContext = CreateNodeKeyConstraintContext;
CypherParser.CreateNodePropertyExistenceConstraintContext = CreateNodePropertyExistenceConstraintContext;
CypherParser.CreateRelationshipPropertyExistenceConstraintContext = CreateRelationshipPropertyExistenceConstraintContext;
CypherParser.CreateIndexContext = CreateIndexContext;
CypherParser.DropUniqueConstraintContext = DropUniqueConstraintContext;
CypherParser.DropNodeKeyConstraintContext = DropNodeKeyConstraintContext;
CypherParser.DropNodePropertyExistenceConstraintContext = DropNodePropertyExistenceConstraintContext;
CypherParser.DropRelationshipPropertyExistenceConstraintContext = DropRelationshipPropertyExistenceConstraintContext;
CypherParser.DropIndexContext = DropIndexContext;
CypherParser.IndexContext = IndexContext;
CypherParser.UniqueConstraintContext = UniqueConstraintContext;
CypherParser.NodeKeyConstraintContext = NodeKeyConstraintContext;
CypherParser.NodePropertyExistenceConstraintContext = NodePropertyExistenceConstraintContext;
CypherParser.RelationshipPropertyExistenceConstraintContext = RelationshipPropertyExistenceConstraintContext;
CypherParser.RelationshipPatternSyntaxContext = RelationshipPatternSyntaxContext;
CypherParser.LoadCSVClauseContext = LoadCSVClauseContext;
CypherParser.MatchClauseContext = MatchClauseContext;
CypherParser.UnwindClauseContext = UnwindClauseContext;
CypherParser.MergeClauseContext = MergeClauseContext;
CypherParser.MergeActionContext = MergeActionContext;
CypherParser.CreateClauseContext = CreateClauseContext;
CypherParser.CreateUniqueClauseContext = CreateUniqueClauseContext;
CypherParser.SetClauseContext = SetClauseContext;
CypherParser.SetItemContext = SetItemContext;
CypherParser.DeleteClauseContext = DeleteClauseContext;
CypherParser.RemoveClauseContext = RemoveClauseContext;
CypherParser.RemoveItemContext = RemoveItemContext;
CypherParser.ForeachClauseContext = ForeachClauseContext;
CypherParser.WithClauseContext = WithClauseContext;
CypherParser.ReturnClauseContext = ReturnClauseContext;
CypherParser.ReturnBodyContext = ReturnBodyContext;
CypherParser.FuncContext = FuncContext;
CypherParser.ReturnItemsContext = ReturnItemsContext;
CypherParser.ReturnItemContext = ReturnItemContext;
CypherParser.CallContext = CallContext;
CypherParser.ProcedureInvocationContext = ProcedureInvocationContext;
CypherParser.ProcedureInvocationBodyContext = ProcedureInvocationBodyContext;
CypherParser.ProcedureArgumentsContext = ProcedureArgumentsContext;
CypherParser.ProcedureResultsContext = ProcedureResultsContext;
CypherParser.ProcedureResultContext = ProcedureResultContext;
CypherParser.AliasedProcedureResultContext = AliasedProcedureResultContext;
CypherParser.SimpleProcedureResultContext = SimpleProcedureResultContext;
CypherParser.ProcedureOutputContext = ProcedureOutputContext;
CypherParser.OrderContext = OrderContext;
CypherParser.SkipContext = SkipContext;
CypherParser.LimitContext = LimitContext;
CypherParser.SortItemContext = SortItemContext;
CypherParser.HintContext = HintContext;
CypherParser.StartClauseContext = StartClauseContext;
CypherParser.StartPointContext = StartPointContext;
CypherParser.LookupContext = LookupContext;
CypherParser.NodeLookupContext = NodeLookupContext;
CypherParser.RelationshipLookupContext = RelationshipLookupContext;
CypherParser.IdentifiedIndexLookupContext = IdentifiedIndexLookupContext;
CypherParser.IndexQueryContext = IndexQueryContext;
CypherParser.IdLookupContext = IdLookupContext;
CypherParser.LiteralIdsContext = LiteralIdsContext;
CypherParser.WhereContext = WhereContext;
CypherParser.PatternContext = PatternContext;
CypherParser.PatternPartContext = PatternPartContext;
CypherParser.AnonymousPatternPartContext = AnonymousPatternPartContext;
CypherParser.PatternElementContext = PatternElementContext;
CypherParser.NodePatternContext = NodePatternContext;
CypherParser.PatternElementChainContext = PatternElementChainContext;
CypherParser.RelationshipPatternContext = RelationshipPatternContext;
CypherParser.RelationshipPatternStartContext = RelationshipPatternStartContext;
CypherParser.RelationshipPatternEndContext = RelationshipPatternEndContext;
CypherParser.RelationshipDetailContext = RelationshipDetailContext;
CypherParser.PropertiesContext = PropertiesContext;
CypherParser.RelTypeContext = RelTypeContext;
CypherParser.RelationshipTypesContext = RelationshipTypesContext;
CypherParser.RelationshipTypeContext = RelationshipTypeContext;
CypherParser.RelationshipTypeOptionalColonContext = RelationshipTypeOptionalColonContext;
CypherParser.NodeLabelsContext = NodeLabelsContext;
CypherParser.NodeLabelContext = NodeLabelContext;
CypherParser.RangeLiteralContext = RangeLiteralContext;
CypherParser.LabelNameContext = LabelNameContext;
CypherParser.RelTypeNameContext = RelTypeNameContext;
CypherParser.ExpressionContext = ExpressionContext;
CypherParser.OrExpressionContext = OrExpressionContext;
CypherParser.XorExpressionContext = XorExpressionContext;
CypherParser.AndExpressionContext = AndExpressionContext;
CypherParser.NotExpressionContext = NotExpressionContext;
CypherParser.ComparisonExpressionContext = ComparisonExpressionContext;
CypherParser.AddOrSubtractExpressionContext = AddOrSubtractExpressionContext;
CypherParser.MultiplyDivideModuloExpressionContext = MultiplyDivideModuloExpressionContext;
CypherParser.PowerOfExpressionContext = PowerOfExpressionContext;
CypherParser.UnaryAddOrSubtractExpressionContext = UnaryAddOrSubtractExpressionContext;
CypherParser.StringListNullOperatorExpressionContext = StringListNullOperatorExpressionContext;
CypherParser.PropertyOrLabelsExpressionContext = PropertyOrLabelsExpressionContext;
CypherParser.FilterFunctionContext = FilterFunctionContext;
CypherParser.FilterFunctionNameContext = FilterFunctionNameContext;
CypherParser.ExistsFunctionContext = ExistsFunctionContext;
CypherParser.ExistsFunctionNameContext = ExistsFunctionNameContext;
CypherParser.AllFunctionContext = AllFunctionContext;
CypherParser.AllFunctionNameContext = AllFunctionNameContext;
CypherParser.AnyFunctionContext = AnyFunctionContext;
CypherParser.AnyFunctionNameContext = AnyFunctionNameContext;
CypherParser.NoneFunctionContext = NoneFunctionContext;
CypherParser.NoneFunctionNameContext = NoneFunctionNameContext;
CypherParser.SingleFunctionContext = SingleFunctionContext;
CypherParser.SingleFunctionNameContext = SingleFunctionNameContext;
CypherParser.ExtractFunctionContext = ExtractFunctionContext;
CypherParser.ExtractFunctionNameContext = ExtractFunctionNameContext;
CypherParser.ReduceFunctionContext = ReduceFunctionContext;
CypherParser.ReduceFunctionNameContext = ReduceFunctionNameContext;
CypherParser.ShortestPathPatternFunctionContext = ShortestPathPatternFunctionContext;
CypherParser.ShortestPathFunctionNameContext = ShortestPathFunctionNameContext;
CypherParser.AllShortestPathFunctionNameContext = AllShortestPathFunctionNameContext;
CypherParser.AtomContext = AtomContext;
CypherParser.LiteralContext = LiteralContext;
CypherParser.StringLiteralContext = StringLiteralContext;
CypherParser.BooleanLiteralContext = BooleanLiteralContext;
CypherParser.ListLiteralContext = ListLiteralContext;
CypherParser.PartialComparisonExpressionContext = PartialComparisonExpressionContext;
CypherParser.ParenthesizedExpressionContext = ParenthesizedExpressionContext;
CypherParser.RelationshipsPatternContext = RelationshipsPatternContext;
CypherParser.FilterExpressionContext = FilterExpressionContext;
CypherParser.IdInCollContext = IdInCollContext;
CypherParser.FunctionInvocationContext = FunctionInvocationContext;
CypherParser.FunctionInvocationBodyContext = FunctionInvocationBodyContext;
CypherParser.FunctionNameContext = FunctionNameContext;
CypherParser.ProcedureNameContext = ProcedureNameContext;
CypherParser.ListComprehensionContext = ListComprehensionContext;
CypherParser.PatternComprehensionContext = PatternComprehensionContext;
CypherParser.PropertyLookupContext = PropertyLookupContext;
CypherParser.CaseExpressionContext = CaseExpressionContext;
CypherParser.CaseAlternativesContext = CaseAlternativesContext;
CypherParser.VariableContext = VariableContext;
CypherParser.NumberLiteralContext = NumberLiteralContext;
CypherParser.MapLiteralContext = MapLiteralContext;
CypherParser.MapProjectionContext = MapProjectionContext;
CypherParser.MapProjectionVariantsContext = MapProjectionVariantsContext;
CypherParser.LiteralEntryContext = LiteralEntryContext;
CypherParser.PropertySelectorContext = PropertySelectorContext;
CypherParser.VariableSelectorContext = VariableSelectorContext;
CypherParser.AllPropertiesSelectorContext = AllPropertiesSelectorContext;
CypherParser.ParameterContext = ParameterContext;
CypherParser.LegacyParameterContext = LegacyParameterContext;
CypherParser.NewParameterContext = NewParameterContext;
CypherParser.ParameterNameContext = ParameterNameContext;
CypherParser.PropertyExpressionsContext = PropertyExpressionsContext;
CypherParser.PropertyExpressionContext = PropertyExpressionContext;
CypherParser.PropertyKeysContext = PropertyKeysContext;
CypherParser.PropertyKeyNameContext = PropertyKeyNameContext;
CypherParser.IntegerLiteralContext = IntegerLiteralContext;
CypherParser.DoubleLiteralContext = DoubleLiteralContext;
CypherParser.NamespaceContext = NamespaceContext;
CypherParser.LeftArrowHeadContext = LeftArrowHeadContext;
CypherParser.RightArrowHeadContext = RightArrowHeadContext;
CypherParser.DashContext = DashContext;
CypherParser.SymbolicNameContext = SymbolicNameContext;
CypherParser.KeywordContext = KeywordContext;

// node_modules/@neo4j-cypher/editor-support/es/lang/CypherTypes.js
var VARIABLE_CONTEXT = CypherParser.VariableContext;
var LABEL_NAME_CONTEXT = CypherParser.LabelNameContext;
var RELATIONSHIP_TYPE_NAME_CONTEXT = CypherParser.RelTypeNameContext;
var PROPERTY_KEY_NAME_CONTEXT = CypherParser.PropertyKeyNameContext;
var PARAMETER_NAME_CONTEXT = CypherParser.ParameterNameContext;
var PARAMETER_CONTEXT = CypherParser.ParameterContext;
var FUNCTION_NAME_CONTEXT = CypherParser.FunctionInvocationBodyContext;
var PROCEDURE_NAME_CONTEXT = CypherParser.ProcedureInvocationBodyContext;
var CONSOLE_COMMAND_NAME_CONTEXT = CypherParser.CypherConsoleCommandNameContext;
var CONSOLE_COMMAND_CONTEXT = CypherParser.CypherConsoleCommandContext;
var CONSOLE_COMMAND_PARAMETERS_CONTEXT = CypherParser.CypherConsoleCommandParametersContext;
var CONSOLE_COMMAND_PARAMETER_CONTEXT = CypherParser.CypherConsoleCommandParameterContext;
var CONSOLE_COMMAND_SUBCOMMAND_CONTEXT = CypherParser.SubCommandContext;
var CONSOLE_COMMAND_PATH_CONTEXT = CypherParser.CommandPathContext;
var PROCEDURE_OUTPUT_CONTEXT = CypherParser.ProcedureOutputContext;
var PROCEDURE_RESULTS_CONTEXT = CypherParser.ProcedureResultsContext;
var ALL_FUNCTION_NAME_CONTEXT = CypherParser.AllFunctionNameContext;
var ANY_FUNCTION_NAME_CONTEXT = CypherParser.AnyFunctionNameContext;
var SINGLE_FUNCTION_NAME_CONTEXT = CypherParser.SingleFunctionNameContext;
var NONE_FUNCTION_NAME_CONTEXT = CypherParser.NoneFunctionNameContext;
var EXTRACT_FUNCTION_NAME_CONTEXT = CypherParser.ExtractFunctionNameContext;
var REDUCE_FUNCTION_NAME_CONTEXT = CypherParser.ReduceFunctionNameContext;
var SHORTEST_PATH_FUNCTION_NAME_CONTEXT = CypherParser.ShortestPathFunctionNameContext;
var ALL_SHORTEST_PATH_FUNCTION_NAME_CONTEXT = CypherParser.AllShortestPathFunctionNameContext;
var FILTER_FUNCTION_NAME_CONTEXT = CypherParser.FilterFunctionNameContext;
var EXISTS_FUNCTION_NAME_CONTEXT = CypherParser.ExistsFunctionNameContext;
var CALL_CONTEXT = CypherParser.CallContext;
var EXPRESSION_CONTEXT = CypherParser.ExpressionContext;
var PATTERN_ELEMENT_CONTEXT = CypherParser.PatternElementContext;
var NODE_PATTERN_CONTEXT = CypherParser.NodePatternContext;
var NODE_LABEL_CONTEXT = CypherParser.NodeLabelContext;
var NODE_LABELS_CONTEXT = CypherParser.NodeLabelsContext;
var RELATIONSHIP_TYPE_CONTEXT = CypherParser.RelationshipTypeContext;
var RELATIONSHIP_TYPE_OPTIONAL_COLON_CONTEXT = CypherParser.RelationshipTypeOptionalColonContext;
var RELATIONSHIP_TYPES_CONTEXT = CypherParser.RelationshipTypesContext;
var RELATIONSHIP_PATTERN_CONTEXT = CypherParser.RelationshipPatternContext;
var PROPERTY_LOOKUP_CONTEXT = CypherParser.PropertyLookupContext;
var MAP_LITERAL_CONTEXT = CypherParser.MapLiteralContext;
var PROPERTIES_CONTEXT = CypherParser.PropertiesContext;
var MAP_LITERAL_ENTRY = CypherParser.LiteralEntryContext;
var STRING_LITERAL_CONTEXT = CypherParser.StringLiteralContext;
var ATOM_CONTEXT = CypherParser.AtomContext;
var QUERY_CONTEXT = CypherParser.CypherQueryContext;
var SYMBOLIC_NAME_CONTEXT = CypherParser.SymbolicNameContext;
var COMPLETION_CANDIDATES = [STRING_LITERAL_CONTEXT, VARIABLE_CONTEXT, PROCEDURE_NAME_CONTEXT, FUNCTION_NAME_CONTEXT, CONSOLE_COMMAND_NAME_CONTEXT, NODE_LABEL_CONTEXT, RELATIONSHIP_TYPE_CONTEXT, RELATIONSHIP_TYPE_OPTIONAL_COLON_CONTEXT];
var SYMBOLIC_CONTEXTS = [VARIABLE_CONTEXT, LABEL_NAME_CONTEXT, RELATIONSHIP_TYPE_NAME_CONTEXT, PROPERTY_KEY_NAME_CONTEXT, PARAMETER_NAME_CONTEXT];

// node_modules/@neo4j-cypher/editor-support/es/util/TreeUtils.js
var TreeUtils = class _TreeUtils {
  static findParent(pt2, type) {
    let el = pt2;
    while (true) {
      if (el == null) {
        return null;
      }
      if (el instanceof type) {
        return el;
      }
      el = el.parentCtx;
    }
  }
  static findAnyParent(pt2, types2 = []) {
    let el = pt2;
    while (true) {
      if (el == null) {
        return null;
      }
      for (let type of types2) {
        if (el instanceof type) {
          return el;
        }
      }
      el = el.parentCtx;
    }
  }
  static findChild(element, type) {
    if (element == null) {
      return null;
    }
    if (element instanceof type) {
      return element;
    }
    if (element.children != null) {
      for (let i2 = 0; i2 < element.children.length; i2 += 1) {
        const e4 = element.children[i2];
        const result = _TreeUtils.findChild(e4, type);
        if (result != null) {
          return result;
        }
      }
    }
    return null;
  }
  static getPosition(el) {
    if (el != null) {
      const {
        start: start2,
        stop,
        symbol
      } = el;
      if (symbol != null) {
        return {
          start: symbol.start,
          stop: symbol.stop
        };
      } else if (start2 != null && stop != null) {
        return {
          start: start2.start,
          stop: stop.stop
        };
      }
    }
    return null;
  }
  static hasErrorNode(element) {
    if (element == null) {
      return false;
    }
    if (element.isErrorNode && element.isErrorNode()) {
      return true;
    }
    if (element.children != null) {
      for (let i2 = 0; i2 < element.children.length; i2 += 1) {
        const e4 = element.children[i2];
        const childHasErrorNode = _TreeUtils.hasErrorNode(e4);
        if (childHasErrorNode) {
          return true;
        }
      }
    }
    return false;
  }
};

// node_modules/@neo4j-cypher/editor-support/es/completion/rules/ruleCheckParent.js
var childToParentTypeMapping = /* @__PURE__ */ new Map();
childToParentTypeMapping.set(VARIABLE_CONTEXT, [{
  type: VARIABLE
}]);
childToParentTypeMapping.set(PARAMETER_NAME_CONTEXT, [{
  type: PARAMETER
}]);
childToParentTypeMapping.set(PROPERTY_KEY_NAME_CONTEXT, [{
  type: PROPERTY_KEY
}]);
childToParentTypeMapping.set(FUNCTION_NAME_CONTEXT, [{
  type: FUNCTION_NAME
}]);
childToParentTypeMapping.set(PROCEDURE_NAME_CONTEXT, [{
  type: PROCEDURE_NAME
}]);
childToParentTypeMapping.set(NODE_LABEL_CONTEXT, [{
  type: LABEL
}]);
childToParentTypeMapping.set(RELATIONSHIP_TYPE_CONTEXT, [{
  type: RELATIONSHIP_TYPE
}]);
childToParentTypeMapping.set(RELATIONSHIP_TYPE_OPTIONAL_COLON_CONTEXT, [{
  type: RELATIONSHIP_TYPE
}]);
childToParentTypeMapping.set(CONSOLE_COMMAND_NAME_CONTEXT, [{
  type: CONSOLE_COMMAND_NAME
}]);
childToParentTypeMapping.set(NODE_LABELS_CONTEXT, [{
  type: LABEL
}]);
childToParentTypeMapping.set(RELATIONSHIP_TYPES_CONTEXT, [{
  type: RELATIONSHIP_TYPE
}]);
var ruleCheckParent_default = (element) => {
  const parent = TreeUtils.findAnyParent(element, Array.from(childToParentTypeMapping.keys()));
  return parent != null ? childToParentTypeMapping.get(parent.constructor) : [];
};

// node_modules/@neo4j-cypher/editor-support/es/completion/rules/ruleVariableInExpressionPossibleFunction.js
var ruleVariableInExpressionPossibleFunction_default = (element) => {
  const variable = TreeUtils.findAnyParent(element, [VARIABLE_CONTEXT]);
  const expression = TreeUtils.findAnyParent(variable, [EXPRESSION_CONTEXT]);
  return variable != null && expression != null ? [{
    type: VARIABLE
  }, {
    type: FUNCTION_NAME
  }] : [];
};

// node_modules/@neo4j-cypher/editor-support/es/completion/rules/ruleProcedureOutputsInCallClause.js
var ruleProcedureOutputsInCallClause_default = (element) => {
  const call = TreeUtils.findAnyParent(element, [CALL_CONTEXT]);
  if (call != null) {
    const procedure = TreeUtils.findChild(call, PROCEDURE_NAME_CONTEXT);
    const resultOutput = TreeUtils.findAnyParent(element, [PROCEDURE_RESULTS_CONTEXT]);
    if (procedure == null || resultOutput == null) {
      return [];
    }
    return [{
      type: PROCEDURE_OUTPUT,
      name: procedure.getText()
    }];
  }
  return [];
};

// node_modules/@neo4j-cypher/editor-support/es/completion/rules/ruleCallClauseBeginning.js
var ruleCallClauseBeginning_default = (element) => {
  const parent = element.parentCtx;
  if (!parent) {
    return [];
  }
  if (parent instanceof CALL_CONTEXT) {
    const secondChild = parent.getChild(1);
    if (secondChild === element) {
      return [{
        type: PROCEDURE_NAME
      }];
    }
  }
  return [];
};

// node_modules/@neo4j-cypher/editor-support/es/completion/rules/rulePossibleKeyword.js
var import_lodash = __toESM(require_lodash());

// node_modules/@neo4j-cypher/editor-support/es/lang/CypherKeywords.js
var CypherKeywords_default = ["CYPHER", "EXPLAIN", "PROFILE", "USING", "PERIODIC", "COMMIT", "UNION", "ALL", "CREATE", "DROP", "INDEX", "ON", "CONSTRAINT", "ASSERT", "IS", "UNIQUE", "EXISTS", "LOAD", "CSV", "WITH", "HEADERS", "FROM", "AS", "FIELDTERMINATOR", "OPTIONAL", "MATCH", "UNWIND", "MERGE", "SET", "DETACH", "DELETE", "REMOVE", "FOREACH", "IN", "DISTINCT", "RETURN", "ORDER", "BY", "SKIP", "LIMIT", "ASCENDING", "ASC", "DESCENDING", "DESC", "JOIN", "SCAN", "STARTS", "START", "NODE", "RELATIONSHIP", "REL", "WHERE", "SHORTESTPATH", "ALLSHORTESTPATHS", "OR", "XOR", "AND", "NOT", "ENDS", "CONTAINS", "NULL", "COUNT", "FILTER", "EXTRACT", "ANY", "NONE", "SINGLE", "TRUE", "FALSE", "REDUCE", "CASE", "ELSE", "END", "WHEN", "THEN", "CALL", "YIELD", "KEY", "CATALOG", "SHOW", "DEFAULT", "DBMS", "DATABASES", "DATABASE", "GRAPHS", "GRAPH", "REPLACE", "IF", "STOP", "ROLES", "ROLE", "USERS", "USER", "POPULATED", "PASSWORD", "CHANGE", "REQUIRED", "STATUS", "ACTIVE", "SUSPENDED", "ALTER", "CURRENT", "TO", "PRIVILEGES", "GRANT", "DENY", "REVOKE", "RELATIONSHIPS", "NODES", "ELEMENTS", "ELEMENT", "COPY", "OF", "TRAVERSE", "READ", "WRITE", "ACCESS", "INDEXES", "MANAGEMENT", "NEW", "LABELS", "LABEL", "NAMES", "NAME", "TYPES", "TYPE", "PROPERTY", "CONSTRAINTS", "ASSIGN", "BTREE", "EXIST", "FOR", "OPTIONS", "EXECUTE", "DEFINED", "FUNCTION", "FUNCTIONS", "BOOSTED", "PROCEDURE", "PROCEDURES", "ADMIN", "ADMINISTRATOR", "BRIEF", "VERBOSE", "OUTPUT"];

// node_modules/@neo4j-cypher/editor-support/es/completion/rules/rulePossibleKeyword.js
var rulePossibleKeyword_default = (element) => {
  const text = element.getText().toLowerCase();
  if (CypherKeywords_default.find((keyword2) => (0, import_lodash.default)(keyword2.toLowerCase(), text))) {
    return ALL;
  }
  return [];
};

// node_modules/@neo4j-cypher/editor-support/es/completion/rules/ruleRelationshipPattern.js
var ruleRelationshipPattern_default = (element) => {
  const parent = TreeUtils.findParent(element, RELATIONSHIP_PATTERN_CONTEXT);
  if (parent) {
    if (element.getText() === "[") {
      return [{
        type: VARIABLE
      }, {
        type: RELATIONSHIP_TYPE
      }];
    }
    if (element.getText() === "]") {
      return [];
    }
  }
  return [];
};

// node_modules/@neo4j-cypher/editor-support/es/completion/rules/ruleNodePattern.js
var ruleNodePattern_default = (element) => {
  const parent = element.getParent ? element.getParent() : null;
  const text = element.getText();
  if (parent) {
    if (parent instanceof PATTERN_ELEMENT_CONTEXT && text === "(") {
      return [{
        type: VARIABLE
      }, {
        type: LABEL
      }];
    }
    if (parent instanceof NODE_PATTERN_CONTEXT) {
      if (text === "(") {
        return [{
          type: VARIABLE
        }, {
          type: LABEL
        }];
      }
      if (text === ":") {
        return [{
          type: LABEL
        }];
      }
    }
  }
  return [];
};

// node_modules/@neo4j-cypher/editor-support/es/completion/rules/rulePropertyLookup.js
var rulePropertyLookup_default = (element) => {
  const lookupContext = element.getParent();
  const text = element.getText();
  if (lookupContext) {
    if (lookupContext instanceof PROPERTY_LOOKUP_CONTEXT && text === ".") {
      return [{
        type: PROPERTY_KEY
      }];
    }
  }
  return [];
};

// node_modules/@neo4j-cypher/editor-support/es/completion/rules/rulePropInMapLiteral.js
var rulePropInMapLiteral_default = (element) => {
  const mapLiteralContext = TreeUtils.findParent(element, MAP_LITERAL_CONTEXT);
  const propertiesContext = TreeUtils.findParent(element, PROPERTIES_CONTEXT);
  if (mapLiteralContext) {
    const text = element.getText();
    if (text === "}") {
      return [];
    }
    return [{
      type: PROPERTY_KEY
    }];
  }
  if (propertiesContext) {
    const text = element.getText();
    if (text === "}") {
      return [];
    }
    if (/\s+/.test(text)) {
      return [];
    }
    return [{
      type: PROPERTY_KEY
    }, {
      type: PARAMETER
    }];
  }
  return [];
};

// node_modules/@neo4j-cypher/editor-support/es/completion/rules/ruleLiteralEntry.js
var ruleLiteralEntry_default = (element) => {
  const literalEntry = TreeUtils.findParent(element, MAP_LITERAL_ENTRY);
  if (!literalEntry) {
    return [];
  }
  const doubleDots = literalEntry.getChild(1);
  const space = literalEntry.getChild(2);
  if (doubleDots === element || space === element) {
    return ALL;
  }
  return [];
};

// node_modules/@neo4j-cypher/editor-support/es/completion/rules/ruleConsoleCommandSubcommands.js
var ruleConsoleCommandSubcommands_default = (element) => {
  let consoleCommand = TreeUtils.findParent(element.parentCtx, CONSOLE_COMMAND_CONTEXT);
  let isAtTheEndOfConsoleCommand = false;
  if (!consoleCommand) {
    const parent = element.parentCtx;
    const child1 = TreeUtils.findChild(parent.children[0], CONSOLE_COMMAND_CONTEXT);
    const child2 = parent.children[1];
    if (child1 && child2 && child2 === element) {
      consoleCommand = child1;
      isAtTheEndOfConsoleCommand = true;
    } else {
      return [];
    }
  }
  const currentElement = TreeUtils.findParent(element, CONSOLE_COMMAND_PARAMETER_CONTEXT) || element;
  const path = [];
  let currentElementInParameter = false;
  for (let i2 = 0; i2 < consoleCommand.children.length; i2 += 1) {
    const child = consoleCommand.children[i2];
    if (child instanceof CONSOLE_COMMAND_NAME_CONTEXT) {
      path.push(child.getText());
    }
    if (child instanceof CONSOLE_COMMAND_PARAMETERS_CONTEXT) {
      for (let j = 0; j < child.children.length; j += 1) {
        const parameterChild = child.children[j];
        if (parameterChild instanceof CONSOLE_COMMAND_PARAMETER_CONTEXT) {
          path.push(parameterChild.getText());
          currentElementInParameter = true;
        } else {
          currentElementInParameter = false;
        }
        if (parameterChild === currentElement) {
          break;
        }
      }
    }
  }
  let filterLastElement;
  if (isAtTheEndOfConsoleCommand) {
    filterLastElement = false;
  } else {
    filterLastElement = currentElementInParameter;
  }
  return [{
    type: CONSOLE_COMMAND_SUBCOMMAND,
    path,
    filterLastElement
  }];
};

// node_modules/@neo4j-cypher/editor-support/es/completion/rules/ruleNoop.js
var ruleNoop_default = (element) => {
  if (element instanceof STRING_LITERAL_CONTEXT) {
    return [{
      type: NOOP3
    }];
  }
  return [];
};

// node_modules/@neo4j-cypher/editor-support/es/completion/rules/ruleParamStartsWithDollar.js
var ruleParamStartsWithDollar_default = (element) => {
  const text = element.getText();
  if (text === "$") {
    return [{
      type: PARAMETER
    }];
  }
  return [];
};

// node_modules/@neo4j-cypher/editor-support/es/completion/CompletionTypeResolver.js
var orderedCompletionRules = [ruleNoop_default, ruleVariableInExpressionPossibleFunction_default, ruleLiteralEntry_default, rulePropInMapLiteral_default, ruleParamStartsWithDollar_default, ruleCheckParent_default, ruleNodePattern_default, ruleRelationshipPattern_default, ruleProcedureOutputsInCallClause_default, ruleCallClauseBeginning_default, ruleConsoleCommandSubcommands_default, rulePropertyLookup_default, rulePossibleKeyword_default];
function evaluateRules(element) {
  for (let i2 = 0; i2 < orderedCompletionRules.length; i2 += 1) {
    const rule = orderedCompletionRules[i2];
    const types2 = rule(element);
    if (types2.length > 0) {
      return types2;
    }
  }
  return [];
}
var CompletionTypeResolver = class {
  static getTypes(element) {
    if (element == null) {
      return {
        found: false,
        types: ALL
      };
    }
    const types2 = evaluateRules(element);
    if (types2.length > 0) {
      return {
        found: true,
        types: types2
      };
    }
    return {
      found: false,
      types: ALL
    };
  }
};

// node_modules/fuse.js/dist/fuse.esm.js
function isArray2(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
var INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString2(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber2(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject3(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject3(value) && value !== null;
}
function isDefined3(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
var PATTERN_LENGTH_TOO_LARGE = (max4) => `Pattern length exceeds max of ${max4}.`;
var MISSING_KEY_PROPERTY = (name2) => `Missing ${name2} property in key`;
var INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
var hasOwn = Object.prototype.hasOwnProperty;
var KeyStore = class {
  constructor(keys2) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys2.forEach((key) => {
      let obj = createKey(key);
      totalWeight += obj.weight;
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
};
function createKey(key) {
  let path = null;
  let id = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray2(key)) {
    src = key;
    path = createKeyPath(key);
    id = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name2 = key.name;
    src = name2;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name2));
      }
    }
    path = createKeyPath(name2);
    id = createKeyId(name2);
    getFn = key.getFn;
  }
  return { path, id, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray2(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray2(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index4) => {
    if (!isDefined3(obj2)) {
      return;
    }
    if (!path2[index4]) {
      list.push(obj2);
    } else {
      let key = path2[index4];
      const value = obj2[key];
      if (!isDefined3(value)) {
        return;
      }
      if (index4 === path2.length - 1 && (isString(value) || isNumber2(value) || isBoolean(value))) {
        list.push(toString2(value));
      } else if (isArray2(value)) {
        arr = true;
        for (let i2 = 0, len = value.length; i2 < len; i2 += 1) {
          deepGet(value[i2], path2, index4 + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index4 + 1);
      }
    }
  };
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
var MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
var BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a3, b2) => a3.score === b2.score ? a3.idx < b2.idx ? -1 : 1 : a3.score < b2.score ? -1 : 1
};
var FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
var AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
var SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m3 = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m3) / m3);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
var FuseIndex = class {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys2 = []) {
    this.keys = keys2;
    this._keysMap = {};
    keys2.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc2, docIndex) => {
        this._addString(doc2, docIndex);
      });
    } else {
      this.docs.forEach((doc2, docIndex) => {
        this._addObject(doc2, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc2) {
    const idx = this.size();
    if (isString(doc2)) {
      this._addString(doc2, idx);
    } else {
      this._addObject(doc2, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i2 = idx, len = this.size(); i2 < len; i2 += 1) {
      this.records[i2].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc2, docIndex) {
    if (!isDefined3(doc2) || isBlank(doc2)) {
      return;
    }
    let record = {
      v: doc2,
      i: docIndex,
      n: this.norm.get(doc2)
    };
    this.records.push(record);
  }
  _addObject(doc2, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc2) : this.getFn(doc2, key.path);
      if (!isDefined3(value)) {
        return;
      }
      if (isArray2(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined3(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray2(value2)) {
            value2.forEach((item, k2) => {
              stack.push({
                nestedArrIndex: k2,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
};
function createIndex(keys2, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys2.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys: keys2, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys2);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start2 = -1;
  let end2 = -1;
  let i2 = 0;
  for (let len = matchmask.length; i2 < len; i2 += 1) {
    let match3 = matchmask[i2];
    if (match3 && start2 === -1) {
      start2 = i2;
    } else if (!match3 && start2 !== -1) {
      end2 = i2 - 1;
      if (end2 - start2 + 1 >= minMatchCharLength) {
        indices.push([start2, end2]);
      }
      start2 = -1;
    }
  }
  if (matchmask[i2 - 1] && i2 - start2 >= minMatchCharLength) {
    indices.push([start2, i2 - 1]);
  }
  return indices;
}
var MAX_BITS = 32;
function search2(text, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index4;
  while ((index4 = text.indexOf(pattern, bestLocation)) > -1) {
    let score2 = computeScore$1(pattern, {
      currentLocation: index4,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score2, currentThreshold);
    bestLocation = index4 + patternLen;
    if (computeMatches) {
      let i2 = 0;
      while (i2 < patternLen) {
        matchMask[index4 + i2] = 1;
        i2 += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i2 = 0; i2 < patternLen; i2 += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score3 = computeScore$1(pattern, {
        errors: i2,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score3 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start2 = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i2) - 1;
    for (let j = finish; j >= start2; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i2) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i2,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start2 = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score2 = computeScore$1(pattern, {
      errors: i2 + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score2 > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i2 = 0, len = pattern.length; i2 < len; i2 += 1) {
    const char2 = pattern.charAt(i2);
    mask[char2] = (mask[char2] || 0) | 1 << len - i2 - 1;
  }
  return mask;
}
var BitapSearch = class {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i2 = 0;
      const remainder = len % MAX_BITS;
      const end2 = len - remainder;
      while (i2 < end2) {
        addChunk(this.pattern.substr(i2, MAX_BITS), i2);
        i2 += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text = text.toLowerCase();
    }
    if (this.pattern === text) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch: isMatch2, score: score2, indices } = search2(text, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch2) {
        hasMatches = true;
      }
      totalScore += score2;
      if (isMatch2 && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
};
var BaseMatch = class {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
};
function getMatch(pattern, exp) {
  const matches2 = pattern.match(exp);
  return matches2 ? matches2[1] : null;
}
var ExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text) {
    const isMatch2 = text === this.pattern;
    return {
      isMatch: isMatch2,
      score: isMatch2 ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InverseExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text) {
    const index4 = text.indexOf(this.pattern);
    const isMatch2 = index4 === -1;
    return {
      isMatch: isMatch2,
      score: isMatch2 ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var PrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text) {
    const isMatch2 = text.startsWith(this.pattern);
    return {
      isMatch: isMatch2,
      score: isMatch2 ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InversePrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text) {
    const isMatch2 = !text.startsWith(this.pattern);
    return {
      isMatch: isMatch2,
      score: isMatch2 ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var SuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text) {
    const isMatch2 = text.endsWith(this.pattern);
    return {
      isMatch: isMatch2,
      score: isMatch2 ? 0 : 1,
      indices: [text.length - this.pattern.length, text.length - 1]
    };
  }
};
var InverseSuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text) {
    const isMatch2 = !text.endsWith(this.pattern);
    return {
      isMatch: isMatch2,
      score: isMatch2 ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var FuzzyMatch = class extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text) {
    return this._bitapSearch.searchIn(text);
  }
};
var IncludeMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text) {
    let location = 0;
    let index4;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index4 = text.indexOf(this.pattern, location)) > -1) {
      location = index4 + patternLen;
      indices.push([index4, location - 1]);
    }
    const isMatch2 = !!indices.length;
    return {
      isMatch: isMatch2,
      score: isMatch2 ? 0 : 1,
      indices
    };
  }
};
var searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
var searchersLen = searchers.length;
var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
var OR_TOKEN = "|";
function parseQuery(pattern, options2 = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i2 = 0, len = query.length; i2 < len; i2 += 1) {
      const queryItem = query[i2];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token2 = searcher.isMultiMatch(queryItem);
        if (token2) {
          results.push(new searcher(token2, options2));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token2 = searcher.isSingleMatch(queryItem);
        if (token2) {
          results.push(new searcher(token2, options2));
          break;
        }
      }
    }
    return results;
  });
}
var MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
var ExtendedSearch = class {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options2) {
    return options2.useExtendedSearch;
  }
  searchIn(text) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text = isCaseSensitive ? text : text.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i2 = 0, qLen = query.length; i2 < qLen; i2 += 1) {
      const searchers2 = query[i2];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch: isMatch2, indices, score: score2 } = searcher.search(text);
        if (isMatch2) {
          numMatches += 1;
          totalScore += score2;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
};
var registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options2) {
  for (let i2 = 0, len = registeredSearchers.length; i2 < len; i2 += 1) {
    let searcherClass = registeredSearchers[i2];
    if (searcherClass.condition(pattern, options2)) {
      return new searcherClass(pattern, options2);
    }
  }
  return new BitapSearch(pattern, options2);
}
var LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
var KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
var isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
var isPath = (query) => !!query[KeyType.PATH];
var isLeaf = (query) => !isArray2(query) && isObject3(query) && !isExpression(query);
var convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse3(query, options2, { auto: auto2 = true } = {}) {
  const next2 = (query2) => {
    let keys2 = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys2.length > 1 && !isExpression(query2)) {
      return next2(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys2[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto2) {
        obj.searcher = createSearcher(pattern, options2);
      }
      return obj;
    }
    let node3 = {
      children: [],
      operator: keys2[0]
    };
    keys2.forEach((key) => {
      const value = query2[key];
      if (isArray2(value)) {
        value.forEach((item) => {
          node3.children.push(next2(item));
        });
      }
    });
    return node3;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next2(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score: score2 }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score2 === 0 && weight ? Number.EPSILON : score2,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches2 = result.matches;
  data.matches = [];
  if (!isDefined3(matches2)) {
    return;
  }
  matches2.forEach((match3) => {
    if (!isDefined3(match3.indices) || !match3.indices.length) {
      return;
    }
    const { indices, value } = match3;
    let obj = {
      indices,
      value
    };
    if (match3.key) {
      obj.key = match3.key.src;
    }
    if (match3.idx > -1) {
      obj.refIndex = match3.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format2(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
var Fuse = class {
  constructor(docs, options2 = {}, index4) {
    this.options = { ...Config, ...options2 };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index4);
  }
  setCollection(docs, index4) {
    this._docs = docs;
    if (index4 && !(index4 instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index4 || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc2) {
    if (!isDefined3(doc2)) {
      return;
    }
    this._docs.push(doc2);
    this._myIndex.add(doc2);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i2 = 0, len = this._docs.length; i2 < len; i2 += 1) {
      const doc2 = this._docs[i2];
      if (predicate(doc2, i2)) {
        this.removeAt(i2);
        i2 -= 1;
        len -= 1;
        results.push(doc2);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber2(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format2(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text, i: idx, n: norm2 }) => {
      if (!isDefined3(text)) {
        return;
      }
      const { isMatch: isMatch2, score: score2, indices } = searcher.searchIn(text);
      if (isMatch2) {
        results.push({
          item: text,
          idx,
          matches: [{ score: score2, value: text, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse3(query, this.options);
    const evaluate2 = (node3, item, idx) => {
      if (!node3.children) {
        const { keyId, searcher } = node3;
        const matches2 = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches2 && matches2.length) {
          return [
            {
              idx,
              item,
              matches: matches2
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i2 = 0, len = node3.children.length; i2 < len; i2 += 1) {
        const child = node3.children[i2];
        const result = evaluate2(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node3.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined3(item)) {
        let expResults = evaluate2(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches: matches2 }) => {
            resultMap[idx].matches.push(...matches2);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys: keys2, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined3(item)) {
        return;
      }
      let matches2 = [];
      keys2.forEach((key, keyIndex) => {
        matches2.push(
          ...this._findMatches({
            key,
            value: item[keyIndex],
            searcher
          })
        );
      });
      if (matches2.length) {
        results.push({
          idx,
          item,
          matches: matches2
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined3(value)) {
      return [];
    }
    let matches2 = [];
    if (isArray2(value)) {
      value.forEach(({ v: text, i: idx, n: norm2 }) => {
        if (!isDefined3(text)) {
          return;
        }
        const { isMatch: isMatch2, score: score2, indices } = searcher.searchIn(text);
        if (isMatch2) {
          matches2.push({
            score: score2,
            key,
            value: text,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text, n: norm2 } = value;
      const { isMatch: isMatch2, score: score2, indices } = searcher.searchIn(text);
      if (isMatch2) {
        matches2.push({ score: score2, key, value: text, norm: norm2, indices });
      }
    }
    return matches2;
  }
};
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse3;
}
{
  register(ExtendedSearch);
}

// node_modules/@neo4j-cypher/editor-support/es/completion/AutoCompletion.js
var import_lodash2 = __toESM(require_lodash2());

// node_modules/@neo4j-cypher/editor-support/es/util/ecsapeCypher.js
var ecsapeCypher = (str) => {
  const prefix3 = str.startsWith(":") ? ":" : "";
  let content2 = str;
  if (prefix3.length > 0) {
    content2 = str.substring(1);
  }
  return /^[A-Za-z][A-Za-z0-9_]*$/.test(content2) ? prefix3 + content2 : `${prefix3}\`${content2.replace(/`/g, "``")}\``;
};

// node_modules/@neo4j-cypher/editor-support/es/completion/AutoCompletion.js
var KEYWORD_ITEMS = CypherKeywords_default.map((keyword2) => ({
  type: KEYWORD,
  view: keyword2,
  content: keyword2,
  postfix: null
}));
var fuzzySearch = (list, text, key) => {
  const fuse = new Fuse(list, {
    keys: [key]
  });
  return fuse.search(text).map(({
    item
  }) => item);
};
var AbstractCachingCompletion = class {
  constructor(cache = {}) {
    _defineProperty(this, "cache", {});
    this.cache = cache;
  }
  // eslint-disable-next-line class-methods-use-this, no-unused-vars
  calculateItems(type, query = null) {
    return [];
  }
  complete(types2, query) {
    return types2.map((typeData) => {
      const cached = this.cache[typeData.type];
      if (cached != null) {
        return cached;
      }
      return this.calculateItems(typeData, query);
    }).reduce((acc, items) => [...acc, ...items], []);
  }
};
var SchemaBasedCompletion = class _SchemaBasedCompletion extends AbstractCachingCompletion {
  constructor(schema = {}) {
    super({
      [KEYWORD]: KEYWORD_ITEMS,
      [LABEL]: (schema.labels || []).map((label) => ({
        type: LABEL,
        view: label,
        content: ecsapeCypher(label),
        postfix: null
      })),
      [RELATIONSHIP_TYPE]: (schema.relationshipTypes || []).map((relType) => ({
        type: RELATIONSHIP_TYPE,
        view: relType,
        content: ecsapeCypher(relType),
        postfix: null
      })),
      [PROPERTY_KEY]: (schema.propertyKeys || []).map((propKey) => ({
        type: PROPERTY_KEY,
        view: propKey,
        content: ecsapeCypher(propKey),
        postfix: null
      })),
      [FUNCTION_NAME]: (schema.functions || []).map(({
        name: name2,
        signature
      }) => ({
        type: FUNCTION_NAME,
        view: name2,
        content: ecsapeCypher(name2),
        postfix: signature
      })),
      [PROCEDURE_NAME]: (schema.procedures || []).map(({
        name: name2,
        signature
      }) => ({
        type: PROCEDURE_NAME,
        view: name2,
        content: name2,
        postfix: signature
      })),
      [CONSOLE_COMMAND_NAME]: (schema.consoleCommands || []).map((consoleCommandName) => ({
        type: CONSOLE_COMMAND_NAME,
        view: consoleCommandName.name,
        content: consoleCommandName.name,
        postfix: consoleCommandName.description || null
      })),
      [PARAMETER]: (schema.parameters || []).map((parameter) => ({
        type: PARAMETER,
        view: parameter,
        content: parameter,
        postfix: null
      }))
    });
    _defineProperty(this, "schema", {});
    this.schema = schema;
  }
  calculateItems(typeData) {
    return (_SchemaBasedCompletion.providers[typeData.type] || (() => []))(this.schema, typeData);
  }
};
_defineProperty(SchemaBasedCompletion, "providers", {
  [PROCEDURE_OUTPUT]: (schema, typeData) => {
    const findByName = (e4) => e4.name === typeData.name && e4.returnItems !== [];
    const procedure = (0, import_lodash2.default)(schema.procedures, findByName);
    if (procedure) {
      return procedure.returnItems.map(({
        name: name2,
        signature
      }) => ({
        type: PROCEDURE_OUTPUT,
        view: name2,
        content: name2,
        postfix: ` :: ${signature}`
      }));
    }
    return [];
  },
  [CONSOLE_COMMAND_SUBCOMMAND]: (schema, typeData) => {
    const {
      filterLastElement,
      path
    } = typeData;
    const length2 = filterLastElement ? path.length - 1 : path.length;
    let currentLevel = schema.consoleCommands;
    for (let i2 = 0; i2 < length2; i2 += 1) {
      const foundCommand = (0, import_lodash2.default)(currentLevel, ["name", path[i2]]);
      if (foundCommand) {
        currentLevel = foundCommand.commands || [];
      } else {
        return [];
      }
    }
    return currentLevel.map(({
      name: name2,
      description
    }) => ({
      type: CONSOLE_COMMAND_SUBCOMMAND,
      view: name2,
      content: name2,
      postfix: description || null
    }));
  }
});
var QueryBasedCompletion = class extends AbstractCachingCompletion {
  constructor(referenceProviders = {}) {
    super();
    _defineProperty(this, "providers", {});
    _defineProperty(this, "emptyProvider", {
      getNames: () => []
    });
    this.providers = {
      [VARIABLE]: (query) => (referenceProviders.get(VARIABLE_CONTEXT) || this.emptyProvider).getNames(query).map((name2) => ({
        type: VARIABLE,
        view: name2,
        content: name2,
        postfix: null
      }))
    };
  }
  calculateItems(typeData, query) {
    return (this.providers[typeData.type] || (() => []))(query);
  }
};
var AutoCompletion = class _AutoCompletion {
  constructor() {
    _defineProperty(this, "queryBased", null);
    _defineProperty(this, "schemaBased", null);
    this.updateSchema({});
  }
  getItems(types2, {
    query = null,
    filter = ""
  }) {
    const text = filter.toLowerCase();
    const filteredText = _AutoCompletion.filterText(text);
    const completionItemFilter = () => true;
    const list = [this.queryBased, this.schemaBased].filter((s3) => s3 != null).map((t4) => t4.complete(types2, query)).reduce((acc, items) => [...acc, ...items], []).filter(completionItemFilter);
    if (filteredText) {
      return fuzzySearch(list, filteredText, "view");
    }
    if (text) {
      return fuzzySearch(list, text, "view");
    }
    return list;
  }
  updateSchema(schema) {
    this.schemaBased = new SchemaBasedCompletion(schema);
  }
  updateReferenceProviders(referenceProviders) {
    this.queryBased = new QueryBasedCompletion(referenceProviders);
  }
  /**
   * Define whether element should be replaced or not.
   */
  static shouldBeReplaced(element) {
    if (element == null) {
      return false;
    }
    const text = element.getText();
    const parent = element.parentCtx;
    if (/^\s+$/.test(text)) {
      return false;
    }
    if (text === "[") {
      return false;
    }
    if (text === "(") {
      return false;
    }
    if (text === ".") {
      return false;
    }
    if (text === "{") {
      return false;
    }
    if (text === "$") {
      return false;
    }
    if (text === ":" && parent != null && parent instanceof MAP_LITERAL_ENTRY) {
      return false;
    }
    return true;
  }
  static filterText(text) {
    if (text.startsWith("$")) {
      return text.slice(1);
    }
    return text;
  }
  // eslint-disable-next-line no-unused-vars
  static calculateSmartReplaceRange(element, start2, stop) {
    if (element instanceof RELATIONSHIP_TYPE_CONTEXT || element instanceof NODE_LABEL_CONTEXT) {
      if (TreeUtils.hasErrorNode(element)) {
        return {
          filterText: ":",
          start: start2,
          stop: start2
        };
      }
    }
    return null;
  }
};

// node_modules/@neo4j-cypher/editor-support/es/highlight/CypherSyntaxHighlight.js
function traverse(element, callback) {
  if (callback(element)) {
    return;
  }
  const c2 = element.getChildCount();
  if (c2 === 0) {
    return;
  }
  for (let i2 = 0; i2 < c2; i2 += 1) {
    traverse(element.getChild(i2), callback);
  }
}
var CypherSyntaxHighlight = class {
  static process(parseTree, callback) {
    traverse(parseTree, (e4) => {
      const {
        start: start2,
        stop
      } = TreeUtils.getPosition(e4) || {
        start: 0,
        stop: 0
      };
      if (start2 > stop) {
        return false;
      }
      if (e4 instanceof VARIABLE_CONTEXT) {
        callback(e4, "variable");
        return true;
      }
      if (e4 instanceof NODE_LABEL_CONTEXT) {
        callback(e4, "label");
        return true;
      }
      if (e4 instanceof RELATIONSHIP_TYPE_CONTEXT || e4 instanceof RELATIONSHIP_TYPE_OPTIONAL_COLON_CONTEXT) {
        callback(e4, "relationshipType");
        return true;
      }
      if (e4 instanceof PROPERTY_KEY_NAME_CONTEXT) {
        callback(e4, "property");
        return true;
      }
      if (e4 instanceof PROCEDURE_NAME_CONTEXT) {
        callback(e4, "procedure");
        return true;
      }
      if (e4 instanceof PROCEDURE_OUTPUT_CONTEXT) {
        callback(e4, "procedureOutput");
        return true;
      }
      if (e4 instanceof FUNCTION_NAME_CONTEXT) {
        callback(e4, "function");
        return true;
      }
      if (e4 instanceof ALL_FUNCTION_NAME_CONTEXT || e4 instanceof REDUCE_FUNCTION_NAME_CONTEXT || e4 instanceof FILTER_FUNCTION_NAME_CONTEXT || e4 instanceof NONE_FUNCTION_NAME_CONTEXT || e4 instanceof EXTRACT_FUNCTION_NAME_CONTEXT || e4 instanceof SHORTEST_PATH_FUNCTION_NAME_CONTEXT || e4 instanceof ALL_SHORTEST_PATH_FUNCTION_NAME_CONTEXT || e4 instanceof SINGLE_FUNCTION_NAME_CONTEXT || e4 instanceof EXISTS_FUNCTION_NAME_CONTEXT || e4 instanceof ANY_FUNCTION_NAME_CONTEXT) {
        callback(e4, "function");
        return true;
      }
      if (e4 instanceof PARAMETER_CONTEXT) {
        callback(e4, "parameter");
        return true;
      }
      if (e4 instanceof CONSOLE_COMMAND_NAME_CONTEXT) {
        callback(e4, "consoleCommand");
        return true;
      }
      if (e4 instanceof CONSOLE_COMMAND_SUBCOMMAND_CONTEXT || e4 instanceof CONSOLE_COMMAND_PATH_CONTEXT) {
        callback(e4, "property");
        return true;
      }
      return false;
    });
  }
};

// node_modules/@neo4j-cypher/editor-support/es/util/PositionConverter.js
var PositionConverter = class {
  constructor(input) {
    _defineProperty(this, "newLines", []);
    for (let i2 = 0; i2 < input.length; i2 += 1) {
      if (input[i2] === "\n") {
        this.newLines.push(i2);
      }
    }
  }
  toAbsolute(line2, column2) {
    return (this.newLines[line2 - 2] || -1) + column2 + 1;
  }
  toRelative(abs2) {
    for (let i2 = this.newLines.length - 1; i2 >= 0; i2 -= 1) {
      const column2 = abs2 - this.newLines[i2];
      if (column2 >= 1) {
        return {
          line: i2 + 2,
          column: column2 - 1
        };
      }
    }
    return {
      line: 1,
      column: abs2
    };
  }
};

// node_modules/@neo4j-cypher/editor-support/es/util/retryOperation.js
var wait = (ms) => new Promise((r2) => setTimeout(r2, ms));
var retryOperation = (operation, delay, times) => new Promise((resolve, reject) => operation().then(resolve).catch((reason) => {
  if (times - 1 > 0) {
    return wait(delay).then(retryOperation.bind(null, operation, delay, times - 1)).then(resolve).catch(reject);
  }
  return reject(reason);
}));

// node_modules/@neo4j-cypher/editor-support/es/references/ReferencesProvider.js
var ReferencesProvider = class {
  constructor(queries, index4) {
    _defineProperty(this, "queries", []);
    _defineProperty(this, "index", {});
    const {
      names: names2,
      namesByQuery,
      referencesByName,
      referencesByQueryAndName
    } = index4;
    this.queries = queries;
    this.index = {
      names: Object.keys(names2),
      namesByQuery: namesByQuery.map((q2) => Object.keys(q2)),
      referencesByName,
      referencesByQueryAndName
    };
  }
  getReferences(name2, query = null) {
    if (query == null) {
      return this.index.referencesByName[name2];
    }
    const pos = this.queries.indexOf(query);
    return (this.index.referencesByQueryAndName[pos] || {})[name2];
  }
  getNames(query = null) {
    if (query == null) {
      return this.index.names;
    }
    const pos = this.queries.indexOf(query);
    return this.index.namesByQuery[pos] || [];
  }
};

// node_modules/@neo4j-cypher/editor-support/es/errors/ErrorListener.js
var ErrorListener2 = class extends es_default.error.ErrorListener {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "errors", []);
  }
  // eslint-disable-next-line no-unused-vars
  syntaxError(rec, sym, line2, col, msg, e4) {
    const {
      start: start2,
      stop
    } = sym || {};
    if (msg === "mismatched input '<EOF>' expecting {';', SP}") {
      return;
    }
    if (msg === "missing ';' at '<EOF>'") {
      return;
    }
    if (msg === "mismatched input '<EOF>' expecting {':', CYPHER, EXPLAIN, PROFILE, USING, CREATE, DROP, LOAD, WITH, OPTIONAL, MATCH, UNWIND, MERGE, SET, DETACH, DELETE, REMOVE, FOREACH, RETURN, START, CALL}") {
      return;
    }
    this.errors.push({
      line: line2,
      col,
      msg,
      start: start2,
      stop
    });
  }
};

// node_modules/@neo4j-cypher/editor-support/es/references/ReferencesListener.js
var Index = class {
  constructor() {
    _defineProperty(this, "names", {});
    _defineProperty(this, "namesByQuery", []);
    _defineProperty(this, "referencesByName", {});
    _defineProperty(this, "referencesByQueryAndName", []);
  }
  addQuery() {
    this.namesByQuery.push([]);
    this.referencesByQueryAndName.push({});
  }
  add(ctx, addName = true) {
    const queryIndex = this.namesByQuery.length - 1;
    const text = ctx.getText();
    if (addName) {
      this.names[text] = true;
      this.namesByQuery[queryIndex][text] = true;
    }
    this.referencesByName[text] = [...this.referencesByName[text] || [], ctx];
    const index4 = this.referencesByQueryAndName[queryIndex];
    index4[text] = [...index4[text] || [], ctx];
  }
  /**
   * Variables have specific rules, because they participate in autocompletion.
   * We should not add to the names list variables that are in expression.
   */
  addVariable(ctx) {
    let addName = true;
    const parent = ctx.parentCtx;
    if (parent && parent instanceof ATOM_CONTEXT) {
      addName = false;
    }
    this.add(ctx, addName);
  }
};
var ReferencesListener = class extends CypherListener {
  constructor() {
    super();
    _defineProperty(this, "queries", []);
    _defineProperty(this, "queriesAndCommands", []);
    _defineProperty(this, "statements", []);
    _defineProperty(this, "raw", []);
    _defineProperty(this, "indexes", /* @__PURE__ */ new Map());
    _defineProperty(this, "inConsoleCommand", false);
    SYMBOLIC_CONTEXTS.forEach((sc) => {
      this.indexes.set(sc, new Index(sc));
    });
  }
  enterRaw(ctx) {
    this.raw.push(ctx);
  }
  exitRaw(ctx) {
    if (this.raw.length === 0) {
      this.raw.push(ctx);
    }
  }
  enterCypherPart(ctx) {
    this.statements.push(ctx);
  }
  exitCypher(ctx) {
    if (this.statements.length === 0) {
      this.statements.push(ctx);
    }
  }
  enterCypherConsoleCommand(ctx) {
    this.queriesAndCommands.push(ctx);
    this.indexes.forEach((index4) => index4.addQuery());
    this.inConsoleCommand = true;
  }
  exitCypherConsoleCommand() {
    this.inConsoleCommand = false;
  }
  enterCypherQuery(ctx) {
    this.queries.push(ctx);
    this.queriesAndCommands.push(ctx);
    this.indexes.forEach((index4) => index4.addQuery());
  }
  exitVariable(ctx) {
    if (this.inConsoleCommand) {
      return;
    }
    this.indexes.get(VARIABLE_CONTEXT).addVariable(ctx);
  }
  exitLabelName(ctx) {
    if (this.inConsoleCommand) {
      return;
    }
    this.indexes.get(LABEL_NAME_CONTEXT).add(ctx);
  }
  exitRelTypeName(ctx) {
    if (this.inConsoleCommand) {
      return;
    }
    this.indexes.get(RELATIONSHIP_TYPE_NAME_CONTEXT).add(ctx);
  }
  exitPropertyKeyName(ctx) {
    if (this.inConsoleCommand) {
      return;
    }
    this.indexes.get(PROPERTY_KEY_NAME_CONTEXT).add(ctx);
  }
  exitParameterName(ctx) {
    if (this.inConsoleCommand) {
      return;
    }
    this.indexes.get(PARAMETER_NAME_CONTEXT).add(ctx);
  }
};

// node_modules/@neo4j-cypher/editor-support/es/util/parse.js
var parse4 = (input) => {
  const referencesListener = new ReferencesListener();
  const errorListener = new ErrorListener2();
  const chars = new es_default.InputStream(input);
  const lexer = new CypherLexer(chars);
  lexer.removeErrorListeners();
  lexer.addErrorListener(errorListener);
  const tokens2 = new es_default.CommonTokenStream(lexer);
  const parser = new CypherParser(tokens2);
  parser.buildParseTrees = true;
  parser.removeErrorListeners();
  parser.addErrorListener(errorListener);
  parser.addParseListener(referencesListener);
  const parseTree = parser.cypher();
  const {
    queries,
    indexes
  } = referencesListener;
  const referencesProviders = /* @__PURE__ */ new Map();
  SYMBOLIC_CONTEXTS.forEach((sc) => {
    referencesProviders.set(sc, new ReferencesProvider(queries, indexes.get(sc)));
  });
  return {
    parseTree,
    referencesListener,
    errorListener,
    referencesProviders
  };
};

// node_modules/@neo4j-cypher/editor-support/es/CypherEditorSupport.js
function ownKeys7(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread6(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys7(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys7(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var CypherEditorSupport = class {
  constructor(input = "") {
    _defineProperty(this, "schema", {});
    _defineProperty(this, "input", null);
    _defineProperty(this, "positionConverter", new PositionConverter(""));
    _defineProperty(this, "parseTree", null);
    _defineProperty(this, "parseErrors", []);
    _defineProperty(this, "referencesProviders", /* @__PURE__ */ new Map());
    _defineProperty(this, "completion", new AutoCompletion());
    _defineProperty(this, "queriesAndCommands", []);
    _defineProperty(this, "statements", []);
    _defineProperty(this, "listeners", []);
    _defineProperty(this, "version", 0);
    _defineProperty(this, "ensureVersion", (version, delay = 30, times = 5) => retryOperation(() => new Promise((resolve, reject) => {
      if (version === this.version) {
        return resolve();
      }
      return reject();
    }), delay, times));
    this.update(input);
  }
  on(eventName, cb) {
    this.listeners[eventName] = Array.isArray(this.listeners[eventName]) ? this.listeners[eventName].concat([cb]) : this.listeners[eventName] = [cb];
  }
  off(eventName, cb) {
    if (!this.listeners[eventName])
      return;
    const index4 = this.listeners[eventName].indexOf(cb);
    if (index4 > -1) {
      this.listeners[eventName].splice(index4, 1);
    }
  }
  trigger(eventName, args = []) {
    if (!this.listeners[eventName])
      return;
    this.listeners[eventName].forEach((cb) => cb(...args));
  }
  update(input = "", version) {
    this.trigger("update");
    if (input === this.input) {
      this.version = version || this.version;
      this.trigger("updated", [{
        queriesAndCommands: this.queriesAndCommands,
        referencesProviders: this.referencesProviders
      }]);
      return;
    }
    this.positionConverter = new PositionConverter(input);
    this.input = input;
    const {
      parseTree,
      referencesListener,
      errorListener,
      referencesProviders
    } = parse4(input);
    this.parseTree = parseTree;
    this.parseErrors = errorListener.errors;
    const {
      queriesAndCommands,
      statements
    } = referencesListener;
    this.statements = statements;
    this.queriesAndCommands = queriesAndCommands;
    this.referencesProviders = referencesProviders;
    this.completion.updateReferenceProviders(this.referencesProviders);
    this.version = version || this.version;
    this.trigger("updated", [{
      queriesAndCommands: this.queriesAndCommands,
      referencesProviders: this.referencesProviders
    }]);
  }
  setSchema(schema) {
    this.schema = schema;
    this.completion.updateSchema(this.schema);
  }
  getElement(line2, column2) {
    const abs2 = this.positionConverter.toAbsolute(line2, column2);
    function getElement(pt2) {
      const pos = TreeUtils.getPosition(pt2);
      if (pos != null && (abs2 < pos.start || abs2 > pos.stop)) {
        return null;
      }
      const c2 = pt2.getChildCount();
      if (c2 === 0 && pos != null) {
        return pt2;
      }
      for (let i2 = 0; i2 < c2; i2 += 1) {
        const e4 = getElement(pt2.getChild(i2));
        if (e4 != null) {
          return e4;
        }
      }
      return pos != null ? pt2 : null;
    }
    return getElement(this.parseTree);
  }
  getReferences(line2, column2) {
    const e4 = TreeUtils.findAnyParent(this.getElement(line2, column2), SYMBOLIC_CONTEXTS);
    if (e4 == null) {
      return [];
    }
    const query = e4 instanceof VARIABLE_CONTEXT ? TreeUtils.findAnyParent(e4, [QUERY_CONTEXT]) : null;
    return this.referencesProviders.get(e4).getReferences(e4.getText(), query);
  }
  getCompletionInfo(line2, column2) {
    const element = this.getElementForCompletion(line2, column2);
    const query = TreeUtils.findAnyParent(element, [QUERY_CONTEXT]);
    const {
      found,
      types: types2
    } = CompletionTypeResolver.getTypes(element);
    return {
      element,
      query,
      found,
      types: types2
    };
  }
  getElementForCompletion(line2, column2) {
    const e4 = this.getElement(line2, column2);
    return TreeUtils.findAnyParent(e4, COMPLETION_CANDIDATES) || e4;
  }
  getCompletion(line2, column2, doFilter = true) {
    let info = this.getCompletionInfo(line2, column2);
    if (!info.found && column2 > 0) {
      const prevInfo = this.getCompletionInfo(line2, column2 - 1);
      if (prevInfo.found) {
        info = prevInfo;
      }
    }
    const {
      element,
      query,
      found,
      types: types2
    } = info;
    const replaceRange2 = {
      from: {
        line: line2,
        column: column2
      },
      to: {
        line: line2,
        column: column2
      }
    };
    let filter = null;
    const shouldBeReplaced = AutoCompletion.shouldBeReplaced(element);
    if (found && shouldBeReplaced) {
      const {
        start: start2,
        stop
      } = TreeUtils.getPosition(element);
      const smartReplaceRange = AutoCompletion.calculateSmartReplaceRange(element, start2, stop);
      if (smartReplaceRange) {
        replaceRange2.from = this.positionConverter.toRelative(smartReplaceRange.start);
        replaceRange2.to = this.positionConverter.toRelative(smartReplaceRange.stop + 1);
        if (smartReplaceRange.filterText) {
          filter = smartReplaceRange.filterText;
        }
      } else {
        replaceRange2.from = this.positionConverter.toRelative(start2);
        replaceRange2.to = this.positionConverter.toRelative(stop + 1);
      }
    }
    if (filter === null) {
      filter = doFilter && found && shouldBeReplaced ? element.getText() : "";
    }
    return _objectSpread6({
      items: this.completion.getItems(types2, {
        filter,
        query
      })
    }, replaceRange2);
  }
  applyHighlighthing(callback) {
    CypherSyntaxHighlight.process(this.parseTree, callback);
  }
};

// node_modules/@neo4j-cypher/codemirror/es/cypher-state-definitions.js
var editorSupportField = StateField.define({
  create() {
    return new CypherEditorSupport();
  },
  update(editorSupport, tr2) {
    return editorSupport;
  }
});
var addTypeMarkerEffect = StateEffect.define();
var clearTypeMarkersEffect = StateEffect.define();
var typeMarkerField = StateField.define({
  create() {
    return Decoration.none;
  },
  update(typeMarkers, tr2) {
    typeMarkers = typeMarkers.map(tr2.changes);
    for (let e4 of tr2.effects) {
      if (e4.is(clearTypeMarkersEffect)) {
        typeMarkers = Decoration.none;
      } else if (e4.is(addTypeMarkerEffect)) {
        if (e4.value.from !== e4.value.to) {
          typeMarkers = typeMarkers.update({
            add: [Decoration.mark({
              class: "cm-p-" + e4.value.type
            }).range(e4.value.from, e4.value.to)]
          });
        }
      }
    }
    return typeMarkers;
  },
  provide: (f) => EditorView.decorations.from(f)
});

// node_modules/@neo4j-cypher/codemirror/es/cypher-state-selectors.js
function ownKeys8(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread7(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys8(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys8(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var getStateField = (mainExtension, label) => {
  const extensions = mainExtension();
  if (Array.isArray(extensions)) {
    const stateField = extensions.find((ex) => ex instanceof StateField);
    if (stateField) {
      return stateField;
    }
  }
  const length2 = Array.isArray(extensions) ? extensions.length : "no";
  throw new Error("getStateField for " + label + " failed (" + length2 + " extensions found)");
};
var searchStateField = getStateField(search, "search");
var autocompletionStateField = getStateField(autocompletion, "autocompletion");
var getStatePositionAbsolute = (state) => state.selection.main.head;
var getStateEditorSupport = (state) => state.field(editorSupportField, false);
var getStateLineCount = (state) => state.doc.lines;
var getStateValue = (state) => state.doc.toString();
var getStateLength = (state) => state.doc.length;
var getStateLineObjectForLine = (state, line2) => state.doc.line(line2);
var getStateLineObjectForAbsolute = (state, position2) => state.doc.lineAt(position2);
var getStatePositionAbsoluteForLineColumn = (state, {
  line: line2,
  column: column2
}) => state.doc.line(line2).from + column2;
var getStatePositionForAbsolute = (state, position2) => {
  const {
    number: line2,
    from: lineStart
  } = getStateLineObjectForAbsolute(state, position2);
  const column2 = position2 - lineStart;
  return {
    line: line2,
    column: column2,
    position: position2
  };
};
var getStatePosition = (state) => getStatePositionForAbsolute(state, getStatePositionAbsolute(state));
var getStatePositionForAny = (state, positionValue) => {
  let position2 = null;
  if (isAbsolutePosition(positionValue)) {
    position2 = positionValue;
  } else if (isLineColumnAbsolutePosition(positionValue)) {
    position2 = positionValue.position;
  } else if (isLineColumnPosition(positionValue)) {
    const {
      line: line2,
      column: column2
    } = positionValue;
    const lineCount = getStateLineCount(state);
    if (line2 <= lineCount) {
      const lineObject = getStateLineObjectForLine(state, line2);
      if (lineObject) {
        const {
          from: from2,
          to
        } = lineObject;
        if (isInteger(from2) && isInteger(to) && column2 <= to - from2) {
          position2 = from2 + column2;
        }
      }
    }
  }
  if (position2 !== null) {
    if (position2 <= getStateLength(state)) {
      const lineObject = getStateLineObjectForAbsolute(state, position2);
      if (lineObject) {
        const {
          number: line2,
          from: lineStart,
          to: lineEnd
        } = lineObject;
        const column2 = position2 - lineStart;
        if (lineStart + column2 <= lineEnd) {
          position2 = {
            line: line2,
            column: column2,
            position: position2
          };
        } else {
          position2 = null;
        }
      } else {
        position2 = null;
      }
    } else {
      position2 = null;
    }
  }
  return position2;
};
var getStateSelection = (state) => state.selection;
var getStateHasSelection = (state) => state.selection.ranges.some((r2) => !r2.empty);
var getSearchState = (state) => state.field(searchStateField, false);
var getStateSearchOpen = (state) => (getSearchState(state) || {
  panel: null
}).panel !== null;
var getStateSearchMatches = (state, maxCount = 1e3) => {
  const matches2 = (getSearchState(state) || {
    query: {
      matchAll: () => null
    }
  }).query.matchAll(state, 1e3);
  return matches2 ? matches2.slice(0, maxCount) : matches2;
};
var getStateSearchSpec = (state) => (getSearchState(state) || {
  query: {
    spec: null
  }
}).query.spec;
var getStateSearchText = (state) => (getSearchState(state) || {
  query: {
    spec: {
      search: null
    }
  }
}).query.spec.search;
var getAutocompleteState = (state) => state.field(autocompletionStateField, false);
var getStateAutocompleteOpen = (state) => (getAutocompleteState(state) || {
  open: null
}).open !== null;
var getFormattedAutocompleteOption = (option) => _objectSpread7({
  from: option.source.from
}, option.completion);
var getStateAutocompleteOptions = (state, format3 = false) => {
  const {
    open
  } = getAutocompleteState(state) || {
    open: null
  };
  if (open !== null) {
    const {
      options: options2
    } = open;
    if (options2) {
      return format3 ? options2.map(getFormattedAutocompleteOption) : options2;
    }
    return [];
  }
  return null;
};
var areViewUpdateAutocompleteOptionsEqual = (v) => {
  const {
    startState: oldState,
    state: newState
  } = v;
  const {
    open: oldOpen
  } = getAutocompleteState(oldState) || {
    open: null
  };
  const {
    open: newOpen
  } = getAutocompleteState(newState) || {
    open: null
  };
  if (oldOpen === null || newOpen === null) {
    return oldOpen === newOpen;
  } else {
    const {
      options: oldOptions
    } = oldOpen;
    const {
      options: newOptions
    } = newOpen;
    if (!oldOptions || !newOptions) {
      return oldOptions === newOptions;
    } else {
      const {
        length: oldLength
      } = oldOptions;
      const {
        length: newLength
      } = newOptions;
      if (!oldLength || !newLength || oldLength !== newLength) {
        return oldLength === newLength;
      }
      for (let i2 = 0; i2 < newLength; i2++) {
        const oldOption = oldOptions[i2];
        const newOption = oldOptions[i2];
        if (oldOption.source.from !== newOption.source.from || oldOption.completion !== newOption.completion) {
          return false;
        }
      }
      return true;
    }
  }
};
var getViewUpdateAnnotationValueForType = (v, type) => {
  for (let transaction of v.transactions) {
    const {
      annotations
    } = transaction;
    const foundAnnotation = annotations.find((a3) => a3.type === type);
    if (foundAnnotation && foundAnnotation.value) {
      return foundAnnotation.value;
    }
  }
  return null;
};
var getViewUpdatePickedAutocompleteOption = (v, format3 = false) => {
  const pickedAutocompletion = getViewUpdateAnnotationValueForType(v, pickedCompletion);
  if (pickedAutocompletion) {
    const pickedAutocompleteOption = getStateAutocompleteOptions(v.startState, false).find(({
      completion
    }) => completion == pickedAutocompletion);
    if (pickedAutocompleteOption) {
      return format3 ? getFormattedAutocompleteOption(pickedAutocompleteOption) : pickedAutocompleteOption;
    }
  }
  return null;
};

// node_modules/@codemirror/commands/dist/index.js
var toggleComment = (target) => {
  let { state } = target, line2 = state.doc.lineAt(state.selection.main.from), config2 = getConfig(target.state, line2.from);
  return config2.line ? toggleLineComment(target) : config2.block ? toggleBlockCommentByLine(target) : false;
};
function command(f, option) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let tr2 = f(option, state);
    if (!tr2)
      return false;
    dispatch(state.update(tr2));
    return true;
  };
}
var toggleLineComment = command(
  changeLineComment,
  0
  /* CommentOption.Toggle */
);
var lineComment = command(
  changeLineComment,
  1
  /* CommentOption.Comment */
);
var lineUncomment = command(
  changeLineComment,
  2
  /* CommentOption.Uncomment */
);
var toggleBlockComment = command(
  changeBlockComment,
  0
  /* CommentOption.Toggle */
);
var blockComment = command(
  changeBlockComment,
  1
  /* CommentOption.Comment */
);
var blockUncomment = command(
  changeBlockComment,
  2
  /* CommentOption.Uncomment */
);
var toggleBlockCommentByLine = command(
  (o, s3) => changeBlockComment(o, s3, selectedLineRanges(s3)),
  0
  /* CommentOption.Toggle */
);
function getConfig(state, pos) {
  let data = state.languageDataAt("commentTokens", pos);
  return data.length ? data[0] : {};
}
var SearchMargin = 50;
function findBlockComment(state, { open, close }, from2, to) {
  let textBefore = state.sliceDoc(from2 - SearchMargin, from2);
  let textAfter = state.sliceDoc(to, to + SearchMargin);
  let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
  let beforeOff = textBefore.length - spaceBefore;
  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
    return {
      open: { pos: from2 - spaceBefore, margin: spaceBefore && 1 },
      close: { pos: to + spaceAfter, margin: spaceAfter && 1 }
    };
  }
  let startText, endText;
  if (to - from2 <= 2 * SearchMargin) {
    startText = endText = state.sliceDoc(from2, to);
  } else {
    startText = state.sliceDoc(from2, from2 + SearchMargin);
    endText = state.sliceDoc(to - SearchMargin, to);
  }
  let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
  let endOff = endText.length - endSpace - close.length;
  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
    return {
      open: {
        pos: from2 + startSpace + open.length,
        margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
      },
      close: {
        pos: to - endSpace - close.length,
        margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
      }
    };
  }
  return null;
}
function selectedLineRanges(state) {
  let ranges = [];
  for (let r2 of state.selection.ranges) {
    let fromLine = state.doc.lineAt(r2.from);
    let toLine = r2.to <= fromLine.to ? fromLine : state.doc.lineAt(r2.to);
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last].to > fromLine.from)
      ranges[last].to = toLine.to;
    else
      ranges.push({ from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length, to: toLine.to });
  }
  return ranges;
}
function changeBlockComment(option, state, ranges = state.selection.ranges) {
  let tokens2 = ranges.map((r2) => getConfig(state, r2.from).block);
  if (!tokens2.every((c2) => c2))
    return null;
  let comments = ranges.map((r2, i2) => findBlockComment(state, tokens2[i2], r2.from, r2.to));
  if (option != 2 && !comments.every((c2) => c2)) {
    return { changes: state.changes(ranges.map((range, i2) => {
      if (comments[i2])
        return [];
      return [{ from: range.from, insert: tokens2[i2].open + " " }, { from: range.to, insert: " " + tokens2[i2].close }];
    })) };
  } else if (option != 1 && comments.some((c2) => c2)) {
    let changes = [];
    for (let i2 = 0, comment3; i2 < comments.length; i2++)
      if (comment3 = comments[i2]) {
        let token2 = tokens2[i2], { open, close } = comment3;
        changes.push({ from: open.pos - token2.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token2.close.length });
      }
    return { changes };
  }
  return null;
}
function changeLineComment(option, state, ranges = state.selection.ranges) {
  let lines = [];
  let prevLine = -1;
  for (let { from: from2, to } of ranges) {
    let startI = lines.length, minIndent = 1e9;
    let token2 = getConfig(state, from2).line;
    if (!token2)
      continue;
    for (let pos = from2; pos <= to; ) {
      let line2 = state.doc.lineAt(pos);
      if (line2.from > prevLine && (from2 == to || to > line2.from)) {
        prevLine = line2.from;
        let indent = /^\s*/.exec(line2.text)[0].length;
        let empty2 = indent == line2.length;
        let comment3 = line2.text.slice(indent, indent + token2.length) == token2 ? indent : -1;
        if (indent < line2.text.length && indent < minIndent)
          minIndent = indent;
        lines.push({ line: line2, comment: comment3, token: token2, indent, empty: empty2, single: false });
      }
      pos = line2.to + 1;
    }
    if (minIndent < 1e9) {
      for (let i2 = startI; i2 < lines.length; i2++)
        if (lines[i2].indent < lines[i2].line.text.length)
          lines[i2].indent = minIndent;
    }
    if (lines.length == startI + 1)
      lines[startI].single = true;
  }
  if (option != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
    let changes = [];
    for (let { line: line2, token: token2, indent, empty: empty2, single } of lines)
      if (single || !empty2)
        changes.push({ from: line2.from + indent, insert: token2 + " " });
    let changeSet = state.changes(changes);
    return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
  } else if (option != 1 && lines.some((l) => l.comment >= 0)) {
    let changes = [];
    for (let { line: line2, comment: comment3, token: token2 } of lines)
      if (comment3 >= 0) {
        let from2 = line2.from + comment3, to = from2 + token2.length;
        if (line2.text[to - line2.from] == " ")
          to++;
        changes.push({ from: from2, to });
      }
    return { changes };
  }
  return null;
}
var fromHistory = Annotation.define();
var isolateHistory = Annotation.define();
var invertedEffects = Facet.define();
var historyConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (_t2, isAdjacent2) => isAdjacent2
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (a3, b2) => (tr2, adj) => a3(tr2, adj) || b2(tr2, adj)
    });
  }
});
var historyField_ = StateField.define({
  create() {
    return HistoryState.empty;
  },
  update(state, tr2) {
    let config2 = tr2.state.facet(historyConfig);
    let fromHist = tr2.annotation(fromHistory);
    if (fromHist) {
      let item = HistEvent.fromTransaction(tr2, fromHist.selection), from2 = fromHist.side;
      let other = from2 == 0 ? state.undone : state.done;
      if (item)
        other = updateBranch(other, other.length, config2.minDepth, item);
      else
        other = addSelection(other, tr2.startState.selection);
      return new HistoryState(from2 == 0 ? fromHist.rest : other, from2 == 0 ? other : fromHist.rest);
    }
    let isolate = tr2.annotation(isolateHistory);
    if (isolate == "full" || isolate == "before")
      state = state.isolate();
    if (tr2.annotation(Transaction.addToHistory) === false)
      return !tr2.changes.empty ? state.addMapping(tr2.changes.desc) : state;
    let event = HistEvent.fromTransaction(tr2);
    let time = tr2.annotation(Transaction.time), userEvent = tr2.annotation(Transaction.userEvent);
    if (event)
      state = state.addChanges(event, time, userEvent, config2, tr2);
    else if (tr2.selection)
      state = state.addSelection(tr2.startState.selection, time, userEvent, config2.newGroupDelay);
    if (isolate == "full" || isolate == "after")
      state = state.isolate();
    return state;
  },
  toJSON(value) {
    return { done: value.done.map((e4) => e4.toJSON()), undone: value.undone.map((e4) => e4.toJSON()) };
  },
  fromJSON(json) {
    return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
  }
});
function history(config2 = {}) {
  return [
    historyField_,
    historyConfig.of(config2),
    EditorView.domEventHandlers({
      beforeinput(e4, view) {
        let command2 = e4.inputType == "historyUndo" ? undo : e4.inputType == "historyRedo" ? redo : null;
        if (!command2)
          return false;
        e4.preventDefault();
        return command2(view);
      }
    })
  ];
}
function cmd(side, selection) {
  return function({ state, dispatch }) {
    if (!selection && state.readOnly)
      return false;
    let historyState = state.field(historyField_, false);
    if (!historyState)
      return false;
    let tr2 = historyState.pop(side, state, selection);
    if (!tr2)
      return false;
    dispatch(tr2);
    return true;
  };
}
var undo = cmd(0, false);
var redo = cmd(1, false);
var undoSelection = cmd(0, true);
var redoSelection = cmd(1, true);
function depth(side) {
  return function(state) {
    let histState = state.field(historyField_, false);
    if (!histState)
      return 0;
    let branch = side == 0 ? histState.done : histState.undone;
    return branch.length - (branch.length && !branch[0].changes ? 1 : 0);
  };
}
var undoDepth = depth(
  0
  /* BranchName.Done */
);
var redoDepth = depth(
  1
  /* BranchName.Undone */
);
var HistEvent = class _HistEvent {
  constructor(changes, effects, mapped, startSelection, selectionsAfter) {
    this.changes = changes;
    this.effects = effects;
    this.mapped = mapped;
    this.startSelection = startSelection;
    this.selectionsAfter = selectionsAfter;
  }
  setSelAfter(after) {
    return new _HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
  }
  toJSON() {
    var _a2, _b, _c;
    return {
      changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
      mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
      startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s3) => s3.toJSON())
    };
  }
  static fromJSON(json) {
    return new _HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(tr2, selection) {
    let effects = none3;
    for (let invert of tr2.startState.facet(invertedEffects)) {
      let result = invert(tr2);
      if (result.length)
        effects = effects.concat(result);
    }
    if (!effects.length && tr2.changes.empty)
      return null;
    return new _HistEvent(tr2.changes.invert(tr2.startState.doc), effects, void 0, selection || tr2.startState.selection, none3);
  }
  static selection(selections) {
    return new _HistEvent(void 0, none3, void 0, void 0, selections);
  }
};
function updateBranch(branch, to, maxLen, newEvent) {
  let start2 = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
  let newBranch = branch.slice(start2, to);
  newBranch.push(newEvent);
  return newBranch;
}
function isAdjacent(a3, b2) {
  let ranges = [], isAdjacent2 = false;
  a3.iterChangedRanges((f, t4) => ranges.push(f, t4));
  b2.iterChangedRanges((_f, _t2, f, t4) => {
    for (let i2 = 0; i2 < ranges.length; ) {
      let from2 = ranges[i2++], to = ranges[i2++];
      if (t4 >= from2 && f <= to)
        isAdjacent2 = true;
    }
  });
  return isAdjacent2;
}
function eqSelectionShape(a3, b2) {
  return a3.ranges.length == b2.ranges.length && a3.ranges.filter((r2, i2) => r2.empty != b2.ranges[i2].empty).length === 0;
}
function conc(a3, b2) {
  return !a3.length ? b2 : !b2.length ? a3 : a3.concat(b2);
}
var none3 = [];
var MaxSelectionsPerEvent = 200;
function addSelection(branch, selection) {
  if (!branch.length) {
    return [HistEvent.selection([selection])];
  } else {
    let lastEvent = branch[branch.length - 1];
    let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
    if (sels.length && sels[sels.length - 1].eq(selection))
      return branch;
    sels.push(selection);
    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
  }
}
function popSelection(branch) {
  let last = branch[branch.length - 1];
  let newBranch = branch.slice();
  newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
  return newBranch;
}
function addMappingToBranch(branch, mapping) {
  if (!branch.length)
    return branch;
  let length2 = branch.length, selections = none3;
  while (length2) {
    let event = mapEvent(branch[length2 - 1], mapping, selections);
    if (event.changes && !event.changes.empty || event.effects.length) {
      let result = branch.slice(0, length2);
      result[length2 - 1] = event;
      return result;
    } else {
      mapping = event.mapped;
      length2--;
      selections = event.selectionsAfter;
    }
  }
  return selections.length ? [HistEvent.selection(selections)] : none3;
}
function mapEvent(event, mapping, extraSelections) {
  let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s3) => s3.map(mapping)) : none3, extraSelections);
  if (!event.changes)
    return HistEvent.selection(selections);
  let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
  let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
  return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
}
var joinableUserEvent = /^(input\.type|delete)($|\.)/;
var HistoryState = class _HistoryState {
  constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
    this.done = done;
    this.undone = undone;
    this.prevTime = prevTime;
    this.prevUserEvent = prevUserEvent;
  }
  isolate() {
    return this.prevTime ? new _HistoryState(this.done, this.undone) : this;
  }
  addChanges(event, time, userEvent, config2, tr2) {
    let done = this.done, lastEvent = done[done.length - 1];
    if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config2.newGroupDelay && config2.joinToEvent(tr2, isAdjacent(lastEvent.changes, event.changes)) || // For compose (but not compose.start) events, always join with previous event
    userEvent == "input.type.compose")) {
      done = updateBranch(done, done.length - 1, config2.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none3));
    } else {
      done = updateBranch(done, done.length, config2.minDepth, event);
    }
    return new _HistoryState(done, none3, time, userEvent);
  }
  addSelection(selection, time, userEvent, newGroupDelay) {
    let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none3;
    if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection))
      return this;
    return new _HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
  }
  addMapping(mapping) {
    return new _HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
  }
  pop(side, state, onlySelection) {
    let branch = side == 0 ? this.done : this.undone;
    if (branch.length == 0)
      return null;
    let event = branch[branch.length - 1], selection = event.selectionsAfter[0] || state.selection;
    if (onlySelection && event.selectionsAfter.length) {
      return state.update({
        selection: event.selectionsAfter[event.selectionsAfter.length - 1],
        annotations: fromHistory.of({ side, rest: popSelection(branch), selection }),
        userEvent: side == 0 ? "select.undo" : "select.redo",
        scrollIntoView: true
      });
    } else if (!event.changes) {
      return null;
    } else {
      let rest = branch.length == 1 ? none3 : branch.slice(0, branch.length - 1);
      if (event.mapped)
        rest = addMappingToBranch(rest, event.mapped);
      return state.update({
        changes: event.changes,
        selection: event.startSelection,
        effects: event.effects,
        annotations: fromHistory.of({ side, rest, selection }),
        filter: false,
        userEvent: side == 0 ? "undo" : "redo",
        scrollIntoView: true
      });
    }
  }
};
HistoryState.empty = new HistoryState(none3, none3);
var historyKeymap = [
  { key: "Mod-z", run: undo, preventDefault: true },
  { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
  { linux: "Ctrl-Shift-z", run: redo, preventDefault: true },
  { key: "Mod-u", run: undoSelection, preventDefault: true },
  { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
];
function updateSel(sel, by) {
  return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state, selection) {
  return state.update({ selection, scrollIntoView: true, userEvent: "select" });
}
function moveSel({ state, dispatch }, how) {
  let selection = updateSel(state.selection, how);
  if (selection.eq(state.selection, true))
    return false;
  dispatch(setSel(state, selection));
  return true;
}
function rangeEnd(range, forward) {
  return EditorSelection.cursor(forward ? range.to : range.from);
}
function cursorByChar(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
}
function ltrAtCursor(view) {
  return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
}
var cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
var cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
function cursorByGroup(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
}
var cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
var cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
var segmenter = typeof Intl != "undefined" && Intl.Segmenter ? new Intl.Segmenter(void 0, { granularity: "word" }) : null;
function interestingNode(state, node3, bracketProp) {
  if (node3.type.prop(bracketProp))
    return true;
  let len = node3.to - node3.from;
  return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node3.from, node3.to))) || node3.firstChild;
}
function moveBySyntax(state, start2, forward) {
  let pos = syntaxTree(state).resolveInner(start2.head);
  let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
  for (let at2 = start2.head; ; ) {
    let next2 = forward ? pos.childAfter(at2) : pos.childBefore(at2);
    if (!next2)
      break;
    if (interestingNode(state, next2, bracketProp))
      pos = next2;
    else
      at2 = forward ? next2.to : next2.from;
  }
  let bracket2 = pos.type.prop(bracketProp), match3, newPos;
  if (bracket2 && (match3 = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match3.matched)
    newPos = forward ? match3.end.to : match3.end.from;
  else
    newPos = forward ? pos.to : pos.from;
  return EditorSelection.cursor(newPos, forward ? -1 : 1);
}
var cursorSyntaxLeft = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
var cursorSyntaxRight = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function cursorByLine(view, forward) {
  return moveSel(view, (range) => {
    if (!range.empty)
      return rangeEnd(range, forward);
    let moved = view.moveVertically(range, forward);
    return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
  });
}
var cursorLineUp = (view) => cursorByLine(view, false);
var cursorLineDown = (view) => cursorByLine(view, true);
function pageInfo(view) {
  let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
  let marginTop = 0, marginBottom = 0, height;
  if (selfScroll) {
    for (let source of view.state.facet(EditorView.scrollMargins)) {
      let margins = source(view);
      if (margins === null || margins === void 0 ? void 0 : margins.top)
        marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
      if (margins === null || margins === void 0 ? void 0 : margins.bottom)
        marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
    }
    height = view.scrollDOM.clientHeight - marginTop - marginBottom;
  } else {
    height = (view.dom.ownerDocument.defaultView || window).innerHeight;
  }
  return {
    marginTop,
    marginBottom,
    selfScroll,
    height: Math.max(view.defaultLineHeight, height - 5)
  };
}
function cursorByPage(view, forward) {
  let page = pageInfo(view);
  let { state } = view, selection = updateSel(state.selection, (range) => {
    return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);
  });
  if (selection.eq(state.selection))
    return false;
  let effect4;
  if (page.selfScroll) {
    let startPos = view.coordsAtPos(state.selection.main.head);
    let scrollRect = view.scrollDOM.getBoundingClientRect();
    let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
    if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
      effect4 = EditorView.scrollIntoView(selection.main.head, { y: "start", yMargin: startPos.top - scrollTop });
  }
  view.dispatch(setSel(state, selection), { effects: effect4 });
  return true;
}
var cursorPageUp = (view) => cursorByPage(view, false);
var cursorPageDown = (view) => cursorByPage(view, true);
function moveByLineBoundary(view, start2, forward) {
  let line2 = view.lineBlockAt(start2.head), moved = view.moveToLineBoundary(start2, forward);
  if (moved.head == start2.head && moved.head != (forward ? line2.to : line2.from))
    moved = view.moveToLineBoundary(start2, forward, false);
  if (!forward && moved.head == line2.from && line2.length) {
    let space = /^\s*/.exec(view.state.sliceDoc(line2.from, Math.min(line2.from + 100, line2.to)))[0].length;
    if (space && start2.head != line2.from + space)
      moved = EditorSelection.cursor(line2.from + space);
  }
  return moved;
}
var cursorLineBoundaryForward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, true));
var cursorLineBoundaryBackward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, false));
var cursorLineBoundaryLeft = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
var cursorLineBoundaryRight = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
var cursorLineStart = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
var cursorLineEnd = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
function toMatchingBracket(state, dispatch, extend2) {
  let found = false, selection = updateSel(state.selection, (range) => {
    let matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);
    if (!matching || !matching.end)
      return range;
    found = true;
    let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
    return extend2 ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
  });
  if (!found)
    return false;
  dispatch(setSel(state, selection));
  return true;
}
var cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);
function extendSel(view, how) {
  let selection = updateSel(view.state.selection, (range) => {
    let head = how(range);
    return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || void 0);
  });
  if (selection.eq(view.state.selection))
    return false;
  view.dispatch(setSel(view.state, selection));
  return true;
}
function selectByChar(view, forward) {
  return extendSel(view, (range) => view.moveByChar(range, forward));
}
var selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
var selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
function selectByGroup(view, forward) {
  return extendSel(view, (range) => view.moveByGroup(range, forward));
}
var selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
var selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
var selectSyntaxLeft = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
var selectSyntaxRight = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function selectByLine(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward));
}
var selectLineUp = (view) => selectByLine(view, false);
var selectLineDown = (view) => selectByLine(view, true);
function selectByPage(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward, pageInfo(view).height));
}
var selectPageUp = (view) => selectByPage(view, false);
var selectPageDown = (view) => selectByPage(view, true);
var selectLineBoundaryForward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, true));
var selectLineBoundaryBackward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, false));
var selectLineBoundaryLeft = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
var selectLineBoundaryRight = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
var selectLineStart = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from));
var selectLineEnd = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to));
var cursorDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: 0 }));
  return true;
};
var cursorDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.doc.length }));
  return true;
};
var selectDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
  return true;
};
var selectDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
  return true;
};
var selectAll = ({ state, dispatch }) => {
  dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
  return true;
};
var selectLine = ({ state, dispatch }) => {
  let ranges = selectedLineBlocks(state).map(({ from: from2, to }) => EditorSelection.range(from2, Math.min(to + 1, state.doc.length)));
  dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
  return true;
};
var selectParentSyntax = ({ state, dispatch }) => {
  let selection = updateSel(state.selection, (range) => {
    var _a2;
    let stack = syntaxTree(state).resolveStack(range.from, 1);
    for (let cur2 = stack; cur2; cur2 = cur2.next) {
      let { node: node3 } = cur2;
      if ((node3.from < range.from && node3.to >= range.to || node3.to > range.to && node3.from <= range.from) && ((_a2 = node3.parent) === null || _a2 === void 0 ? void 0 : _a2.parent))
        return EditorSelection.range(node3.to, node3.from);
    }
    return range;
  });
  dispatch(setSel(state, selection));
  return true;
};
var simplifySelection = ({ state, dispatch }) => {
  let cur2 = state.selection, selection = null;
  if (cur2.ranges.length > 1)
    selection = EditorSelection.create([cur2.main]);
  else if (!cur2.main.empty)
    selection = EditorSelection.create([EditorSelection.cursor(cur2.main.head)]);
  if (!selection)
    return false;
  dispatch(setSel(state, selection));
  return true;
};
function deleteBy(target, by) {
  if (target.state.readOnly)
    return false;
  let event = "delete.selection", { state } = target;
  let changes = state.changeByRange((range) => {
    let { from: from2, to } = range;
    if (from2 == to) {
      let towards = by(range);
      if (towards < from2) {
        event = "delete.backward";
        towards = skipAtomic(target, towards, false);
      } else if (towards > from2) {
        event = "delete.forward";
        towards = skipAtomic(target, towards, true);
      }
      from2 = Math.min(from2, towards);
      to = Math.max(to, towards);
    } else {
      from2 = skipAtomic(target, from2, false);
      to = skipAtomic(target, to, true);
    }
    return from2 == to ? { range } : { changes: { from: from2, to }, range: EditorSelection.cursor(from2, from2 < range.head ? -1 : 1) };
  });
  if (changes.changes.empty)
    return false;
  target.dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: event,
    effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
  }));
  return true;
}
function skipAtomic(target, pos, forward) {
  if (target instanceof EditorView)
    for (let ranges of target.state.facet(EditorView.atomicRanges).map((f) => f(target)))
      ranges.between(pos, pos, (from2, to) => {
        if (from2 < pos && to > pos)
          pos = forward ? to : from2;
      });
  return pos;
}
var deleteByChar = (target, forward) => deleteBy(target, (range) => {
  let pos = range.from, { state } = target, line2 = state.doc.lineAt(pos), before, targetPos;
  if (!forward && pos > line2.from && pos < line2.from + 200 && !/[^ \t]/.test(before = line2.text.slice(0, pos - line2.from))) {
    if (before[before.length - 1] == "	")
      return pos - 1;
    let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
    for (let i2 = 0; i2 < drop && before[before.length - 1 - i2] == " "; i2++)
      pos--;
    targetPos = pos;
  } else {
    targetPos = findClusterBreak(line2.text, pos - line2.from, forward, forward) + line2.from;
    if (targetPos == pos && line2.number != (forward ? state.doc.lines : 1))
      targetPos += forward ? 1 : -1;
    else if (!forward && /[\ufe00-\ufe0f]/.test(line2.text.slice(targetPos - line2.from, pos - line2.from)))
      targetPos = findClusterBreak(line2.text, targetPos - line2.from, false, false) + line2.from;
  }
  return targetPos;
});
var deleteCharBackward = (view) => deleteByChar(view, false);
var deleteCharForward = (view) => deleteByChar(view, true);
var deleteByGroup = (target, forward) => deleteBy(target, (range) => {
  let pos = range.head, { state } = target, line2 = state.doc.lineAt(pos);
  let categorize = state.charCategorizer(pos);
  for (let cat = null; ; ) {
    if (pos == (forward ? line2.to : line2.from)) {
      if (pos == range.head && line2.number != (forward ? state.doc.lines : 1))
        pos += forward ? 1 : -1;
      break;
    }
    let next2 = findClusterBreak(line2.text, pos - line2.from, forward) + line2.from;
    let nextChar2 = line2.text.slice(Math.min(pos, next2) - line2.from, Math.max(pos, next2) - line2.from);
    let nextCat = categorize(nextChar2);
    if (cat != null && nextCat != cat)
      break;
    if (nextChar2 != " " || pos != range.head)
      cat = nextCat;
    pos = next2;
  }
  return pos;
});
var deleteGroupBackward = (target) => deleteByGroup(target, false);
var deleteGroupForward = (target) => deleteByGroup(target, true);
var deleteToLineEnd = (view) => deleteBy(view, (range) => {
  let lineEnd = view.lineBlockAt(range.head).to;
  return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);
});
var deleteLineBoundaryBackward = (view) => deleteBy(view, (range) => {
  let lineStart = view.moveToLineBoundary(range, false).head;
  return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
});
var deleteLineBoundaryForward = (view) => deleteBy(view, (range) => {
  let lineStart = view.moveToLineBoundary(range, true).head;
  return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);
});
var splitLine = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    return {
      changes: { from: range.from, to: range.to, insert: Text.of(["", ""]) },
      range: EditorSelection.cursor(range.from)
    };
  });
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
  return true;
};
var transposeChars = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    if (!range.empty || range.from == 0 || range.from == state.doc.length)
      return { range };
    let pos = range.from, line2 = state.doc.lineAt(pos);
    let from2 = pos == line2.from ? pos - 1 : findClusterBreak(line2.text, pos - line2.from, false) + line2.from;
    let to = pos == line2.to ? pos + 1 : findClusterBreak(line2.text, pos - line2.from, true) + line2.from;
    return {
      changes: { from: from2, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from2, pos)) },
      range: EditorSelection.cursor(to)
    };
  });
  if (changes.changes.empty)
    return false;
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
  return true;
};
function selectedLineBlocks(state) {
  let blocks = [], upto = -1;
  for (let range of state.selection.ranges) {
    let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
    if (!range.empty && range.to == endLine.from)
      endLine = state.doc.lineAt(range.to - 1);
    if (upto >= startLine.number) {
      let prev2 = blocks[blocks.length - 1];
      prev2.to = endLine.to;
      prev2.ranges.push(range);
    } else {
      blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
    }
    upto = endLine.number + 1;
  }
  return blocks;
}
function moveLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [], ranges = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward ? block.to == state.doc.length : block.from == 0)
      continue;
    let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
    let size3 = nextLine.length + 1;
    if (forward) {
      changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });
      for (let r2 of block.ranges)
        ranges.push(EditorSelection.range(Math.min(state.doc.length, r2.anchor + size3), Math.min(state.doc.length, r2.head + size3)));
    } else {
      changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });
      for (let r2 of block.ranges)
        ranges.push(EditorSelection.range(r2.anchor - size3, r2.head - size3));
    }
  }
  if (!changes.length)
    return false;
  dispatch(state.update({
    changes,
    scrollIntoView: true,
    selection: EditorSelection.create(ranges, state.selection.mainIndex),
    userEvent: "move.line"
  }));
  return true;
}
var moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
var moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
function copyLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward)
      changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
    else
      changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
  }
  dispatch(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
  return true;
}
var copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
var copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
var deleteLine = (view) => {
  if (view.state.readOnly)
    return false;
  let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from: from2, to }) => {
    if (from2 > 0)
      from2--;
    else if (to < state.doc.length)
      to++;
    return { from: from2, to };
  }));
  let selection = updateSel(state.selection, (range) => view.moveVertically(range, true)).map(changes);
  view.dispatch({ changes, selection, scrollIntoView: true, userEvent: "delete.line" });
  return true;
};
function isBetweenBrackets(state, pos) {
  if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
    return { from: pos, to: pos };
  let context = syntaxTree(state).resolveInner(pos);
  let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\S/.test(state.sliceDoc(before.to, after.from)))
    return { from: before.to, to: after.from };
  return null;
}
var insertNewlineAndIndent = newlineAndIndent(false);
var insertBlankLine = newlineAndIndent(true);
function newlineAndIndent(atEof) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range) => {
      let { from: from2, to } = range, line2 = state.doc.lineAt(from2);
      let explode = !atEof && from2 == to && isBetweenBrackets(state, from2);
      if (atEof)
        from2 = to = (to <= line2.to ? line2 : state.doc.lineAt(to)).to;
      let cx = new IndentContext(state, { simulateBreak: from2, simulateDoubleBreak: !!explode });
      let indent = getIndentation(cx, from2);
      if (indent == null)
        indent = countColumn(/^\s*/.exec(state.doc.lineAt(from2).text)[0], state.tabSize);
      while (to < line2.to && /\s/.test(line2.text[to - line2.from]))
        to++;
      if (explode)
        ({ from: from2, to } = explode);
      else if (from2 > line2.from && from2 < line2.from + 100 && !/\S/.test(line2.text.slice(0, from2)))
        from2 = line2.from;
      let insert2 = ["", indentString(state, indent)];
      if (explode)
        insert2.push(indentString(state, cx.lineIndent(line2.from, -1)));
      return {
        changes: { from: from2, to, insert: Text.of(insert2) },
        range: EditorSelection.cursor(from2 + 1 + insert2[1].length)
      };
    });
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
}
function changeBySelectedLine(state, f) {
  let atLine = -1;
  return state.changeByRange((range) => {
    let changes = [];
    for (let pos = range.from; pos <= range.to; ) {
      let line2 = state.doc.lineAt(pos);
      if (line2.number > atLine && (range.empty || range.to > line2.from)) {
        f(line2, changes, range);
        atLine = line2.number;
      }
      pos = line2.to + 1;
    }
    let changeSet = state.changes(changes);
    return {
      changes,
      range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
    };
  });
}
var indentSelection = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let updated = /* @__PURE__ */ Object.create(null);
  let context = new IndentContext(state, { overrideIndentation: (start2) => {
    let found = updated[start2];
    return found == null ? -1 : found;
  } });
  let changes = changeBySelectedLine(state, (line2, changes2, range) => {
    let indent = getIndentation(context, line2.from);
    if (indent == null)
      return;
    if (!/\S/.test(line2.text))
      indent = 0;
    let cur2 = /^\s*/.exec(line2.text)[0];
    let norm2 = indentString(state, indent);
    if (cur2 != norm2 || range.from < line2.from + cur2.length) {
      updated[line2.from] = indent;
      changes2.push({ from: line2.from, to: line2.from + cur2.length, insert: norm2 });
    }
  });
  if (!changes.changes.empty)
    dispatch(state.update(changes, { userEvent: "indent" }));
  return true;
};
var indentMore = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line2, changes) => {
    changes.push({ from: line2.from, insert: state.facet(indentUnit) });
  }), { userEvent: "input.indent" }));
  return true;
};
var indentLess = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line2, changes) => {
    let space = /^\s*/.exec(line2.text)[0];
    if (!space)
      return;
    let col = countColumn(space, state.tabSize), keep = 0;
    let insert2 = indentString(state, Math.max(0, col - getIndentUnit(state)));
    while (keep < space.length && keep < insert2.length && space.charCodeAt(keep) == insert2.charCodeAt(keep))
      keep++;
    changes.push({ from: line2.from + keep, to: line2.from + space.length, insert: insert2.slice(keep) });
  }), { userEvent: "delete.dedent" }));
  return true;
};
var emacsStyleKeymap = [
  { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
  { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
  { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
  { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
  { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
  { key: "Ctrl-d", run: deleteCharForward },
  { key: "Ctrl-h", run: deleteCharBackward },
  { key: "Ctrl-k", run: deleteToLineEnd },
  { key: "Ctrl-Alt-h", run: deleteGroupBackward },
  { key: "Ctrl-o", run: splitLine },
  { key: "Ctrl-t", run: transposeChars },
  { key: "Ctrl-v", run: cursorPageDown }
];
var standardKeymap = [
  { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
  { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
  { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
  { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
  { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
  { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
  { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
  { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
  { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
  { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
  { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
  { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
  { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
  { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
  { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
  { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
  { key: "Enter", run: insertNewlineAndIndent },
  { key: "Mod-a", run: selectAll },
  { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
  { key: "Delete", run: deleteCharForward },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
  { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
  { mac: "Mod-Backspace", run: deleteLineBoundaryBackward },
  { mac: "Mod-Delete", run: deleteLineBoundaryForward }
].concat(emacsStyleKeymap.map((b2) => ({ mac: b2.key, run: b2.run, shift: b2.shift })));
var defaultKeymap = [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
  { key: "Alt-ArrowUp", run: moveLineUp },
  { key: "Shift-Alt-ArrowUp", run: copyLineUp },
  { key: "Alt-ArrowDown", run: moveLineDown },
  { key: "Shift-Alt-ArrowDown", run: copyLineDown },
  { key: "Escape", run: simplifySelection },
  { key: "Mod-Enter", run: insertBlankLine },
  { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
  { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
  { key: "Mod-[", run: indentLess },
  { key: "Mod-]", run: indentMore },
  { key: "Mod-Alt-\\", run: indentSelection },
  { key: "Shift-Mod-k", run: deleteLine },
  { key: "Shift-Mod-\\", run: cursorMatchingBracket },
  { key: "Mod-/", run: toggleComment },
  { key: "Alt-A", run: toggleBlockComment }
].concat(standardKeymap);

// node_modules/@codemirror/lint/dist/index.js
var SelectedDiagnostic = class {
  constructor(from2, to, diagnostic) {
    this.from = from2;
    this.to = to;
    this.diagnostic = diagnostic;
  }
};
var LintState = class _LintState {
  constructor(diagnostics, panel, selected) {
    this.diagnostics = diagnostics;
    this.panel = panel;
    this.selected = selected;
  }
  static init(diagnostics, panel, state) {
    let markedDiagnostics = diagnostics;
    let diagnosticFilter = state.facet(lintConfig).markerFilter;
    if (diagnosticFilter)
      markedDiagnostics = diagnosticFilter(markedDiagnostics);
    let ranges = Decoration.set(markedDiagnostics.map((d3) => {
      return d3.from == d3.to || d3.from == d3.to - 1 && state.doc.lineAt(d3.from).to == d3.from ? Decoration.widget({
        widget: new DiagnosticWidget(d3),
        diagnostic: d3
      }).range(d3.from) : Decoration.mark({
        attributes: { class: "cm-lintRange cm-lintRange-" + d3.severity + (d3.markClass ? " " + d3.markClass : "") },
        diagnostic: d3
      }).range(d3.from, d3.to);
    }), true);
    return new _LintState(ranges, panel, findDiagnostic(ranges));
  }
};
function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
  let found = null;
  diagnostics.between(after, 1e9, (from2, to, { spec }) => {
    if (diagnostic && spec.diagnostic != diagnostic)
      return;
    found = new SelectedDiagnostic(from2, to, spec.diagnostic);
    return false;
  });
  return found;
}
function hideTooltip(tr2, tooltip) {
  let line2 = tr2.startState.doc.lineAt(tooltip.pos);
  return !!(tr2.effects.some((e4) => e4.is(setDiagnosticsEffect)) || tr2.changes.touchesRange(line2.from, line2.to));
}
function maybeEnableLint(state, effects) {
  return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of(lintExtensions));
}
function setDiagnostics(state, diagnostics) {
  return {
    effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])
  };
}
var setDiagnosticsEffect = StateEffect.define();
var togglePanel2 = StateEffect.define();
var movePanelSelection = StateEffect.define();
var lintState = StateField.define({
  create() {
    return new LintState(Decoration.none, null, null);
  },
  update(value, tr2) {
    if (tr2.docChanged) {
      let mapped = value.diagnostics.map(tr2.changes), selected = null;
      if (value.selected) {
        let selPos = tr2.changes.mapPos(value.selected.from, 1);
        selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
      }
      value = new LintState(mapped, value.panel, selected);
    }
    for (let effect4 of tr2.effects) {
      if (effect4.is(setDiagnosticsEffect)) {
        value = LintState.init(effect4.value, value.panel, tr2.state);
      } else if (effect4.is(togglePanel2)) {
        value = new LintState(value.diagnostics, effect4.value ? LintPanel.open : null, value.selected);
      } else if (effect4.is(movePanelSelection)) {
        value = new LintState(value.diagnostics, value.panel, effect4.value);
      }
    }
    return value;
  },
  provide: (f) => [
    showPanel.from(f, (val) => val.panel),
    EditorView.decorations.from(f, (s3) => s3.diagnostics)
  ]
});
var activeMark = Decoration.mark({ class: "cm-lintRange cm-lintRange-active" });
function lintTooltip(view, pos, side) {
  let { diagnostics } = view.state.field(lintState);
  let found = [], stackStart = 2e8, stackEnd = 0;
  diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from2, to, { spec }) => {
    if (pos >= from2 && pos <= to && (from2 == to || (pos > from2 || side > 0) && (pos < to || side < 0))) {
      found.push(spec.diagnostic);
      stackStart = Math.min(from2, stackStart);
      stackEnd = Math.max(to, stackEnd);
    }
  });
  let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
  if (diagnosticFilter)
    found = diagnosticFilter(found);
  if (!found.length)
    return null;
  return {
    pos: stackStart,
    end: stackEnd,
    above: view.state.doc.lineAt(stackStart).to < stackEnd,
    create() {
      return { dom: diagnosticsTooltip(view, found) };
    }
  };
}
function diagnosticsTooltip(view, diagnostics) {
  return crelt("ul", { class: "cm-tooltip-lint" }, diagnostics.map((d3) => renderDiagnostic(view, d3, false)));
}
var openLintPanel = (view) => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel)
    view.dispatch({ effects: maybeEnableLint(view.state, [togglePanel2.of(true)]) });
  let panel = getPanel(view, LintPanel.open);
  if (panel)
    panel.dom.querySelector(".cm-panel-lint ul").focus();
  return true;
};
var closeLintPanel = (view) => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel)
    return false;
  view.dispatch({ effects: togglePanel2.of(false) });
  return true;
};
var nextDiagnostic = (view) => {
  let field = view.state.field(lintState, false);
  if (!field)
    return false;
  let sel = view.state.selection.main, next2 = field.diagnostics.iter(sel.to + 1);
  if (!next2.value) {
    next2 = field.diagnostics.iter(0);
    if (!next2.value || next2.from == sel.from && next2.to == sel.to)
      return false;
  }
  view.dispatch({ selection: { anchor: next2.from, head: next2.to }, scrollIntoView: true });
  return true;
};
var lintKeymap = [
  { key: "Mod-Shift-m", run: openLintPanel, preventDefault: true },
  { key: "F8", run: nextDiagnostic }
];
var lintPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.timeout = -1;
    this.set = true;
    let { delay } = view.state.facet(lintConfig);
    this.lintTime = Date.now() + delay;
    this.run = this.run.bind(this);
    this.timeout = setTimeout(this.run, delay);
  }
  run() {
    let now = Date.now();
    if (now < this.lintTime - 10) {
      this.timeout = setTimeout(this.run, this.lintTime - now);
    } else {
      this.set = false;
      let { state } = this.view, { sources } = state.facet(lintConfig);
      Promise.all(sources.map((source) => Promise.resolve(source(this.view)))).then((annotations) => {
        let all = annotations.reduce((a3, b2) => a3.concat(b2));
        if (this.view.state.doc == state.doc)
          this.view.dispatch(setDiagnostics(this.view.state, all));
      }, (error) => {
        logException(this.view.state, error);
      });
    }
  }
  update(update) {
    let config2 = update.state.facet(lintConfig);
    if (update.docChanged || config2 != update.startState.facet(lintConfig) || config2.needsRefresh && config2.needsRefresh(update)) {
      this.lintTime = Date.now() + config2.delay;
      if (!this.set) {
        this.set = true;
        this.timeout = setTimeout(this.run, config2.delay);
      }
    }
  }
  force() {
    if (this.set) {
      this.lintTime = Date.now();
      this.run();
    }
  }
  destroy() {
    clearTimeout(this.timeout);
  }
});
var lintConfig = Facet.define({
  combine(input) {
    return Object.assign({ sources: input.map((i2) => i2.source) }, combineConfig(input.map((i2) => i2.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null
    }, {
      needsRefresh: (a3, b2) => !a3 ? b2 : !b2 ? a3 : (u2) => a3(u2) || b2(u2)
    }));
  }
});
function linter(source, config2 = {}) {
  return [
    lintConfig.of({ source, config: config2 }),
    lintPlugin,
    lintExtensions
  ];
}
function assignKeys(actions) {
  let assigned = [];
  if (actions)
    actions:
      for (let { name: name2 } of actions) {
        for (let i2 = 0; i2 < name2.length; i2++) {
          let ch = name2[i2];
          if (/[a-zA-Z]/.test(ch) && !assigned.some((c2) => c2.toLowerCase() == ch.toLowerCase())) {
            assigned.push(ch);
            continue actions;
          }
        }
        assigned.push("");
      }
  return assigned;
}
function renderDiagnostic(view, diagnostic, inPanel) {
  var _a2;
  let keys2 = inPanel ? assignKeys(diagnostic.actions) : [];
  return crelt("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, crelt("span", { class: "cm-diagnosticText" }, diagnostic.renderMessage ? diagnostic.renderMessage() : diagnostic.message), (_a2 = diagnostic.actions) === null || _a2 === void 0 ? void 0 : _a2.map((action, i2) => {
    let fired = false, click = (e4) => {
      e4.preventDefault();
      if (fired)
        return;
      fired = true;
      let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
      if (found)
        action.apply(view, found.from, found.to);
    };
    let { name: name2 } = action, keyIndex = keys2[i2] ? name2.indexOf(keys2[i2]) : -1;
    let nameElt = keyIndex < 0 ? name2 : [
      name2.slice(0, keyIndex),
      crelt("u", name2.slice(keyIndex, keyIndex + 1)),
      name2.slice(keyIndex + 1)
    ];
    return crelt("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: click,
      onmousedown: click,
      "aria-label": ` Action: ${name2}${keyIndex < 0 ? "" : ` (access key "${keys2[i2]})"`}.`
    }, nameElt);
  }), diagnostic.source && crelt("div", { class: "cm-diagnosticSource" }, diagnostic.source));
}
var DiagnosticWidget = class extends WidgetType {
  constructor(diagnostic) {
    super();
    this.diagnostic = diagnostic;
  }
  eq(other) {
    return other.diagnostic == this.diagnostic;
  }
  toDOM() {
    return crelt("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
};
var PanelItem = class {
  constructor(view, diagnostic) {
    this.diagnostic = diagnostic;
    this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
    this.dom = renderDiagnostic(view, diagnostic, true);
    this.dom.id = this.id;
    this.dom.setAttribute("role", "option");
  }
};
var LintPanel = class _LintPanel {
  constructor(view) {
    this.view = view;
    this.items = [];
    let onkeydown = (event) => {
      if (event.keyCode == 27) {
        closeLintPanel(this.view);
        this.view.focus();
      } else if (event.keyCode == 38 || event.keyCode == 33) {
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      } else if (event.keyCode == 40 || event.keyCode == 34) {
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      } else if (event.keyCode == 36) {
        this.moveSelection(0);
      } else if (event.keyCode == 35) {
        this.moveSelection(this.items.length - 1);
      } else if (event.keyCode == 13) {
        this.view.focus();
      } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic } = this.items[this.selectedIndex], keys2 = assignKeys(diagnostic.actions);
        for (let i2 = 0; i2 < keys2.length; i2++)
          if (keys2[i2].toUpperCase().charCodeAt(0) == event.keyCode) {
            let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
            if (found)
              diagnostic.actions[i2].apply(view, found.from, found.to);
          }
      } else {
        return;
      }
      event.preventDefault();
    };
    let onclick = (event) => {
      for (let i2 = 0; i2 < this.items.length; i2++) {
        if (this.items[i2].dom.contains(event.target))
          this.moveSelection(i2);
      }
    };
    this.list = crelt("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown,
      onclick
    });
    this.dom = crelt("div", { class: "cm-panel-lint" }, this.list, crelt("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => closeLintPanel(this.view)
    }, ""));
    this.update();
  }
  get selectedIndex() {
    let selected = this.view.state.field(lintState).selected;
    if (!selected)
      return -1;
    for (let i2 = 0; i2 < this.items.length; i2++)
      if (this.items[i2].diagnostic == selected.diagnostic)
        return i2;
    return -1;
  }
  update() {
    let { diagnostics, selected } = this.view.state.field(lintState);
    let i2 = 0, needsSync = false, newSelectedItem = null;
    diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
      let found = -1, item;
      for (let j = i2; j < this.items.length; j++)
        if (this.items[j].diagnostic == spec.diagnostic) {
          found = j;
          break;
        }
      if (found < 0) {
        item = new PanelItem(this.view, spec.diagnostic);
        this.items.splice(i2, 0, item);
        needsSync = true;
      } else {
        item = this.items[found];
        if (found > i2) {
          this.items.splice(i2, found - i2);
          needsSync = true;
        }
      }
      if (selected && item.diagnostic == selected.diagnostic) {
        if (!item.dom.hasAttribute("aria-selected")) {
          item.dom.setAttribute("aria-selected", "true");
          newSelectedItem = item;
        }
      } else if (item.dom.hasAttribute("aria-selected")) {
        item.dom.removeAttribute("aria-selected");
      }
      i2++;
    });
    while (i2 < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
      needsSync = true;
      this.items.pop();
    }
    if (this.items.length == 0) {
      this.items.push(new PanelItem(this.view, {
        from: -1,
        to: -1,
        severity: "info",
        message: this.view.state.phrase("No diagnostics")
      }));
      needsSync = true;
    }
    if (newSelectedItem) {
      this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
      this.view.requestMeasure({
        key: this,
        read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
        write: ({ sel, panel }) => {
          let scaleY = panel.height / this.list.offsetHeight;
          if (sel.top < panel.top)
            this.list.scrollTop -= (panel.top - sel.top) / scaleY;
          else if (sel.bottom > panel.bottom)
            this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;
        }
      });
    } else if (this.selectedIndex < 0) {
      this.list.removeAttribute("aria-activedescendant");
    }
    if (needsSync)
      this.sync();
  }
  sync() {
    let domPos = this.list.firstChild;
    function rm2() {
      let prev2 = domPos;
      domPos = prev2.nextSibling;
      prev2.remove();
    }
    for (let item of this.items) {
      if (item.dom.parentNode == this.list) {
        while (domPos != item.dom)
          rm2();
        domPos = item.dom.nextSibling;
      } else {
        this.list.insertBefore(item.dom, domPos);
      }
    }
    while (domPos)
      rm2();
  }
  moveSelection(selectedIndex) {
    if (this.selectedIndex < 0)
      return;
    let field = this.view.state.field(lintState);
    let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
    if (!selection)
      return;
    this.view.dispatch({
      selection: { anchor: selection.from, head: selection.to },
      scrollIntoView: true,
      effects: movePanelSelection.of(selection)
    });
  }
  static open(view) {
    return new _LintPanel(view);
  }
};
function svg(content2, attrs = `viewBox="0 0 40 40"`) {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content2)}</svg>')`;
}
function underline(color) {
  return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
}
var baseTheme5 = EditorView.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: underline("#d11") },
  ".cm-lintRange-warning": { backgroundImage: underline("orange") },
  ".cm-lintRange-info": { backgroundImage: underline("#999") },
  ".cm-lintRange-hint": { backgroundImage: underline("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function severityWeight(sev) {
  return sev == "error" ? 4 : sev == "warning" ? 3 : sev == "info" ? 2 : 1;
}
var LintGutterMarker = class extends GutterMarker {
  constructor(diagnostics) {
    super();
    this.diagnostics = diagnostics;
    this.severity = diagnostics.reduce((max4, d3) => severityWeight(max4) < severityWeight(d3.severity) ? d3.severity : max4, "hint");
  }
  toDOM(view) {
    let elt = document.createElement("div");
    elt.className = "cm-lint-marker cm-lint-marker-" + this.severity;
    let diagnostics = this.diagnostics;
    let diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter;
    if (diagnosticsFilter)
      diagnostics = diagnosticsFilter(diagnostics);
    if (diagnostics.length)
      elt.onmouseover = () => gutterMarkerMouseOver(view, elt, diagnostics);
    return elt;
  }
};
function trackHoverOn(view, marker) {
  let mousemove = (event) => {
    let rect = marker.getBoundingClientRect();
    if (event.clientX > rect.left - 10 && event.clientX < rect.right + 10 && event.clientY > rect.top - 10 && event.clientY < rect.bottom + 10)
      return;
    for (let target = event.target; target; target = target.parentNode) {
      if (target.nodeType == 1 && target.classList.contains("cm-tooltip-lint"))
        return;
    }
    window.removeEventListener("mousemove", mousemove);
    if (view.state.field(lintGutterTooltip))
      view.dispatch({ effects: setLintGutterTooltip.of(null) });
  };
  window.addEventListener("mousemove", mousemove);
}
function gutterMarkerMouseOver(view, marker, diagnostics) {
  function hovered() {
    let line2 = view.elementAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);
    const linePos = view.coordsAtPos(line2.from);
    if (linePos) {
      view.dispatch({ effects: setLintGutterTooltip.of({
        pos: line2.from,
        above: false,
        create() {
          return {
            dom: diagnosticsTooltip(view, diagnostics),
            getCoords: () => marker.getBoundingClientRect()
          };
        }
      }) });
    }
    marker.onmouseout = marker.onmousemove = null;
    trackHoverOn(view, marker);
  }
  let { hoverTime } = view.state.facet(lintGutterConfig);
  let hoverTimeout = setTimeout(hovered, hoverTime);
  marker.onmouseout = () => {
    clearTimeout(hoverTimeout);
    marker.onmouseout = marker.onmousemove = null;
  };
  marker.onmousemove = () => {
    clearTimeout(hoverTimeout);
    hoverTimeout = setTimeout(hovered, hoverTime);
  };
}
function markersForDiagnostics(doc2, diagnostics) {
  let byLine = /* @__PURE__ */ Object.create(null);
  for (let diagnostic of diagnostics) {
    let line2 = doc2.lineAt(diagnostic.from);
    (byLine[line2.from] || (byLine[line2.from] = [])).push(diagnostic);
  }
  let markers = [];
  for (let line2 in byLine) {
    markers.push(new LintGutterMarker(byLine[line2]).range(+line2));
  }
  return RangeSet.of(markers, true);
}
var lintGutterExtension = gutter({
  class: "cm-gutter-lint",
  markers: (view) => view.state.field(lintGutterMarkers)
});
var lintGutterMarkers = StateField.define({
  create() {
    return RangeSet.empty;
  },
  update(markers, tr2) {
    markers = markers.map(tr2.changes);
    let diagnosticFilter = tr2.state.facet(lintGutterConfig).markerFilter;
    for (let effect4 of tr2.effects) {
      if (effect4.is(setDiagnosticsEffect)) {
        let diagnostics = effect4.value;
        if (diagnosticFilter)
          diagnostics = diagnosticFilter(diagnostics || []);
        markers = markersForDiagnostics(tr2.state.doc, diagnostics.slice(0));
      }
    }
    return markers;
  }
});
var setLintGutterTooltip = StateEffect.define();
var lintGutterTooltip = StateField.define({
  create() {
    return null;
  },
  update(tooltip, tr2) {
    if (tooltip && tr2.docChanged)
      tooltip = hideTooltip(tr2, tooltip) ? null : Object.assign(Object.assign({}, tooltip), { pos: tr2.changes.mapPos(tooltip.pos) });
    return tr2.effects.reduce((t4, e4) => e4.is(setLintGutterTooltip) ? e4.value : t4, tooltip);
  },
  provide: (field) => showTooltip.from(field)
});
var lintGutterTheme = EditorView.baseTheme({
  ".cm-gutter-lint": {
    width: "1.4em",
    "& .cm-gutterElement": {
      padding: ".2em"
    }
  },
  ".cm-lint-marker": {
    width: "1em",
    height: "1em"
  },
  ".cm-lint-marker-info": {
    content: svg(`<path fill="#aaf" stroke="#77e" stroke-width="6" stroke-linejoin="round" d="M5 5L35 5L35 35L5 35Z"/>`)
  },
  ".cm-lint-marker-warning": {
    content: svg(`<path fill="#fe8" stroke="#fd7" stroke-width="6" stroke-linejoin="round" d="M20 6L37 35L3 35Z"/>`)
  },
  ".cm-lint-marker-error": {
    content: svg(`<circle cx="20" cy="20" r="15" fill="#f87" stroke="#f43" stroke-width="6"/>`)
  }
});
var lintExtensions = [
  lintState,
  EditorView.decorations.compute([lintState], (state) => {
    let { selected, panel } = state.field(lintState);
    return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
      activeMark.range(selected.from, selected.to)
    ]);
  }),
  hoverTooltip(lintTooltip, { hideOn: hideTooltip }),
  baseTheme5
];
var lintGutterConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      hoverTime: 300,
      markerFilter: null,
      tooltipFilter: null
    });
  }
});

// node_modules/@neo4j-cypher/codemirror/es/cypher.js
var operators = [";", "(", ")", "{", "}", "[", "]", "$", ":", ".", "=", "<", ">", "+", "-", "*", "`", ",", "?", "|", "..", "+=", "<>", "!=", "<=", ">=", "/", "%", "^", "=~"];
var curPunc;
var keywordRegexes = CypherKeywords_default.map((w3) => new RegExp(w3, "i"));
var lineCommentRegex = /\/\/[^\r\n]*/;
var blockCommentRegex = /\/\*([\S\s]*?)\*\//;
var stringRegex = /('([^'\\]|\\.)*'|"([^"\\]|\\.)*")/;
var stringStartRegex = /('([^'\\]|\\.)*|"([^"\\]|\\.)*)/;
var integerRegex = /[+-]?(([1-9][0-9]+)|([0-9]))/;
var decimalRegex = /[+-]?(([1-9][0-9]+)|([0-9]))\.[0-9]+/;
var tokenBase = (stream) => {
  if (stream.match(lineCommentRegex) || stream.match(blockCommentRegex)) {
    return "comment";
  } else if (stream.match(stringRegex)) {
    return "string";
  } else if (stream.match(integerRegex)) {
    return "number";
  } else if (stream.match(decimalRegex)) {
    return "number";
  } else if (operators.find((o) => stream.match(o))) {
    return "operator";
  } else if (keywordRegexes.find((k2) => stream.match(k2))) {
    return "keyword";
  } else if (stream.match(stringStartRegex)) {
    return "string";
  }
  stream.next();
  stream.eatWhile(/[#\*0-9A-Z_a-z\xA9\xAA\xAE\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203C\u2049\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2122\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3030-\u3035\u303B-\u303D\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3297\u3299\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{10300}-\u{1031F}\u{1032D}-\u{10340}\u{10342}-\u{10349}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{103A0}-\u{103C3}\u{103C8}-\u{103CF}\u{10400}-\u{1049D}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{10570}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10860}-\u{10876}\u{10880}-\u{1089E}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{10900}-\u{10915}\u{10920}-\u{10939}\u{10980}-\u{109B7}\u{109BE}\u{109BF}\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A60}-\u{10A7C}\u{10A80}-\u{10A9C}\u{10AC0}-\u{10AC7}\u{10AC9}-\u{10AE4}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B60}-\u{10B72}\u{10B80}-\u{10B91}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10D00}-\u{10D23}\u{10E80}-\u{10EA9}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F1C}\u{10F27}\u{10F30}-\u{10F45}\u{10F70}-\u{10F81}\u{10FB0}-\u{10FC4}\u{10FE0}-\u{10FF6}\u{11003}-\u{11037}\u{11071}\u{11072}\u{11075}\u{11083}-\u{110AF}\u{110D0}-\u{110E8}\u{11103}-\u{11126}\u{11144}\u{11147}\u{11150}-\u{11172}\u{11176}\u{11183}-\u{111B2}\u{111C1}-\u{111C4}\u{111DA}\u{111DC}\u{11200}-\u{11211}\u{11213}-\u{1122B}\u{1123F}\u{11240}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A8}\u{112B0}-\u{112DE}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}\u{11350}\u{1135D}-\u{11361}\u{11400}-\u{11434}\u{11447}-\u{1144A}\u{1145F}-\u{11461}\u{11480}-\u{114AF}\u{114C4}\u{114C5}\u{114C7}\u{11580}-\u{115AE}\u{115D8}-\u{115DB}\u{11600}-\u{1162F}\u{11644}\u{11680}-\u{116AA}\u{116B8}\u{11700}-\u{1171A}\u{11740}-\u{11746}\u{11800}-\u{1182B}\u{118A0}-\u{118DF}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{1192F}\u{1193F}\u{11941}\u{119A0}-\u{119A7}\u{119AA}-\u{119D0}\u{119E1}\u{119E3}\u{11A00}\u{11A0B}-\u{11A32}\u{11A3A}\u{11A50}\u{11A5C}-\u{11A89}\u{11A9D}\u{11AB0}-\u{11AF8}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2E}\u{11C40}\u{11C72}-\u{11C8F}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D89}\u{11D98}\u{11EE0}-\u{11EF2}\u{11F02}\u{11F04}-\u{11F10}\u{11F12}-\u{11F33}\u{11FB0}\u{12000}-\u{12399}\u{12480}-\u{12543}\u{12F90}-\u{12FF0}\u{13000}-\u{1342F}\u{13441}-\u{13446}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A70}-\u{16ABE}\u{16AD0}-\u{16AED}\u{16B00}-\u{16B2F}\u{16B40}-\u{16B43}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16E40}-\u{16E7F}\u{16F00}-\u{16F4A}\u{16F50}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18D00}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6C0}\u{1D6C2}-\u{1D6DA}\u{1D6DC}-\u{1D6FA}\u{1D6FC}-\u{1D714}\u{1D716}-\u{1D734}\u{1D736}-\u{1D74E}\u{1D750}-\u{1D76E}\u{1D770}-\u{1D788}\u{1D78A}-\u{1D7A8}\u{1D7AA}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E030}-\u{1E06D}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E14E}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E4D0}-\u{1E4EB}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1E800}-\u{1E8C4}\u{1E900}-\u{1E943}\u{1E94B}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1F004}\u{1F0CF}\u{1F170}\u{1F171}\u{1F17E}\u{1F17F}\u{1F18E}\u{1F191}-\u{1F19A}\u{1F1E6}-\u{1F1FF}\u{1F201}\u{1F202}\u{1F21A}\u{1F22F}\u{1F232}-\u{1F23A}\u{1F250}\u{1F251}\u{1F300}-\u{1F321}\u{1F324}-\u{1F393}\u{1F396}\u{1F397}\u{1F399}-\u{1F39B}\u{1F39E}-\u{1F3F0}\u{1F3F3}-\u{1F3F5}\u{1F3F7}-\u{1F4FD}\u{1F4FF}-\u{1F53D}\u{1F549}-\u{1F54E}\u{1F550}-\u{1F567}\u{1F56F}\u{1F570}\u{1F573}-\u{1F57A}\u{1F587}\u{1F58A}-\u{1F58D}\u{1F590}\u{1F595}\u{1F596}\u{1F5A4}\u{1F5A5}\u{1F5A8}\u{1F5B1}\u{1F5B2}\u{1F5BC}\u{1F5C2}-\u{1F5C4}\u{1F5D1}-\u{1F5D3}\u{1F5DC}-\u{1F5DE}\u{1F5E1}\u{1F5E3}\u{1F5E8}\u{1F5EF}\u{1F5F3}\u{1F5FA}-\u{1F64F}\u{1F680}-\u{1F6C5}\u{1F6CB}-\u{1F6D2}\u{1F6D5}-\u{1F6D7}\u{1F6DC}-\u{1F6E5}\u{1F6E9}\u{1F6EB}\u{1F6EC}\u{1F6F0}\u{1F6F3}-\u{1F6FC}\u{1F7E0}-\u{1F7EB}\u{1F7F0}\u{1F90C}-\u{1F93A}\u{1F93C}-\u{1F945}\u{1F947}-\u{1F9FF}\u{1FA70}-\u{1FA7C}\u{1FA80}-\u{1FA88}\u{1FA90}-\u{1FABD}\u{1FABF}-\u{1FAC5}\u{1FACE}-\u{1FADB}\u{1FAE0}-\u{1FAE8}\u{1FAF0}-\u{1FAF8}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}]/u);
  return "variable";
};
var pushContext = (state, type, col) => {
  state.context = {
    prev: state.context,
    indent: state.indent,
    col,
    type
  };
  return state.context;
};
var popContext = (state) => {
  state.indent = state.context.indent;
  state.context = state.context.prev;
  return state.context;
};
var cypher = {
  startState() {
    return {
      tokenize: tokenBase,
      context: null,
      indent: 0,
      col: 0
    };
  },
  token(stream, state) {
    if (stream.sol()) {
      if (state.context && state.context.align == null) {
        state.context.align = false;
      }
      state.indent = stream.indentation();
    }
    if (stream.eatSpace()) {
      return null;
    }
    const style = state.tokenize(stream, state);
    if (style !== "comment" && state.context && state.context.align == null && state.context.type !== "pattern") {
      state.context.align = true;
    }
    if (curPunc === "(") {
      pushContext(state, ")", stream.column());
    } else if (curPunc === "[") {
      pushContext(state, "]", stream.column());
    } else if (curPunc === "{") {
      pushContext(state, "}", stream.column());
    } else if (/[\]})]/.test(curPunc)) {
      while (state.context && state.context.type === "pattern") {
        popContext(state);
      }
      if (state.context && curPunc === state.context.type) {
        popContext(state);
      }
    } else if (curPunc === "." && state.context && state.context.type === "pattern") {
      popContext(state);
    } else if (/atom|string|variable/.test(style) && state.context) {
      if (/[}\]]/.test(state.context.type)) {
        pushContext(state, "pattern", stream.column());
      } else if (state.context.type === "pattern" && !state.context.align) {
        state.context.align = true;
        state.context.col = stream.column();
      }
    }
    return style;
  },
  indent: (state, textAfter, cx) => {
    const firstChar = textAfter && textAfter.charAt(0);
    let context = state.context;
    if (/[\]}]/.test(firstChar)) {
      while (context && context.type === "pattern") {
        context = context.prev;
      }
    }
    const closing2 = context && firstChar === context.type;
    if (!context)
      return 0;
    if (context.type === "keywords")
      return null;
    if (context.align)
      return context.col + (closing2 ? 0 : 1);
    return context.indent + (closing2 ? 0 : cx.unit);
  },
  languageData: {
    commentTokens: {
      line: "//",
      block: {
        open: "/*",
        close: "*/"
      }
    }
  }
};

// node_modules/@neo4j-cypher/codemirror/es/cypher-extensions.js
var _excluded12 = ["delay", "showErrors"];
function ownKeys9(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread8(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys9(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys9(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var typeMarkerTheme = EditorView.baseTheme({
  // ".cm-underline": { textDecoration: "underline 3px red" }
});
var typeMarkerFromTo = (view, options2 = {}) => {
  const effects = [addTypeMarkerEffect.of(options2)];
  view.dispatch({
    effects
  });
  return true;
};
var resetColors = (view, editorSupport) => {
  const effects = [clearTypeMarkersEffect.of()];
  view.dispatch({
    effects
  });
};
var fixColors = (view, editorSupport) => {
  resetColors(view, editorSupport);
  if (!editorSupport.parseTree || !editorSupport.input) {
    return;
  }
  editorSupport.applyHighlighthing((element, type) => {
    const {
      start: from2,
      stop: to
    } = TreeUtils.getPosition(element) || {
      start: 0,
      stop: 0
    };
    typeMarkerFromTo(view, {
      from: from2,
      to: to + 1,
      type
    });
  });
};
var domListener = ({
  onFocusChanged = () => {
  },
  onScrollChanged = () => {
  },
  onKeyDown = () => {
  },
  onKeyUp = () => {
  }
}) => [EditorView.domEventHandlers({
  focus: () => {
    onFocusChanged(true);
  },
  blur: () => {
    onFocusChanged(false);
  },
  scroll: (event, view) => {
    if (event.target === view.scrollDOM) {
      const {
        scrollTop,
        clientHeight,
        scrollHeight,
        scrollLeft,
        clientWidth,
        scrollWidth
      } = event.target;
      onScrollChanged({
        scrollTop,
        clientHeight,
        scrollHeight,
        scrollLeft,
        clientWidth,
        scrollWidth
      });
    }
  },
  keydown: (event) => {
    onKeyDown(event);
  },
  keyup: (event) => {
    onKeyUp(event);
  }
})];
var cypherLinter = (_ref4 = {}) => {
  let {
    delay = 750,
    showErrors = true
  } = _ref4, otherOptions = _objectWithoutProperties2(_ref4, _excluded12);
  return [linter((view) => {
    if (!getStateValue(view.state).length)
      return [];
    const editorSupport = getStateEditorSupport(view.state);
    if (!editorSupport)
      return [];
    const version = view.newContentVersion();
    editorSupport.update(getStateValue(view.state), version);
    fixColors(view, editorSupport);
    return (showErrors && editorSupport.parseErrors || []).map(({
      msg,
      start: start2,
      stop
    }) => {
      return {
        severity: "error",
        from: start2,
        to: stop + 1,
        message: msg
      };
    });
  }, _objectSpread8(_objectSpread8({}, otherOptions), {}, {
    delay
  }))];
};
var cypherLanguage = () => [StreamLanguage.define(cypher)];
var cypherCompletions = (context) => {
  const editorSupport = getStateEditorSupport(context.state);
  editorSupport.update(getStateValue(context.state));
  const {
    line: line2,
    column: column2
  } = editorSupport.positionConverter.toRelative(context.pos);
  const completion = editorSupport.getCompletion(line2, column2, true);
  const {
    items,
    from: from2,
    to
  } = completion;
  const completions = items.map(({
    type,
    view,
    content: content2,
    postfix
  }) => ({
    type,
    label: view,
    apply: content2,
    detail: postfix
  }));
  let word = context.matchBefore(/\w*/);
  let cypherCompletions2 = null;
  if (!(word.from == word.to && !context.explicit)) {
    cypherCompletions2 = {
      //from: word.from,
      // TODO - line is 1 based, column is 0 based
      from: getStatePositionAbsoluteForLineColumn(context.state, from2),
      options: completions,
      filter: false,
      getMatch: () => []
    };
  }
  return cypherCompletions2;
};
var cypherCompletion = ({
  activateOnTyping = false,
  closeOnBlur = true
} = {}) => [autocompletion({
  activateOnTyping,
  closeOnBlur,
  override: [cypherCompletions]
})];
var syntaxStyles = [{
  tag: tags.comment,
  class: "cm-comment"
}, {
  tag: tags.variableName,
  class: "cm-variable"
}, {
  tag: [tags.string, tags.special(tags.brace)],
  class: "cm-string"
}, {
  tag: tags.number,
  class: "cm-number"
}, {
  tag: tags.keyword,
  class: "cm-keyword"
}, {
  tag: tags.operator,
  class: "cm-operator"
}];
var syntaxStyle = HighlightStyle.define(syntaxStyles);
var syntaxCSS = [syntaxHighlighting(syntaxStyle)];
var cypherLineNumbers = ({
  lineNumberFormatter,
  onLineNumberClick = () => {
  }
}) => [lineNumbers({
  formatNumber: (number2, state) => lineNumberFormatter(number2, getStateLineCount(state), state),
  domEventHandlers: {
    click(view, lineObject, event) {
      const {
        line: line2
      } = getStatePositionForAbsolute(view.state, lineObject.from) || {};
      onLineNumberClick(line2, event);
      return true;
    }
  }
})];
var themeOverrides = {
  "&.cm-editor": {
    "&.cm-focused": {
      outline: "none"
    }
  },
  ".cm-cursor .cm-cursor-wide": {
    borderLeft: "0.67em solid rgba(147, 161, 161, 0.37)"
  }
};
var USE_DARK_FLAG = true;
var themeDarkExtensions = [EditorView.theme(themeOverrides, USE_DARK_FLAG ? {
  dark: true
} : {}), EditorView.editorAttributes.of({
  class: "cm-dark"
})];
var themeLightExtensions = [EditorView.theme(themeOverrides, USE_DARK_FLAG ? {
  dark: false
} : {}), EditorView.editorAttributes.of({
  class: "cm-light"
})];
var themeAutoExtensions = [EditorView.theme(themeOverrides, {}), EditorView.editorAttributes.of({
  class: "cm-auto"
})];
var cursorWideExtensions = [EditorView.editorAttributes.of({
  class: "cm-cursor-wide"
})];
var cursorNormalExtensions = [EditorView.editorAttributes.of({
  class: "cm-cursor-normal"
})];
var runTab = (view) => {
  const {
    state,
    dispatch
  } = view;
  const status = completionStatus(state);
  if (status === null) {
    if (getStateHasSelection(state)) {
      return indentMore(view);
    } else {
      dispatch(state.update(state.replaceSelection(state.facet(indentUnit)), {
        scrollIntoView: true,
        userEvent: "input"
      }));
      return true;
    }
  } else if (status === "active") {
    return acceptCompletion(view);
  }
  return false;
};
var shiftTab = (view) => {
  const {
    state
  } = view;
  const status = completionStatus(state);
  if (status === null && getStateHasSelection(state)) {
    return indentLess(view);
  }
  return false;
};
var tabKeyExtensions = [keymap.of([{
  key: "Tab",
  run: runTab,
  shift: shiftTab
}])];
var historyExtensions = [history(), keymap.of(historyKeymap)];
var searchTopExtensions = [search({
  top: true
}), keymap.of(searchKeymap)];
var searchBottomExtensions = [search({
  top: false
}), keymap.of(searchKeymap)];
var readableExtensions = [drawSelection(), EditorState.allowMultipleSelections.of(true), indentOnInput(), rectangularSelection(), crosshairCursor(), keymap.of([...defaultKeymap, ...foldKeymap])];
var readOnlyExtensions = [EditorState.readOnly.of(true)];
var readOnlyNoCursorExtensions = [EditorState.readOnly.of(true), EditorView.editable.of(false)];
var lineWrappingExtensions = [EditorView.lineWrapping];
var useLintExtensions = [cypherLinter(), keymap.of(lintKeymap)];
var useNoLintExtensions = [cypherLinter({
  showErrors: false
})];
var useAutocompleteExtensions = [cypherCompletion(), keymap.of(completionKeymap)];
var useStickyAutocompleteExtensions = [cypherCompletion({
  closeOnBlur: false
}), keymap.of(completionKeymap)];
var getCypherLanguageExtensions = ({
  cypherLanguage: cypher2
}) => cypher2 ? [cypherLanguage(), typeMarkerField, typeMarkerTheme, editorSupportField, syntaxCSS, EditorView.editorAttributes.of({
  class: "cm-cypher"
})] : [];
var getAutocompleteExtensions = ({
  cypherLanguage: cypherLanguage2,
  readOnly: readOnly2,
  autocomplete,
  autocompleteCloseOnBlur
}) => cypherLanguage2 && readOnly2 === false && autocomplete ? !autocompleteCloseOnBlur ? useStickyAutocompleteExtensions : useAutocompleteExtensions : [];
var getCursorWideExtensions = ({
  cursorWide
}) => cursorWide ? cursorWideExtensions : cursorNormalExtensions;
var getHistoryExtensions = ({
  history: history2
}) => history2 ? historyExtensions : [];
var getLineNumbersExtensions = ({
  lineNumbers: lineNumbers2,
  lineNumberFormatter,
  onLineNumberClick
}) => lineNumbers2 ? [cypherLineNumbers({
  lineNumberFormatter,
  onLineNumberClick
})] : [];
var getLineWrappingExtensions = ({
  lineWrapping
}) => lineWrapping ? lineWrappingExtensions : [];
var getLintExtensions = ({
  cypherLanguage: cypherLanguage2,
  readOnly: readOnly2,
  lint
}) => cypherLanguage2 && readOnly2 === false && lint ? useLintExtensions : useNoLintExtensions;
var getPlaceholderExtensions = ({
  placeholder: placeholder2
}) => placeholder2 !== void 0 ? [placeholder(placeholder2)] : [];
var getReadableExtensions = ({
  readOnly: readOnly2,
  readOnlyCursor
}) => !readOnly2 || readOnlyCursor ? readableExtensions : [];
var getReadOnlyExtensions = ({
  readOnly: readOnly2,
  readOnlyCursor
}) => readOnly2 ? readOnlyCursor ? readOnlyExtensions : readOnlyNoCursorExtensions : [];
var getTabKeyExtensions = ({
  tabKey,
  indentUnit: indentUnit2
}) => tabKey ? tabKeyExtensions.concat(indentUnit.of(indentUnit2)) : [];
var getThemeExtensions = ({
  theme: theme2
}) => theme2 === THEME_DARK ? themeDarkExtensions : theme2 === THEME_AUTO ? themeAutoExtensions : themeLightExtensions;
var getSearchExtensions = ({
  readOnly: readOnly2,
  search: search3,
  searchTop
}) => search3 ? searchTop ? searchTopExtensions : searchBottomExtensions : [];
var getTooltipAbsoluteExtensions = ({
  tooltipAbsolute
}) => tooltipAbsolute ? [tooltips({
  position: "absolute"
})] : [tooltips({
  position: "fixed"
})];
var getCloseBracketsExtensions = ({
  closeBrackets: closeBrackets2
}) => closeBrackets2 ? [closeBrackets(), keymap.of(closeBracketsKeymap)] : [];
var getBracketMatchingExtensions = ({
  bracketMatching: bracketMatching2
}) => bracketMatching2 ? [bracketMatching()] : [];

// node_modules/@neo4j-cypher/codemirror/es/codemirror.js
function ownKeys10(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread9(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys10(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys10(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var withDefaultOptions = (options2) => {
  const combinedOptions = _objectSpread9({}, defaultOptions2);
  for (let key of Object.keys(options2)) {
    if (options2[key] !== void 0) {
      combinedOptions[key] = options2[key];
    }
  }
  return combinedOptions;
};
var isTruthyObject = (obj) => obj && typeof obj === "object";
var areSchemasDifferent = (oldSchema, newSchema) => {
  const oldIsObject = isTruthyObject(oldSchema);
  const newIsObject = isTruthyObject(newSchema);
  if (oldIsObject !== newIsObject) {
    return true;
  } else if (oldIsObject) {
    const oldKeys = Object.keys(oldSchema);
    const newKeys = Object.keys(newSchema);
    if (oldKeys.length !== newKeys.length) {
      return true;
    } else {
      return oldKeys.some((key) => oldSchema[key] !== newSchema[key]);
    }
  } else {
    return false;
  }
};
var getExtensions = (options2 = {}, {
  lintConf = new Compartment(),
  autocompleteConf = new Compartment(),
  bracketMatchingConf = new Compartment(),
  closeBracketsConf = new Compartment(),
  cursorWideConf = new Compartment(),
  cypherLanguageConf = new Compartment(),
  readableConf = new Compartment(),
  readOnlyConf = new Compartment(),
  showLinesConf = new Compartment(),
  lineWrappingConf = new Compartment(),
  historyConf = new Compartment(),
  placeholderConf = new Compartment(),
  searchConf = new Compartment(),
  tabKeyConf = new Compartment(),
  themeConf = new Compartment(),
  tooltipAbsoluteConf = new Compartment(),
  onLineNumberClick = () => {
  },
  onFocusChanged = () => {
  },
  onScrollChanged = () => {
  },
  onKeyDown = () => {
  },
  onKeyUp = () => {
  }
} = {}) => {
  const combinedOptions = withDefaultOptions(options2);
  const {
    autocomplete,
    autocompleteCloseOnBlur,
    bracketMatching: bracketMatching2,
    closeBrackets: closeBrackets2,
    cursorWide,
    cypherLanguage: cypherLanguage2,
    history: history2,
    tabKey,
    indentUnit: indentUnit2,
    lineNumberFormatter,
    lineNumbers: lineNumbers2,
    lineWrapping,
    lint,
    placeholder: placeholder2,
    readOnly: readOnly2,
    readOnlyCursor,
    search: search3,
    searchTop,
    theme: theme2,
    tooltipAbsolute
  } = combinedOptions;
  return [domListener({
    onFocusChanged,
    onScrollChanged,
    onKeyDown,
    onKeyUp
  }), cypherLanguageConf.of(getCypherLanguageExtensions({
    cypherLanguage: cypherLanguage2
  })), lintConf.of(getLintExtensions({
    cypherLanguage: cypherLanguage2,
    readOnly: readOnly2,
    lint
  })), autocompleteConf.of(getAutocompleteExtensions({
    cypherLanguage: cypherLanguage2,
    readOnly: readOnly2,
    autocomplete,
    autocompleteCloseOnBlur
  })), showLinesConf.of(getLineNumbersExtensions({
    lineNumbers: lineNumbers2,
    lineNumberFormatter,
    onLineNumberClick
  })), lineWrappingConf.of(getLineWrappingExtensions({
    lineWrapping
  })), historyConf.of(getHistoryExtensions({
    history: history2
  })), tabKeyConf.of(getTabKeyExtensions({
    tabKey,
    indentUnit: indentUnit2
  })), readableConf.of(getReadableExtensions({
    readOnly: readOnly2,
    readOnlyCursor
  })), placeholderConf.of(getPlaceholderExtensions({
    placeholder: placeholder2
  })), themeConf.of(getThemeExtensions({
    theme: theme2
  })), cursorWideConf.of(getCursorWideExtensions({
    cursorWide
  })), searchConf.of(getSearchExtensions({
    readOnly: readOnly2,
    search: search3,
    searchTop
  })), tooltipAbsoluteConf.of(getTooltipAbsoluteExtensions({
    tooltipAbsolute
  })), readOnlyConf.of(getReadOnlyExtensions({
    readOnly: readOnly2,
    readOnlyCursor
  })), bracketMatchingConf.of(getBracketMatchingExtensions({
    bracketMatching: bracketMatching2
  })), closeBracketsConf.of(getCloseBracketsExtensions({
    closeBrackets: closeBrackets2
  }))];
};
var isActiveSearchMatches = (searchMatches) => searchMatches > 0 && searchMatches <= 1e3;
var detectThemeDark = () => window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
var addDetectThemeDarkListener = (isThemeDarkCallback) => {
  const listener = (event) => {
    isThemeDarkCallback(event.matches);
  };
  window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", listener);
  return listener;
};
var removeDetectThemeDarkListener = (listener) => {
  window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").removeEventListener("change", listener);
};
function createCypherEditor(parentDOMElement, options2 = {}) {
  const combinedOptions = withDefaultOptions(options2);
  const {
    autofocus,
    position: position2,
    selection,
    parseOnSetValue,
    value,
    preExtensions,
    postExtensions
  } = combinedOptions;
  let {
    autocomplete,
    autocompleteOpen,
    autocompleteCloseOnBlur,
    autocompleteTriggerStrings,
    cypherLanguage: cypherLanguage2,
    history: history2,
    indentUnit: indentUnit2,
    lineNumberFormatter,
    lineNumbers: lineNumbers2,
    lineWrapping,
    lint,
    placeholder: placeholder2,
    readOnly: readOnly2,
    readOnlyCursor,
    search: search3,
    searchMatches,
    searchOpen,
    searchText,
    searchTop,
    schema,
    tabKey,
    theme: theme2,
    tooltipAbsolute
  } = combinedOptions;
  let editorSupport = null;
  let lastPosition = null;
  let lastSelection = null;
  let searchInitializing = false;
  let detectedThemeDark = theme2 === "auto" ? detectThemeDark() : null;
  let pressedKey = null;
  let deferredAutocomplete = false;
  const setDetectedThemeDark = (dark) => {
    detectedThemeDark = dark;
    updateTheme();
  };
  let detectedThemeDarkListener = theme2 === "auto" ? addDetectThemeDarkListener(setDetectedThemeDark) : null;
  const {
    on: onValueChanged,
    off: offValueChanged,
    fire: fireValueChanged
  } = createEventHandlers();
  const {
    on: onFocusChanged,
    off: offFocusChanged,
    fire: fireFocusChanged
  } = createEventHandlers();
  const {
    on: onScrollChanged,
    off: offScrollChanged,
    fire: fireScrollChanged
  } = createEventHandlers();
  const {
    on: onPositionChanged,
    off: offPositionChanged,
    fire: firePositionChanged
  } = createEventHandlers();
  const {
    on: onSelectionChanged,
    off: offSelectionChanged,
    fire: fireSelectionChanged
  } = createEventHandlers();
  const {
    on: onAutocompleteChanged,
    off: offAutocompleteChanged,
    fire: fireAutocompleteChanged
  } = createEventHandlers();
  const {
    on: onSearchChanged,
    off: offSearchChanged,
    fire: fireSearchChanged
  } = createEventHandlers();
  const {
    on: onLineNumberClick,
    off: offLineNumberClick,
    fire: fireLineNumberClick
  } = createEventHandlers();
  const {
    on: onKeyDown,
    off: offKeyDown,
    fire: fireKeyDown
  } = createEventHandlers();
  const {
    on: onKeyUp,
    off: offKeyUp,
    fire: fireKeyUp
  } = createEventHandlers();
  const lineNumberClick = (line2, event) => {
    fireLineNumberClick(line2, event);
  };
  const keyDown = (event) => {
    pressedKey = !event.metaKey && !event.ctrlKey && !event.altKey && event.key && event.key.length === 1 ? event.key : null;
    fireKeyDown(event);
  };
  const keyUp = (event) => {
    if (deferredAutocomplete) {
      showAutocomplete();
      deferredAutocomplete = false;
    }
    pressedKey = null;
    fireKeyUp(event);
  };
  const deferAutocompleteForChanges = (changes) => {
    const {
      length: length2 = 0,
      newLength = 0
    } = changes;
    const isSmallInsert = newLength > length2 && newLength - length2 <= 2;
    if (pressedKey && cypherLanguage2 && autocomplete && Array.isArray(autocompleteTriggerStrings) && isSmallInsert) {
      let changedText = null;
      changes.iterChanges((fromA, toA, fromB, toB, inserted) => {
        if (!changedText && inserted && typeof inserted === "object" && Array.isArray(inserted.text) && inserted.text.length == 1) {
          changedText = inserted.text[0];
        }
      });
      if (changedText && autocompleteTriggerStrings.includes(changedText)) {
        deferredAutocomplete = true;
      }
    }
  };
  const handleValueChanged = (value2, changes) => {
    deferAutocompleteForChanges(changes);
    fireValueChanged(value2, changes);
  };
  const handlePositionChanged = (positionObject) => {
    lastPosition = (positionObject || {
      position: null
    }).position;
    firePositionChanged(positionOldToNew(positionObject));
  };
  const handleSelectionChanged = (selection2) => {
    lastSelection = selection2;
    fireSelectionChanged(selection2);
  };
  const handleAutocompleteChanged = (newAutocompleteOpen, options3, option) => {
    autocompleteOpen = newAutocompleteOpen;
    fireAutocompleteChanged(autocompleteOpen, options3, option);
  };
  const handleSearchChanged = (newSearchOpen, text, matches2) => {
    if (!searchInitializing) {
      searchOpen = newSearchOpen;
      fireSearchChanged(searchOpen, text, matches2);
    }
  };
  const handleFocusChanged = (focused) => {
    fireFocusChanged(focused);
  };
  const handleScrollChanged = (scrollInfo) => {
    fireScrollChanged(scrollInfo);
  };
  const updateListener2 = EditorView.updateListener.of((v) => {
    const {
      docChanged: valueChanged,
      selectionSet: selectionChanged
    } = v;
    const oldPosition = selectionChanged ? valueChanged ? null : getStatePositionAbsolute(v.startState) : null;
    const newPosition = selectionChanged ? getStatePositionAbsolute(v.state) : null;
    const positionChanged = valueChanged || oldPosition !== newPosition;
    const oldAutocompleteOpen = getStateAutocompleteOpen(v.startState);
    const newAutocompleteOpen = getStateAutocompleteOpen(v.state);
    const pickedAutocompleteOption = getViewUpdatePickedAutocompleteOption(v, true);
    const autocompleteChanged = cypherLanguage2 && autocomplete && (oldAutocompleteOpen !== newAutocompleteOpen || !areViewUpdateAutocompleteOptionsEqual(v) || pickedAutocompleteOption);
    const oldSearchOpen = getStateSearchOpen(v.startState);
    const newSearchOpen = getStateSearchOpen(v.state);
    const oldSearchText = getStateSearchText(v.startState);
    const newSearchText = getStateSearchText(v.state);
    const oldSearchSpec = getStateSearchSpec(v.startState);
    const newSearchSpec = getStateSearchSpec(v.state);
    const activeSearchMatches = isActiveSearchMatches(searchMatches);
    const searchChanged = search3 && (oldSearchOpen !== newSearchOpen || (activeSearchMatches ? oldSearchSpec !== newSearchSpec : oldSearchText !== newSearchText));
    if (valueChanged) {
      handleValueChanged(getStateValue(v.state), v.changes);
    }
    if (positionChanged) {
      handlePositionChanged(getStatePosition(v.state));
    }
    if (selectionChanged) {
      handleSelectionChanged(getStateSelection(v.state));
    }
    if (autocompleteChanged) {
      const newAutocompleteOptions = newAutocompleteOpen ? getStateAutocompleteOptions(v.state, true) : void 0;
      const newAutocompleteOption = pickedAutocompleteOption;
      handleAutocompleteChanged(newAutocompleteOpen, newAutocompleteOptions, newAutocompleteOption);
    }
    if (searchChanged) {
      if (oldSearchOpen || newSearchOpen) {
        const newSearchMatches = activeSearchMatches && newSearchOpen ? getStateSearchMatches(v.state, searchMatches) : void 0;
        handleSearchChanged(newSearchOpen, newSearchText, newSearchMatches);
      }
    } else if (valueChanged && activeSearchMatches && newSearchOpen) {
      handleSearchChanged(newSearchOpen, newSearchText, getStateSearchMatches(v.state, searchMatches));
    }
  });
  const preConf = new Compartment();
  const lintConf = new Compartment();
  const autocompleteConf = new Compartment();
  const bracketMatchingConf = new Compartment();
  const closeBracketsConf = new Compartment();
  const readableConf = new Compartment();
  const readOnlyConf = new Compartment();
  const showLinesConf = new Compartment();
  const lineWrappingConf = new Compartment();
  const historyConf = new Compartment();
  const placeholderConf = new Compartment();
  const searchConf = new Compartment();
  const tabKeyConf = new Compartment();
  const themeConf = new Compartment();
  const cursorWideConf = new Compartment();
  const cypherLanguageConf = new Compartment();
  const tooltipAbsoluteConf = new Compartment();
  const postConf = new Compartment();
  const createOptions = theme2 === "auto" ? _objectSpread9(_objectSpread9({}, combinedOptions), {}, {
    theme: detectedThemeDark ? "dark" : "light"
  }) : combinedOptions;
  const initialState2 = EditorState.create({
    doc: value,
    extensions: [preConf.of(preExtensions), ...getExtensions(createOptions, {
      lintConf,
      autocompleteConf,
      bracketMatchingConf,
      closeBracketsConf,
      cursorWideConf,
      cypherLanguageConf,
      tabKeyConf,
      readableConf,
      readOnlyConf,
      showLinesConf,
      lineWrappingConf,
      historyConf,
      placeholderConf,
      searchConf,
      themeConf,
      tooltipAbsoluteConf,
      postConf,
      onLineNumberClick: lineNumberClick,
      onFocusChanged: handleFocusChanged,
      onScrollChanged: handleScrollChanged,
      onKeyDown: keyDown,
      onKeyUp: keyUp
    }), updateListener2, postConf.of(postExtensions)]
  });
  let editor = new EditorView({
    parent: parentDOMElement,
    state: initialState2
  });
  editor.version = 1;
  editor.newContentVersion = function newContentVersion() {
    this.version += 1;
    return this.version;
  };
  editor.newContentVersion.bind(editor);
  if (cypherLanguage2) {
    editorSupport = getStateEditorSupport(editor.state);
    editorSupport.update(value);
  }
  const getPositionForValue = (positionValue) => getStatePositionForAny(editor.state, positionNewToOld(positionValue));
  const setPosition = (positionParam, scrollIntoView4 = true) => {
    const positionObject = getPositionForValue(positionParam);
    if (positionObject) {
      const {
        position: position3
      } = positionObject;
      if (position3 !== lastPosition) {
        lastPosition = position3;
        editor.dispatch(editor.state.update({
          scrollIntoView: scrollIntoView4,
          selection: {
            anchor: position3
          }
        }));
      }
    }
  };
  const setSelection = (selection2, scrollIntoView4 = true) => {
    const ranges = [SelectionRange.fromJSON({
      from: 0,
      to: 2,
      anchor: 0,
      head: 2
    }), SelectionRange.fromJSON({
      from: 3,
      to: 4,
      anchor: 3,
      head: 4
    }), SelectionRange.fromJSON({
      from: 6,
      to: 8,
      anchor: 6,
      head: 8
    })];
    let newSelection = EditorSelection.create(ranges, 2);
    if (selection2 && selection2 !== lastSelection) {
      lastSelection = selection2;
      editor.dispatch(editor.state.update({
        scrollIntoView: scrollIntoView4,
        selection: selection2
      }));
    }
  };
  const showAutocomplete = () => {
    if (cypherLanguage2 && autocomplete) {
      startCompletion(editor);
    }
  };
  const hideAutocomplete = () => {
    if (cypherLanguage2 && autocomplete) {
      closeCompletion(editor);
    }
  };
  const showSearch = () => {
    if (search3) {
      openSearchPanel(editor);
    }
  };
  const hideSearch = () => {
    if (search3) {
      closeSearchPanel(editor);
    }
  };
  if (position2 !== void 0) {
    setPosition(position2);
  } else if (selection !== void 0) {
    setSelection(selection);
  }
  lastPosition = (getStatePosition(editor.state) || {
    position: null
  }).position;
  lastSelection = getStateSelection(editor.state) || null;
  if (cypherLanguage2 && schema !== void 0) {
    editorSupport.setSchema(schema);
  }
  if (cypherLanguage2 && autocomplete && autocompleteOpen === true) {
    showAutocomplete();
  }
  if (cypherLanguage2 && search3 && searchOpen === true) {
    showSearch();
  }
  if (autofocus) {
    editor.contentDOM.focus();
  }
  const setPreExtensions = (preExtensions2 = defaultOptions2.preExtensions) => {
    editor.dispatch({
      effects: preConf.reconfigure(preExtensions2)
    });
  };
  const setPostExtensions = (postExtensions2 = defaultOptions2.postExtensions) => {
    editor.dispatch({
      effects: postConf.reconfigure(postExtensions2)
    });
  };
  const setValue = (value2 = defaultOptions2.value, parseOnSetValueParam = parseOnSetValue) => {
    const update = editor.state.update({
      changes: {
        from: 0,
        to: getStateLength(editor.state),
        insert: value2
      }
    });
    editor.update([update]);
    if (cypherLanguage2 && parseOnSetValueParam !== false) {
      const version = editor.newContentVersion();
      const editorSupport2 = getStateEditorSupport(editor.state);
      editorSupport2.update(value2, version);
      fixColors(editor, editorSupport2);
    }
  };
  const selectAutocompleteOption = (index4) => {
    if (cypherLanguage2 && autocomplete) {
      editor.dispatch({
        effects: setSelectedCompletion(index4)
      });
      acceptCompletion(editor);
    }
  };
  const setHistory = (newHistory = defaultOptions2.history) => {
    history2 = newHistory;
    editor.dispatch({
      effects: historyConf.reconfigure(getHistoryExtensions({
        history: history2
      }))
    });
  };
  const clearHistory = () => {
    if (history2) {
      editor.dispatch({
        effects: historyConf.reconfigure([])
      });
      editor.dispatch({
        effects: historyConf.reconfigure(getHistoryExtensions({
          history: history2
        }))
      });
    }
  };
  const setLineNumbers = (newLineNumbers = defaultOptions2.lineNumbers) => {
    lineNumbers2 = newLineNumbers;
    editor.dispatch({
      effects: showLinesConf.reconfigure(getLineNumbersExtensions({
        lineNumbers: lineNumbers2,
        lineNumberFormatter,
        onLineNumberClick: lineNumberClick
      }))
    });
  };
  const setLineNumberFormatter = (newLineNumberFormatter = defaultOptions2.lineNumberFormatter) => {
    lineNumberFormatter = newLineNumberFormatter;
    if (lineNumbers2) {
      editor.dispatch({
        effects: showLinesConf.reconfigure(getLineNumbersExtensions({
          lineNumbers: lineNumbers2,
          lineNumberFormatter,
          onLineNumberClick: lineNumberClick
        }))
      });
    }
  };
  const setReadOnly = (newReadOnly = defaultOptions2.readOnly) => {
    readOnly2 = newReadOnly;
    editor.dispatch({
      effects: [readableConf.reconfigure(getReadableExtensions({
        readOnly: readOnly2,
        readOnlyCursor
      })), readOnlyConf.reconfigure(getReadOnlyExtensions({
        readOnly: readOnly2,
        readOnlyCursor
      })), autocompleteConf.reconfigure(getAutocompleteExtensions({
        cypherLanguage: cypherLanguage2,
        readOnly: readOnly2,
        autocomplete,
        autocompleteCloseOnBlur
      })), lintConf.reconfigure(getLintExtensions({
        cypherLanguage: cypherLanguage2,
        readOnly: readOnly2,
        lint
      }))]
    });
  };
  const setReadOnlyCursor = (newReadOnlyCursor = defaultOptions2.readOnlyCursor) => {
    readOnlyCursor = newReadOnlyCursor;
    editor.dispatch({
      effects: [readableConf.reconfigure(getReadableExtensions({
        readOnly: readOnly2,
        readOnlyCursor
      })), readOnlyConf.reconfigure(getReadOnlyExtensions({
        readOnly: readOnly2,
        readOnlyCursor
      }))]
    });
  };
  const setPlaceholder = (newPlaceholder = defaultOptions2.placeholder) => {
    placeholder2 = newPlaceholder;
    editor.dispatch({
      effects: [placeholderConf.reconfigure(getPlaceholderExtensions({
        placeholder: placeholder2
      }))]
    });
  };
  const setLineWrapping = (newLineWrapping = defaultOptions2.lineWrapping) => {
    lineWrapping = newLineWrapping;
    editor.dispatch({
      effects: [lineWrappingConf.reconfigure(getLineWrappingExtensions({
        lineWrapping
      }))]
    });
  };
  const setAutocomplete = (newAutocomplete = defaultOptions2.autocomplete) => {
    const autocompleteActivated = cypherLanguage2 && newAutocomplete && !(cypherLanguage2 && autocomplete);
    autocomplete = newAutocomplete;
    editor.dispatch({
      effects: autocompleteConf.reconfigure(getAutocompleteExtensions({
        cypherLanguage: cypherLanguage2,
        readOnly: readOnly2,
        autocomplete,
        autocompleteCloseOnBlur
      }))
    });
    if (autocompleteActivated) {
      if (autocompleteOpen) {
        showAutocomplete();
      }
    }
  };
  const setAutocompleteCloseOnBlur = (newAutocompleteCloseOnBlur = defaultOptions2.autocompleteCloseOnBlur) => {
    autocompleteCloseOnBlur = newAutocompleteCloseOnBlur;
    editor.dispatch({
      effects: autocompleteConf.reconfigure(getAutocompleteExtensions({
        cypherLanguage: cypherLanguage2,
        readOnly: readOnly2,
        autocomplete,
        autocompleteCloseOnBlur
      }))
    });
  };
  const setAutocompleteOpen = (newAutocompleteOpen = defaultOptions2.autocompleteOpen) => {
    autocompleteOpen = newAutocompleteOpen;
    if (autocompleteOpen) {
      showAutocomplete();
    } else {
      hideAutocomplete();
    }
  };
  const setAutocompleteTriggerStrings = (newAutocompleteTriggerStrings = defaultOptions2.autocompleteTriggerStrings) => {
    autocompleteTriggerStrings = newAutocompleteTriggerStrings;
  };
  const setLint = (newLint = defaultOptions2.lint) => {
    lint = newLint;
    editor.dispatch({
      effects: lintConf.reconfigure(getLintExtensions({
        cypherLanguage: cypherLanguage2,
        readOnly: readOnly2,
        lint
      }))
    });
  };
  const getPosition = () => {
    return positionOldToNew(getStatePosition(editor.state));
  };
  const getSelection2 = () => {
    return getStateSelection(editor.state);
  };
  const getLineCount = () => {
    return editor ? getStateLineCount(editor.state) : 0;
  };
  const setSchema = (newSchema = defaultOptions2.schema) => {
    const schemaChanged = areSchemasDifferent(schema, newSchema);
    schema = newSchema;
    if (cypherLanguage2) {
      editorSupport.setSchema(schema);
      if (schemaChanged && autocomplete && autocompleteOpen) {
        showAutocomplete();
      }
    }
  };
  const setTheme = (newTheme = defaultOptions2.theme) => {
    const oldTheme = theme2;
    theme2 = newTheme;
    if (oldTheme === "auto" && newTheme !== "auto") {
      detectedThemeDark = null;
      detectedThemeDarkListener && removeDetectThemeDarkListener(detectedThemeDarkListener);
      detectedThemeDarkListener = null;
    }
    if (oldTheme !== "auto" && newTheme === "auto") {
      detectedThemeDark = detectThemeDark();
      detectedThemeDarkListener = addDetectThemeDarkListener(setDetectedThemeDark);
    }
    const derivedTheme = theme2 === "auto" ? detectedThemeDark ? "dark" : "light" : theme2;
    editor.dispatch({
      effects: themeConf.reconfigure(getThemeExtensions({
        theme: derivedTheme
      }))
    });
  };
  const updateTheme = () => {
    setTheme(theme2);
  };
  const setCursorWide = (cursorWide = defaultOptions2.cursorWide) => {
    editor.dispatch({
      effects: cursorWideConf.reconfigure(getCursorWideExtensions({
        cursorWide
      }))
    });
  };
  const setCypherLanguage = (newCypherLanguage = defaultOptions2.cypherLanguage) => {
    const cypherLanguageChanged = cypherLanguage2 !== newCypherLanguage;
    const autocompleteActivated = newCypherLanguage && autocomplete && !(cypherLanguage2 && autocomplete);
    cypherLanguage2 = newCypherLanguage;
    if (cypherLanguageChanged && !cypherLanguage2) {
      editorSupport = null;
    }
    editor.dispatch({
      effects: cypherLanguageConf.reconfigure(getCypherLanguageExtensions({
        cypherLanguage: cypherLanguage2
      }))
    });
    editor.dispatch({
      effects: autocompleteConf.reconfigure(getAutocompleteExtensions({
        cypherLanguage: cypherLanguage2,
        readOnly: readOnly2,
        autocomplete,
        autocompleteCloseOnBlur
      }))
    });
    editor.dispatch({
      effects: lintConf.reconfigure(getLintExtensions({
        cypherLanguage: cypherLanguage2,
        readOnly: readOnly2,
        lint
      }))
    });
    if (cypherLanguageChanged && cypherLanguage2) {
      editor.version = 1;
      const version = editor.newContentVersion();
      editorSupport = getStateEditorSupport(editor.state);
      editorSupport.setSchema(schema);
      editorSupport.update(value, version);
      fixColors(editor, editorSupport);
    }
    if (autocompleteActivated) {
      if (autocompleteOpen) {
        showAutocomplete();
      }
    }
    if (!cypherLanguage2) {
      editor && resetColors(editor);
    }
  };
  const setTooltipAbsolute = (newTooltipAbsolute = defaultOptions2.tooltipAbsolute) => {
    tooltipAbsolute = newTooltipAbsolute;
    editor.dispatch({
      effects: tooltipAbsoluteConf.reconfigure(getTooltipAbsoluteExtensions({
        tooltipAbsolute
      }))
    });
  };
  const focus = () => {
    editor && editor.focus();
  };
  const destroy = () => {
    editor && editor.destroy();
    detectedThemeDarkListener && removeDetectThemeDarkListener(detectedThemeDarkListener);
  };
  const setTabKey = (newTabKey = defaultOptions2.tabKey) => {
    tabKey = newTabKey;
    editor.dispatch({
      effects: tabKeyConf.reconfigure(getTabKeyExtensions({
        tabKey,
        indentUnit: indentUnit2
      }))
    });
  };
  const setIndentUnit = (newIndentUnit = defaultOptions2.indentUnit) => {
    indentUnit2 = newIndentUnit;
    editor.dispatch({
      effects: tabKeyConf.reconfigure(getTabKeyExtensions({
        tabKey,
        indentUnit: indentUnit2
      }))
    });
  };
  const setSearch = (newSearch = defaultOptions2.search) => {
    const searchActivated = newSearch && !search3;
    search3 = newSearch;
    if (searchActivated) {
      searchInitializing = true;
    }
    editor.dispatch({
      effects: searchConf.reconfigure(getSearchExtensions({
        readOnly: readOnly2,
        search: search3,
        searchTop
      }))
    });
    if (searchActivated) {
      setSearchText(searchText);
      if (searchOpen) {
        showSearch();
      }
      searchInitializing = false;
      handleSearchChanged(searchOpen, searchText, searchOpen ? getStateSearchMatches(editor.state, searchMatches) : void 0);
    }
  };
  const setSearchMatches = (newSearchMatches = defaultOptions2.searchMatches) => {
    const searchMatchesChanged = newSearchMatches !== searchMatches;
    searchMatches = newSearchMatches;
    if (searchMatchesChanged && searchMatches > 0) {
    }
  };
  const setSearchOpen = (newSearchOpen = defaultOptions2.searchOpen) => {
    searchOpen = newSearchOpen;
    if (searchOpen) {
      showSearch();
    } else {
      hideSearch();
    }
  };
  const setSearchText = (newSearchText = defaultOptions2.searchText) => {
    searchText = newSearchText;
    if (search3) {
      const searchQuery = getSearchQuery(editor.state);
      const {
        caseSensitive,
        literal: literal2,
        regexp,
        replace: replace2,
        wholeWord
      } = searchQuery;
      const newSearchQuery = new SearchQuery({
        search: searchText,
        caseSensitive,
        literal: literal2,
        regexp,
        replace: replace2,
        wholeWord
      });
      editor.dispatch({
        effects: setSearchQuery.of(newSearchQuery)
      });
    }
  };
  const setSearchTop = (newSearchTop = defaultOptions2.searchTop) => {
    searchTop = newSearchTop;
    editor.dispatch({
      effects: searchConf.reconfigure(getSearchExtensions({
        readOnly: readOnly2,
        search: search3,
        searchTop
      }))
    });
  };
  const setBracketMatching = (bracketMatching2 = defaultOptions2.bracketMatching) => {
    editor.dispatch({
      effects: bracketMatchingConf.reconfigure(getBracketMatchingExtensions({
        bracketMatching: bracketMatching2
      }))
    });
  };
  const setCloseBrackets = (closeBrackets2 = defaultOptions2.closeBrackets) => {
    editor.dispatch({
      effects: closeBracketsConf.reconfigure(getCloseBracketsExtensions({
        closeBrackets: closeBrackets2
      }))
    });
  };
  const editorAPI = {
    clearHistory,
    destroy,
    focus,
    getLineCount,
    getPosition,
    getPositionForValue,
    getSelection: getSelection2,
    selectAutocompleteOption,
    setAutocomplete,
    setAutocompleteCloseOnBlur,
    setAutocompleteOpen,
    setAutocompleteTriggerStrings,
    setBracketMatching,
    setCloseBrackets,
    setCursorWide,
    setCypherLanguage,
    setHistory,
    setIndentUnit,
    setLineNumberFormatter,
    setLineNumbers,
    setLineWrapping,
    setLint,
    setPlaceholder,
    setPosition,
    setReadOnly,
    setReadOnlyCursor,
    setSchema,
    setSearch,
    setSearchMatches,
    setSearchOpen,
    setSearchText,
    setSearchTop,
    setSelection,
    setTabKey,
    setTheme,
    setTooltipAbsolute,
    setValue,
    onAutocompleteChanged,
    offAutocompleteChanged,
    onFocusChanged,
    offFocusChanged,
    onKeyDown,
    offKeyDown,
    onKeyUp,
    offKeyUp,
    onLineNumberClick,
    offLineNumberClick,
    onPositionChanged,
    offPositionChanged,
    onScrollChanged,
    offScrollChanged,
    onSearchChanged,
    offSearchChanged,
    onSelectionChanged,
    offSelectionChanged,
    onValueChanged,
    offValueChanged,
    setPreExtensions,
    setPostExtensions,
    codemirror: editor,
    editorSupport
  };
  if (cypherLanguage2 && parseOnSetValue !== false) {
    const version = editor.newContentVersion();
    editorSupport.update(value, version);
    fixColors(editor, editorSupport);
  }
  return {
    editor: editorAPI
  };
}

// node_modules/@neo4j-cypher/react-codemirror/es/CypherEditor.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime());
var CypherEditor = class extends import_react174.Component {
  constructor(props) {
    super(props);
    _defineProperty(this, "setEditorRef", (ref) => {
      this.editorRef = ref;
    });
    _defineProperty(this, "valueChanged", (value, changes) => {
      this.lastValue = value;
      const {
        onValueChanged
      } = this.props;
      onValueChanged && onValueChanged(value, changes);
    });
    _defineProperty(this, "focusChanged", (focused) => {
      const {
        onFocusChanged
      } = this.props;
      this.setState({
        focused
      });
      onFocusChanged && onFocusChanged(focused);
    });
    _defineProperty(this, "scrollChanged", (scrollInfo) => {
      const {
        onScrollChanged
      } = this.props;
      onScrollChanged && onScrollChanged(scrollInfo);
    });
    _defineProperty(this, "positionChanged", (positionObject) => {
      this.lastPosition = (positionObject || {
        position: null
      }).position;
      const {
        onPositionChanged
      } = this.props;
      onPositionChanged && onPositionChanged(positionObject);
    });
    _defineProperty(this, "selectionChanged", (selection) => {
      this.lastSelection = selection;
      const {
        onSelectionChanged
      } = this.props;
      onSelectionChanged && onSelectionChanged(selection);
    });
    _defineProperty(this, "autocompleteChanged", (autocompleteOpen, options2, option) => {
      const {
        onAutocompleteChanged
      } = this.props;
      onAutocompleteChanged && onAutocompleteChanged(autocompleteOpen, options2, option);
    });
    _defineProperty(this, "searchChanged", (searchOpen, text, matches2) => {
      const {
        onSearchChanged
      } = this.props;
      onSearchChanged && onSearchChanged(searchOpen, text, matches2);
    });
    _defineProperty(this, "lineNumberClick", (line2, event) => {
      const {
        onLineNumberClick
      } = this.props;
      onLineNumberClick && onLineNumberClick(line2, event);
    });
    _defineProperty(this, "keyDown", (event) => {
      const {
        onKeyDown
      } = this.props;
      onKeyDown && onKeyDown(event);
    });
    _defineProperty(this, "keyUp", (event) => {
      const {
        onKeyUp
      } = this.props;
      onKeyUp && onKeyUp(event);
    });
    this.state = {
      focused: false
    };
    this.lastValue = null;
    this.lastPosition = null;
    this.lastSelection = null;
  }
  componentDidMount() {
    const {
      autocomplete,
      autocompleteCloseOnBlur,
      autocompleteOpen,
      autocompleteTriggerStrings,
      autofocus,
      bracketMatching: bracketMatching2,
      closeBrackets: closeBrackets2,
      cursorWide,
      cypherLanguage: cypherLanguage2,
      history: history2,
      indentUnit: indentUnit2,
      lineNumberFormatter,
      lineNumbers: lineNumbers2,
      lineWrapping,
      lint,
      placeholder: placeholder2,
      position: position2,
      readOnly: readOnly2,
      readOnlyCursor,
      schema,
      search: search3,
      searchMatches,
      searchOpen,
      searchText,
      searchTop,
      selection,
      tabKey,
      theme: theme2,
      tooltipAbsolute,
      parseOnSetValue,
      value,
      onEditorCreated,
      preExtensions,
      postExtensions
    } = this.props;
    this.value = value;
    const {
      editor
    } = createCypherEditor(this.editorRef, {
      autocomplete,
      autocompleteCloseOnBlur,
      autocompleteOpen,
      autocompleteTriggerStrings,
      autofocus,
      bracketMatching: bracketMatching2,
      closeBrackets: closeBrackets2,
      cursorWide,
      cypherLanguage: cypherLanguage2,
      history: history2,
      indentUnit: indentUnit2,
      lineNumberFormatter,
      lineNumbers: lineNumbers2,
      lineWrapping,
      lint,
      placeholder: placeholder2,
      position: position2,
      readOnly: readOnly2,
      readOnlyCursor,
      schema,
      search: search3,
      searchMatches,
      searchOpen,
      searchText,
      searchTop,
      selection,
      tabKey,
      theme: theme2,
      tooltipAbsolute,
      parseOnSetValue,
      value,
      preExtensions,
      postExtensions
    });
    this.cypherEditor = editor;
    this.cypherEditor.onValueChanged(this.valueChanged);
    this.cypherEditor.onFocusChanged(this.focusChanged);
    this.cypherEditor.onScrollChanged(this.scrollChanged);
    this.cypherEditor.onPositionChanged(this.positionChanged);
    this.cypherEditor.onSelectionChanged(this.selectionChanged);
    this.cypherEditor.onAutocompleteChanged(this.autocompleteChanged);
    this.cypherEditor.onSearchChanged(this.searchChanged);
    this.cypherEditor.onLineNumberClick(this.lineNumberClick);
    this.cypherEditor.onKeyDown(this.keyDown);
    this.cypherEditor.onKeyUp(this.keyUp);
    onEditorCreated && onEditorCreated(this.cypherEditor);
  }
  componentWillUnmount() {
    if (this.cypherEditor) {
      this.cypherEditor.offValueChanged(this.valueChanged);
      this.cypherEditor.offFocusChanged(this.focusChanged);
      this.cypherEditor.offScrollChanged(this.scrollChanged);
      this.cypherEditor.offPositionChanged(this.positionChanged);
      this.cypherEditor.offSelectionChanged(this.selectionChanged);
      this.cypherEditor.offAutocompleteChanged(this.autocompleteChanged);
      this.cypherEditor.offSearchChanged(this.searchChanged);
      this.cypherEditor.offLineNumberClick(this.lineNumberClick);
      this.cypherEditor.offKeyDown(this.keyDown);
      this.cypherEditor.offKeyUp(this.keyUp);
      this.cypherEditor.destroy();
    }
  }
  componentDidUpdate(prevProps) {
    if (prevProps.value !== this.props.value) {
      this.value = this.props.value;
    }
    for (let key of reactiveOptionKeys) {
      if (prevProps[key] !== this.props[key]) {
        this.updateOption({
          [key]: this.props[key]
        });
      }
    }
  }
  updateOption(prop) {
    if (!this.cypherEditor) {
      return;
    }
    const key = Object.keys(prop).pop();
    if (key === "value") {
      if (prop[key] === this.lastValue) {
        return;
      } else {
        this.lastValue = prop[key];
      }
    }
    if (key === "position") {
      const {
        position: position2
      } = this.cypherEditor.getPositionForValue(prop[key]) || {
        position: null
      };
      if (position2 === this.lastPosition) {
        return;
      } else {
        this.lastPosition = position2;
      }
    }
    if (key === "selection") {
      if (prop[key] === this.lastSelection) {
        return;
      } else {
        this.lastSelection = prop[key];
      }
    }
    const methodName = "set" + key[0].toUpperCase() + key.slice(1);
    if (this.cypherEditor[methodName]) {
      this.cypherEditor[methodName](prop[key]);
    }
    const autofocusProps = this.props.autofocusProps !== void 0 ? this.props.autofocusProps : defaultOptions2.autofocusProps;
    if (autofocusProps.includes(key)) {
      this.cypherEditor.focus();
    }
    const clearHistoryProps = this.props.clearHistoryProps !== void 0 ? this.props.clearHistoryProps : defaultOptions2.clearHistoryProps;
    if (clearHistoryProps.includes(key)) {
      this.cypherEditor.clearHistory();
    }
  }
  render() {
    const {
      className,
      focusedClassName,
      style
    } = this.props;
    const {
      focused
    } = this.state;
    const editorClassName = (className ? className + " " : "") + (focused && focusedClassName ? focusedClassName : "");
    return (0, import_jsx_runtime45.jsx)("div", {
      className: editorClassName,
      style,
      ref: this.setEditorRef
    });
  }
};
var CypherEditor_default = CypherEditor;

// node_modules/@neo4j-ndl/react/lib/esm/cypher-code-block/CypherCodeBlock.js
var CypherCodeBlock = import_react175.default.forwardRef(function CypherCodeBlock2({ maxHeight, code, headerTitle, theme: theme2 = "light", showLineNumbers, disabled, actions }, ref) {
  const cypherEditorRef = (0, import_react175.useRef)(null);
  const [shouldShowExpandButton, setShouldShowExpandButton] = (0, import_react175.useState)(maxHeight !== void 0);
  (0, import_react175.useEffect)(() => {
    var _a2;
    const editorHtml = (_a2 = cypherEditorRef.current) === null || _a2 === void 0 ? void 0 : _a2.editorRef;
    if (!editorHtml) {
      return;
    }
    const editorContentHtml = editorHtml.querySelector(".cm-content");
    if (!editorContentHtml) {
      return;
    }
    editorContentHtml.style.padding = `0 calc(0.75em + ${headerTitle === void 0 || headerTitle === "" ? ((actions === null || actions === void 0 ? void 0 : actions.length) || (shouldShowExpandButton ? 1 : 0)) * 36 : (shouldShowExpandButton ? 1 : 0) * 36}px) 0.75em 0.45em`;
  }, [headerTitle, actions, shouldShowExpandButton]);
  return (0, import_jsx_runtime46.jsx)(CodeBlockWrapper, { ref, maxHeight, code, headerTitle, disabled, actions, shouldShowExpandButton, setShouldShowExpandButton, children: (0, import_jsx_runtime46.jsx)(CypherEditor_default, { ref: cypherEditorRef, className: "ndl-cypher-editor ndl-cypher-code-block", lineNumbers: showLineNumbers, value: code, theme: theme2, readOnly: true, readOnlyCursor: true, autofocus: false }) });
});

// node_modules/@neo4j-ndl/react/lib/esm/status-indicator/StatusIndicator.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime());
var import_react176 = __toESM(require_react());
var __rest33 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var StatusIndicator = import_react176.default.forwardRef(function StatusIndicator2(_a2, ref) {
  var { className, type = "unknown" } = _a2, restProps = __rest33(_a2, ["className", "type"]);
  const classes = classNames("ndl-status-indicator", className);
  switch (type) {
    case "success":
      return (0, import_jsx_runtime47.jsx)("span", Object.assign({}, restProps, { className: classes, ref, children: (0, import_jsx_runtime47.jsx)("svg", { width: "8", height: "8", viewBox: "0 0 8 8", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, import_jsx_runtime47.jsx)("circle", { cx: "4", cy: "4", r: "4", fill: "rgb(var(--theme-palette-success-bg-status))" }) }) }));
    case "info":
      return (0, import_jsx_runtime47.jsx)("span", Object.assign({}, restProps, { className: classes, ref, children: (0, import_jsx_runtime47.jsx)("svg", { width: "8", height: "8", viewBox: "0 0 8 8", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, import_jsx_runtime47.jsx)("circle", { cx: "4", cy: "4", r: "4", fill: "rgb(var(--theme-palette-primary-bg-status))" }) }) }));
    case "warning":
      return (0, import_jsx_runtime47.jsx)("span", Object.assign({}, restProps, { className: classes, ref, children: (0, import_jsx_runtime47.jsx)("svg", { width: "8", height: "8", viewBox: "0 0 8 8", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, import_jsx_runtime47.jsx)("path", { d: "M4.57641 0.35903C4.52349 0.251301 4.44144 0.160559 4.33957 0.0970988C4.23769 0.0336384 4.12007 0 4.00005 0C3.88002 0 3.7624 0.0336384 3.66053 0.0970988C3.55865 0.160559 3.4766 0.251301 3.42368 0.35903L0.0554707 7.22061C0.0149262 7.30309 -0.00393024 7.39454 0.000681349 7.48633C0.00529294 7.57812 0.0332205 7.66722 0.0818275 7.74522C0.130434 7.82322 0.198117 7.88754 0.278487 7.93212C0.358856 7.9767 0.44926 8.00006 0.541165 8H7.45893C7.55083 8.00006 7.64124 7.9767 7.7216 7.93212C7.80197 7.88754 7.86966 7.82322 7.91826 7.74522C7.96687 7.66722 7.9948 7.57812 7.99941 7.48633C8.00402 7.39454 7.98517 7.30309 7.94462 7.22061L4.57641 0.35903Z", fill: "rgb(var(--theme-palette-warning-bg-status))" }) }) }));
    case "danger":
      return (0, import_jsx_runtime47.jsx)("span", Object.assign({}, restProps, { className: classes, ref, children: (0, import_jsx_runtime47.jsx)("svg", { width: "8", height: "8", viewBox: "0 0 8 8", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, import_jsx_runtime47.jsx)("path", { d: "M0.188426 4.45553C0.067771 4.33472 0 4.17097 0 4.00024C0 3.8295 0.067771 3.66575 0.188426 3.54494L3.54489 0.188838C3.6046 0.128979 3.67554 0.0814871 3.75363 0.0490833C3.83173 0.0166795 3.91545 0 4 0C4.08455 0 4.16827 0.0166795 4.24637 0.0490833C4.32446 0.0814871 4.3954 0.128979 4.45511 0.188838L7.81157 3.54494C7.93223 3.66575 8 3.8295 8 4.00024C8 4.17097 7.93223 4.33472 7.81157 4.45553L4.45511 7.81163C4.33437 7.93226 4.17068 8.00003 4 8.00003C3.82932 8.00003 3.66563 7.93226 3.54489 7.81163L0.188426 4.45553Z", fill: "rgb(var(--theme-palette-danger-bg-status))" }) }) }));
    default:
      return (0, import_jsx_runtime47.jsx)("span", Object.assign({}, restProps, { className: classes, ref, children: (0, import_jsx_runtime47.jsx)("svg", { width: "8", height: "8", viewBox: "0 0 8 8", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, import_jsx_runtime47.jsx)("rect", { width: "8", height: "8", rx: "1", fill: "rgb(var(--theme-palette-neutral-bg-status))" }) }) }));
  }
});
var StatusIndicator_default = StatusIndicator;

// node_modules/@neo4j-ndl/react/lib/esm/side-navigation/SideNavigation.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime());
var import_react177 = __toESM(require_react());
var __rest34 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var getExpandIconName = (position2, expanded) => {
  if (expanded) {
    return position2 === "left" ? (0, import_jsx_runtime48.jsx)(CollapseExpandLeft_default, { className: "n-w-full n-h-full" }) : (0, import_jsx_runtime48.jsx)(CollapseExpandRight_default, { className: "n-w-full n-h-full" });
  } else {
    return position2 === "left" ? (0, import_jsx_runtime48.jsx)(CollapseExpandRight_default, { className: "n-w-full n-h-full" }) : (0, import_jsx_runtime48.jsx)(CollapseExpandLeft_default, { className: "n-w-full n-h-full" });
  }
};
var SideNavigationComponent = (0, import_react177.forwardRef)(function SideNavigationComponent2(_a2, ref) {
  var { expanded, children, className, onExpandedChange, iconMenu = false, position: position2 = "left" } = _a2, restProps = __rest34(_a2, ["expanded", "children", "className", "onExpandedChange", "iconMenu", "position"]);
  const setOnExpandedChange = (0, import_react177.useCallback)(() => {
    if (onExpandedChange !== void 0) {
      onExpandedChange(!expanded);
    }
  }, [expanded, onExpandedChange]);
  const classes = classNames("ndl-side-navigation", className, {
    "ndl-expanded": expanded,
    [`ndl-${position2}`]: position2
  });
  const icon = getExpandIconName(position2, expanded);
  return (0, import_jsx_runtime48.jsx)(SideNavigationContext.Provider, { value: { expanded, iconMenu }, children: (0, import_jsx_runtime48.jsxs)("div", Object.assign({}, restProps, { className: classes, ref }, !expanded && !iconMenu && {
    "aria-label": "open-side-navigation",
    onClick: setOnExpandedChange
  }, { children: [(0, import_jsx_runtime48.jsx)("nav", { className: "ndl-side-navigation-nav", children }), onExpandedChange !== void 0 && (0, import_jsx_runtime48.jsx)(IconButton, { className: "ndl-side-navigation-drawer-button", onClick: setOnExpandedChange, "aria-label": expanded ? "collapse-navigation" : "expand-navigation", size: "large", "data-testid": "ndl-side-nav-expand-btn", title: `${expanded ? "Collapse" : "Expand"} side navigation`, clean: true, children: icon })] })) });
});
SideNavigationComponent.displayName = "SideNavigation";
var SideNavigationContext = (0, import_react177.createContext)(null);
var useSideNavigationContext = () => (0, import_react177.useContext)(SideNavigationContext);
var SideNavigationListContext = (0, import_react177.createContext)(null);
var useSideNavigationListContext = () => (0, import_react177.useContext)(SideNavigationListContext);
var SideNavigationList = (0, import_react177.forwardRef)(function SideNavigationList2(_a2, ref) {
  var _b, _c;
  var { children, className } = _a2, restProps = __rest34(_a2, ["children", "className"]);
  const classes = classNames("ndl-side-navigation-nav-list", className);
  const { level } = (_b = useSideNavigationListContext()) !== null && _b !== void 0 ? _b : {
    level: -1
  };
  const { expanded, iconMenu } = (_c = useSideNavigationContext()) !== null && _c !== void 0 ? _c : {
    expanded: true,
    iconMenu: false
  };
  if (!expanded && !iconMenu)
    return null;
  return (0, import_jsx_runtime48.jsx)(SideNavigationListContext.Provider, { value: { level: level + 1 }, children: (0, import_jsx_runtime48.jsx)("ul", Object.assign({ className: classes, ref }, restProps, { children })) });
});
SideNavigationList.displayName = "SideNavigation.List";
var SideNavigationItem = (0, import_react177.forwardRef)(function SideNavigationItem2(_a2, ref) {
  var _b, _c;
  var { className, children, icon, as, selected = false, selectable = true, style = {} } = _a2, restProps = __rest34(_a2, ["className", "children", "icon", "as", "selected", "selectable", "style"]);
  const Component4 = as || "a";
  const { level } = (_b = useSideNavigationListContext()) !== null && _b !== void 0 ? _b : { level: 0 };
  const { expanded, iconMenu } = (_c = useSideNavigationContext()) !== null && _c !== void 0 ? _c : {
    expanded: true,
    iconMenu: false
  };
  const defaultIndent = level ? 0 : 12;
  const indent = expanded ? defaultIndent + level * 32 : 0;
  const itemClasses = classNames("ndl-side-navigation-nav-item", className, {
    "ndl-expanded": expanded
  });
  const innerClasses = classNames("ndl-side-navigation-inner-item", {
    "ndl-selected": selected,
    "ndl-selectable": selectable
  });
  if (iconMenu && !icon) {
    throw new Error("SideNavigation is an IconMenu but icon is not defined! Set an icon on this SideNavigationItem or set `iconMenu` to false on SideNavigation");
  } else if (!iconMenu && icon) {
    throw new Error("SideNavigation is not an IconMenu but icon is defined! Remove the icon or set `iconMenu` to true on SideNavigation to allow icons");
  }
  if (!expanded && !(icon && iconMenu))
    return null;
  return (0, import_jsx_runtime48.jsx)("li", { className: itemClasses, children: (0, import_jsx_runtime48.jsxs)(Component4, Object.assign({ className: innerClasses, style: Object.assign(Object.assign({}, style), { paddingLeft: indent }), ref }, restProps, { children: [iconMenu && icon && (0, import_jsx_runtime48.jsx)("span", { className: "ndl-icon", children: icon }), expanded && children] })) });
});
SideNavigationItem.displayName = "SideNavigation.Item";
var SideNavigationGroupHeader = (0, import_react177.forwardRef)(function SideNavigationGroupHeader2(_a2, ref) {
  var _b;
  var { children, className, as, style } = _a2, restProps = __rest34(_a2, ["children", "className", "as", "style"]);
  const Component4 = as !== null && as !== void 0 ? as : "div";
  const { expanded, iconMenu } = (_b = useSideNavigationContext()) !== null && _b !== void 0 ? _b : {
    expanded: true,
    iconMenu: false
  };
  const classes = classNames("ndl-side-navigation-nav-item", className);
  const indent = expanded ? "12px" : "0";
  return (0, import_jsx_runtime48.jsx)("li", Object.assign({ className: classes, role: "presentation", style: Object.assign({ paddingLeft: indent }, style) }, restProps, { children: (0, import_jsx_runtime48.jsxs)(Component4, { className: "ndl-side-navigation-inner-item ndl-side-navigation-group-header", ref, children: [!expanded && iconMenu && (0, import_jsx_runtime48.jsx)(Divider, {}), expanded && children] }) }));
});
SideNavigationGroupHeader.displayName = "SideNavigation.GroupHeader";
var Divider = () => (0, import_jsx_runtime48.jsx)("div", { className: "ndl-divider" });
var SideNavigation = Object.assign(SideNavigationComponent, {
  List: SideNavigationList,
  GroupHeader: SideNavigationGroupHeader,
  Item: SideNavigationItem
});

// node_modules/@neo4j-ndl/react/lib/esm/drawer/Drawer.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime());
var import_react178 = __toESM(require_react());

// node_modules/re-resizable/lib/index.js
var React62 = __toESM(require_react());
var import_react_dom11 = __toESM(require_react_dom());

// node_modules/re-resizable/lib/resizer.js
var React61 = __toESM(require_react());
var __extends2 = function() {
  var extendStatics2 = function(d3, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
      d4.__proto__ = b3;
    } || function(d4, b3) {
      for (var p in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p))
          d4[p] = b3[p];
    };
    return extendStatics2(d3, b2);
  };
  return function(d3, b2) {
    extendStatics2(d3, b2);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign2 = function() {
  __assign2 = Object.assign || function(t4) {
    for (var s3, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s3 = arguments[i2];
      for (var p in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p))
          t4[p] = s3[p];
    }
    return t4;
  };
  return __assign2.apply(this, arguments);
};
var rowSizeBase = {
  width: "100%",
  height: "10px",
  top: "0px",
  left: "0px",
  cursor: "row-resize"
};
var colSizeBase = {
  width: "10px",
  height: "100%",
  top: "0px",
  left: "0px",
  cursor: "col-resize"
};
var edgeBase = {
  width: "20px",
  height: "20px",
  position: "absolute"
};
var styles = {
  top: __assign2(__assign2({}, rowSizeBase), { top: "-5px" }),
  right: __assign2(__assign2({}, colSizeBase), { left: void 0, right: "-5px" }),
  bottom: __assign2(__assign2({}, rowSizeBase), { top: void 0, bottom: "-5px" }),
  left: __assign2(__assign2({}, colSizeBase), { left: "-5px" }),
  topRight: __assign2(__assign2({}, edgeBase), { right: "-10px", top: "-10px", cursor: "ne-resize" }),
  bottomRight: __assign2(__assign2({}, edgeBase), { right: "-10px", bottom: "-10px", cursor: "se-resize" }),
  bottomLeft: __assign2(__assign2({}, edgeBase), { left: "-10px", bottom: "-10px", cursor: "sw-resize" }),
  topLeft: __assign2(__assign2({}, edgeBase), { left: "-10px", top: "-10px", cursor: "nw-resize" })
};
var Resizer = (
  /** @class */
  function(_super) {
    __extends2(Resizer2, _super);
    function Resizer2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.onMouseDown = function(e4) {
        _this.props.onResizeStart(e4, _this.props.direction);
      };
      _this.onTouchStart = function(e4) {
        _this.props.onResizeStart(e4, _this.props.direction);
      };
      return _this;
    }
    Resizer2.prototype.render = function() {
      return React61.createElement("div", { className: this.props.className || "", style: __assign2(__assign2({ position: "absolute", userSelect: "none" }, styles[this.props.direction]), this.props.replaceStyles || {}), onMouseDown: this.onMouseDown, onTouchStart: this.onTouchStart }, this.props.children);
    };
    return Resizer2;
  }(React61.PureComponent)
);

// node_modules/re-resizable/lib/index.js
var __extends3 = function() {
  var extendStatics2 = function(d3, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
      d4.__proto__ = b3;
    } || function(d4, b3) {
      for (var p in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p))
          d4[p] = b3[p];
    };
    return extendStatics2(d3, b2);
  };
  return function(d3, b2) {
    extendStatics2(d3, b2);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign3 = function() {
  __assign3 = Object.assign || function(t4) {
    for (var s3, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s3 = arguments[i2];
      for (var p in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p))
          t4[p] = s3[p];
    }
    return t4;
  };
  return __assign3.apply(this, arguments);
};
var DEFAULT_SIZE = {
  width: "auto",
  height: "auto"
};
var clamp3 = function(n, min4, max4) {
  return Math.max(Math.min(n, max4), min4);
};
var snap = function(n, size3) {
  return Math.round(n / size3) * size3;
};
var hasDirection = function(dir, target) {
  return new RegExp(dir, "i").test(target);
};
var isTouchEvent = function(event) {
  return Boolean(event.touches && event.touches.length);
};
var isMouseEvent = function(event) {
  return Boolean((event.clientX || event.clientX === 0) && (event.clientY || event.clientY === 0));
};
var findClosestSnap = function(n, snapArray, snapGap) {
  if (snapGap === void 0) {
    snapGap = 0;
  }
  var closestGapIndex = snapArray.reduce(function(prev2, curr, index4) {
    return Math.abs(curr - n) < Math.abs(snapArray[prev2] - n) ? index4 : prev2;
  }, 0);
  var gap = Math.abs(snapArray[closestGapIndex] - n);
  return snapGap === 0 || gap < snapGap ? snapArray[closestGapIndex] : n;
};
var getStringSize = function(n) {
  n = n.toString();
  if (n === "auto") {
    return n;
  }
  if (n.endsWith("px")) {
    return n;
  }
  if (n.endsWith("%")) {
    return n;
  }
  if (n.endsWith("vh")) {
    return n;
  }
  if (n.endsWith("vw")) {
    return n;
  }
  if (n.endsWith("vmax")) {
    return n;
  }
  if (n.endsWith("vmin")) {
    return n;
  }
  return n + "px";
};
var getPixelSize = function(size3, parentSize, innerWidth, innerHeight2) {
  if (size3 && typeof size3 === "string") {
    if (size3.endsWith("px")) {
      return Number(size3.replace("px", ""));
    }
    if (size3.endsWith("%")) {
      var ratio = Number(size3.replace("%", "")) / 100;
      return parentSize * ratio;
    }
    if (size3.endsWith("vw")) {
      var ratio = Number(size3.replace("vw", "")) / 100;
      return innerWidth * ratio;
    }
    if (size3.endsWith("vh")) {
      var ratio = Number(size3.replace("vh", "")) / 100;
      return innerHeight2 * ratio;
    }
  }
  return size3;
};
var calculateNewMax = function(parentSize, innerWidth, innerHeight2, maxWidth, maxHeight, minWidth, minHeight) {
  maxWidth = getPixelSize(maxWidth, parentSize.width, innerWidth, innerHeight2);
  maxHeight = getPixelSize(maxHeight, parentSize.height, innerWidth, innerHeight2);
  minWidth = getPixelSize(minWidth, parentSize.width, innerWidth, innerHeight2);
  minHeight = getPixelSize(minHeight, parentSize.height, innerWidth, innerHeight2);
  return {
    maxWidth: typeof maxWidth === "undefined" ? void 0 : Number(maxWidth),
    maxHeight: typeof maxHeight === "undefined" ? void 0 : Number(maxHeight),
    minWidth: typeof minWidth === "undefined" ? void 0 : Number(minWidth),
    minHeight: typeof minHeight === "undefined" ? void 0 : Number(minHeight)
  };
};
var definedProps = [
  "as",
  "style",
  "className",
  "grid",
  "snap",
  "bounds",
  "boundsByDirection",
  "size",
  "defaultSize",
  "minWidth",
  "minHeight",
  "maxWidth",
  "maxHeight",
  "lockAspectRatio",
  "lockAspectRatioExtraWidth",
  "lockAspectRatioExtraHeight",
  "enable",
  "handleStyles",
  "handleClasses",
  "handleWrapperStyle",
  "handleWrapperClass",
  "children",
  "onResizeStart",
  "onResize",
  "onResizeStop",
  "handleComponent",
  "scale",
  "resizeRatio",
  "snapGap"
];
var baseClassName = "__resizable_base__";
var Resizable = (
  /** @class */
  function(_super) {
    __extends3(Resizable2, _super);
    function Resizable2(props) {
      var _this = _super.call(this, props) || this;
      _this.ratio = 1;
      _this.resizable = null;
      _this.parentLeft = 0;
      _this.parentTop = 0;
      _this.resizableLeft = 0;
      _this.resizableRight = 0;
      _this.resizableTop = 0;
      _this.resizableBottom = 0;
      _this.targetLeft = 0;
      _this.targetTop = 0;
      _this.appendBase = function() {
        if (!_this.resizable || !_this.window) {
          return null;
        }
        var parent = _this.parentNode;
        if (!parent) {
          return null;
        }
        var element = _this.window.document.createElement("div");
        element.style.width = "100%";
        element.style.height = "100%";
        element.style.position = "absolute";
        element.style.transform = "scale(0, 0)";
        element.style.left = "0";
        element.style.flex = "0 0 100%";
        if (element.classList) {
          element.classList.add(baseClassName);
        } else {
          element.className += baseClassName;
        }
        parent.appendChild(element);
        return element;
      };
      _this.removeBase = function(base2) {
        var parent = _this.parentNode;
        if (!parent) {
          return;
        }
        parent.removeChild(base2);
      };
      _this.ref = function(c2) {
        if (c2) {
          _this.resizable = c2;
        }
      };
      _this.state = {
        isResizing: false,
        width: typeof (_this.propsSize && _this.propsSize.width) === "undefined" ? "auto" : _this.propsSize && _this.propsSize.width,
        height: typeof (_this.propsSize && _this.propsSize.height) === "undefined" ? "auto" : _this.propsSize && _this.propsSize.height,
        direction: "right",
        original: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        },
        backgroundStyle: {
          height: "100%",
          width: "100%",
          backgroundColor: "rgba(0,0,0,0)",
          cursor: "auto",
          opacity: 0,
          position: "fixed",
          zIndex: 9999,
          top: "0",
          left: "0",
          bottom: "0",
          right: "0"
        },
        flexBasis: void 0
      };
      _this.onResizeStart = _this.onResizeStart.bind(_this);
      _this.onMouseMove = _this.onMouseMove.bind(_this);
      _this.onMouseUp = _this.onMouseUp.bind(_this);
      return _this;
    }
    Object.defineProperty(Resizable2.prototype, "parentNode", {
      get: function() {
        if (!this.resizable) {
          return null;
        }
        return this.resizable.parentNode;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Resizable2.prototype, "window", {
      get: function() {
        if (!this.resizable) {
          return null;
        }
        if (!this.resizable.ownerDocument) {
          return null;
        }
        return this.resizable.ownerDocument.defaultView;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Resizable2.prototype, "propsSize", {
      get: function() {
        return this.props.size || this.props.defaultSize || DEFAULT_SIZE;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Resizable2.prototype, "size", {
      get: function() {
        var width = 0;
        var height = 0;
        if (this.resizable && this.window) {
          var orgWidth = this.resizable.offsetWidth;
          var orgHeight = this.resizable.offsetHeight;
          var orgPosition = this.resizable.style.position;
          if (orgPosition !== "relative") {
            this.resizable.style.position = "relative";
          }
          width = this.resizable.style.width !== "auto" ? this.resizable.offsetWidth : orgWidth;
          height = this.resizable.style.height !== "auto" ? this.resizable.offsetHeight : orgHeight;
          this.resizable.style.position = orgPosition;
        }
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Resizable2.prototype, "sizeStyle", {
      get: function() {
        var _this = this;
        var size3 = this.props.size;
        var getSize = function(key) {
          if (typeof _this.state[key] === "undefined" || _this.state[key] === "auto") {
            return "auto";
          }
          if (_this.propsSize && _this.propsSize[key] && _this.propsSize[key].toString().endsWith("%")) {
            if (_this.state[key].toString().endsWith("%")) {
              return _this.state[key].toString();
            }
            var parentSize = _this.getParentSize();
            var value = Number(_this.state[key].toString().replace("px", ""));
            var percent = value / parentSize[key] * 100;
            return percent + "%";
          }
          return getStringSize(_this.state[key]);
        };
        var width = size3 && typeof size3.width !== "undefined" && !this.state.isResizing ? getStringSize(size3.width) : getSize("width");
        var height = size3 && typeof size3.height !== "undefined" && !this.state.isResizing ? getStringSize(size3.height) : getSize("height");
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    Resizable2.prototype.getParentSize = function() {
      if (!this.parentNode) {
        if (!this.window) {
          return { width: 0, height: 0 };
        }
        return { width: this.window.innerWidth, height: this.window.innerHeight };
      }
      var base2 = this.appendBase();
      if (!base2) {
        return { width: 0, height: 0 };
      }
      var wrapChanged = false;
      var wrap = this.parentNode.style.flexWrap;
      if (wrap !== "wrap") {
        wrapChanged = true;
        this.parentNode.style.flexWrap = "wrap";
      }
      base2.style.position = "relative";
      base2.style.minWidth = "100%";
      base2.style.minHeight = "100%";
      var size3 = {
        width: base2.offsetWidth,
        height: base2.offsetHeight
      };
      if (wrapChanged) {
        this.parentNode.style.flexWrap = wrap;
      }
      this.removeBase(base2);
      return size3;
    };
    Resizable2.prototype.bindEvents = function() {
      if (this.window) {
        this.window.addEventListener("mouseup", this.onMouseUp);
        this.window.addEventListener("mousemove", this.onMouseMove);
        this.window.addEventListener("mouseleave", this.onMouseUp);
        this.window.addEventListener("touchmove", this.onMouseMove, {
          capture: true,
          passive: false
        });
        this.window.addEventListener("touchend", this.onMouseUp);
      }
    };
    Resizable2.prototype.unbindEvents = function() {
      if (this.window) {
        this.window.removeEventListener("mouseup", this.onMouseUp);
        this.window.removeEventListener("mousemove", this.onMouseMove);
        this.window.removeEventListener("mouseleave", this.onMouseUp);
        this.window.removeEventListener("touchmove", this.onMouseMove, true);
        this.window.removeEventListener("touchend", this.onMouseUp);
      }
    };
    Resizable2.prototype.componentDidMount = function() {
      if (!this.resizable || !this.window) {
        return;
      }
      var computedStyle = this.window.getComputedStyle(this.resizable);
      this.setState({
        width: this.state.width || this.size.width,
        height: this.state.height || this.size.height,
        flexBasis: computedStyle.flexBasis !== "auto" ? computedStyle.flexBasis : void 0
      });
    };
    Resizable2.prototype.componentWillUnmount = function() {
      if (this.window) {
        this.unbindEvents();
      }
    };
    Resizable2.prototype.createSizeForCssProperty = function(newSize, kind) {
      var propsSize = this.propsSize && this.propsSize[kind];
      return this.state[kind] === "auto" && this.state.original[kind] === newSize && (typeof propsSize === "undefined" || propsSize === "auto") ? "auto" : newSize;
    };
    Resizable2.prototype.calculateNewMaxFromBoundary = function(maxWidth, maxHeight) {
      var boundsByDirection = this.props.boundsByDirection;
      var direction = this.state.direction;
      var widthByDirection = boundsByDirection && hasDirection("left", direction);
      var heightByDirection = boundsByDirection && hasDirection("top", direction);
      var boundWidth;
      var boundHeight;
      if (this.props.bounds === "parent") {
        var parent_1 = this.parentNode;
        if (parent_1) {
          boundWidth = widthByDirection ? this.resizableRight - this.parentLeft : parent_1.offsetWidth + (this.parentLeft - this.resizableLeft);
          boundHeight = heightByDirection ? this.resizableBottom - this.parentTop : parent_1.offsetHeight + (this.parentTop - this.resizableTop);
        }
      } else if (this.props.bounds === "window") {
        if (this.window) {
          boundWidth = widthByDirection ? this.resizableRight : this.window.innerWidth - this.resizableLeft;
          boundHeight = heightByDirection ? this.resizableBottom : this.window.innerHeight - this.resizableTop;
        }
      } else if (this.props.bounds) {
        boundWidth = widthByDirection ? this.resizableRight - this.targetLeft : this.props.bounds.offsetWidth + (this.targetLeft - this.resizableLeft);
        boundHeight = heightByDirection ? this.resizableBottom - this.targetTop : this.props.bounds.offsetHeight + (this.targetTop - this.resizableTop);
      }
      if (boundWidth && Number.isFinite(boundWidth)) {
        maxWidth = maxWidth && maxWidth < boundWidth ? maxWidth : boundWidth;
      }
      if (boundHeight && Number.isFinite(boundHeight)) {
        maxHeight = maxHeight && maxHeight < boundHeight ? maxHeight : boundHeight;
      }
      return { maxWidth, maxHeight };
    };
    Resizable2.prototype.calculateNewSizeFromDirection = function(clientX, clientY) {
      var scale = this.props.scale || 1;
      var resizeRatio = this.props.resizeRatio || 1;
      var _a2 = this.state, direction = _a2.direction, original = _a2.original;
      var _b = this.props, lockAspectRatio = _b.lockAspectRatio, lockAspectRatioExtraHeight = _b.lockAspectRatioExtraHeight, lockAspectRatioExtraWidth = _b.lockAspectRatioExtraWidth;
      var newWidth = original.width;
      var newHeight = original.height;
      var extraHeight = lockAspectRatioExtraHeight || 0;
      var extraWidth = lockAspectRatioExtraWidth || 0;
      if (hasDirection("right", direction)) {
        newWidth = original.width + (clientX - original.x) * resizeRatio / scale;
        if (lockAspectRatio) {
          newHeight = (newWidth - extraWidth) / this.ratio + extraHeight;
        }
      }
      if (hasDirection("left", direction)) {
        newWidth = original.width - (clientX - original.x) * resizeRatio / scale;
        if (lockAspectRatio) {
          newHeight = (newWidth - extraWidth) / this.ratio + extraHeight;
        }
      }
      if (hasDirection("bottom", direction)) {
        newHeight = original.height + (clientY - original.y) * resizeRatio / scale;
        if (lockAspectRatio) {
          newWidth = (newHeight - extraHeight) * this.ratio + extraWidth;
        }
      }
      if (hasDirection("top", direction)) {
        newHeight = original.height - (clientY - original.y) * resizeRatio / scale;
        if (lockAspectRatio) {
          newWidth = (newHeight - extraHeight) * this.ratio + extraWidth;
        }
      }
      return { newWidth, newHeight };
    };
    Resizable2.prototype.calculateNewSizeFromAspectRatio = function(newWidth, newHeight, max4, min4) {
      var _a2 = this.props, lockAspectRatio = _a2.lockAspectRatio, lockAspectRatioExtraHeight = _a2.lockAspectRatioExtraHeight, lockAspectRatioExtraWidth = _a2.lockAspectRatioExtraWidth;
      var computedMinWidth = typeof min4.width === "undefined" ? 10 : min4.width;
      var computedMaxWidth = typeof max4.width === "undefined" || max4.width < 0 ? newWidth : max4.width;
      var computedMinHeight = typeof min4.height === "undefined" ? 10 : min4.height;
      var computedMaxHeight = typeof max4.height === "undefined" || max4.height < 0 ? newHeight : max4.height;
      var extraHeight = lockAspectRatioExtraHeight || 0;
      var extraWidth = lockAspectRatioExtraWidth || 0;
      if (lockAspectRatio) {
        var extraMinWidth = (computedMinHeight - extraHeight) * this.ratio + extraWidth;
        var extraMaxWidth = (computedMaxHeight - extraHeight) * this.ratio + extraWidth;
        var extraMinHeight = (computedMinWidth - extraWidth) / this.ratio + extraHeight;
        var extraMaxHeight = (computedMaxWidth - extraWidth) / this.ratio + extraHeight;
        var lockedMinWidth = Math.max(computedMinWidth, extraMinWidth);
        var lockedMaxWidth = Math.min(computedMaxWidth, extraMaxWidth);
        var lockedMinHeight = Math.max(computedMinHeight, extraMinHeight);
        var lockedMaxHeight = Math.min(computedMaxHeight, extraMaxHeight);
        newWidth = clamp3(newWidth, lockedMinWidth, lockedMaxWidth);
        newHeight = clamp3(newHeight, lockedMinHeight, lockedMaxHeight);
      } else {
        newWidth = clamp3(newWidth, computedMinWidth, computedMaxWidth);
        newHeight = clamp3(newHeight, computedMinHeight, computedMaxHeight);
      }
      return { newWidth, newHeight };
    };
    Resizable2.prototype.setBoundingClientRect = function() {
      if (this.props.bounds === "parent") {
        var parent_2 = this.parentNode;
        if (parent_2) {
          var parentRect = parent_2.getBoundingClientRect();
          this.parentLeft = parentRect.left;
          this.parentTop = parentRect.top;
        }
      }
      if (this.props.bounds && typeof this.props.bounds !== "string") {
        var targetRect = this.props.bounds.getBoundingClientRect();
        this.targetLeft = targetRect.left;
        this.targetTop = targetRect.top;
      }
      if (this.resizable) {
        var _a2 = this.resizable.getBoundingClientRect(), left2 = _a2.left, top_1 = _a2.top, right2 = _a2.right, bottom2 = _a2.bottom;
        this.resizableLeft = left2;
        this.resizableRight = right2;
        this.resizableTop = top_1;
        this.resizableBottom = bottom2;
      }
    };
    Resizable2.prototype.onResizeStart = function(event, direction) {
      if (!this.resizable || !this.window) {
        return;
      }
      var clientX = 0;
      var clientY = 0;
      if (event.nativeEvent && isMouseEvent(event.nativeEvent)) {
        clientX = event.nativeEvent.clientX;
        clientY = event.nativeEvent.clientY;
      } else if (event.nativeEvent && isTouchEvent(event.nativeEvent)) {
        clientX = event.nativeEvent.touches[0].clientX;
        clientY = event.nativeEvent.touches[0].clientY;
      }
      if (this.props.onResizeStart) {
        if (this.resizable) {
          var startResize = this.props.onResizeStart(event, direction, this.resizable);
          if (startResize === false) {
            return;
          }
        }
      }
      if (this.props.size) {
        if (typeof this.props.size.height !== "undefined" && this.props.size.height !== this.state.height) {
          this.setState({ height: this.props.size.height });
        }
        if (typeof this.props.size.width !== "undefined" && this.props.size.width !== this.state.width) {
          this.setState({ width: this.props.size.width });
        }
      }
      this.ratio = typeof this.props.lockAspectRatio === "number" ? this.props.lockAspectRatio : this.size.width / this.size.height;
      var flexBasis;
      var computedStyle = this.window.getComputedStyle(this.resizable);
      if (computedStyle.flexBasis !== "auto") {
        var parent_3 = this.parentNode;
        if (parent_3) {
          var dir = this.window.getComputedStyle(parent_3).flexDirection;
          this.flexDir = dir.startsWith("row") ? "row" : "column";
          flexBasis = computedStyle.flexBasis;
        }
      }
      this.setBoundingClientRect();
      this.bindEvents();
      var state = {
        original: {
          x: clientX,
          y: clientY,
          width: this.size.width,
          height: this.size.height
        },
        isResizing: true,
        backgroundStyle: __assign3(__assign3({}, this.state.backgroundStyle), { cursor: this.window.getComputedStyle(event.target).cursor || "auto" }),
        direction,
        flexBasis
      };
      this.setState(state);
    };
    Resizable2.prototype.onMouseMove = function(event) {
      var _this = this;
      if (!this.state.isResizing || !this.resizable || !this.window) {
        return;
      }
      if (this.window.TouchEvent && isTouchEvent(event)) {
        try {
          event.preventDefault();
          event.stopPropagation();
        } catch (e4) {
        }
      }
      var _a2 = this.props, maxWidth = _a2.maxWidth, maxHeight = _a2.maxHeight, minWidth = _a2.minWidth, minHeight = _a2.minHeight;
      var clientX = isTouchEvent(event) ? event.touches[0].clientX : event.clientX;
      var clientY = isTouchEvent(event) ? event.touches[0].clientY : event.clientY;
      var _b = this.state, direction = _b.direction, original = _b.original, width = _b.width, height = _b.height;
      var parentSize = this.getParentSize();
      var max4 = calculateNewMax(parentSize, this.window.innerWidth, this.window.innerHeight, maxWidth, maxHeight, minWidth, minHeight);
      maxWidth = max4.maxWidth;
      maxHeight = max4.maxHeight;
      minWidth = max4.minWidth;
      minHeight = max4.minHeight;
      var _c = this.calculateNewSizeFromDirection(clientX, clientY), newHeight = _c.newHeight, newWidth = _c.newWidth;
      var boundaryMax = this.calculateNewMaxFromBoundary(maxWidth, maxHeight);
      if (this.props.snap && this.props.snap.x) {
        newWidth = findClosestSnap(newWidth, this.props.snap.x, this.props.snapGap);
      }
      if (this.props.snap && this.props.snap.y) {
        newHeight = findClosestSnap(newHeight, this.props.snap.y, this.props.snapGap);
      }
      var newSize = this.calculateNewSizeFromAspectRatio(newWidth, newHeight, { width: boundaryMax.maxWidth, height: boundaryMax.maxHeight }, { width: minWidth, height: minHeight });
      newWidth = newSize.newWidth;
      newHeight = newSize.newHeight;
      if (this.props.grid) {
        var newGridWidth = snap(newWidth, this.props.grid[0]);
        var newGridHeight = snap(newHeight, this.props.grid[1]);
        var gap = this.props.snapGap || 0;
        newWidth = gap === 0 || Math.abs(newGridWidth - newWidth) <= gap ? newGridWidth : newWidth;
        newHeight = gap === 0 || Math.abs(newGridHeight - newHeight) <= gap ? newGridHeight : newHeight;
      }
      var delta = {
        width: newWidth - original.width,
        height: newHeight - original.height
      };
      if (width && typeof width === "string") {
        if (width.endsWith("%")) {
          var percent = newWidth / parentSize.width * 100;
          newWidth = percent + "%";
        } else if (width.endsWith("vw")) {
          var vw = newWidth / this.window.innerWidth * 100;
          newWidth = vw + "vw";
        } else if (width.endsWith("vh")) {
          var vh = newWidth / this.window.innerHeight * 100;
          newWidth = vh + "vh";
        }
      }
      if (height && typeof height === "string") {
        if (height.endsWith("%")) {
          var percent = newHeight / parentSize.height * 100;
          newHeight = percent + "%";
        } else if (height.endsWith("vw")) {
          var vw = newHeight / this.window.innerWidth * 100;
          newHeight = vw + "vw";
        } else if (height.endsWith("vh")) {
          var vh = newHeight / this.window.innerHeight * 100;
          newHeight = vh + "vh";
        }
      }
      var newState = {
        width: this.createSizeForCssProperty(newWidth, "width"),
        height: this.createSizeForCssProperty(newHeight, "height")
      };
      if (this.flexDir === "row") {
        newState.flexBasis = newState.width;
      } else if (this.flexDir === "column") {
        newState.flexBasis = newState.height;
      }
      (0, import_react_dom11.flushSync)(function() {
        _this.setState(newState);
      });
      if (this.props.onResize) {
        this.props.onResize(event, direction, this.resizable, delta);
      }
    };
    Resizable2.prototype.onMouseUp = function(event) {
      var _a2 = this.state, isResizing = _a2.isResizing, direction = _a2.direction, original = _a2.original;
      if (!isResizing || !this.resizable) {
        return;
      }
      var delta = {
        width: this.size.width - original.width,
        height: this.size.height - original.height
      };
      if (this.props.onResizeStop) {
        this.props.onResizeStop(event, direction, this.resizable, delta);
      }
      if (this.props.size) {
        this.setState(this.props.size);
      }
      this.unbindEvents();
      this.setState({
        isResizing: false,
        backgroundStyle: __assign3(__assign3({}, this.state.backgroundStyle), { cursor: "auto" })
      });
    };
    Resizable2.prototype.updateSize = function(size3) {
      this.setState({ width: size3.width, height: size3.height });
    };
    Resizable2.prototype.renderResizer = function() {
      var _this = this;
      var _a2 = this.props, enable = _a2.enable, handleStyles = _a2.handleStyles, handleClasses = _a2.handleClasses, handleWrapperStyle = _a2.handleWrapperStyle, handleWrapperClass = _a2.handleWrapperClass, handleComponent = _a2.handleComponent;
      if (!enable) {
        return null;
      }
      var resizers = Object.keys(enable).map(function(dir) {
        if (enable[dir] !== false) {
          return React62.createElement(Resizer, { key: dir, direction: dir, onResizeStart: _this.onResizeStart, replaceStyles: handleStyles && handleStyles[dir], className: handleClasses && handleClasses[dir] }, handleComponent && handleComponent[dir] ? handleComponent[dir] : null);
        }
        return null;
      });
      return React62.createElement("div", { className: handleWrapperClass, style: handleWrapperStyle }, resizers);
    };
    Resizable2.prototype.render = function() {
      var _this = this;
      var extendsProps = Object.keys(this.props).reduce(function(acc, key) {
        if (definedProps.indexOf(key) !== -1) {
          return acc;
        }
        acc[key] = _this.props[key];
        return acc;
      }, {});
      var style = __assign3(__assign3(__assign3({ position: "relative", userSelect: this.state.isResizing ? "none" : "auto" }, this.props.style), this.sizeStyle), { maxWidth: this.props.maxWidth, maxHeight: this.props.maxHeight, minWidth: this.props.minWidth, minHeight: this.props.minHeight, boxSizing: "border-box", flexShrink: 0 });
      if (this.state.flexBasis) {
        style.flexBasis = this.state.flexBasis;
      }
      var Wrapper = this.props.as || "div";
      return React62.createElement(
        Wrapper,
        __assign3({ ref: this.ref, style, className: this.props.className }, extendsProps),
        this.state.isResizing && React62.createElement("div", { style: this.state.backgroundStyle }),
        this.props.children,
        this.renderResizer()
      );
    };
    Resizable2.defaultProps = {
      as: "div",
      onResizeStart: function() {
      },
      onResize: function() {
      },
      onResizeStop: function() {
      },
      enable: {
        top: true,
        right: true,
        bottom: true,
        left: true,
        topRight: true,
        bottomRight: true,
        bottomLeft: true,
        topLeft: true
      },
      style: {},
      grid: [1, 1],
      lockAspectRatio: false,
      lockAspectRatioExtraWidth: 0,
      lockAspectRatioExtraHeight: 0,
      scale: 1,
      resizeRatio: 1,
      snapGap: 0
    };
    return Resizable2;
  }(React62.PureComponent)
);

// node_modules/@neo4j-ndl/react/lib/esm/drawer/Drawer.js
var __rest35 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var Drawer = (_a2) => {
  var { children, className = "", expanded, onExpandedChange, position: position2 = "left", type = "overlay", isResizeable = false, resizeableProps, closeable = true } = _a2, restProps = __rest35(_a2, ["children", "className", "expanded", "onExpandedChange", "position", "type", "isResizeable", "resizeableProps", "closeable"]);
  const setOnExpandedChange = (0, import_react178.useCallback)(() => {
    if (onExpandedChange)
      onExpandedChange(!expanded);
  }, [expanded, onExpandedChange]);
  const classes = classNames("ndl-drawer", className, {
    "ndl-drawer-expanded": expanded,
    "ndl-drawer-left": position2 === "left",
    "ndl-drawer-right": position2 === "right",
    "ndl-drawer-overlay": type === "overlay",
    "ndl-drawer-push": type === "push"
  });
  const stylePosition = type === "overlay" ? "absolute" : "relative";
  const Close = () => (0, import_jsx_runtime49.jsx)(import_jsx_runtime49.Fragment, { children: closeable && (0, import_jsx_runtime49.jsx)(IconButton, { className: "ndl-drawer-close-button", onClick: setOnExpandedChange, "aria-label": "close-drawer", size: "large", "data-testid": "ndl-drawer-close-button", title: "Close drawer", clean: true, children: (0, import_jsx_runtime49.jsx)(import_XMarkIcon.default, { className: "n-w-6 n-h-6" }) }) });
  if (isResizeable) {
    return (0, import_jsx_runtime49.jsxs)(Resizable, Object.assign({ defaultSize: {
      width: "auto",
      height: "100%"
    } }, resizeableProps, { className: classes, style: Object.assign({ position: stylePosition }, resizeableProps === null || resizeableProps === void 0 ? void 0 : resizeableProps.style), boundsByDirection: true, bounds: "parent", enable: {
      top: false,
      right: position2 === "left",
      bottom: false,
      left: position2 === "right",
      topRight: false,
      bottomRight: false,
      bottomLeft: false,
      topLeft: false
    }, children: [children, (0, import_jsx_runtime49.jsx)(Close, {})] }));
  }
  return (0, import_jsx_runtime49.jsxs)("div", Object.assign({}, restProps, { className: classes, children: [children, (0, import_jsx_runtime49.jsx)(Close, {})] }));
};
var Header5 = (_a2) => {
  var { children, className = "" } = _a2, restProps = __rest35(_a2, ["children", "className"]);
  const classes = classNames("ndl-drawer-header", className);
  return (0, import_jsx_runtime49.jsx)("h5", Object.assign({}, restProps, { className: classes, children }));
};
Drawer.Header = Header5;
var Actions4 = (_a2) => {
  var { children, className = "" } = _a2, restProps = __rest35(_a2, ["children", "className"]);
  const classes = classNames("ndl-drawer-actions", className);
  return (0, import_jsx_runtime49.jsx)("div", Object.assign({}, restProps, { className: classes, children }));
};
Drawer.Actions = Actions4;
var Body5 = (_a2) => {
  var { children, className = "" } = _a2, restProps = __rest35(_a2, ["children", "className"]);
  const classes = classNames("ndl-drawer-body", className);
  return (0, import_jsx_runtime49.jsx)("div", { className: "ndl-drawer-body-wrapper", children: (0, import_jsx_runtime49.jsx)("div", Object.assign({}, restProps, { className: classes, children })) });
};
Drawer.Body = Body5;

// node_modules/@neo4j-ndl/react/lib/esm/breadcrumbs/Breadcrumbs.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime());
var import_react179 = __toESM(require_react());
var __rest36 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var BreadcrumbsBaseItem = (_a2) => {
  var { as = "a", children = (0, import_jsx_runtime50.jsx)(import_HomeIcon.default, {}), className, href, isCurrentPage = false, onClick } = _a2, restProps = __rest36(_a2, ["as", "children", "className", "href", "isCurrentPage", "onClick"]);
  const Component4 = as;
  const classes = classNames("ndl-breadcrumbs-base-item-link", className, {
    "ndl-breadcrumbs-base-item-link-active": isCurrentPage
  });
  return (0, import_jsx_runtime50.jsx)("li", { className: "ndl-breadcrumbs-base-item", children: (0, import_jsx_runtime50.jsx)(
    Component4,
    Object.assign({
      /* Overridable */
      role: "button",
      tabIndex: 0
    }, restProps, {
      /* Non-overridable */
      className: classes,
      href,
      onClick: (event) => {
        if (onClick)
          onClick(event, href);
      },
      children
    })
  ) });
};
BreadcrumbsBaseItem.displayName = "Breadcrumbs.BaseItem";
var BreadcrumbsGroupItem = (_a2) => {
  var { as = "li", children, className } = _a2, restProps = __rest36(_a2, ["as", "children", "className"]);
  const Component4 = as;
  const classes = classNames("ndl-breadcrumbs-group-item", className);
  return (0, import_jsx_runtime50.jsx)(
    Component4,
    Object.assign({}, restProps, {
      /* Non-overridable */
      className: classes,
      children: (0, import_jsx_runtime50.jsx)("ol", { children })
    })
  );
};
BreadcrumbsGroupItem.displayName = "Breadcrumbs.GroupItem";
var BreadcrumbsItem = (_a2) => {
  var { as = "a", children, className, hasSeparator = true, href, isCurrentPage = false, onClick } = _a2, restProps = __rest36(_a2, ["as", "children", "className", "hasSeparator", "href", "isCurrentPage", "onClick"]);
  const listItemClasses = classNames("ndl-breadcrumbs-item", {
    "ndl-breadcrumbs-separator": hasSeparator
  });
  const linkClasses = classNames("ndl-breadcrumbs-item-link", {
    "ndl-breadcrumbs-item-link-active": isCurrentPage
  }, className);
  return (0, import_jsx_runtime50.jsx)("li", { className: listItemClasses, children: (0, import_jsx_runtime50.jsx)(
    Typography,
    Object.assign({ "aria-current": isCurrentPage ? "page" : void 0, as, role: "button", tabIndex: 0, variant: "body-medium" }, restProps, {
      /* Non-overridable */
      className: linkClasses,
      href,
      onClick: (event) => {
        if (onClick)
          onClick(event, href);
      },
      children
    })
  ) });
};
BreadcrumbsItem.displayName = "Breadcrumbs.Item";
var BreadcrumbsItemMenu = (_a2) => {
  var { children, className, isOpen = false, onClick, onClose } = _a2, restProps = __rest36(_a2, ["children", "className", "isOpen", "onClick", "onClose"]);
  const buttonRef = (0, import_react179.useRef)(null);
  const [isItemMenuOpen, setIsItemMenuOpen] = (0, import_react179.useState)(isOpen);
  const classes = classNames("ndl-breadcrumbs-item-menu-button", className);
  return (0, import_jsx_runtime50.jsxs)("li", { className: "ndl-breadcrumbs-item-menu", children: [(0, import_jsx_runtime50.jsx)(
    IconButton,
    Object.assign({ "aria-haspopup": "true", "aria-label": "breadcrumbs item menu", clean: true, grouped: true, size: "small" }, restProps, {
      /* Non-overridable */
      className: classes,
      onClick: (event) => {
        setIsItemMenuOpen(true);
        if (onClick)
          onClick(event);
      },
      ref: buttonRef,
      children: (0, import_jsx_runtime50.jsx)(import_ChevronDownIcon.default, {})
    })
  ), (0, import_jsx_runtime50.jsx)(Menu, { anchorEl: buttonRef, anchorOrigin: {
    vertical: "bottom",
    horizontal: "center"
  }, captureFocus: true, onClose: (event) => {
    setIsItemMenuOpen(false);
    if (onClose)
      onClose(event);
  }, open: isItemMenuOpen, transformOrigin: { vertical: "top", horizontal: "left" }, children: (0, import_jsx_runtime50.jsx)(Menu.Items, { children }) })] });
};
BreadcrumbsItemMenu.displayName = "Breadcrumbs.ItemMenu";
var BreadcrumbsEllipsisMenu = (_a2) => {
  var { as = "span", children, className, isOpen = false, onClick, onClose, onKeyDown } = _a2, restProps = __rest36(_a2, ["as", "children", "className", "isOpen", "onClick", "onClose", "onKeyDown"]);
  const ellipsisButtonRef = (0, import_react179.useRef)(null);
  const ellipsisMenuRef = (0, import_react179.useRef)(null);
  const [isEllipsisMenuOpen, setIsEllipsisMenuOpen] = (0, import_react179.useState)(isOpen);
  const Component4 = as;
  const classes = classNames("ndl-breadcrumbs-ellipsis-menu-button", className);
  return (0, import_jsx_runtime50.jsxs)("li", { className: "ndl-breadcrumbs-ellipsis-menu ndl-breadcrumbs-separator", children: [(0, import_jsx_runtime50.jsx)(
    Component4,
    Object.assign({ "aria-controls": isEllipsisMenuOpen ? "ellipsis-menu" : void 0, "aria-expanded": isEllipsisMenuOpen ? "true" : void 0, "aria-haspopup": "true", role: "button", tabIndex: 0 }, restProps, {
      /* Non-overridable */
      className: classes,
      onClick: (event) => {
        setIsEllipsisMenuOpen(true);
        if (onClick)
          onClick(event);
      },
      onKeyDown: (event) => {
        if (event.key === "Enter")
          setIsEllipsisMenuOpen(true);
        if (onKeyDown)
          onKeyDown(event);
      },
      ref: ellipsisButtonRef,
      children: ""
    })
  ), (0, import_jsx_runtime50.jsx)(Menu, { anchorEl: ellipsisButtonRef, captureFocus: true, onClose: (event) => {
    setIsEllipsisMenuOpen(false);
    if (onClose)
      onClose(event);
  }, open: isEllipsisMenuOpen, ref: ellipsisMenuRef, children: (0, import_jsx_runtime50.jsx)(Menu.Items, { children }) })] });
};
BreadcrumbsEllipsisMenu.displayName = "Breadcrumbs.EllipsisMenu";
var BreadcrumbsMenuItem = (_a2) => {
  var { as = "span", children, className, href, isCurrentPage = false, onClick } = _a2, restProps = __rest36(_a2, ["as", "children", "className", "href", "isCurrentPage", "onClick"]);
  const linkClasses = classNames("ndl-breadcrumbs-item-link", className, {
    "ndl-breadcrumbs-item-link-active": isCurrentPage
  });
  return (0, import_jsx_runtime50.jsx)(Menu.Item, { as, className: "ndl-breadcrumbs-menu-item", title: href ? (0, import_jsx_runtime50.jsx)(
    Typography,
    Object.assign({ "aria-current": isCurrentPage ? "page" : void 0, as, role: "button", tabIndex: 0, variant: "body-medium" }, restProps, {
      /* Non-overridable */
      className: linkClasses,
      href,
      onClick: (event) => {
        if (onClick)
          onClick(event, href);
      },
      children
    })
  ) : (0, import_jsx_runtime50.jsx)(
    Typography,
    Object.assign({
      /* Overridable */
      as,
      tabIndex: -1,
      variant: "body-medium"
    }, restProps, {
      /* Non-overridable */
      className: linkClasses,
      children
    })
  ) });
};
BreadcrumbsMenuItem.displayName = "Breadcrumbs.MenuItem";
var BreadcrumbsComponent = (_a2) => {
  var { as = "nav", children, className } = _a2, restProps = __rest36(_a2, ["as", "children", "className"]);
  const Component4 = as;
  const classes = classNames("ndl-breadcrumbs", className);
  return (0, import_jsx_runtime50.jsx)(
    Component4,
    Object.assign({ "aria-label": "breadcrumb" }, restProps, {
      /* Non-overridable */
      className: classes,
      children: (0, import_jsx_runtime50.jsx)("ol", { children })
    })
  );
};
BreadcrumbsComponent.displayName = "Breadcrumbs";
var Breadcrumbs = Object.assign(BreadcrumbsComponent, {
  BaseItem: BreadcrumbsBaseItem,
  GroupItem: BreadcrumbsGroupItem,
  Item: BreadcrumbsItem,
  ItemMenu: BreadcrumbsItemMenu,
  EllipsisMenu: BreadcrumbsEllipsisMenu,
  MenuItem: BreadcrumbsMenuItem
});

// node_modules/@neo4j-ndl/react/lib/esm/hooks/index.js
var import_react212 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useBoolean/useBoolean.js
var import_react180 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useCopyToClipboard/useCopyToClipboard.js
var import_react181 = __toESM(require_react());
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e4) {
        reject(e4);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e4) {
        reject(e4);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function useCopyToClipboard() {
  const [copiedText, setCopiedText] = (0, import_react181.useState)(null);
  const copy2 = (text) => __awaiter2(this, void 0, void 0, function* () {
    if (!(navigator === null || navigator === void 0 ? void 0 : navigator.clipboard)) {
      console.warn("Clipboard not supported");
      return false;
    }
    try {
      yield navigator.clipboard.writeText(text);
      setCopiedText(text);
      return true;
    } catch (error) {
      console.warn("Copy failed", error);
      setCopiedText(null);
      return false;
    }
  });
  return [copiedText, copy2];
}
var useCopyToClipboard_default2 = useCopyToClipboard;

// node_modules/usehooks-ts/dist/esm/useCountdown/useCountdown.js
var import_react182 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useCounter/useCounter.js
var import_react183 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useDebounce/useDebounce.js
var import_react184 = __toESM(require_react());
function useDebounce2(value, delay) {
  const [debouncedValue, setDebouncedValue] = (0, import_react184.useState)(value);
  (0, import_react184.useEffect)(() => {
    const timer = setTimeout(() => setDebouncedValue(value), delay || 500);
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);
  return debouncedValue;
}
var useDebounce_default = useDebounce2;

// node_modules/usehooks-ts/dist/esm/useEffectOnce/useEffectOnce.js
var import_react185 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useElementSize/useElementSize.js
var import_react186 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useEventCallback/useEventCallback.js
var import_react187 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useEventListener/useEventListener.js
var import_react188 = __toESM(require_react());
function useEventListener(eventName, handler, element, options2) {
  const savedHandler = (0, import_react188.useRef)(handler);
  useIsomorphicLayoutEffect_default2(() => {
    savedHandler.current = handler;
  }, [handler]);
  (0, import_react188.useEffect)(() => {
    var _a2;
    const targetElement = (_a2 = element === null || element === void 0 ? void 0 : element.current) !== null && _a2 !== void 0 ? _a2 : window;
    if (!(targetElement && targetElement.addEventListener))
      return;
    const listener = (event) => savedHandler.current(event);
    targetElement.addEventListener(eventName, listener, options2);
    return () => {
      targetElement.removeEventListener(eventName, listener, options2);
    };
  }, [eventName, element, options2]);
}
var useEventListener_default = useEventListener;

// node_modules/usehooks-ts/dist/esm/useFetch/useFetch.js
var import_react189 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useHover/useHover.js
var import_react190 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useImageOnLoad/useImageOnLoad.js
var import_react191 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useIntersectionObserver/useIntersectionObserver.js
var import_react192 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useInterval/useInterval.js
var import_react193 = __toESM(require_react());
function useInterval(callback, delay) {
  const savedCallback = (0, import_react193.useRef)(callback);
  useIsomorphicLayoutEffect_default2(() => {
    savedCallback.current = callback;
  }, [callback]);
  (0, import_react193.useEffect)(() => {
    if (!delay && delay !== 0) {
      return;
    }
    const id = setInterval(() => savedCallback.current(), delay);
    return () => clearInterval(id);
  }, [delay]);
}
var useInterval_default2 = useInterval;

// node_modules/usehooks-ts/dist/esm/useIsClient/useIsClient.js
var import_react194 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useIsFirstRender/useIsFirstRender.js
var import_react195 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useIsMounted/useIsMounted.js
var import_react196 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useIsomorphicLayoutEffect/useIsomorphicLayoutEffect.js
var import_react197 = __toESM(require_react());
var useIsomorphicLayoutEffect3 = typeof window !== "undefined" ? import_react197.useLayoutEffect : import_react197.useEffect;
var useIsomorphicLayoutEffect_default2 = useIsomorphicLayoutEffect3;

// node_modules/usehooks-ts/dist/esm/useLocalStorage/useLocalStorage.js
var import_react198 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useLockedBody/useLockedBody.js
var import_react199 = __toESM(require_react());
function useLockedBody(initialLocked = false, rootId = "___gatsby") {
  const [locked, setLocked] = (0, import_react199.useState)(initialLocked);
  useIsomorphicLayoutEffect_default2(() => {
    if (!locked) {
      return;
    }
    const originalOverflow = document.body.style.overflow;
    const originalPaddingRight = document.body.style.paddingRight;
    document.body.style.overflow = "hidden";
    const root = document.getElementById(rootId);
    const scrollBarWidth = root ? root.offsetWidth - root.scrollWidth : 0;
    if (scrollBarWidth) {
      document.body.style.paddingRight = `${scrollBarWidth}px`;
    }
    return () => {
      document.body.style.overflow = originalOverflow;
      if (scrollBarWidth) {
        document.body.style.paddingRight = originalPaddingRight;
      }
    };
  }, [locked]);
  (0, import_react199.useEffect)(() => {
    if (locked !== initialLocked) {
      setLocked(initialLocked);
    }
  }, [initialLocked]);
  return [locked, setLocked];
}
var useLockedBody_default = useLockedBody;

// node_modules/usehooks-ts/dist/esm/useMap/useMap.js
var import_react200 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useMediaQuery/useMediaQuery.js
var import_react201 = __toESM(require_react());
function useMediaQuery(query) {
  const getMatches = (query2) => {
    if (typeof window !== "undefined") {
      return window.matchMedia(query2).matches;
    }
    return false;
  };
  const [matches2, setMatches] = (0, import_react201.useState)(getMatches(query));
  function handleChange() {
    setMatches(getMatches(query));
  }
  (0, import_react201.useEffect)(() => {
    const matchMedia = window.matchMedia(query);
    handleChange();
    if (matchMedia.addListener) {
      matchMedia.addListener(handleChange);
    } else {
      matchMedia.addEventListener("change", handleChange);
    }
    return () => {
      if (matchMedia.removeListener) {
        matchMedia.removeListener(handleChange);
      } else {
        matchMedia.removeEventListener("change", handleChange);
      }
    };
  }, [query]);
  return matches2;
}
var useMediaQuery_default = useMediaQuery;

// node_modules/usehooks-ts/dist/esm/useOnClickOutside/useOnClickOutside.js
function useOnClickOutside2(ref, handler, mouseEvent = "mousedown") {
  useEventListener_default(mouseEvent, (event) => {
    const el = ref === null || ref === void 0 ? void 0 : ref.current;
    if (!el || el.contains(event.target)) {
      return;
    }
    handler(event);
  });
}
var useOnClickOutside_default = useOnClickOutside2;

// node_modules/usehooks-ts/dist/esm/useReadLocalStorage/useReadLocalStorage.js
var import_react202 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useScreen/useScreen.js
var import_react203 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useScript/useScript.js
var import_react204 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useSessionStorage/useSessionStorage.js
var import_react205 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useStep/useStep.js
var import_react206 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useTernaryDarkMode/useTernaryDarkMode.js
var import_react207 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useTimeout/useTimeout.js
var import_react208 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useToggle/useToggle.js
var import_react209 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useUpdateEffect/useUpdateEffect.js
var import_react210 = __toESM(require_react());

// node_modules/usehooks-ts/dist/esm/useWindowSize/useWindowSize.js
var import_react211 = __toESM(require_react());
function useWindowSize() {
  const [windowSize, setWindowSize] = (0, import_react211.useState)({
    width: 0,
    height: 0
  });
  const handleSize = () => {
    setWindowSize({
      width: window.innerWidth,
      height: window.innerHeight
    });
  };
  useEventListener_default("resize", handleSize);
  useIsomorphicLayoutEffect_default2(() => {
    handleSize();
  }, []);
  return windowSize;
}
var useWindowSize_default2 = useWindowSize;

// node_modules/@neo4j-ndl/react/lib/esm/hooks/index.js
function usePrevious2(value) {
  const ref = (0, import_react212.useRef)();
  (0, import_react212.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
function useEffectDebugger(effectHook, dependencies, dependencyNames = []) {
  const previousDeps = usePrevious2(dependencies);
  const changedDeps = dependencies.reduce((accum, dependency, index4) => {
    if (previousDeps === void 0) {
      return accum;
    }
    if (dependency !== previousDeps[index4]) {
      const keyName2 = dependencyNames[index4] || index4;
      return Object.assign(Object.assign({}, accum), { [keyName2]: {
        before: previousDeps[index4],
        after: dependency
      } });
    }
    return accum;
  }, {});
  if (Object.keys(changedDeps).length) {
    console.info("[use-effect-debugger] ", changedDeps);
  }
  (0, import_react212.useEffect)(effectHook, dependencies);
}
function useRenderCount() {
  const count2 = (0, import_react212.useRef)(0);
  count2.current++;
  return count2.current;
}

// node_modules/@neo4j-ndl/react/lib/esm/layout/Flex.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime());
var import_react213 = __toESM(require_react());

// node_modules/@neo4j-ndl/react/lib/esm/layout/types.js
var SpacingDefaults = {
  padding: "4",
  paddingBlockStart: void 0,
  paddingBlockEnd: void 0,
  paddingInline: void 0,
  paddingInlineStart: void 0,
  paddingInlineEnd: void 0,
  gap: "4"
};
var getSpacing = (spacing2, property) => {
  return spacing2 ? tokens.space[spacing2 || SpacingDefaults[property]] : void 0;
};
var RadiusDefaults = {
  borderRadius: void 0
};
var getRadius = (spacing2, property) => {
  return spacing2 ? tokens.borderRadius[spacing2 || RadiusDefaults[property]] : void 0;
};

// node_modules/@neo4j-ndl/react/lib/esm/layout/Flex.js
var __rest37 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var Flex = (0, import_react213.forwardRef)(function Flex2(_a2, ref) {
  var { as = "div", gap = "4", rowGap, columnGap, children, borderRadius: borderRadius2, flexDirection = "column", flexWrap = "nowrap", alignItems, justifyContent } = _a2, restProps = __rest37(_a2, ["as", "gap", "rowGap", "columnGap", "children", "borderRadius", "flexDirection", "flexWrap", "alignItems", "justifyContent"]);
  const Component4 = as;
  const gapPx = getSpacing(gap, "gap");
  const rowGapPx = rowGap ? tokens.space[rowGap] : void 0;
  const columnGapPx = columnGap ? tokens.space[columnGap] : void 0;
  const gapFormatted = `${rowGapPx !== null && rowGapPx !== void 0 ? rowGapPx : gapPx} ${columnGapPx !== null && columnGapPx !== void 0 ? columnGapPx : gapPx}`;
  const style = {
    flexDirection,
    alignItems,
    flexWrap,
    justifyContent,
    display: "flex",
    gap: gapFormatted,
    borderRadius: getRadius(borderRadius2, "borderRadius")
  };
  return (0, import_jsx_runtime51.jsx)(Component4, Object.assign({ ref }, restProps, { style: Object.assign(Object.assign({}, style), restProps.style), children }));
});

// node_modules/@neo4j-ndl/react/lib/esm/layout/Box.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime());
var import_react214 = __toESM(require_react());
var __rest38 = function(s3, e4) {
  var t4 = {};
  for (var p in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p) && e4.indexOf(p) < 0)
      t4[p] = s3[p];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
      if (e4.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
        t4[p[i2]] = s3[p[i2]];
    }
  return t4;
};
var Box = (0, import_react214.forwardRef)(function Box2(_a2, ref) {
  var { as = "div", padding, paddingInline, paddingInlineStart, paddingInlineEnd, paddingBlockEnd, paddingBlockStart, borderRadius: borderRadius2, children } = _a2, restProps = __rest38(_a2, ["as", "padding", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlockEnd", "paddingBlockStart", "borderRadius", "children"]);
  const Component4 = as;
  const style = {
    padding: getSpacing(padding, "padding"),
    paddingInline: getSpacing(paddingInline, "paddingInline"),
    paddingInlineStart: getSpacing(paddingInlineStart, "paddingInlineStart"),
    paddingInlineEnd: getSpacing(paddingInlineEnd, "paddingInlineEnd"),
    paddingBlockEnd: getSpacing(paddingBlockEnd, "paddingBlockEnd"),
    paddingBlockStart: getSpacing(paddingBlockStart, "paddingBlockStart"),
    borderRadius: getRadius(borderRadius2, "borderRadius")
  };
  return (0, import_jsx_runtime52.jsx)(Component4, Object.assign({ ref }, restProps, { style: Object.assign(Object.assign({}, style), restProps.style), children }));
});
export {
  Accordion,
  Action,
  Actions,
  BannerNamespace as Banner,
  Body,
  Box,
  Breadcrumbs,
  Button,
  Checkbox_default as Checkbox,
  CodeBlock,
  Content,
  CypherCodeBlock,
  DataGrid_default as DataGrid,
  DataGridComponents,
  DatePicker,
  Dialog,
  DialogCloseReason,
  Drawer,
  Dropdown,
  Dropzone_default as Dropzone,
  Flex,
  Footer,
  GraphLabel_default as GraphLabel,
  Header,
  Horizontal,
  IconButton,
  IconButtonArray,
  Label_default as Label,
  LoadingSpinner_default as LoadingSpinner,
  Menu,
  Modal,
  ModalCloseReason,
  NeedleThemeProvider,
  Popover,
  ProgressBar_default as ProgressBar,
  Radio_default as Radio,
  SegmentedControl,
  SideNavigation,
  StatusIndicator_default as StatusIndicator,
  Switch_default as Switch,
  Table_default as Table,
  TableComponents,
  Tabs,
  Tag,
  TextInput_default as TextInput,
  TextLink_default as TextLink,
  Textarea_default as Textarea,
  ThemeContext,
  Tip,
  Tooltip_default as Tooltip,
  Trigger,
  Typography,
  Vertical,
  Widget_default as Widget,
  Wizard,
  helpers_exports2 as dataGridUtils,
  helpers_exports as tableUtils,
  useCopyToClipboard_default2 as useCopyToClipboard,
  useDataGridContext,
  useDebounce_default as useDebounce,
  useEffectDebugger,
  useEventListener_default as useEventListener,
  useInterval_default2 as useInterval,
  useLockedBody_default as useLockedBody,
  useMediaQuery_default as useMediaQuery,
  useNeedleTheme,
  useOnClickOutside_default as useOnClickOutside,
  usePrevious2 as usePrevious,
  useRenderCount,
  useTableContext,
  useTip,
  useTipContext,
  useWindowSize_default2 as useWindowSize
};
/*! Bundled license information:

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

js-cookie/src/js.cookie.js:
  (*!
   * JavaScript Cookie v2.2.1
   * https://github.com/js-cookie/js-cookie
   *
   * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
   * Released under the MIT license
   *)

screenfull/dist/screenfull.js:
  (*!
  * screenfull
  * v5.2.0 - 2021-11-03
  * (c) Sindre Sorhus; MIT License
  *)

@babel/runtime/helpers/regeneratorRuntime.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.2.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

@tanstack/table-core/build/lib/index.mjs:
  (**
     * table-core
     *
     * Copyright (c) TanStack
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     *)

@tanstack/react-table/build/lib/index.mjs:
  (**
     * react-table
     *
     * Copyright (c) TanStack
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     *)

antlr4/src/antlr4/polyfills/codepointat.js:
  (*! https://mths.be/codepointat v0.2.0 by @mathias *)

antlr4/src/antlr4/polyfills/fromcodepoint.js:
  (*! https://mths.be/fromcodepoint v0.2.1 by @mathias *)
*/
//# sourceMappingURL=@neo4j-ndl_react.js.map
