/**
 *
 *  Copyright (c) "Neo4j"
 *  Neo4j Sweden AB [http://neo4j.com]
 *
 *  This file is part of Neo4j.
 *
 *  Neo4j is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import { FloatingPortal } from '@floating-ui/react';
import { type Side } from '@floating-ui/core/src/types';
import { type ElementBase } from '../helpers';
import { Typography } from '../typography';
import React, { type ComponentProps } from 'react';
export interface TipProps {
    /** Type of the tip */
    type?: 'tooltip' | 'toggletip';
    /** Allowed places of the tooltip */
    allowedPlacements?: Side[];
    /** Controlled open state */
    isOpen?: boolean;
    /** If the tip is disabled, to Tip.Content will not be rendered if provided */
    isDisabled?: boolean;
    /** For controlled open state */
    onOpenChange?: (isOpen: boolean, event?: Event) => void;
}
export declare function useTip({ allowedPlacements, isOpen: controlledOpen, isDisabled, onOpenChange: setControlledOpen, type, }?: TipProps): {
    placement: import("@floating-ui/utils").Placement;
    strategy: import("@floating-ui/utils").Strategy;
    middlewareData: import("@floating-ui/react").MiddlewareData;
    x: number;
    y: number;
    isPositioned: boolean;
    update: () => void;
    floatingStyles: React.CSSProperties;
    refs: {
        reference: React.MutableRefObject<import("@floating-ui/react-dom").ReferenceType | null>;
        floating: React.MutableRefObject<HTMLElement | null>;
        setReference: (node: import("@floating-ui/react-dom").ReferenceType | null) => void;
        setFloating: (node: HTMLElement | null) => void;
    } & import("@floating-ui/react").ExtendedRefs<import("@floating-ui/react").ReferenceType>;
    elements: {
        reference: import("@floating-ui/react-dom").ReferenceType | null;
        floating: HTMLElement | null;
    } & import("@floating-ui/react").ExtendedElements<import("@floating-ui/react").ReferenceType>;
    context: {
        placement: import("@floating-ui/utils").Placement;
        strategy: import("@floating-ui/utils").Strategy;
        x: number;
        y: number;
        middlewareData: import("@floating-ui/react").MiddlewareData;
        isPositioned: boolean;
        update: () => void;
        floatingStyles: React.CSSProperties;
        open: boolean;
        onOpenChange: (open: boolean, event?: Event | undefined) => void;
        events: import("@floating-ui/react").FloatingEvents;
        dataRef: React.MutableRefObject<import("@floating-ui/react").ContextData>;
        nodeId: string | undefined;
        floatingId: string;
        refs: import("@floating-ui/react").ExtendedRefs<import("@floating-ui/react").ReferenceType>;
        elements: import("@floating-ui/react").ExtendedElements<import("@floating-ui/react").ReferenceType>;
    };
    getReferenceProps: (userProps?: React.HTMLProps<Element> | undefined) => Record<string, unknown>;
    getFloatingProps: (userProps?: React.HTMLProps<HTMLElement> | undefined) => Record<string, unknown>;
    getItemProps: (userProps?: React.HTMLProps<HTMLElement> | undefined) => Record<string, unknown>;
    open: boolean;
    setOpen: (isOpen: boolean, event?: Event | undefined) => void;
    type: "tooltip" | "toggletip";
};
export declare const useTipContext: () => {
    placement: import("@floating-ui/utils").Placement;
    strategy: import("@floating-ui/utils").Strategy;
    middlewareData: import("@floating-ui/react").MiddlewareData;
    x: number;
    y: number;
    isPositioned: boolean;
    update: () => void;
    floatingStyles: React.CSSProperties;
    refs: {
        reference: React.MutableRefObject<import("@floating-ui/react-dom").ReferenceType | null>;
        floating: React.MutableRefObject<HTMLElement | null>;
        setReference: (node: import("@floating-ui/react-dom").ReferenceType | null) => void;
        setFloating: (node: HTMLElement | null) => void;
    } & import("@floating-ui/react").ExtendedRefs<import("@floating-ui/react").ReferenceType>;
    elements: {
        reference: import("@floating-ui/react-dom").ReferenceType | null;
        floating: HTMLElement | null;
    } & import("@floating-ui/react").ExtendedElements<import("@floating-ui/react").ReferenceType>;
    context: {
        placement: import("@floating-ui/utils").Placement;
        strategy: import("@floating-ui/utils").Strategy;
        x: number;
        y: number;
        middlewareData: import("@floating-ui/react").MiddlewareData;
        isPositioned: boolean;
        update: () => void;
        floatingStyles: React.CSSProperties;
        open: boolean;
        onOpenChange: (open: boolean, event?: Event | undefined) => void;
        events: import("@floating-ui/react").FloatingEvents;
        dataRef: React.MutableRefObject<import("@floating-ui/react").ContextData>;
        nodeId: string | undefined;
        floatingId: string;
        refs: import("@floating-ui/react").ExtendedRefs<import("@floating-ui/react").ReferenceType>;
        elements: import("@floating-ui/react").ExtendedElements<import("@floating-ui/react").ReferenceType>;
    };
    getReferenceProps: (userProps?: React.HTMLProps<Element> | undefined) => Record<string, unknown>;
    getFloatingProps: (userProps?: React.HTMLProps<HTMLElement> | undefined) => Record<string, unknown>;
    getItemProps: (userProps?: React.HTMLProps<HTMLElement> | undefined) => Record<string, unknown>;
    open: boolean;
    setOpen: (isOpen: boolean, event?: Event) => void;
    type: "tooltip" | "toggletip";
};
export declare function Tip({ children, ...options }: {
    children: React.ReactNode;
} & TipProps): import("react/jsx-runtime").JSX.Element;
export declare namespace Tip {
    var Content: React.ForwardRefExoticComponent<ContentProps & React.RefAttributes<HTMLDivElement>>;
    var Trigger: React.ForwardRefExoticComponent<Omit<React.HTMLProps<HTMLElement> & {
        /** Wraps trigger element in an accessible `button` element */
        hasButtonWrapper?: boolean | undefined;
    }, "ref"> & React.RefAttributes<HTMLElement>>;
    var Header: React.ForwardRefExoticComponent<HeaderProps & React.RefAttributes<HTMLDivElement>>;
    var Body: React.ForwardRefExoticComponent<BodyProps & React.RefAttributes<HTMLDivElement>>;
    var Actions: React.ForwardRefExoticComponent<ActionsProps & React.RefAttributes<HTMLDivElement>>;
    var Action: ({ className, ...restProps }: ActionProps) => import("react/jsx-runtime").JSX.Element | null;
}
/**
 * Wrapping the trigger in a button by default
 * Use `asChild` to pass any element as the trigger
 */
export declare const Trigger: React.ForwardRefExoticComponent<Omit<React.HTMLProps<HTMLElement> & {
    /** Wraps trigger element in an accessible `button` element */
    hasButtonWrapper?: boolean | undefined;
}, "ref"> & React.RefAttributes<HTMLElement>>;
export interface ContentProps extends Omit<ElementBase<HTMLDivElement>, 'as'> {
    /** Whether to portal the content */
    isPortaled?: boolean;
    /**
     * Props to pass to the portal from @floating-ui/react FloatingPortal
     * @see https://floating-ui.com/docs/floatingportal
     */
    portalProps?: ComponentProps<typeof FloatingPortal>;
}
export declare const Content: React.ForwardRefExoticComponent<ContentProps & React.RefAttributes<HTMLDivElement>>;
export interface HeaderProps extends Omit<ElementBase<HTMLDivElement>, 'as'> {
    /** Close button will be visible */
    isCloseable?: boolean;
}
export declare const Header: React.ForwardRefExoticComponent<HeaderProps & React.RefAttributes<HTMLDivElement>>;
export type BodyProps = Omit<ElementBase<HTMLDivElement>, 'as'>;
export declare const Body: React.ForwardRefExoticComponent<BodyProps & React.RefAttributes<HTMLDivElement>>;
export type ActionsProps = Omit<ElementBase<HTMLDivElement>, 'as'>;
export declare const Actions: React.ForwardRefExoticComponent<ActionsProps & React.RefAttributes<HTMLDivElement>>;
export type ActionProps = Omit<ComponentProps<typeof Typography>, 'variant'>;
export declare const Action: ({ className, ...restProps }: ActionProps) => import("react/jsx-runtime").JSX.Element | null;
