"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Menu = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
/**
 *
 *  Copyright (c) "Neo4j"
 *  Neo4j Sweden AB [http://neo4j.com]
 *
 *  This file is part of Neo4j.
 *
 *  Neo4j is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
const react_1 = __importStar(require("react"));
const debounce_1 = require("../helpers/debounce");
const icons_1 = require("../icons");
const popover_1 = require("../popover");
const defaultImports_1 = require("../_common/defaultImports");
const SafeArea_1 = require("./SafeArea");
const ThemeProvider_1 = require("../theme/ThemeProvider");
const button_1 = require("../button");
const MenuContext = react_1.default.createContext(null);
const useMenuContext = () => {
    const context = (0, react_1.useContext)(MenuContext);
    if (context === null) {
        throw new Error('Menu used without context. Did you render this component inside a <Menu />?');
    }
    return context;
};
const MenuComponent = react_1.default.forwardRef(function MenuComponent(_a, ref) {
    var { size = 'small', className, minWidth = 250, open, onClose, children, level = 0, nested } = _a, rest = __rest(_a, ["size", "className", "minWidth", "open", "onClose", "children", "level", "nested"]);
    const menuRef = (0, react_1.useRef)();
    const focus = (0, react_1.useCallback)(() => {
        const menu = menuRef.current;
        if (!menu)
            return;
        const menuItems = menu.querySelectorAll(':scope > .ndl-menu-items');
        const menuItemsItems = menu.querySelectorAll(':scope > .ndl-menu-items > .ndl-menu-item');
        if (menuItemsItems.length > 0 && menu.className.includes('nested-menu')) {
            menuItemsItems[0].focus();
            return;
        }
        if (menuItems.length > 0) {
            menuItems[0].focus();
            return;
        }
        menu.focus();
    }, []);
    // Override ref to map to internal ref
    // as well as change focus to focus the
    // first menu item
    (0, react_1.useImperativeHandle)(ref, () => {
        const menu = menuRef.current;
        if (!menu) {
            return null;
        }
        return Object.assign(Object.assign({}, menu), { getElem: () => menu, focus: focus });
    });
    (0, react_1.useEffect)(() => {
        // Focus menu item immediately, when
        // menu is not nested
        if (open && !nested) {
            focus();
        }
    }, [open, nested, focus]);
    const { themeClassName } = (0, ThemeProvider_1.useNeedleTheme)();
    const classes = (0, defaultImports_1.classNames)('ndl-menu', themeClassName, {
        'ndl-small': size === 'small',
        'ndl-large': size === 'large',
    }, className);
    return ((0, jsx_runtime_1.jsx)(MenuContext.Provider, { value: { onClose, level, size }, children: (0, jsx_runtime_1.jsx)(popover_1.Popover, Object.assign({ tabIndex: -1, captureFocus: false }, rest, { open: open, style: Object.assign({ minWidth }, (rest.style || {})), className: classes, ref: menuRef, onClose: onClose, children: children })) }));
});
MenuComponent.displayName = 'Menu';
const getMenuItem = (menuItems, iterator) => {
    const activeElement = document.activeElement;
    let newEl = iterator(menuItems, activeElement);
    let menuItem = null;
    // Iterate over next element until we find a menu item
    // Iterate a maximum of 10 times looking for an element
    for (let i = 0; i < 10; i++) {
        // Can't find new element, break
        if (!newEl) {
            return null;
        }
        const role = newEl.getAttribute('role');
        if (role === 'menuitem') {
            menuItem = newEl;
            break;
        }
        newEl = iterator(menuItems, newEl);
    }
    return menuItem;
};
// Gets next sibling child of the menu items, looping at the end
const nextElement = (menuItems, currentEl) => {
    if (currentEl === menuItems || !(currentEl === null || currentEl === void 0 ? void 0 : currentEl.nextElementSibling)) {
        return menuItems.firstChild ? menuItems.firstChild : null;
    }
    else if (currentEl === null || currentEl === void 0 ? void 0 : currentEl.nextElementSibling) {
        const nextItem = currentEl.nextElementSibling;
        return currentEl.nextElementSibling.className.includes('ndl-disabled')
            ? nextElement(menuItems, nextItem)
            : nextItem;
    }
    return null;
};
// Gets prev sibling child of the menu items, looping at the top
const prevElement = (menuItems, currentEl) => {
    if (currentEl === menuItems || !(currentEl === null || currentEl === void 0 ? void 0 : currentEl.previousElementSibling)) {
        return menuItems.lastChild ? menuItems.lastChild : null;
    }
    else if (currentEl === null || currentEl === void 0 ? void 0 : currentEl.previousElementSibling) {
        const prevItem = currentEl.previousElementSibling;
        return currentEl.previousElementSibling.className.includes('ndl-disabled')
            ? prevElement(menuItems, prevItem)
            : prevItem;
    }
    return null;
};
/** Get all siblings of an element */
function getAllSiblings(element) {
    var _a;
    const children = [...(((_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.children) || [])];
    return children.filter((child) => child !== element && child.tagName !== 'svg');
}
const MenuItems = react_1.default.forwardRef(function MenuItems(_a, ref) {
    var { as = 'ul', children, className } = _a, rest = __rest(_a, ["as", "children", "className"]);
    const menuItemsRef = (0, react_1.useRef)();
    const { onClose } = useMenuContext();
    const handleKeyDown = (event) => {
        const menuItems = menuItemsRef.current;
        if (!menuItems) {
            return;
        }
        if (event.key == 'ArrowDown') {
            event.preventDefault();
            event.stopPropagation();
            const newFocusedElement = getMenuItem(menuItems, nextElement);
            newFocusedElement === null || newFocusedElement === void 0 ? void 0 : newFocusedElement.focus();
        }
        else if (event.key == 'ArrowUp') {
            event.preventDefault();
            event.stopPropagation();
            const newFocusedElement = getMenuItem(menuItems, prevElement);
            newFocusedElement === null || newFocusedElement === void 0 ? void 0 : newFocusedElement.focus();
        }
        else if (event.key == 'Escape') {
            event.preventDefault();
            event.stopPropagation();
            onClose && onClose(event);
        }
    };
    (0, react_1.useImperativeHandle)(ref, () => menuItemsRef.current);
    const Component = as;
    const classes = (0, defaultImports_1.classNames)('ndl-menu-items', className);
    return ((0, jsx_runtime_1.jsx)(Component, Object.assign({ tabIndex: -1, onKeyDown: handleKeyDown, role: "menu" }, rest, { className: classes, ref: menuItemsRef, children: children })));
});
MenuItems.displayName = 'Menu.Items';
const isNested = (props) => {
    return !!props.children;
};
const MenuItem = react_1.default.forwardRef(function MenuItem(props, ref) {
    if (isNested(props)) {
        return (0, jsx_runtime_1.jsx)(NestedMenuItem, Object.assign({}, props, { ref: ref }));
    }
    return (0, jsx_runtime_1.jsx)(StandardMenuItem, Object.assign({}, props, { ref: ref }));
});
MenuItem.displayName = 'Menu.Item';
const StandardMenuItem = react_1.default.forwardRef(function MenuItem(_a, ref) {
    var { as = 'li', icon, title, description, className, disabled = false, nested = false, onClick, onKeyDown } = _a, rest = __rest(_a, ["as", "icon", "title", "description", "className", "disabled", "nested", "onClick", "onKeyDown"]);
    const Component = as;
    const classes = (0, defaultImports_1.classNames)(`ndl-menu-item n-flex n-flex-col`, className, {
        'ndl-disabled': disabled,
        nested,
    });
    const handleClick = (e) => {
        if (disabled) {
            e.preventDefault();
            return;
        }
        if (onClick)
            onClick(e);
    };
    const handleKeyDown = (e) => {
        if (onKeyDown)
            onKeyDown(e);
        if (e.key === 'Enter') {
            if (disabled) {
                e.preventDefault();
                return;
            }
            if (onClick)
                onClick(e);
        }
    };
    return ((0, jsx_runtime_1.jsx)(Component, Object.assign({ tabIndex: -1, role: "menuitem" }, rest, { className: classes, onClick: handleClick, onKeyDown: handleKeyDown, ref: ref, children: (0, jsx_runtime_1.jsxs)("div", { className: "n-flex n-flex-row n-gap-token-4", children: [icon && (0, jsx_runtime_1.jsx)("div", { className: "ndl-menu-item-icon", children: icon }), (0, jsx_runtime_1.jsxs)("div", { className: "n-flex n-flex-col n-gap-token-2 n-w-full", children: [(0, jsx_runtime_1.jsx)("div", { className: "ndl-menu-item-title", children: title }), description && ((0, jsx_runtime_1.jsx)("div", { className: "ndl-menu-item-description", children: description }))] })] }) })));
});
const MenuHeader = react_1.default.forwardRef(function MenuHeader(_a, ref) {
    var { as = 'div', title, description, className } = _a, rest = __rest(_a, ["as", "title", "description", "className"]);
    const Component = as;
    const { onClose, size } = useMenuContext();
    const handleClose = (e) => onClose && onClose(e);
    const classes = (0, defaultImports_1.classNames)('ndl-menu-header n-flex n-flex-col', className);
    return ((0, jsx_runtime_1.jsxs)(Component, Object.assign({}, rest, { className: classes, ref: ref, children: [(0, jsx_runtime_1.jsxs)("div", { className: "n-flex n-justify-between n-items-center", children: [(0, jsx_runtime_1.jsx)("div", { className: "ndl-menu-header-title", children: title }), (0, jsx_runtime_1.jsx)(button_1.IconButton, { clean: true, tabIndex: 0, onKeyDown: handleClose, onClick: handleClose, size: size, children: (0, jsx_runtime_1.jsx)(icons_1.XMarkIconOutline, {}) })] }), description && ((0, jsx_runtime_1.jsx)("div", { className: "ndl-menu-header-description", children: description }))] })));
});
MenuHeader.displayName = 'Menu.Header';
const MenuDivider = () => (0, jsx_runtime_1.jsx)("div", { className: "ndl-menu-divider" });
MenuDivider.displayName = 'Menu.Divider';
const MenuSubheader = (props) => ((0, jsx_runtime_1.jsx)("div", { className: "ndl-menu-subheader", children: (0, jsx_runtime_1.jsx)("div", { className: "ndl-menu-subheader-title", children: props.title }) }));
MenuSubheader.displayName = 'Menu.Subheader';
const NestedMenuItem = react_1.default.forwardRef(function NestedMenuItem(_a, ref) {
    var { title, className, children, disabled, safeArea = true } = _a, props = __rest(_a, ["title", "className", "children", "disabled", "safeArea"]);
    const [nestedAnchorEl, setNestedAnchorEl] = (0, react_1.useState)(null);
    const nestedMenuRef = (0, react_1.useRef)(null);
    const menuItemRef = (0, react_1.useRef)(null);
    const [safe, setSafe] = (0, react_1.useState)(undefined);
    const svgRef = (0, react_1.useRef)(null);
    const { level } = useMenuContext();
    const levelClass = `nested-level-${level}`;
    (0, react_1.useImperativeHandle)(ref, () => menuItemRef.current);
    const handleNestedOpen = (event) => {
        if (disabled)
            return;
        setNestedAnchorEl(event.currentTarget);
        if (!menuItemRef.current)
            return;
        const siblings = getAllSiblings(menuItemRef.current);
        siblings.forEach((sibling) => {
            if (sibling instanceof HTMLElement)
                sibling.focus();
            if (sibling instanceof HTMLElement)
                sibling.blur();
        });
    };
    const handleNestedClose = (0, react_1.useCallback)(() => {
        var _a;
        if (safe)
            return;
        (_a = menuItemRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }, [safe]);
    const handleNestedFocus = (event) => {
        if (disabled)
            return;
        const el = event.currentTarget;
        setNestedAnchorEl(el);
        el.focus();
    };
    const handleNestedMouseLeave = (0, react_1.useCallback)((event) => {
        var _a;
        // If the event comes from the safe hit area "path"
        // element then ignore it.
        if (event.relatedTarget instanceof SVGPathElement &&
            ((_a = event.relatedTarget.parentElement) === null || _a === void 0 ? void 0 : _a.previousElementSibling) ===
                menuItemRef.current) {
            return;
        }
        const el = event.relatedTarget;
        if (el instanceof Element && el.closest(`.${levelClass}`)) {
            setSafe(undefined);
            return;
        }
        setSafe(undefined);
        setNestedAnchorEl(null);
    }, [levelClass]);
    const handleNestedBlur = (event) => {
        const el = event.relatedTarget;
        if (el === null || el === void 0 ? void 0 : el.closest(`.${levelClass}`)) {
            return;
        }
        setNestedAnchorEl(null);
    };
    const handleMenuItemKeyDown = (event) => {
        var _a, _b;
        if (event.key === 'ArrowRight') {
            event.preventDefault();
            event.stopPropagation();
            (_a = nestedMenuRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        }
        if (event.key === 'Tab') {
            event.preventDefault();
            event.stopPropagation();
            (_b = nestedMenuRef.current) === null || _b === void 0 ? void 0 : _b.focus();
        }
    };
    const handleNestedMenuKeyDown = (event) => {
        if (event.key === 'ArrowLeft' || event.key === 'Escape') {
            event.preventDefault();
            event.stopPropagation();
            nestedAnchorEl === null || nestedAnchorEl === void 0 ? void 0 : nestedAnchorEl.focus();
        }
    };
    const nestedMenuProps = {
        className: `nested-menu ${levelClass}`,
        open: Boolean(nestedAnchorEl),
        anchorEl: nestedAnchorEl,
        onClose: handleNestedClose,
        onMouseLeave: handleNestedClose,
        onKeyDown: handleNestedMenuKeyDown,
        disableBackdrop: true,
        ref: nestedMenuRef,
        nested: true,
        level: level + 1,
    };
    const handleMouseMove = (event) => {
        var _a;
        if (!nestedMenuRef.current)
            return;
        const nested = nestedMenuRef.current.getElem();
        // Update SVG Coordinates
        if (event.nativeEvent instanceof MouseEvent &&
            nestedMenuRef.current &&
            menuItemRef.current) {
            setSafe({
                mouse: {
                    x: event.nativeEvent.clientX,
                    y: event.nativeEvent.clientY,
                },
                nestedRect: nested.getBoundingClientRect(),
                anchorRect: menuItemRef.current.getBoundingClientRect(),
            });
        }
        // We need to continue the focus
        (_a = nestedMenuRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    };
    const deleteSafeArea = (0, react_1.useCallback)((0, debounce_1.debounce)(() => {
        setSafe(undefined);
    }, 200), [setSafe]);
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(StandardMenuItem, Object.assign({}, props, { title: (0, jsx_runtime_1.jsxs)("span", { className: "n-flex n-justify-between n-items-center", children: [(0, jsx_runtime_1.jsx)("span", { children: title }), (0, jsx_runtime_1.jsx)("span", { className: "n-text-palette-neutral-text-weak", children: (0, jsx_runtime_1.jsx)(icons_1.ChevronRightIconOutline, { className: "n-h-4 n-w-4" }) })] }), onMouseOver: handleNestedOpen, onMouseMove: handleMouseMove, onMouseLeave: handleNestedMouseLeave, onFocus: handleNestedFocus, onBlur: handleNestedBlur, onKeyDown: handleMenuItemKeyDown, className: (0, defaultImports_1.classNames)(className, {
                    'ndl-nested-open': !!nestedAnchorEl,
                }), ref: menuItemRef, disabled: disabled })), safeArea && safe && safe.mouse && ((0, jsx_runtime_1.jsx)(SafeArea_1.SafeArea, { onMouseMove: () => {
                    var _a;
                    (_a = nestedMenuRef.current) === null || _a === void 0 ? void 0 : _a.focus();
                    deleteSafeArea();
                }, area: safe, ref: svgRef })), children({ nestedMenuProps })] }));
});
// Issue with TypeScript forwardRef and subcomponents: https://github.com/DefinitelyTyped/DefinitelyTyped/issues/34757#issuecomment-894053907
const Menu = Object.assign(MenuComponent, {
    Divider: MenuDivider,
    Subheader: MenuSubheader,
    Header: MenuHeader,
    Item: MenuItem,
    Items: MenuItems,
});
exports.Menu = Menu;
//# sourceMappingURL=ContextMenu.js.map