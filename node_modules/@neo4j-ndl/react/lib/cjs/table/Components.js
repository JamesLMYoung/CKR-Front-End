"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scrollable = exports.LoadingPlaceholder = exports.NoDataPlaceholder = exports.PaginationNumericButton = exports.PaginationArrowButton = exports.PaginationNumericButtons = exports.Pagination = exports.RowsPerPage = exports.TableResults = exports.Navigation = exports.HeaderCell = exports.BodyRow = exports.BodyCell = exports.Body = exports.Header = exports.ResizingBar = exports.ColumnControls = exports.SortingButton = void 0;
const react_1 = require("react");
const jsx_runtime_1 = require("react/jsx-runtime");
/**
 *
 *  Copyright (c) "Neo4j"
 *  Neo4j Sweden AB [http://neo4j.com]
 *
 *  This file is part of Neo4j.
 *
 *  Neo4j is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
const react_2 = require("react");
const react_table_1 = require("@tanstack/react-table");
const defaultImports_1 = require("../_common/defaultImports");
const icons_1 = require("../icons");
const loading_spinner_1 = require("../loading-spinner");
const helpers_1 = require("./helpers");
const TableContext_1 = require("./TableContext");
/** Table results per page, with the first option being the default */
const TABLE_RESULTS = {
    DEFAULT: 10,
    values: [10, 25, 50, 100],
};
const ResizingBar = ({ header, children, innerProps, }) => {
    const { className = undefined } = innerProps || {};
    return ((0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: children || ((0, jsx_runtime_1.jsx)("button", Object.assign({}, innerProps, { type: "button", className: "ndl-table-resizer-wrapper", onMouseDown: header.getResizeHandler(), onTouchStart: header.getResizeHandler(), "aria-label": "resizing bar", children: (0, jsx_runtime_1.jsx)("div", { className: (0, defaultImports_1.classNames)('ndl-table-resizer', className, {
                    'ndl-table-is-resizing': header.column.getIsResizing(),
                }) }) }))) }));
};
exports.ResizingBar = ResizingBar;
const Scrollable = ({ children, innerProps }) => {
    const { className } = innerProps || {};
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({}, innerProps, { className: (0, defaultImports_1.classNames)('ndl-table-scrollable', className), children: children })));
};
exports.Scrollable = Scrollable;
const Header = ({ children, innerProps }) => {
    const { tableProps, components } = (0, TableContext_1.useTableContext)();
    const { getHeaderGroups, getState } = tableProps;
    const { className = undefined } = innerProps || {};
    const commonStyle = {
        display: 'grid',
        gridTemplateColumns: (0, helpers_1.gridGenerator)(tableProps),
    };
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({}, innerProps, { role: "rowgroup", className: (0, defaultImports_1.classNames)('ndl-table-thead', className, {
            'ndl-table-is-resizing': getState().columnSizingInfo.isResizingColumn,
        }), children: children || ((0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: getHeaderGroups().map((headerGroup) => ((0, jsx_runtime_1.jsx)("div", { className: "ndl-table-tr", style: commonStyle, role: "row", children: headerGroup.headers.map((header) => components.HeaderCell && ((0, jsx_runtime_1.jsx)(components.HeaderCell, { cell: header }, header.id))) }, headerGroup.id))) })) })));
};
exports.Header = Header;
const SortingButton = ({ sortDirection, children, innerProps, }) => {
    let icon;
    const { className, style, onClick } = innerProps || {};
    const commonProps = Object.assign(Object.assign({}, innerProps), { className: (0, defaultImports_1.classNames)('ndl-header-icon', className), style: Object.assign(Object.assign({}, style), (sortDirection && { display: 'inline-block' })), onClick: (e) => onClick && onClick(e), onKeyDown: (e) => {
            if (e.key === ' ' && typeof onClick === 'function')
                onClick(e);
        }, tabIndex: 0 });
    switch (sortDirection) {
        case 'desc':
            icon = (0, jsx_runtime_1.jsx)(icons_1.BarsArrowDownIconOutline, Object.assign({}, commonProps));
            break;
        case 'asc':
            icon = (0, jsx_runtime_1.jsx)(icons_1.BarsArrowUpIconOutline, Object.assign({}, commonProps));
            break;
        default:
            icon = (0, jsx_runtime_1.jsx)(icons_1.Bars3CenterLeftIconOutline, Object.assign({}, commonProps));
    }
    return (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: children || icon });
};
exports.SortingButton = SortingButton;
const ColumnControls = ({ cell, controls, children, innerProps, }) => {
    const { className } = innerProps || {};
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({}, innerProps, { className: (0, defaultImports_1.classNames)('ndl-header-action-group', className), children: children || (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: controls === null || controls === void 0 ? void 0 : controls.map((control) => control) }) })));
};
exports.ColumnControls = ColumnControls;
const HeaderCell = ({ cell, children, innerProps, }) => {
    const { components, resizable } = (0, TableContext_1.useTableContext)();
    const { className } = innerProps || {};
    const sort = cell.column.getIsSorted();
    const canSort = cell.column.getCanSort();
    const ariaSortRole = (0, react_2.useMemo)(() => {
        switch (sort) {
            case 'asc':
                return 'ascending';
            case 'desc':
                return 'descending';
            default:
                return 'none';
        }
    }, [sort]);
    const sortingControl = (0, react_2.useMemo)(() => {
        if (canSort) {
            return ((0, jsx_runtime_1.jsx)(exports.SortingButton, { sortDirection: sort, innerProps: {
                    onClick: () => cell.column.toggleSorting(),
                } }, cell.id));
        }
        else if (!canSort && sort !== false) {
            return ((0, jsx_runtime_1.jsx)(exports.SortingButton, { sortDirection: sort, innerProps: {
                    tabIndex: -1,
                    style: {
                        cursor: 'not-allowed',
                    },
                } }, cell.id));
        }
    }, [sort, cell, canSort]);
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({ tabIndex: -1, role: "columnheader" }, innerProps, { className: (0, defaultImports_1.classNames)('ndl-table-th ndl-focusable-cell', className), "aria-sort": ariaSortRole, children: children || ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsxs)("div", { className: "ndl-header-group", children: [(0, jsx_runtime_1.jsx)("div", { className: "ndl-header-cell", children: cell.isPlaceholder
                                ? null
                                : (0, react_table_1.flexRender)(cell.column.columnDef.header, cell.getContext()) }), components.ColumnControls && ((0, jsx_runtime_1.jsx)(components.ColumnControls, { cell: cell, controls: sortingControl ? [sortingControl] : [], innerProps: {
                                tabIndex: canSort ? 0 : -1,
                            } }))] }), resizable &&
                    cell.headerGroup.headers.length - 1 !== cell.index &&
                    cell.column.getCanResize() &&
                    components.ResizingBar && (0, jsx_runtime_1.jsx)(components.ResizingBar, { header: cell })] })) }), cell.id));
};
exports.HeaderCell = HeaderCell;
const Body = ({ children, innerProps }) => {
    const { tableProps, components, loading } = (0, TableContext_1.useTableContext)();
    const { getRowModel } = tableProps;
    const { className } = innerProps || {};
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({}, innerProps, { className: (0, defaultImports_1.classNames)('ndl-table-tbody', className), role: "rowgroup", "aria-busy": loading ? 'true' : 'false', children: children || ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [loading && components.LoadingPlaceholder && ((0, jsx_runtime_1.jsx)(components.LoadingPlaceholder, {})), !loading &&
                    getRowModel().rows.length === 0 &&
                    components.NoDataPlaceholder && (0, jsx_runtime_1.jsx)(components.NoDataPlaceholder, {}), !loading &&
                    getRowModel().rows.map((row, idx) => components.BodyRow && ((0, jsx_runtime_1.jsx)(components.BodyRow, { row: row }, `table-row-${idx}`)))] })) })));
};
exports.Body = Body;
const BodyCell = ({ cell, children, innerProps, }) => {
    const isResizing = cell.column.getIsResizing();
    const { className } = innerProps || {};
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({}, innerProps, { className: (0, defaultImports_1.classNames)('ndl-table-td ndl-focusable-cell', className, {
            'ndl-table-is-resizing': isResizing,
        }), role: "cell", tabIndex: 0, children: children || (0, react_table_1.flexRender)(cell.column.columnDef.cell, cell.getContext()) }), cell.id));
};
exports.BodyCell = BodyCell;
const BodyRow = ({ row, children, innerProps, }) => {
    const { components, tableProps } = (0, TableContext_1.useTableContext)();
    const { className } = innerProps || {};
    const commonStyle = {
        display: 'grid',
        gridTemplateColumns: (0, helpers_1.gridGenerator)(tableProps),
    };
    return ((0, react_1.createElement)("div", Object.assign({}, innerProps, { key: row.id, className: (0, defaultImports_1.classNames)('ndl-table-tr', className), style: commonStyle, role: "row" }), children || ((0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: row
            .getVisibleCells()
            .map((cell) => components.BodyCell && ((0, jsx_runtime_1.jsx)(components.BodyCell, { cell: cell }, cell.id))) }))));
};
exports.BodyRow = BodyRow;
const TableResults = ({ children, innerProps, manualPagination, }) => {
    const { tableProps } = (0, TableContext_1.useTableContext)();
    const { getState, getRowModel, getCoreRowModel } = tableProps;
    const { pagination: { pageSize, pageIndex }, } = getState();
    const { rows } = getRowModel();
    const { from, to, totalRows } = (0, react_2.useMemo)(() => manualPagination || {
        from: 1 + pageIndex * pageSize,
        to: rows.length + pageIndex * pageSize,
        totalRows: getCoreRowModel().rows.length,
    }, [pageIndex, pageSize, manualPagination, rows, getCoreRowModel]);
    const { className } = innerProps || {};
    return ((0, jsx_runtime_1.jsx)("span", Object.assign({}, innerProps, { className: (0, defaultImports_1.classNames)('ndl-table-results', className), children: children || ((0, jsx_runtime_1.jsxs)("span", { children: ["Showing", ' ', (0, jsx_runtime_1.jsx)("b", { children: totalRows ? `${from}${to !== from ? `-${to}` : ''}` : 0 }), " of", ' ', (0, jsx_runtime_1.jsx)("b", { children: totalRows }), " results"] })) })));
};
exports.TableResults = TableResults;
const RowsPerPage = ({ children, innerProps, }) => {
    const { tableProps } = (0, TableContext_1.useTableContext)();
    const { setPageSize, getState } = tableProps;
    const { className } = innerProps || {};
    const { pagination: { pageSize }, } = getState();
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({}, innerProps, { className: (0, defaultImports_1.classNames)('ndl-table-rows-per-page', className), children: children || ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: ["Show", (0, jsx_runtime_1.jsx)("select", { onChange: (e) => setPageSize(parseInt(e.target.value, 10)), className: "ndl-table-select", value: pageSize, "aria-label": "Select page size", children: [...new Set([...TABLE_RESULTS.values, pageSize])]
                        .sort((a, b) => a - b)
                        .map((option) => ((0, jsx_runtime_1.jsx)("option", { value: `${option}`, children: option }, `${option}`))) })] })) })));
};
exports.RowsPerPage = RowsPerPage;
const PaginationArrowButton = ({ action, children, innerProps, }) => {
    const { className } = innerProps || {};
    return ((0, jsx_runtime_1.jsx)("button", Object.assign({}, innerProps, { type: "button", className: (0, defaultImports_1.classNames)('ndl-table-pagination-icon-button', className), children: children || ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [action === 'previous' && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)("span", { className: "n-sr-only", children: "Previous table page" }), (0, jsx_runtime_1.jsx)(icons_1.ChevronLeftIconOutline, { className: "ndl-table-pagination-icon" })] })), action === 'next' && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)("span", { className: "n-sr-only", children: "Next table page" }), (0, jsx_runtime_1.jsx)(icons_1.ChevronRightIconOutline, { className: "ndl-table-pagination-icon" })] }))] })) })));
};
exports.PaginationArrowButton = PaginationArrowButton;
const PaginationNumericButton = ({ currentIndex, isSelected, children, innerProps, }) => {
    const { className, onClick } = innerProps || {};
    return ((0, jsx_runtime_1.jsx)("button", Object.assign({}, innerProps, { type: "button", "data-testid": `ndl-table-${currentIndex}`, className: (0, defaultImports_1.classNames)('ndl-table-pagination-numeric-button', className, {
            'ndl-not-selected-numeric': typeof currentIndex === 'number' && !isSelected,
            'ndl-is-selected': isSelected,
            'ndl-not-selected': !isSelected,
        }), onClick: (e) => typeof currentIndex === 'number' && onClick && onClick(e), tabIndex: typeof currentIndex === 'number' ? 0 : -1, children: children || currentIndex })));
};
exports.PaginationNumericButton = PaginationNumericButton;
const PaginationNumericButtons = () => {
    const { tableProps, components } = (0, TableContext_1.useTableContext)();
    const { getState, setPageIndex, getPageCount } = tableProps;
    const { pagination: { pageIndex }, } = getState();
    return ((0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: (0, helpers_1.userFriendlyPagination)(pageIndex + 1, getPageCount()).map((option, idx) => components.PaginationNumericButton && ((0, jsx_runtime_1.jsx)(components.PaginationNumericButton
        /** Use index to avoid situations where two "..." values will appear, causing a key conflict */
        , { innerProps: {
                onClick: () => typeof option === 'number' && setPageIndex(option - 1),
            }, currentIndex: option, isSelected: option === pageIndex + 1 }, `${option}-${idx}`))) }));
};
exports.PaginationNumericButtons = PaginationNumericButtons;
const Pagination = ({ children, innerProps, }) => {
    const { tableProps, components } = (0, TableContext_1.useTableContext)();
    const { getCanPreviousPage, getCanNextPage, previousPage, nextPage } = tableProps;
    const { className } = innerProps || {};
    return ((0, jsx_runtime_1.jsx)("nav", Object.assign({}, innerProps, { className: (0, defaultImports_1.classNames)('ndl-table-nav', className), "aria-label": "Pagination", children: children || ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [getCanPreviousPage()
                    ? components.PaginationArrowButton && ((0, jsx_runtime_1.jsx)(components.PaginationArrowButton, { action: "previous", innerProps: {
                            onClick: previousPage,
                        } }))
                    : null, components.PaginationNumericButtons && ((0, jsx_runtime_1.jsx)(components.PaginationNumericButtons, {})), getCanNextPage()
                    ? components.PaginationArrowButton && ((0, jsx_runtime_1.jsx)(components.PaginationArrowButton, { action: "next", innerProps: {
                            onClick: nextPage,
                        } }))
                    : null] })) })));
};
exports.Pagination = Pagination;
const Navigation = ({ children, innerProps, }) => {
    const { tableProps, components } = (0, TableContext_1.useTableContext)();
    const { getPageCount } = tableProps;
    const { className } = innerProps || {};
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({}, innerProps, { className: (0, defaultImports_1.classNames)('ndl-table-navigation', className), children: (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: children || ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [components.TableResults && (0, jsx_runtime_1.jsx)(components.TableResults, {}), (0, jsx_runtime_1.jsxs)("div", { className: "ndl-table-navigation-right-items", children: [getPageCount() > 1 && components.Pagination && ((0, jsx_runtime_1.jsx)(components.Pagination, {})), components.RowsPerPage && (0, jsx_runtime_1.jsx)(components.RowsPerPage, {})] })] })) }) })));
};
exports.Navigation = Navigation;
const LoadingPlaceholder = ({ children, innerProps, }) => {
    const { className } = innerProps || {};
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({}, innerProps, { className: (0, defaultImports_1.classNames)('nld-table-placeholder-wrapper', className), role: "row", children: children || ((0, jsx_runtime_1.jsx)("div", { role: "cell", className: "ndl-table-placeholder", children: (0, jsx_runtime_1.jsxs)("div", { className: "ndl-table-loading-placeholder", children: [(0, jsx_runtime_1.jsx)(loading_spinner_1.LoadingSpinner, {}), (0, jsx_runtime_1.jsx)("h6", { children: "Loading data" })] }) })) })));
};
exports.LoadingPlaceholder = LoadingPlaceholder;
const NoDataPlaceholder = ({ children, innerProps, }) => {
    const { className } = innerProps || {};
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({}, innerProps, { className: (0, defaultImports_1.classNames)('nld-table-placeholder-wrapper', className), role: "row", children: children || ((0, jsx_runtime_1.jsx)("div", { role: "cell", className: "ndl-table-placeholder", children: (0, jsx_runtime_1.jsx)("h6", { children: "No data present" }) })) })));
};
exports.NoDataPlaceholder = NoDataPlaceholder;
//# sourceMappingURL=Components.js.map