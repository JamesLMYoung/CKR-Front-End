"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scrollable = exports.LoadingPlaceholder = exports.NoDataPlaceholder = exports.PaginationNumericButton = exports.PaginationArrowButton = exports.PaginationNumericButtons = exports.Pagination = exports.RowsPerPage = exports.TableResults = exports.Navigation = exports.HeaderCell = exports.BodyRow = exports.BodyCell = exports.Body = exports.Header = exports.ResizingBar = exports.ColumnControls = exports.RowActionCell = exports.ActionButton = exports.DEFAULT_SORT_ACTIONS = void 0;
const react_1 = require("react");
const jsx_runtime_1 = require("react/jsx-runtime");
/**
 *
 *  Copyright (c) "Neo4j"
 *  Neo4j Sweden AB [http://neo4j.com]
 *
 *  This file is part of Neo4j.
 *
 *  Neo4j is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
const react_table_1 = require("@tanstack/react-table");
const defaultImports_1 = require("../_common/defaultImports");
const react_2 = require("react");
const icons_1 = require("../icons");
const loading_spinner_1 = require("../loading-spinner");
const helpers_1 = require("./helpers");
const DataGridContext_1 = require("./DataGridContext");
const button_1 = require("../button");
const context_menu_1 = require("../context-menu");
/** Table results per page, with the first option being the default */
const TABLE_RESULTS = {
    DEFAULT: 10,
    values: [10, 25, 50, 100],
};
const DEFAULT_SORT_ACTIONS = (cell) => ({
    asc: {
        title: 'Sort ascending',
        icon: (0, jsx_runtime_1.jsx)(icons_1.BarsArrowUpIconOutline, {}),
        onClick: () => cell.column.toggleSorting(false),
    },
    desc: {
        title: 'Sort descending',
        icon: (0, jsx_runtime_1.jsx)(icons_1.BarsArrowDownIconOutline, {}),
        onClick: () => cell.column.toggleSorting(true),
    },
    default: {
        title: 'Default sort',
        icon: (0, jsx_runtime_1.jsx)(icons_1.Bars3CenterLeftIconOutline, {}),
        onClick: () => cell.column.clearSorting(),
    },
});
exports.DEFAULT_SORT_ACTIONS = DEFAULT_SORT_ACTIONS;
const ResizingBar = ({ header, children, innerProps, }) => {
    const { className = undefined } = innerProps || {};
    return ((0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: children || ((0, jsx_runtime_1.jsx)("button", Object.assign({}, innerProps, { type: "button", className: "ndl-data-grid-resizer-wrapper", onMouseDown: header.getResizeHandler(), onTouchStart: header.getResizeHandler(), "aria-label": "resizing bar", children: (0, jsx_runtime_1.jsx)("div", { className: (0, defaultImports_1.classNames)('ndl-data-grid-resizer', className, {
                    'ndl-data-grid-is-resizing': header.column.getIsResizing(),
                }) }) }))) }));
};
exports.ResizingBar = ResizingBar;
const Scrollable = ({ children, innerProps }) => {
    const { className } = innerProps || {};
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({}, innerProps, { className: (0, defaultImports_1.classNames)('ndl-data-grid-scrollable', className), children: children })));
};
exports.Scrollable = Scrollable;
const Header = ({ children, innerProps }) => {
    const { tableProps, components } = (0, DataGridContext_1.useDataGridContext)();
    const { getHeaderGroups, getState } = tableProps;
    const { className = undefined } = innerProps || {};
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({}, innerProps, { role: "rowgroup", className: (0, defaultImports_1.classNames)('ndl-data-grid-thead', className, {
            'ndl-data-grid-is-resizing': getState().columnSizingInfo.isResizingColumn,
        }), children: children || ((0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: getHeaderGroups().map((headerGroup) => ((0, jsx_runtime_1.jsx)("div", { className: "ndl-data-grid-tr", role: "row", children: headerGroup.headers.map((header) => components.HeaderCell && ((0, jsx_runtime_1.jsx)(components.HeaderCell, { cell: header }, header.id))) }, headerGroup.id))) })) })));
};
exports.Header = Header;
const ActionButton = ({ action, children, onClose, innerProps, }) => {
    const { className } = innerProps || {};
    const { onClick } = action;
    const interceptedOnClick = (0, react_2.useCallback)((e) => {
        const providedOnClick = onClick || (innerProps === null || innerProps === void 0 ? void 0 : innerProps.onClick);
        if (typeof providedOnClick === 'function') {
            providedOnClick(e);
        }
        onClose();
    }, [innerProps === null || innerProps === void 0 ? void 0 : innerProps.onClick, onClick, onClose]);
    // const commonProps: MenuItemProps = {
    const commonProps = Object.assign(Object.assign(Object.assign({}, innerProps), action), { className: (0, defaultImports_1.classNames)('ndl-data-grid-column-action', className), onClick: interceptedOnClick });
    return (0, jsx_runtime_1.jsx)(react_2.Fragment, { children: children || (0, jsx_runtime_1.jsx)(context_menu_1.Menu.Item, Object.assign({}, commonProps)) });
};
exports.ActionButton = ActionButton;
const RowActionCell = ({ cell, innerProps, }) => {
    var _a, _b;
    const { components } = (0, DataGridContext_1.useDataGridContext)();
    const actionsButtonRef = (0, react_2.useRef)(null);
    const [actionsOpen, setActionsOpen] = (0, react_2.useState)(false);
    if (!cell ||
        !cell.column.columnDef.meta ||
        typeof ((_b = (_a = cell.column.columnDef) === null || _a === void 0 ? void 0 : _a.meta) === null || _b === void 0 ? void 0 : _b.isActionCell) !== 'object')
        return null;
    const { actions, onOpenChange } = cell.column.columnDef.meta.isActionCell;
    return ((0, jsx_runtime_1.jsxs)(react_2.Fragment, { children: [(0, jsx_runtime_1.jsx)(button_1.IconButton, Object.assign({ clean: true, size: "medium", "aria-label": `Row actions for row id: ${cell.row.id}`, ref: actionsButtonRef, active: actionsOpen, onClick: () => {
                    onOpenChange && onOpenChange(!actionsOpen);
                    setActionsOpen(!actionsOpen);
                } }, innerProps, { children: (0, jsx_runtime_1.jsx)(icons_1.ChevronDownIconSolid, {}) })), (0, jsx_runtime_1.jsx)(context_menu_1.Menu, { open: actionsOpen, anchorEl: actionsButtonRef.current, onClose: () => {
                    onOpenChange && onOpenChange(false);
                    setActionsOpen(false);
                }, anchorOrigin: {
                    vertical: 'bottom',
                    horizontal: 'left',
                }, transformOrigin: {
                    horizontal: 'right',
                    vertical: 'top',
                }, children: actions.map((action, i) => components.ActionButton && ((0, jsx_runtime_1.jsx)(components.ActionButton, { action: action, onClose: () => setActionsOpen(false) }, `${cell.column.id}-action-${i}`))) })] }));
};
exports.RowActionCell = RowActionCell;
const ColumnControls = ({ cell, children, innerProps, }) => {
    var _a;
    const { className } = innerProps || {};
    const { components } = (0, DataGridContext_1.useDataGridContext)();
    const sort = cell.column.getIsSorted();
    const canSort = cell.column.getCanSort();
    const { defaultSortingActions = true, actions } = ((_a = cell.column.columnDef.meta) === null || _a === void 0 ? void 0 : _a.columnActions) || {};
    const sortingActions = (0, react_2.useMemo)(() => {
        if (canSort) {
            if (sort !== 'asc' && sort !== 'desc') {
                return [
                    (0, exports.DEFAULT_SORT_ACTIONS)(cell).asc,
                    (0, exports.DEFAULT_SORT_ACTIONS)(cell).desc,
                ];
            }
            if (sort === 'asc') {
                return [
                    (0, exports.DEFAULT_SORT_ACTIONS)(cell).default,
                    (0, exports.DEFAULT_SORT_ACTIONS)(cell).desc,
                ];
            }
            if (sort === 'desc') {
                return [
                    (0, exports.DEFAULT_SORT_ACTIONS)(cell).default,
                    (0, exports.DEFAULT_SORT_ACTIONS)(cell).asc,
                ];
            }
        }
        // Default case
        return [];
    }, [sort, cell, canSort]);
    const newActions = [
        ...(defaultSortingActions ? sortingActions : []),
        ...(actions !== null && actions !== void 0 ? actions : []),
    ];
    const actionsButtonRef = (0, react_2.useRef)(null);
    const [actionsOpen, setActionsOpen] = (0, react_2.useState)(false);
    if (!actions || actions.length === 0)
        return null;
    return newActions.length > 0 ? ((0, jsx_runtime_1.jsx)("div", Object.assign({}, innerProps, { className: (0, defaultImports_1.classNames)('ndl-header-action-group', className), style: {
            zIndex: 100000,
            position: 'relative',
            right: '12px',
        }, children: children || ((0, jsx_runtime_1.jsxs)(react_2.Fragment, { children: [(0, jsx_runtime_1.jsx)(button_1.IconButton, { clean: true, size: "medium", "arial-label": `Column actions for ${cell.column.id} column`, ref: actionsButtonRef, active: actionsOpen, onClick: () => {
                        setActionsOpen(!actionsOpen);
                    }, children: (0, jsx_runtime_1.jsx)(icons_1.ChevronDownIconSolid, {}) }), (0, jsx_runtime_1.jsx)(context_menu_1.Menu, { open: actionsOpen, anchorEl: actionsButtonRef.current, onClose: () => setActionsOpen(false), anchorOrigin: {
                        vertical: 'bottom',
                        horizontal: 'center',
                    }, transformOrigin: {
                        horizontal: 'center',
                        vertical: 'top',
                    }, children: newActions.map((action, i) => components.ActionButton && ((0, jsx_runtime_1.jsx)(components.ActionButton, { action: action, onClose: () => setActionsOpen(false) }, `${cell.column.id}-action-${i}`))) })] })) }))) : null;
};
exports.ColumnControls = ColumnControls;
const HeaderCell = ({ cell, children, innerProps, }) => {
    var _a;
    const { components, resizable, tableProps, resizeColumns } = (0, DataGridContext_1.useDataGridContext)();
    const { className } = innerProps || {};
    const sort = cell.column.getIsSorted();
    const canSort = cell.column.getCanSort();
    const ariaSortRole = (0, react_2.useMemo)(() => {
        switch (sort) {
            case 'asc':
                return 'ascending';
            case 'desc':
                return 'descending';
            default:
                return 'none';
        }
    }, [sort]);
    const Icon = (0, react_2.useMemo)(() => {
        switch (sort) {
            case 'asc':
                return (0, jsx_runtime_1.jsx)(icons_1.BarsArrowUpIconOutline, { className: "ndl-header-icon" });
            case 'desc':
                return (0, jsx_runtime_1.jsx)(icons_1.BarsArrowDownIconOutline, { className: "ndl-header-icon" });
            default:
                return ((0, jsx_runtime_1.jsx)(icons_1.Bars3CenterLeftIconSolid, { className: "ndl-hoverable-indicator ndl-header-icon" }));
        }
    }, [sort]);
    const ariaDescription = canSort
        ? `Press ENTER or SPACE to sort column ${cell.column.id}`
        : `Column id: ${cell.column.id}`;
    const constrained = (0, helpers_1.isSizeConstrained)(cell.column.columnDef);
    const ref = (0, react_2.useRef)(null);
    const [grow, setGrow] = (0, react_2.useState)(resizeColumns);
    /**
     * This part enables the auto sizing of the columns.
     *
     * On initial render we need to wait for the width to be
     * calculated by the browser with `flex-grow: 1`, if the size is not
     * constrained by the user.
     * Then we update the table state with the new width to aligned
     * with the one calculated by browser, for optimal user experience.
     */
    (0, react_2.useEffect)(() => {
        var _a;
        if (resizeColumns) {
            // The `flex-grow` property is modifying the
            // width of the column, update this also in the table state
            const { width } = ((_a = ref.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) || {};
            if (width) {
                // Update column sizing in table's state
                tableProps.setState((prev) => (Object.assign(Object.assign({}, prev), { columnSizing: Object.assign(Object.assign({}, prev.columnSizing), { [cell.column.id]: width }) })));
                // Disable flex grow, to avoid weird resizing behaviour
                setGrow(false);
            }
        }
    }, [tableProps, cell.column.id]);
    const isActionColumn = typeof ((_a = cell.column.columnDef.meta) === null || _a === void 0 ? void 0 : _a.isActionCell) === 'object';
    const Tag = canSort ? 'button' : 'div';
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({ tabIndex: -1, role: "columnheader" }, innerProps, { className: (0, defaultImports_1.classNames)('ndl-data-grid-th ndl-focusable-cell', className, {
            'ndl-data-grid-row-action': isActionColumn,
        }), "aria-sort": ariaSortRole, style: {
            width: isActionColumn ? 40 : cell.getSize(),
            maxWidth: cell.column.columnDef.maxSize
                ? `${cell.column.columnDef.maxSize}px`
                : 'none',
            flexGrow: !isActionColumn && !constrained && grow ? 1 : 0,
        }, ref: ref, children: children || ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Tag, { className: "ndl-header-group", style: {
                        cursor: canSort ? 'pointer' : 'default',
                    }, tabIndex: canSort ? -1 : undefined, "aria-describedby": ariaDescription, onClick: () => canSort && cell.column.toggleSorting(), children: (0, jsx_runtime_1.jsxs)("div", { className: "ndl-header-cell", children: [cell.isPlaceholder
                                ? null
                                : (0, react_table_1.flexRender)(cell.column.columnDef.header, cell.getContext()), canSort && Icon] }) }), components.ColumnControls && ((0, jsx_runtime_1.jsx)(components.ColumnControls, { cell: cell })), resizable &&
                    cell.headerGroup.headers.length - 1 !== cell.index &&
                    cell.column.getCanResize() &&
                    components.ResizingBar && (0, jsx_runtime_1.jsx)(components.ResizingBar, { header: cell })] })) }), cell.id));
};
exports.HeaderCell = HeaderCell;
const Body = ({ children, innerProps }) => {
    const { tableProps, components, loading } = (0, DataGridContext_1.useDataGridContext)();
    const { getRowModel } = tableProps;
    const { className } = innerProps || {};
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({}, innerProps, { className: (0, defaultImports_1.classNames)('ndl-data-grid-tbody', className), role: "rowgroup", "aria-busy": loading ? 'true' : 'false', children: children || ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [loading && components.LoadingPlaceholder && ((0, jsx_runtime_1.jsx)(components.LoadingPlaceholder, {})), !loading &&
                    getRowModel().rows.length === 0 &&
                    components.NoDataPlaceholder && (0, jsx_runtime_1.jsx)(components.NoDataPlaceholder, {}), !loading &&
                    getRowModel().rows.map((row, idx) => components.BodyRow && ((0, jsx_runtime_1.jsx)(components.BodyRow, { row: row }, `table-row-${idx}`)))] })) })));
};
exports.Body = Body;
const BodyCell = ({ cell, children, innerProps, }) => {
    var _a;
    const isResizing = cell.column.getIsResizing();
    const { className } = innerProps || {};
    const isActionColumn = typeof ((_a = cell.column.columnDef.meta) === null || _a === void 0 ? void 0 : _a.isActionCell) === 'object';
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({}, innerProps, { className: (0, defaultImports_1.classNames)('ndl-data-grid-td ndl-focusable-cell', className, {
            'ndl-data-grid-is-resizing': isResizing,
            'ndl-data-grid-row-action': isActionColumn,
        }), role: "cell", tabIndex: 0, style: {
            width: isActionColumn ? 40 : cell.column.getSize(),
        }, children: children || (0, react_table_1.flexRender)(cell.column.columnDef.cell, cell.getContext()) }), cell.id));
};
exports.BodyCell = BodyCell;
const BodyRow = ({ row, children, innerProps, }) => {
    const { components } = (0, DataGridContext_1.useDataGridContext)();
    const { className, style = {} } = innerProps || {};
    return ((0, react_1.createElement)("div", Object.assign({}, innerProps, { key: row.id, className: (0, defaultImports_1.classNames)('ndl-data-grid-tr', className), role: "row", style: Object.assign({ display: 'flex', flexDirection: 'row' }, style) }), children || ((0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: row
            .getVisibleCells()
            .map((cell) => components.BodyCell && ((0, jsx_runtime_1.jsx)(components.BodyCell, { cell: cell }, cell.id))) }))));
};
exports.BodyRow = BodyRow;
const TableResults = ({ children, innerProps, manualPagination, }) => {
    const { tableProps } = (0, DataGridContext_1.useDataGridContext)();
    const { getState, getRowModel, getCoreRowModel } = tableProps;
    const { pagination: { pageSize, pageIndex }, } = getState();
    const { rows } = getRowModel();
    const { from, to, totalRows } = (0, react_2.useMemo)(() => manualPagination || {
        from: 1 + pageIndex * pageSize,
        to: rows.length + pageIndex * pageSize,
        totalRows: getCoreRowModel().rows.length,
    }, [pageIndex, pageSize, manualPagination, rows, getCoreRowModel]);
    const { className } = innerProps || {};
    return ((0, jsx_runtime_1.jsx)("span", Object.assign({}, innerProps, { className: (0, defaultImports_1.classNames)('ndl-data-grid-results', className), children: children || ((0, jsx_runtime_1.jsxs)("span", { children: ["Showing", ' ', (0, jsx_runtime_1.jsx)("b", { children: totalRows ? `${from}${to !== from ? `-${to}` : ''}` : 0 }), " of", ' ', (0, jsx_runtime_1.jsx)("b", { children: totalRows }), " results"] })) })));
};
exports.TableResults = TableResults;
const RowsPerPage = ({ children, innerProps, }) => {
    const { tableProps } = (0, DataGridContext_1.useDataGridContext)();
    const { setPageSize, getState } = tableProps;
    const { className } = innerProps || {};
    const { pagination: { pageSize }, } = getState();
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({}, innerProps, { className: (0, defaultImports_1.classNames)('ndl-data-grid-rows-per-page', className), children: children || ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: ["Show", (0, jsx_runtime_1.jsx)("select", { onChange: (e) => setPageSize(parseInt(e.target.value, 10)), className: "ndl-data-grid-select", value: pageSize, "aria-label": "Select page size", children: [...new Set([...TABLE_RESULTS.values, pageSize])]
                        .sort((a, b) => a - b)
                        .map((option) => ((0, jsx_runtime_1.jsx)("option", { value: `${option}`, children: option }, `${option}`))) })] })) })));
};
exports.RowsPerPage = RowsPerPage;
const PaginationArrowButton = ({ action, children, innerProps, }) => {
    const { className } = innerProps || {};
    return ((0, jsx_runtime_1.jsx)("button", Object.assign({}, innerProps, { type: "button", className: (0, defaultImports_1.classNames)('ndl-data-grid-pagination-icon-button', className), children: children || ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [action === 'previous' && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)("span", { className: "n-sr-only", children: "Previous table page" }), (0, jsx_runtime_1.jsx)(icons_1.ChevronLeftIconOutline, { className: "ndl-data-grid-pagination-icon" })] })), action === 'next' && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)("span", { className: "n-sr-only", children: "Next table page" }), (0, jsx_runtime_1.jsx)(icons_1.ChevronRightIconOutline, { className: "ndl-data-grid-pagination-icon" })] }))] })) })));
};
exports.PaginationArrowButton = PaginationArrowButton;
const PaginationNumericButton = ({ currentIndex, isSelected, children, innerProps, }) => {
    const { className, onClick } = innerProps || {};
    return ((0, jsx_runtime_1.jsx)("button", Object.assign({}, innerProps, { type: "button", "data-testid": `ndl-table-${currentIndex}`, className: (0, defaultImports_1.classNames)('ndl-data-grid-pagination-numeric-button', className, {
            'ndl-not-selected-numeric': typeof currentIndex === 'number' && !isSelected,
            'ndl-is-selected': isSelected,
            'ndl-not-selected': !isSelected,
        }), onClick: (e) => typeof currentIndex === 'number' && onClick && onClick(e), tabIndex: typeof currentIndex === 'number' ? 0 : -1, children: children || currentIndex })));
};
exports.PaginationNumericButton = PaginationNumericButton;
const PaginationNumericButtons = () => {
    const { tableProps, components } = (0, DataGridContext_1.useDataGridContext)();
    const { getState, setPageIndex, getPageCount } = tableProps;
    const { pagination: { pageIndex }, } = getState();
    return ((0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: (0, helpers_1.userFriendlyPagination)(pageIndex + 1, getPageCount()).map((option, idx) => components.PaginationNumericButton && ((0, jsx_runtime_1.jsx)(components.PaginationNumericButton
        /** Use index to avoid situations where two "..." values will appear, causing a key conflict */
        , { innerProps: {
                onClick: () => typeof option === 'number' && setPageIndex(option - 1),
            }, currentIndex: option, isSelected: option === pageIndex + 1 }, `${option}-${idx}`))) }));
};
exports.PaginationNumericButtons = PaginationNumericButtons;
const Pagination = ({ children, innerProps, }) => {
    const { tableProps, components } = (0, DataGridContext_1.useDataGridContext)();
    const { getCanPreviousPage, getCanNextPage, previousPage, nextPage } = tableProps;
    const { className } = innerProps || {};
    return ((0, jsx_runtime_1.jsx)("nav", Object.assign({}, innerProps, { className: (0, defaultImports_1.classNames)('ndl-data-grid-nav', className), "aria-label": "Pagination", children: children || ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [getCanPreviousPage()
                    ? components.PaginationArrowButton && ((0, jsx_runtime_1.jsx)(components.PaginationArrowButton, { action: "previous", innerProps: {
                            onClick: previousPage,
                        } }))
                    : null, components.PaginationNumericButtons && ((0, jsx_runtime_1.jsx)(components.PaginationNumericButtons, {})), getCanNextPage()
                    ? components.PaginationArrowButton && ((0, jsx_runtime_1.jsx)(components.PaginationArrowButton, { action: "next", innerProps: {
                            onClick: nextPage,
                        } }))
                    : null] })) })));
};
exports.Pagination = Pagination;
const Navigation = ({ children, innerProps, }) => {
    const { tableProps, components } = (0, DataGridContext_1.useDataGridContext)();
    const { getPageCount } = tableProps;
    const { className } = innerProps || {};
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({}, innerProps, { className: (0, defaultImports_1.classNames)('ndl-data-grid-navigation', className), children: (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: children || ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [components.TableResults && (0, jsx_runtime_1.jsx)(components.TableResults, {}), (0, jsx_runtime_1.jsxs)("div", { className: "ndl-data-grid-navigation-right-items", children: [getPageCount() > 1 && components.Pagination && ((0, jsx_runtime_1.jsx)(components.Pagination, {})), components.RowsPerPage && (0, jsx_runtime_1.jsx)(components.RowsPerPage, {})] })] })) }) })));
};
exports.Navigation = Navigation;
const LoadingPlaceholder = ({ children, innerProps, }) => {
    const { className } = innerProps || {};
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({}, innerProps, { className: (0, defaultImports_1.classNames)('nld-table-placeholder-wrapper', className), role: "row", children: children || ((0, jsx_runtime_1.jsx)("div", { role: "cell", className: "ndl-data-grid-placeholder", children: (0, jsx_runtime_1.jsxs)("div", { className: "ndl-data-grid-loading-placeholder", children: [(0, jsx_runtime_1.jsx)(loading_spinner_1.LoadingSpinner, {}), (0, jsx_runtime_1.jsx)("h6", { children: "Loading data" })] }) })) })));
};
exports.LoadingPlaceholder = LoadingPlaceholder;
const NoDataPlaceholder = ({ children, innerProps, }) => {
    const { className } = innerProps || {};
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({}, innerProps, { className: (0, defaultImports_1.classNames)('nld-table-placeholder-wrapper', className), role: "row", children: children || ((0, jsx_runtime_1.jsx)("div", { role: "cell", className: "ndl-data-grid-placeholder", children: (0, jsx_runtime_1.jsx)("h6", { children: "No data present" }) })) })));
};
exports.NoDataPlaceholder = NoDataPlaceholder;
//# sourceMappingURL=Components.js.map