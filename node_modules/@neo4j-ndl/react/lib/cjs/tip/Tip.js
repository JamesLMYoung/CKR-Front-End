"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Action = exports.Actions = exports.Body = exports.Header = exports.Content = exports.Trigger = exports.Tip = exports.useTipContext = exports.useTip = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
/**
 *
 *  Copyright (c) "Neo4j"
 *  Neo4j Sweden AB [http://neo4j.com]
 *
 *  This file is part of Neo4j.
 *
 *  Neo4j is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
const react_1 = require("@floating-ui/react");
const Tooltip_1 = __importDefault(require("./Tooltip"));
const ConditionalWrap_1 = __importDefault(require("../_common/ConditionalWrap"));
const typography_1 = require("../typography");
const icons_1 = require("../icons");
const defaultImports_1 = require("../_common/defaultImports");
const base_1 = require("@neo4j-ndl/base");
const button_1 = require("../button");
const react_2 = __importDefault(require("react"));
const PLACEMENTS = ['top', 'bottom', 'left', 'right'];
const calculateArrow = (placement) => {
    switch (placement) {
        case 'bottom':
            return 'top';
        case 'left':
            return 'right';
        case 'right':
            return 'left';
        case 'top':
        default:
            return 'bottom';
    }
};
function useTip({ allowedPlacements = PLACEMENTS, isOpen: controlledOpen, isDisabled = false, onOpenChange: setControlledOpen, type = 'tooltip', } = {}) {
    const [uncontrolledOpen, setUncontrolledOpen] = react_2.default.useState(false);
    /** If `isDisabled` is passed, tip is never opened */
    const open = isDisabled === true ? false : controlledOpen !== null && controlledOpen !== void 0 ? controlledOpen : uncontrolledOpen;
    const setOpen = setControlledOpen !== null && setControlledOpen !== void 0 ? setControlledOpen : setUncontrolledOpen;
    const data = (0, react_1.useFloating)({
        placement: allowedPlacements[0],
        open,
        onOpenChange: setOpen,
        whileElementsMounted: react_1.autoUpdate,
        middleware: [
            (0, react_1.offset)(10),
            (0, react_1.flip)({
                fallbackAxisSideDirection: 'start',
                fallbackPlacements: allowedPlacements,
            }),
        ],
    });
    const context = data.context;
    const hover = (0, react_1.useHover)(context, {
        move: false,
        enabled: type == 'tooltip',
        delay: {
            open: parseInt(base_1.tokens.transitions.values.duration.slow.replace('ms', '')),
            // Strip the 'ms' from the duration token, need to provide pure ms durations
            close: parseInt(base_1.tokens.transitions.values.duration.quick.replace('ms', '')),
        },
    });
    const focus = (0, react_1.useFocus)(context, {
        enabled: type == 'tooltip',
    });
    const dismiss = (0, react_1.useDismiss)(context, {
        enabled: type == 'tooltip',
    });
    const click = (0, react_1.useClick)(context, {
        enabled: type == 'toggletip',
    });
    const role = (0, react_1.useRole)(context, { role: 'tooltip' });
    const interactions = (0, react_1.useInteractions)([hover, focus, dismiss, role, click]);
    return react_2.default.useMemo(() => (Object.assign(Object.assign({ open,
        setOpen,
        type }, interactions), data)), [open, setOpen, interactions, data, type]);
}
exports.useTip = useTip;
const TooltipContext = react_2.default.createContext(null);
const useTipContext = () => {
    const context = react_2.default.useContext(TooltipContext);
    if (context == null) {
        throw new Error('Tip components must be wrapped in <Tip />');
    }
    return context;
};
exports.useTipContext = useTipContext;
function Tip(_a) {
    var { children } = _a, options = __rest(_a, ["children"]);
    // This can accept any props as options, e.g. `placement`,
    // or other positioning options.
    const tooltip = useTip(Object.assign({}, options));
    return ((0, jsx_runtime_1.jsx)(TooltipContext.Provider, { value: tooltip, children: children }));
}
exports.Tip = Tip;
/**
 * Wrapping the trigger in a button by default
 * Use `asChild` to pass any element as the trigger
 */
exports.Trigger = react_2.default.forwardRef(function Trigger(_a, propRef) {
    var { children, hasButtonWrapper = false } = _a, restProps = __rest(_a, ["children", "hasButtonWrapper"]);
    const context = (0, exports.useTipContext)();
    const childrenRef = children.ref;
    const ref = (0, react_1.useMergeRefs)([context.refs.setReference, propRef, childrenRef]);
    // `hasButtonWrapper=false` allows the user to pass any element as the anchor
    if (!hasButtonWrapper && react_2.default.isValidElement(children)) {
        return react_2.default.cloneElement(children, context.getReferenceProps(Object.assign(Object.assign(Object.assign({ ref }, restProps), children.props), { 'data-state': context.open ? 'open' : 'closed' })));
    }
    return ((0, jsx_runtime_1.jsx)("button", Object.assign({ ref: ref, "data-state": context.open ? 'open' : 'closed' }, context.getReferenceProps(restProps), { children: children })));
});
exports.Content = react_2.default.forwardRef(function Content(_a, propRef) {
    var { style, isPortaled = true, portalProps = {}, className, children } = _a, restProps = __rest(_a, ["style", "isPortaled", "portalProps", "className", "children"]);
    const { open, type, context, getFloatingProps, placement } = (0, exports.useTipContext)();
    const ref = (0, react_1.useMergeRefs)([context.refs.setFloating, propRef]);
    if (!open)
        return null;
    const floatingProps = getFloatingProps(Object.assign(Object.assign({}, restProps), {
        className: (0, defaultImports_1.classNames)('ndl-tip ndl-tooltip-wrapper', className, {
            'ndl-toggletip': type === 'toggletip',
        }),
    }));
    return ((0, jsx_runtime_1.jsx)(ConditionalWrap_1.default, { condition: isPortaled, wrap: (wrapChildren) => ((0, jsx_runtime_1.jsx)(react_1.FloatingPortal, Object.assign({ preserveTabOrder: true }, portalProps, { children: wrapChildren }))), children: (0, jsx_runtime_1.jsx)(react_1.FloatingFocusManager, { context: context, disabled: type === 'tooltip', children: (0, jsx_runtime_1.jsx)(Tooltip_1.default, Object.assign({ ref: ref }, floatingProps, { arrowPosition: calculateArrow(placement), style: Object.assign(Object.assign({ zIndex: base_1.tokens.zIndex.alias.tooltip }, context.floatingStyles), style), children: children })) }) }));
});
exports.Header = react_2.default.forwardRef(function Content(_a, ref) {
    var { isCloseable = true } = _a, restProps = __rest(_a, ["isCloseable"]);
    const { open, setOpen } = (0, exports.useTipContext)();
    if (!open)
        return null;
    return ((0, jsx_runtime_1.jsxs)("div", Object.assign({ className: "ndl-toggletip-header" }, restProps, { ref: ref, children: [(0, jsx_runtime_1.jsx)(typography_1.Typography, { variant: "h6", children: restProps.children }), isCloseable && ((0, jsx_runtime_1.jsx)(button_1.IconButton, { clean: true, tabIndex: 0, role: "button", size: "small", className: "ndl-toggletip-close-icon", onKeyDown: (event) => {
                    if (event.key === 'Enter' || event.key === 'Space') {
                        setOpen(false, event.nativeEvent);
                    }
                }, onClick: (event) => {
                    setOpen(false, event.nativeEvent);
                }, "aria-label": "close-toggletip", "data-testid": "ndl-close-toggletip", children: (0, jsx_runtime_1.jsx)(icons_1.XMarkIconOutline, {}) }))] })));
});
exports.Body = react_2.default.forwardRef(function Body(_a, ref) {
    var restProps = __rest(_a, []);
    const { open } = (0, exports.useTipContext)();
    if (!open)
        return null;
    return (0, jsx_runtime_1.jsx)("div", Object.assign({}, restProps, { ref: ref }));
});
exports.Actions = react_2.default.forwardRef(function Actions(_a, ref) {
    var restProps = __rest(_a, []);
    const { open } = (0, exports.useTipContext)();
    const classes = (0, defaultImports_1.classNames)('ndl-toggletip-actions', restProps.className);
    if (!open)
        return null;
    return (0, jsx_runtime_1.jsx)("div", Object.assign({}, restProps, { className: classes, ref: ref }));
});
const Action = (_a) => {
    var { className } = _a, restProps = __rest(_a, ["className"]);
    const { open } = (0, exports.useTipContext)();
    const classes = (0, defaultImports_1.classNames)('ndl-toggletip-action', className);
    if (!open)
        return null;
    return ((0, jsx_runtime_1.jsx)(typography_1.Typography, Object.assign({ as: "button" }, restProps, { tabIndex: 0, variant: "label", className: classes })));
};
exports.Action = Action;
Tip.Content = exports.Content;
Tip.Trigger = exports.Trigger;
Tip.Header = exports.Header;
Tip.Body = exports.Body;
Tip.Actions = exports.Actions;
Tip.Action = exports.Action;
//# sourceMappingURL=Tip.js.map