var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
/**
 *
 *  Copyright (c) "Neo4j"
 *  Neo4j Sweden AB [http://neo4j.com]
 *
 *  This file is part of Neo4j.
 *
 *  Neo4j is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import { classNames } from '../_common/defaultImports';
import { useCallback, useRef, useImperativeHandle, createContext, useContext, } from 'react';
import { forwardRef, } from '../helpers';
import { ChevronDownIconOutline } from '../icons';
import { Typography } from '../typography';
const getAccordionItem = (activeElement, accordionElement, iterator) => {
    var _a;
    const accordionItemElement = activeElement.parentElement;
    let newItemElement = iterator(accordionElement, accordionItemElement);
    let childItemElement = null;
    // Iterate over next element until we find a menu item
    // Iterate a maximum of 10 times looking for an element
    for (let i = 0; i < 10; i++) {
        // Can't find new element, break
        if (!newItemElement) {
            return null;
        }
        const role = (_a = newItemElement.firstElementChild) === null || _a === void 0 ? void 0 : _a.getAttribute('role');
        if (role === 'heading') {
            childItemElement = newItemElement;
            break;
        }
        newItemElement = iterator(accordionElement, newItemElement);
    }
    return childItemElement;
};
// Gets next sibling child, looping at the end
const nextElement = (accordionElement, currentElement) => {
    var _a, _b;
    if (currentElement === accordionElement ||
        !(currentElement === null || currentElement === void 0 ? void 0 : currentElement.nextElementSibling)) {
        const nextItem = accordionElement.firstChild;
        const firstAccordionItemHeaderElement = (_a = accordionElement === null || accordionElement === void 0 ? void 0 : accordionElement.firstElementChild) === null || _a === void 0 ? void 0 : _a.firstElementChild;
        return (firstAccordionItemHeaderElement === null || firstAccordionItemHeaderElement === void 0 ? void 0 : firstAccordionItemHeaderElement.className.includes('ndl-accordion-item-header-disabled'))
            ? nextElement(accordionElement, nextItem)
            : nextItem;
    }
    else if (currentElement === null || currentElement === void 0 ? void 0 : currentElement.nextElementSibling) {
        const nextItem = currentElement.nextElementSibling;
        return ((_b = currentElement.nextElementSibling.firstElementChild) === null || _b === void 0 ? void 0 : _b.className.includes('ndl-accordion-item-header-disabled'))
            ? nextElement(accordionElement, nextItem)
            : nextItem;
    }
    return null;
};
// Gets prev sibling child, looping at the top
const previousElement = (accordionElement, currentElement) => {
    var _a, _b;
    if (currentElement === accordionElement ||
        !(currentElement === null || currentElement === void 0 ? void 0 : currentElement.previousElementSibling)) {
        const prevItem = accordionElement.lastElementChild;
        const lastAccordionItemHeaderElement = (_a = accordionElement === null || accordionElement === void 0 ? void 0 : accordionElement.lastElementChild) === null || _a === void 0 ? void 0 : _a.firstElementChild;
        return (lastAccordionItemHeaderElement === null || lastAccordionItemHeaderElement === void 0 ? void 0 : lastAccordionItemHeaderElement.className.includes('ndl-accordion-item-header-disabled'))
            ? previousElement(accordionElement, prevItem)
            : prevItem;
    }
    else if (currentElement === null || currentElement === void 0 ? void 0 : currentElement.previousElementSibling) {
        const prevItem = currentElement.previousElementSibling;
        return ((_b = currentElement.previousElementSibling.firstElementChild) === null || _b === void 0 ? void 0 : _b.className.includes('ndl-accordion-item-header-disabled'))
            ? previousElement(accordionElement, prevItem)
            : prevItem;
    }
    return null;
};
const AccordionContext = createContext(null);
const useAccordionContext = () => {
    const context = useContext(AccordionContext);
    if (context === null) {
        throw new Error('Accordion used without context');
    }
    return context;
};
const AccordionComponent = forwardRef(function AccordionComponent(_a, ref) {
    var { as = 'div', children, className, multiple, onChange } = _a, restProps = __rest(_a, ["as", "children", "className", "multiple", "onChange"]);
    const accordionRef = useRef(null);
    // The following function includes code needed to be
    // able to navigate with the arrow keys (not tab).
    const handleKeyDown = (event) => {
        const accordionElement = accordionRef.current;
        if (!accordionElement) {
            return;
        }
        const activeElement = document.activeElement;
        if (event.key == 'ArrowDown') {
            event.preventDefault();
            event.stopPropagation();
            const newFocusedElement = getAccordionItem(activeElement, accordionElement, nextElement);
            const newHeader = newFocusedElement === null || newFocusedElement === void 0 ? void 0 : newFocusedElement.firstElementChild;
            newHeader.focus();
        }
        else if (event.key == 'ArrowUp') {
            event.preventDefault();
            event.stopPropagation();
            const newFocusedElement = getAccordionItem(activeElement, accordionElement, previousElement);
            const newHeader = newFocusedElement === null || newFocusedElement === void 0 ? void 0 : newFocusedElement.firstElementChild;
            newHeader.focus();
        }
        else if (event.key == ' ' || event.key == 'Enter') {
            event.preventDefault();
            event.stopPropagation();
            const buttonElement = activeElement.getElementsByClassName('ndl-accordion-item-header-button')[0];
            buttonElement.click();
        }
    };
    useImperativeHandle(ref, () => accordionRef.current);
    const classes = classNames('ndl-accordion', className);
    const Component = as;
    const _b = restProps, { expandedItemIds } = _b, isMultipleRootProps = __rest(_b, ["expandedItemIds"]);
    const _c = restProps, { expandedItemId } = _c, isNotMultipleRootProps = __rest(_c, ["expandedItemId"]);
    const rootProps = multiple ? isMultipleRootProps : isNotMultipleRootProps;
    const contextValue = multiple
        ? {
            onChange,
            multiple,
            expandedItemIds,
        }
        : {
            onChange,
            multiple,
            expandedItemId,
        };
    return (_jsx(Component, Object.assign({}, rootProps, { className: classes, ref: accordionRef, onKeyDown: handleKeyDown, children: _jsx(AccordionContext.Provider, { value: contextValue, children: children }) })));
});
AccordionComponent.displayName = 'Accordion';
const createItemId = (type, id) => `ndl-accordionitem${type}id-${id}`;
const AccordionItem = (_a) => {
    var { itemId, children, title, className = '', arrowPosition = 'right', disabled = false, onExpandedChange } = _a, restProps = __rest(_a, ["itemId", "children", "title", "className", "arrowPosition", "disabled", "onExpandedChange"]);
    const contentRef = useRef(null);
    const innerContentRef = useRef(null);
    const itemElementId = createItemId('item', itemId);
    const headerElementId = createItemId('header', itemId);
    const buttonElementId = createItemId('button', itemId);
    const panelElementId = createItemId('panel', itemId);
    const context = useAccordionContext();
    const { multiple } = context;
    const isExpanded = multiple
        ? context.expandedItemIds.includes(itemId)
        : context.expandedItemId === itemId;
    const handleOnClick = useCallback(() => {
        var _a, _b;
        if (disabled)
            return;
        // Custom callback to call.
        if (onExpandedChange !== undefined)
            onExpandedChange(!isExpanded);
        if (multiple) {
            const { expandedItemIds, onChange } = context;
            // Multiple expanded.
            if (isExpanded) {
                // Remove from list.
                const newArray = expandedItemIds.filter((activeId) => activeId !== itemId);
                onChange(newArray);
            }
            else if (!isExpanded) {
                // Add to list.
                const newArray = [...expandedItemIds];
                newArray.push(itemId);
                onChange(newArray);
            }
        }
        else {
            const { onChange } = context;
            // Single expanded.
            if (isExpanded) {
                // Set null.
                onChange(null);
            }
            else if (!isExpanded) {
                // Set to id.
                onChange(itemId);
            }
        }
        // The W3 WAI-ARIA states that focus can only happen on the header not the header button.
        (_b = (_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.focus();
    }, [isExpanded, multiple, disabled, itemId, onExpandedChange, context]);
    const classes = classNames('ndl-accordion-item', className, {
        'ndl-accordion-item-disabled': disabled,
    });
    const headerClasses = classNames('ndl-accordion-item-header', {
        'ndl-accordion-item-header-disabled': disabled,
    });
    const iconClasses = classNames('ndl-accordion-item-header-icon-wrapper', {
        'ndl-accordion-item-header-icon-wrapper-right': arrowPosition === 'right',
    });
    const buttonClasses = classNames('ndl-accordion-item-header-button', {
        'ndl-accordion-item-header-button-disabled': disabled,
    });
    const titleClasses = classNames('ndl-accordion-item-header-button-title', {
        'ndl-accordion-item-header-button-title': disabled,
        'ndl-accordion-item-header-button-title-right': arrowPosition === 'right',
    });
    const contentClasses = classNames('ndl-accordion-item-content', {
        'ndl-accordion-item-content-expanded': isExpanded,
        'ndl-accordion-item-content-right': arrowPosition === 'right',
    });
    const headerTitle = _jsx("span", { className: titleClasses, children: title });
    return (_jsxs("div", Object.assign({}, restProps, { className: classes, id: itemElementId, children: [_jsx(Typography, { variant: "subheading-medium", className: headerClasses, role: "heading", tabIndex: disabled ? -1 : 0, id: headerElementId, "aria-level": "2", children: _jsx("button", { id: buttonElementId, onClick: handleOnClick, className: buttonClasses, "aria-expanded": isExpanded, "aria-disabled": disabled, "aria-label": title, "aria-controls": panelElementId, tabIndex: -1, children: _jsxs("span", { className: iconClasses, children: [headerTitle, _jsx(ChevronDownIconOutline, { className: classNames('ndl-accordion-item-header-icon', {
                                    '-n-rotate-180': isExpanded,
                                }) })] }) }) }), _jsx("div", { id: panelElementId, ref: contentRef, className: contentClasses, "aria-hidden": !isExpanded, "aria-labelledby": buttonElementId, role: "region", children: _jsx("div", { ref: innerContentRef, className: "ndl-accordion-item-content-inner", children: _jsx(Typography, { variant: "body-medium", className: "n-text-palette-neutral-text-weak", as: "div", children: children }) }) })] })));
};
AccordionItem.displayName = 'Accordion.Item';
// Issue with TypeScript forwardRef and subcomponents: https://github.com/DefinitelyTyped/DefinitelyTyped/issues/34757#issuecomment-894053907
// Fixes issue with: Accordion.Item = Item;
const Accordion = Object.assign(AccordionComponent, { Item: AccordionItem });
export { Accordion };
//# sourceMappingURL=Accordion.js.map