import { createElement as _createElement } from "react";
import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
/**
 *
 *  Copyright (c) "Neo4j"
 *  Neo4j Sweden AB [http://neo4j.com]
 *
 *  This file is part of Neo4j.
 *
 *  Neo4j is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import { useMemo } from 'react';
import { flexRender, } from '@tanstack/react-table';
import { classNames } from '../_common/defaultImports';
import { Bars3CenterLeftIconOutline, BarsArrowDownIconOutline, BarsArrowUpIconOutline, ChevronLeftIconOutline, ChevronRightIconOutline, } from '../icons';
import { LoadingSpinner } from '../loading-spinner';
import { gridGenerator, userFriendlyPagination } from './helpers';
import { useTableContext } from './TableContext';
/** Table results per page, with the first option being the default */
const TABLE_RESULTS = {
    DEFAULT: 10,
    values: [10, 25, 50, 100],
};
const ResizingBar = ({ header, children, innerProps, }) => {
    const { className = undefined } = innerProps || {};
    return (_jsx(_Fragment, { children: children || (_jsx("button", Object.assign({}, innerProps, { type: "button", className: "ndl-table-resizer-wrapper", onMouseDown: header.getResizeHandler(), onTouchStart: header.getResizeHandler(), "aria-label": "resizing bar", children: _jsx("div", { className: classNames('ndl-table-resizer', className, {
                    'ndl-table-is-resizing': header.column.getIsResizing(),
                }) }) }))) }));
};
const Scrollable = ({ children, innerProps }) => {
    const { className } = innerProps || {};
    return (_jsx("div", Object.assign({}, innerProps, { className: classNames('ndl-table-scrollable', className), children: children })));
};
const Header = ({ children, innerProps }) => {
    const { tableProps, components } = useTableContext();
    const { getHeaderGroups, getState } = tableProps;
    const { className = undefined } = innerProps || {};
    const commonStyle = {
        display: 'grid',
        gridTemplateColumns: gridGenerator(tableProps),
    };
    return (_jsx("div", Object.assign({}, innerProps, { role: "rowgroup", className: classNames('ndl-table-thead', className, {
            'ndl-table-is-resizing': getState().columnSizingInfo.isResizingColumn,
        }), children: children || (_jsx(_Fragment, { children: getHeaderGroups().map((headerGroup) => (_jsx("div", { className: "ndl-table-tr", style: commonStyle, role: "row", children: headerGroup.headers.map((header) => components.HeaderCell && (_jsx(components.HeaderCell, { cell: header }, header.id))) }, headerGroup.id))) })) })));
};
export const SortingButton = ({ sortDirection, children, innerProps, }) => {
    let icon;
    const { className, style, onClick } = innerProps || {};
    const commonProps = Object.assign(Object.assign({}, innerProps), { className: classNames('ndl-header-icon', className), style: Object.assign(Object.assign({}, style), (sortDirection && { display: 'inline-block' })), onClick: (e) => onClick && onClick(e), onKeyDown: (e) => {
            if (e.key === ' ' && typeof onClick === 'function')
                onClick(e);
        }, tabIndex: 0 });
    switch (sortDirection) {
        case 'desc':
            icon = _jsx(BarsArrowDownIconOutline, Object.assign({}, commonProps));
            break;
        case 'asc':
            icon = _jsx(BarsArrowUpIconOutline, Object.assign({}, commonProps));
            break;
        default:
            icon = _jsx(Bars3CenterLeftIconOutline, Object.assign({}, commonProps));
    }
    return _jsx(_Fragment, { children: children || icon });
};
export const ColumnControls = ({ cell, controls, children, innerProps, }) => {
    const { className } = innerProps || {};
    return (_jsx("div", Object.assign({}, innerProps, { className: classNames('ndl-header-action-group', className), children: children || _jsx(_Fragment, { children: controls === null || controls === void 0 ? void 0 : controls.map((control) => control) }) })));
};
const HeaderCell = ({ cell, children, innerProps, }) => {
    const { components, resizable } = useTableContext();
    const { className } = innerProps || {};
    const sort = cell.column.getIsSorted();
    const canSort = cell.column.getCanSort();
    const ariaSortRole = useMemo(() => {
        switch (sort) {
            case 'asc':
                return 'ascending';
            case 'desc':
                return 'descending';
            default:
                return 'none';
        }
    }, [sort]);
    const sortingControl = useMemo(() => {
        if (canSort) {
            return (_jsx(SortingButton, { sortDirection: sort, innerProps: {
                    onClick: () => cell.column.toggleSorting(),
                } }, cell.id));
        }
        else if (!canSort && sort !== false) {
            return (_jsx(SortingButton, { sortDirection: sort, innerProps: {
                    tabIndex: -1,
                    style: {
                        cursor: 'not-allowed',
                    },
                } }, cell.id));
        }
    }, [sort, cell, canSort]);
    return (_jsx("div", Object.assign({ tabIndex: -1, role: "columnheader" }, innerProps, { className: classNames('ndl-table-th ndl-focusable-cell', className), "aria-sort": ariaSortRole, children: children || (_jsxs(_Fragment, { children: [_jsxs("div", { className: "ndl-header-group", children: [_jsx("div", { className: "ndl-header-cell", children: cell.isPlaceholder
                                ? null
                                : flexRender(cell.column.columnDef.header, cell.getContext()) }), components.ColumnControls && (_jsx(components.ColumnControls, { cell: cell, controls: sortingControl ? [sortingControl] : [], innerProps: {
                                tabIndex: canSort ? 0 : -1,
                            } }))] }), resizable &&
                    cell.headerGroup.headers.length - 1 !== cell.index &&
                    cell.column.getCanResize() &&
                    components.ResizingBar && _jsx(components.ResizingBar, { header: cell })] })) }), cell.id));
};
const Body = ({ children, innerProps }) => {
    const { tableProps, components, loading } = useTableContext();
    const { getRowModel } = tableProps;
    const { className } = innerProps || {};
    return (_jsx("div", Object.assign({}, innerProps, { className: classNames('ndl-table-tbody', className), role: "rowgroup", "aria-busy": loading ? 'true' : 'false', children: children || (_jsxs(_Fragment, { children: [loading && components.LoadingPlaceholder && (_jsx(components.LoadingPlaceholder, {})), !loading &&
                    getRowModel().rows.length === 0 &&
                    components.NoDataPlaceholder && _jsx(components.NoDataPlaceholder, {}), !loading &&
                    getRowModel().rows.map((row, idx) => components.BodyRow && (_jsx(components.BodyRow, { row: row }, `table-row-${idx}`)))] })) })));
};
const BodyCell = ({ cell, children, innerProps, }) => {
    const isResizing = cell.column.getIsResizing();
    const { className } = innerProps || {};
    return (_jsx("div", Object.assign({}, innerProps, { className: classNames('ndl-table-td ndl-focusable-cell', className, {
            'ndl-table-is-resizing': isResizing,
        }), role: "cell", tabIndex: 0, children: children || flexRender(cell.column.columnDef.cell, cell.getContext()) }), cell.id));
};
const BodyRow = ({ row, children, innerProps, }) => {
    const { components, tableProps } = useTableContext();
    const { className } = innerProps || {};
    const commonStyle = {
        display: 'grid',
        gridTemplateColumns: gridGenerator(tableProps),
    };
    return (_createElement("div", Object.assign({}, innerProps, { key: row.id, className: classNames('ndl-table-tr', className), style: commonStyle, role: "row" }), children || (_jsx(_Fragment, { children: row
            .getVisibleCells()
            .map((cell) => components.BodyCell && (_jsx(components.BodyCell, { cell: cell }, cell.id))) }))));
};
const TableResults = ({ children, innerProps, manualPagination, }) => {
    const { tableProps } = useTableContext();
    const { getState, getRowModel, getCoreRowModel } = tableProps;
    const { pagination: { pageSize, pageIndex }, } = getState();
    const { rows } = getRowModel();
    const { from, to, totalRows } = useMemo(() => manualPagination || {
        from: 1 + pageIndex * pageSize,
        to: rows.length + pageIndex * pageSize,
        totalRows: getCoreRowModel().rows.length,
    }, [pageIndex, pageSize, manualPagination, rows, getCoreRowModel]);
    const { className } = innerProps || {};
    return (_jsx("span", Object.assign({}, innerProps, { className: classNames('ndl-table-results', className), children: children || (_jsxs("span", { children: ["Showing", ' ', _jsx("b", { children: totalRows ? `${from}${to !== from ? `-${to}` : ''}` : 0 }), " of", ' ', _jsx("b", { children: totalRows }), " results"] })) })));
};
const RowsPerPage = ({ children, innerProps, }) => {
    const { tableProps } = useTableContext();
    const { setPageSize, getState } = tableProps;
    const { className } = innerProps || {};
    const { pagination: { pageSize }, } = getState();
    return (_jsx("div", Object.assign({}, innerProps, { className: classNames('ndl-table-rows-per-page', className), children: children || (_jsxs(_Fragment, { children: ["Show", _jsx("select", { onChange: (e) => setPageSize(parseInt(e.target.value, 10)), className: "ndl-table-select", value: pageSize, "aria-label": "Select page size", children: [...new Set([...TABLE_RESULTS.values, pageSize])]
                        .sort((a, b) => a - b)
                        .map((option) => (_jsx("option", { value: `${option}`, children: option }, `${option}`))) })] })) })));
};
const PaginationArrowButton = ({ action, children, innerProps, }) => {
    const { className } = innerProps || {};
    return (_jsx("button", Object.assign({}, innerProps, { type: "button", className: classNames('ndl-table-pagination-icon-button', className), children: children || (_jsxs(_Fragment, { children: [action === 'previous' && (_jsxs(_Fragment, { children: [_jsx("span", { className: "n-sr-only", children: "Previous table page" }), _jsx(ChevronLeftIconOutline, { className: "ndl-table-pagination-icon" })] })), action === 'next' && (_jsxs(_Fragment, { children: [_jsx("span", { className: "n-sr-only", children: "Next table page" }), _jsx(ChevronRightIconOutline, { className: "ndl-table-pagination-icon" })] }))] })) })));
};
const PaginationNumericButton = ({ currentIndex, isSelected, children, innerProps, }) => {
    const { className, onClick } = innerProps || {};
    return (_jsx("button", Object.assign({}, innerProps, { type: "button", "data-testid": `ndl-table-${currentIndex}`, className: classNames('ndl-table-pagination-numeric-button', className, {
            'ndl-not-selected-numeric': typeof currentIndex === 'number' && !isSelected,
            'ndl-is-selected': isSelected,
            'ndl-not-selected': !isSelected,
        }), onClick: (e) => typeof currentIndex === 'number' && onClick && onClick(e), tabIndex: typeof currentIndex === 'number' ? 0 : -1, children: children || currentIndex })));
};
const PaginationNumericButtons = () => {
    const { tableProps, components } = useTableContext();
    const { getState, setPageIndex, getPageCount } = tableProps;
    const { pagination: { pageIndex }, } = getState();
    return (_jsx(_Fragment, { children: userFriendlyPagination(pageIndex + 1, getPageCount()).map((option, idx) => components.PaginationNumericButton && (_jsx(components.PaginationNumericButton
        /** Use index to avoid situations where two "..." values will appear, causing a key conflict */
        , { innerProps: {
                onClick: () => typeof option === 'number' && setPageIndex(option - 1),
            }, currentIndex: option, isSelected: option === pageIndex + 1 }, `${option}-${idx}`))) }));
};
const Pagination = ({ children, innerProps, }) => {
    const { tableProps, components } = useTableContext();
    const { getCanPreviousPage, getCanNextPage, previousPage, nextPage } = tableProps;
    const { className } = innerProps || {};
    return (_jsx("nav", Object.assign({}, innerProps, { className: classNames('ndl-table-nav', className), "aria-label": "Pagination", children: children || (_jsxs(_Fragment, { children: [getCanPreviousPage()
                    ? components.PaginationArrowButton && (_jsx(components.PaginationArrowButton, { action: "previous", innerProps: {
                            onClick: previousPage,
                        } }))
                    : null, components.PaginationNumericButtons && (_jsx(components.PaginationNumericButtons, {})), getCanNextPage()
                    ? components.PaginationArrowButton && (_jsx(components.PaginationArrowButton, { action: "next", innerProps: {
                            onClick: nextPage,
                        } }))
                    : null] })) })));
};
const Navigation = ({ children, innerProps, }) => {
    const { tableProps, components } = useTableContext();
    const { getPageCount } = tableProps;
    const { className } = innerProps || {};
    return (_jsx("div", Object.assign({}, innerProps, { className: classNames('ndl-table-navigation', className), children: _jsx(_Fragment, { children: children || (_jsxs(_Fragment, { children: [components.TableResults && _jsx(components.TableResults, {}), _jsxs("div", { className: "ndl-table-navigation-right-items", children: [getPageCount() > 1 && components.Pagination && (_jsx(components.Pagination, {})), components.RowsPerPage && _jsx(components.RowsPerPage, {})] })] })) }) })));
};
const LoadingPlaceholder = ({ children, innerProps, }) => {
    const { className } = innerProps || {};
    return (_jsx("div", Object.assign({}, innerProps, { className: classNames('nld-table-placeholder-wrapper', className), role: "row", children: children || (_jsx("div", { role: "cell", className: "ndl-table-placeholder", children: _jsxs("div", { className: "ndl-table-loading-placeholder", children: [_jsx(LoadingSpinner, {}), _jsx("h6", { children: "Loading data" })] }) })) })));
};
const NoDataPlaceholder = ({ children, innerProps, }) => {
    const { className } = innerProps || {};
    return (_jsx("div", Object.assign({}, innerProps, { className: classNames('nld-table-placeholder-wrapper', className), role: "row", children: children || (_jsx("div", { role: "cell", className: "ndl-table-placeholder", children: _jsx("h6", { children: "No data present" }) })) })));
};
export { ResizingBar, Header, Body, BodyCell, BodyRow, HeaderCell, Navigation, TableResults, RowsPerPage, Pagination, PaginationNumericButtons, PaginationArrowButton, PaginationNumericButton, NoDataPlaceholder, LoadingPlaceholder, Scrollable, };
//# sourceMappingURL=Components.js.map