import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
/**
 *
 *  Copyright (c) "Neo4j"
 *  Neo4j Sweden AB [http://neo4j.com]
 *
 *  This file is part of Neo4j.
 *
 *  Neo4j is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import { forwardRef } from 'react';
import { tokens } from '@neo4j-ndl/base';
const DEBUG = false;
const ARBITRARY_OFFSET = 2;
/**
 * This is a component that renders an SVG area that is used to
 * detect if the mouse is heading towards the nested element or not.
 *
 * You can debug this visually by setting DEBUG variable to true.
 */
export const SafeArea = forwardRef((props, ref) => {
    const { mouse, nestedRect, anchorRect } = props.area;
    const svgHeight = nestedRect.height;
    const position = mouse.x < nestedRect.x ? 'right' : 'left';
    const svgWidth = position === 'right'
        ? nestedRect.x - mouse.x + 4
        : mouse.x - nestedRect.x - nestedRect.width;
    const belowStartingY = anchorRect.y + anchorRect.height - nestedRect.y;
    const aboveHeight = anchorRect.y - nestedRect.y;
    // Distance between mouse and start of the anchor element
    const distance = position === 'right'
        ? mouse.x - anchorRect.x
        : anchorRect.x + anchorRect.width - mouse.x;
    // How close we are to the nested element in % (0-1) of anchor's width
    const factor = (anchorRect.width - distance) / anchorRect.width;
    const svgBox = {
        width: svgWidth,
        height: svgHeight,
        top: nestedRect.y,
        left: position === 'right'
            ? mouse.x - ARBITRARY_OFFSET
            : nestedRect.x + nestedRect.width + ARBITRARY_OFFSET,
        position: 'fixed',
        zIndex: 1000000000,
        pointerEvents: 'none',
        transform: position === 'right' ? 'none' : 'scaleX(-1)',
        border: DEBUG ? '1px #212121 solid' : 'none',
    };
    return (_jsxs("svg", { ref: ref, className: "svg-triangle", style: svgBox, id: "svg-hit-area", children: [_jsxs("defs", { children: [_jsxs("linearGradient", { id: "safe", x1: "0%", y1: "0%", x2: "100%", y2: "0%", children: [_jsx("stop", { offset: "0%", style: { stopColor: tokens.colors.baltic['60'], stopOpacity: 1 } }), _jsx("stop", { offset: "100%", style: {
                                    stopColor: tokens.colors.baltic['50'],
                                    stopOpacity: 0,
                                } })] }), _jsxs("linearGradient", { id: "unsafe", x1: "0%", y1: "0%", x2: "100%", y2: "0%", children: [_jsx("stop", { offset: "0%", style: { stopColor: tokens.colors.hibiscus['50'], stopOpacity: 1 } }), _jsx("stop", { offset: "100%", style: {
                                    stopColor: tokens.colors.hibiscus['50'],
                                    stopOpacity: 0,
                                } })] })] }), _jsx("path", { pointerEvents: "none", width: "100%", height: "100%", fill: DEBUG ? 'url(#unsafe)' : 'transparent', d: `M 0,0 L ${svgWidth},0 L ${svgWidth},${svgHeight} L 0,${svgHeight} z` }), _jsx("path", { onMouseMove: props.onMouseMove, pointerEvents: "auto", stroke: DEBUG ? 'black' : 'none', strokeWidth: "0.4", fill: DEBUG ? 'url(#safe)' : 'transparent', 
                // prettier-ignore
                d: `M 0, ${aboveHeight + 10}
        Q ${svgWidth * 0.7},${(anchorRect.y - nestedRect.y) * (1 - 0.4 * factor)} ${svgWidth},0
        L ${svgWidth},${aboveHeight}
        L 0, ${aboveHeight + 10} z
        ` }), _jsx("path", { onMouseMove: props.onMouseMove, pointerEvents: "auto", stroke: DEBUG ? 'black' : 'none', strokeWidth: "0.4", fill: DEBUG ? 'url(#safe)' : 'transparent', 
                // prettier-ignore
                d: `M 0, ${belowStartingY - 10} 
            Q ${svgWidth * 0.7},${belowStartingY + (svgHeight - belowStartingY) * (0.4 * factor)} ${svgWidth},${svgHeight}
            L ${svgWidth},${belowStartingY}
            L 0, ${belowStartingY - 10} z
           ` })] }));
});
SafeArea.displayName = 'SafeArea';
//# sourceMappingURL=SafeArea.js.map