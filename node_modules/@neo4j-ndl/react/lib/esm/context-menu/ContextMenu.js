var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
/**
 *
 *  Copyright (c) "Neo4j"
 *  Neo4j Sweden AB [http://neo4j.com]
 *
 *  This file is part of Neo4j.
 *
 *  Neo4j is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import React, { useCallback, useContext, useEffect, useImperativeHandle, useRef, useState, } from 'react';
import { debounce } from '../helpers/debounce';
import { ChevronRightIconOutline, XMarkIconOutline } from '../icons';
import { Popover } from '../popover';
import { classNames } from '../_common/defaultImports';
import { SafeArea } from './SafeArea';
import { useNeedleTheme } from '../theme/ThemeProvider';
import { IconButton } from '../button';
const MenuContext = React.createContext(null);
const useMenuContext = () => {
    const context = useContext(MenuContext);
    if (context === null) {
        throw new Error('Menu used without context. Did you render this component inside a <Menu />?');
    }
    return context;
};
const MenuComponent = React.forwardRef(function MenuComponent(_a, ref) {
    var { size = 'small', className, minWidth = 250, open, onClose, children, level = 0, nested } = _a, rest = __rest(_a, ["size", "className", "minWidth", "open", "onClose", "children", "level", "nested"]);
    const menuRef = useRef();
    const focus = useCallback(() => {
        const menu = menuRef.current;
        if (!menu)
            return;
        const menuItems = menu.querySelectorAll(':scope > .ndl-menu-items');
        const menuItemsItems = menu.querySelectorAll(':scope > .ndl-menu-items > .ndl-menu-item');
        if (menuItemsItems.length > 0 && menu.className.includes('nested-menu')) {
            menuItemsItems[0].focus();
            return;
        }
        if (menuItems.length > 0) {
            menuItems[0].focus();
            return;
        }
        menu.focus();
    }, []);
    // Override ref to map to internal ref
    // as well as change focus to focus the
    // first menu item
    useImperativeHandle(ref, () => {
        const menu = menuRef.current;
        if (!menu) {
            return null;
        }
        return Object.assign(Object.assign({}, menu), { getElem: () => menu, focus: focus });
    });
    useEffect(() => {
        // Focus menu item immediately, when
        // menu is not nested
        if (open && !nested) {
            focus();
        }
    }, [open, nested, focus]);
    const { themeClassName } = useNeedleTheme();
    const classes = classNames('ndl-menu', themeClassName, {
        'ndl-small': size === 'small',
        'ndl-large': size === 'large',
    }, className);
    return (_jsx(MenuContext.Provider, { value: { onClose, level, size }, children: _jsx(Popover, Object.assign({ tabIndex: -1, captureFocus: false }, rest, { open: open, style: Object.assign({ minWidth }, (rest.style || {})), className: classes, ref: menuRef, onClose: onClose, children: children })) }));
});
MenuComponent.displayName = 'Menu';
const getMenuItem = (menuItems, iterator) => {
    const activeElement = document.activeElement;
    let newEl = iterator(menuItems, activeElement);
    let menuItem = null;
    // Iterate over next element until we find a menu item
    // Iterate a maximum of 10 times looking for an element
    for (let i = 0; i < 10; i++) {
        // Can't find new element, break
        if (!newEl) {
            return null;
        }
        const role = newEl.getAttribute('role');
        if (role === 'menuitem') {
            menuItem = newEl;
            break;
        }
        newEl = iterator(menuItems, newEl);
    }
    return menuItem;
};
// Gets next sibling child of the menu items, looping at the end
const nextElement = (menuItems, currentEl) => {
    if (currentEl === menuItems || !(currentEl === null || currentEl === void 0 ? void 0 : currentEl.nextElementSibling)) {
        return menuItems.firstChild ? menuItems.firstChild : null;
    }
    else if (currentEl === null || currentEl === void 0 ? void 0 : currentEl.nextElementSibling) {
        const nextItem = currentEl.nextElementSibling;
        return currentEl.nextElementSibling.className.includes('ndl-disabled')
            ? nextElement(menuItems, nextItem)
            : nextItem;
    }
    return null;
};
// Gets prev sibling child of the menu items, looping at the top
const prevElement = (menuItems, currentEl) => {
    if (currentEl === menuItems || !(currentEl === null || currentEl === void 0 ? void 0 : currentEl.previousElementSibling)) {
        return menuItems.lastChild ? menuItems.lastChild : null;
    }
    else if (currentEl === null || currentEl === void 0 ? void 0 : currentEl.previousElementSibling) {
        const prevItem = currentEl.previousElementSibling;
        return currentEl.previousElementSibling.className.includes('ndl-disabled')
            ? prevElement(menuItems, prevItem)
            : prevItem;
    }
    return null;
};
/** Get all siblings of an element */
function getAllSiblings(element) {
    var _a;
    const children = [...(((_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.children) || [])];
    return children.filter((child) => child !== element && child.tagName !== 'svg');
}
const MenuItems = React.forwardRef(function MenuItems(_a, ref) {
    var { as = 'ul', children, className } = _a, rest = __rest(_a, ["as", "children", "className"]);
    const menuItemsRef = useRef();
    const { onClose } = useMenuContext();
    const handleKeyDown = (event) => {
        const menuItems = menuItemsRef.current;
        if (!menuItems) {
            return;
        }
        if (event.key == 'ArrowDown') {
            event.preventDefault();
            event.stopPropagation();
            const newFocusedElement = getMenuItem(menuItems, nextElement);
            newFocusedElement === null || newFocusedElement === void 0 ? void 0 : newFocusedElement.focus();
        }
        else if (event.key == 'ArrowUp') {
            event.preventDefault();
            event.stopPropagation();
            const newFocusedElement = getMenuItem(menuItems, prevElement);
            newFocusedElement === null || newFocusedElement === void 0 ? void 0 : newFocusedElement.focus();
        }
        else if (event.key == 'Escape') {
            event.preventDefault();
            event.stopPropagation();
            onClose && onClose(event);
        }
    };
    useImperativeHandle(ref, () => menuItemsRef.current);
    const Component = as;
    const classes = classNames('ndl-menu-items', className);
    return (_jsx(Component, Object.assign({ tabIndex: -1, onKeyDown: handleKeyDown, role: "menu" }, rest, { className: classes, ref: menuItemsRef, children: children })));
});
MenuItems.displayName = 'Menu.Items';
const isNested = (props) => {
    return !!props.children;
};
const MenuItem = React.forwardRef(function MenuItem(props, ref) {
    if (isNested(props)) {
        return _jsx(NestedMenuItem, Object.assign({}, props, { ref: ref }));
    }
    return _jsx(StandardMenuItem, Object.assign({}, props, { ref: ref }));
});
MenuItem.displayName = 'Menu.Item';
const StandardMenuItem = React.forwardRef(function MenuItem(_a, ref) {
    var { as = 'li', icon, title, description, className, disabled = false, nested = false, onClick, onKeyDown } = _a, rest = __rest(_a, ["as", "icon", "title", "description", "className", "disabled", "nested", "onClick", "onKeyDown"]);
    const Component = as;
    const classes = classNames(`ndl-menu-item n-flex n-flex-col`, className, {
        'ndl-disabled': disabled,
        nested,
    });
    const handleClick = (e) => {
        if (disabled) {
            e.preventDefault();
            return;
        }
        if (onClick)
            onClick(e);
    };
    const handleKeyDown = (e) => {
        if (onKeyDown)
            onKeyDown(e);
        if (e.key === 'Enter') {
            if (disabled) {
                e.preventDefault();
                return;
            }
            if (onClick)
                onClick(e);
        }
    };
    return (_jsx(Component, Object.assign({ tabIndex: -1, role: "menuitem" }, rest, { className: classes, onClick: handleClick, onKeyDown: handleKeyDown, ref: ref, children: _jsxs("div", { className: "n-flex n-flex-row n-gap-token-4", children: [icon && _jsx("div", { className: "ndl-menu-item-icon", children: icon }), _jsxs("div", { className: "n-flex n-flex-col n-gap-token-2 n-w-full", children: [_jsx("div", { className: "ndl-menu-item-title", children: title }), description && (_jsx("div", { className: "ndl-menu-item-description", children: description }))] })] }) })));
});
const MenuHeader = React.forwardRef(function MenuHeader(_a, ref) {
    var { as = 'div', title, description, className } = _a, rest = __rest(_a, ["as", "title", "description", "className"]);
    const Component = as;
    const { onClose, size } = useMenuContext();
    const handleClose = (e) => onClose && onClose(e);
    const classes = classNames('ndl-menu-header n-flex n-flex-col', className);
    return (_jsxs(Component, Object.assign({}, rest, { className: classes, ref: ref, children: [_jsxs("div", { className: "n-flex n-justify-between n-items-center", children: [_jsx("div", { className: "ndl-menu-header-title", children: title }), _jsx(IconButton, { clean: true, tabIndex: 0, onKeyDown: handleClose, onClick: handleClose, size: size, children: _jsx(XMarkIconOutline, {}) })] }), description && (_jsx("div", { className: "ndl-menu-header-description", children: description }))] })));
});
MenuHeader.displayName = 'Menu.Header';
const MenuDivider = () => _jsx("div", { className: "ndl-menu-divider" });
MenuDivider.displayName = 'Menu.Divider';
const MenuSubheader = (props) => (_jsx("div", { className: "ndl-menu-subheader", children: _jsx("div", { className: "ndl-menu-subheader-title", children: props.title }) }));
MenuSubheader.displayName = 'Menu.Subheader';
const NestedMenuItem = React.forwardRef(function NestedMenuItem(_a, ref) {
    var { title, className, children, disabled, safeArea = true } = _a, props = __rest(_a, ["title", "className", "children", "disabled", "safeArea"]);
    const [nestedAnchorEl, setNestedAnchorEl] = useState(null);
    const nestedMenuRef = useRef(null);
    const menuItemRef = useRef(null);
    const [safe, setSafe] = useState(undefined);
    const svgRef = useRef(null);
    const { level } = useMenuContext();
    const levelClass = `nested-level-${level}`;
    useImperativeHandle(ref, () => menuItemRef.current);
    const handleNestedOpen = (event) => {
        if (disabled)
            return;
        setNestedAnchorEl(event.currentTarget);
        if (!menuItemRef.current)
            return;
        const siblings = getAllSiblings(menuItemRef.current);
        siblings.forEach((sibling) => {
            if (sibling instanceof HTMLElement)
                sibling.focus();
            if (sibling instanceof HTMLElement)
                sibling.blur();
        });
    };
    const handleNestedClose = useCallback(() => {
        var _a;
        if (safe)
            return;
        (_a = menuItemRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }, [safe]);
    const handleNestedFocus = (event) => {
        if (disabled)
            return;
        const el = event.currentTarget;
        setNestedAnchorEl(el);
        el.focus();
    };
    const handleNestedMouseLeave = useCallback((event) => {
        var _a;
        // If the event comes from the safe hit area "path"
        // element then ignore it.
        if (event.relatedTarget instanceof SVGPathElement &&
            ((_a = event.relatedTarget.parentElement) === null || _a === void 0 ? void 0 : _a.previousElementSibling) ===
                menuItemRef.current) {
            return;
        }
        const el = event.relatedTarget;
        if (el instanceof Element && el.closest(`.${levelClass}`)) {
            setSafe(undefined);
            return;
        }
        setSafe(undefined);
        setNestedAnchorEl(null);
    }, [levelClass]);
    const handleNestedBlur = (event) => {
        const el = event.relatedTarget;
        if (el === null || el === void 0 ? void 0 : el.closest(`.${levelClass}`)) {
            return;
        }
        setNestedAnchorEl(null);
    };
    const handleMenuItemKeyDown = (event) => {
        var _a, _b;
        if (event.key === 'ArrowRight') {
            event.preventDefault();
            event.stopPropagation();
            (_a = nestedMenuRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        }
        if (event.key === 'Tab') {
            event.preventDefault();
            event.stopPropagation();
            (_b = nestedMenuRef.current) === null || _b === void 0 ? void 0 : _b.focus();
        }
    };
    const handleNestedMenuKeyDown = (event) => {
        if (event.key === 'ArrowLeft' || event.key === 'Escape') {
            event.preventDefault();
            event.stopPropagation();
            nestedAnchorEl === null || nestedAnchorEl === void 0 ? void 0 : nestedAnchorEl.focus();
        }
    };
    const nestedMenuProps = {
        className: `nested-menu ${levelClass}`,
        open: Boolean(nestedAnchorEl),
        anchorEl: nestedAnchorEl,
        onClose: handleNestedClose,
        onMouseLeave: handleNestedClose,
        onKeyDown: handleNestedMenuKeyDown,
        disableBackdrop: true,
        ref: nestedMenuRef,
        nested: true,
        level: level + 1,
    };
    const handleMouseMove = (event) => {
        var _a;
        if (!nestedMenuRef.current)
            return;
        const nested = nestedMenuRef.current.getElem();
        // Update SVG Coordinates
        if (event.nativeEvent instanceof MouseEvent &&
            nestedMenuRef.current &&
            menuItemRef.current) {
            setSafe({
                mouse: {
                    x: event.nativeEvent.clientX,
                    y: event.nativeEvent.clientY,
                },
                nestedRect: nested.getBoundingClientRect(),
                anchorRect: menuItemRef.current.getBoundingClientRect(),
            });
        }
        // We need to continue the focus
        (_a = nestedMenuRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    };
    const deleteSafeArea = useCallback(debounce(() => {
        setSafe(undefined);
    }, 200), [setSafe]);
    return (_jsxs(_Fragment, { children: [_jsx(StandardMenuItem, Object.assign({}, props, { title: _jsxs("span", { className: "n-flex n-justify-between n-items-center", children: [_jsx("span", { children: title }), _jsx("span", { className: "n-text-palette-neutral-text-weak", children: _jsx(ChevronRightIconOutline, { className: "n-h-4 n-w-4" }) })] }), onMouseOver: handleNestedOpen, onMouseMove: handleMouseMove, onMouseLeave: handleNestedMouseLeave, onFocus: handleNestedFocus, onBlur: handleNestedBlur, onKeyDown: handleMenuItemKeyDown, className: classNames(className, {
                    'ndl-nested-open': !!nestedAnchorEl,
                }), ref: menuItemRef, disabled: disabled })), safeArea && safe && safe.mouse && (_jsx(SafeArea, { onMouseMove: () => {
                    var _a;
                    (_a = nestedMenuRef.current) === null || _a === void 0 ? void 0 : _a.focus();
                    deleteSafeArea();
                }, area: safe, ref: svgRef })), children({ nestedMenuProps })] }));
});
// Issue with TypeScript forwardRef and subcomponents: https://github.com/DefinitelyTyped/DefinitelyTyped/issues/34757#issuecomment-894053907
const Menu = Object.assign(MenuComponent, {
    Divider: MenuDivider,
    Subheader: MenuSubheader,
    Header: MenuHeader,
    Item: MenuItem,
    Items: MenuItems,
});
export { Menu };
//# sourceMappingURL=ContextMenu.js.map