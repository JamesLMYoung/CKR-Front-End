var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
/**
 *
 *  Copyright (c) "Neo4j"
 *  Neo4j Sweden AB [http://neo4j.com]
 *
 *  This file is part of Neo4j.
 *
 *  Neo4j is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import { forwardRef, useCallback, useEffect, useImperativeHandle, useLayoutEffect, useRef, useState, } from 'react';
import { classNames } from '../_common/defaultImports';
import { debounce } from '../helpers';
import { Portal } from '../portal';
import { useDocumentScrollToggle, useOnClickOutside, isRefObject, } from '../_common/utils';
import { anchorElNotSetWarningMessage } from '../_common/messages';
import { ConditionalWrap } from '../_common/coditionalWrap';
import FocusLock from 'react-focus-lock';
import { useNeedleTheme } from '../theme/ThemeProvider';
const getOffsetTop = (rect, vertical) => {
    let offset = 0;
    if (vertical === 'bottom') {
        offset = rect.height;
    }
    return offset;
};
const getOffsetLeft = (rect, horizontal) => {
    switch (horizontal) {
        case 'right':
            return rect.width;
        case 'center':
            return rect.width / 2;
        case 'left':
            return 0;
    }
};
export const Popover = forwardRef(function Popover(_a, ref) {
    var { as = 'div', children, open, anchorEl, onClose, anchorOrigin = { vertical: 'bottom', horizontal: 'left' }, transformOrigin = { vertical: 'top', horizontal: 'left' }, transformOriginOffsetFromAnchorOrigin = { vertical: 0, horizontal: 0 }, className, anchorPortal, disableBackdrop = false, nested = false, captureFocus = true, focusLockProps = {} } = _a, restProps = __rest(_a, ["as", "children", "open", "anchorEl", "onClose", "anchorOrigin", "transformOrigin", "transformOriginOffsetFromAnchorOrigin", "className", "anchorPortal", "disableBackdrop", "nested", "captureFocus", "focusLockProps"]);
    const Component = as;
    const popoverRef = useRef(null);
    const backdropRef = useRef(null);
    const toggleScrollbar = useDocumentScrollToggle();
    const { themeClassName } = useNeedleTheme();
    useOnClickOutside(popoverRef, (event) => {
        disableBackdrop
            ? onClose && onClose(event)
            : null;
    });
    // Override ref to map to internal ref
    useImperativeHandle(ref, () => {
        const popover = popoverRef.current;
        if (!popover) {
            return null;
        }
        return popover;
    });
    const [enter, setEnter] = useState(false);
    const baseClasses = classNames({
        'ndl-open': open,
        'ndl-enter': enter,
    });
    const getPositioningStyles = useCallback((element) => {
        const anchor = isRefObject(anchorEl) ? anchorEl.current : anchorEl;
        if (!(anchor instanceof HTMLElement)) {
            console.warn(anchorElNotSetWarningMessage);
            return;
        }
        const anchorRect = anchor.getBoundingClientRect();
        const menuRect = {
            width: element.offsetWidth,
            height: element.offsetHeight,
        };
        let transformX;
        switch (transformOrigin.horizontal) {
            case 'right':
                transformX = -menuRect.width;
                break;
            case 'center':
                transformX = -menuRect.width / 2;
                break;
            case 'left':
                transformX = 0;
                break;
        }
        transformX += transformOriginOffsetFromAnchorOrigin.horizontal;
        const transformY = (transformOrigin.vertical == 'bottom' ? -menuRect.height : 0) +
            transformOriginOffsetFromAnchorOrigin.vertical;
        const marginThreshold = 16; // An arbitrary margin between the menu popup and the border of the window
        // Window thresholds taking required margin into account
        const heightThreshold = window.innerHeight - marginThreshold;
        const widthThreshold = window.innerWidth - marginThreshold;
        let top = anchorRect.top +
            getOffsetTop(anchorRect, anchorOrigin.vertical) +
            transformY;
        let left = anchorRect.left +
            getOffsetLeft(anchorRect, anchorOrigin.horizontal) +
            transformX;
        const right = left + menuRect.width;
        const bottom = top + menuRect.height;
        // Check if the vertical axis needs shifting
        if (top < marginThreshold) {
            const diff = top - marginThreshold;
            top -= diff;
        }
        else if (bottom > heightThreshold) {
            const diff = bottom - heightThreshold;
            top -= diff;
        }
        // Check if the horizontal axis needs shifting
        if (left < marginThreshold) {
            const diff = left - marginThreshold;
            left -= diff;
        }
        else if (right > widthThreshold) {
            // Flip to the left side
            left = anchorRect.left - element.getBoundingClientRect().width;
        }
        return {
            top,
            left,
        };
    }, 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [anchorOrigin, transformOrigin, anchorEl]);
    const setPositioningStyles = useCallback(() => {
        const element = popoverRef.current;
        if (!element) {
            return;
        }
        const positioning = getPositioningStyles(element);
        if (!positioning)
            return;
        if (positioning.top !== null) {
            element.style.top = `${positioning.top}px`;
        }
        if (positioning.left !== null) {
            element.style.left = `${positioning.left}px`;
        }
    }, [getPositioningStyles]);
    useLayoutEffect(() => {
        // Avoid if popover/backdrop is not rendered
        if (!popoverRef.current || !backdropRef.current)
            return;
        // Select the node that will be observed for mutations
        const targetNode = document.body;
        // Simpler approach
        const popovers = [...targetNode.childNodes].filter((node) => node instanceof HTMLElement &&
            node.classList.contains('ndl-popover') &&
            node !== popoverRef.current);
        if (popovers.length > 0) {
            const max = Math.max(...popovers.map((node) => parseInt(window.getComputedStyle(node).zIndex)));
            const [backdrop, content] = [max + 2, max + 3];
            popoverRef.current.style.zIndex = `${content}`;
            backdropRef.current.style.zIndex = `${backdrop}`;
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [popoverRef.current, backdropRef.current]);
    // Disable scroll and add padding when the popover is open
    useEffect(() => {
        if (nested) {
            return;
        }
        toggleScrollbar(open);
        return () => {
            if (nested)
                return;
            toggleScrollbar(false);
        };
    }, [open, nested, toggleScrollbar]);
    useEffect(() => {
        if (open) {
            setPositioningStyles();
        }
    }, [open, setPositioningStyles]);
    // Set Enter to trigger fade in animation
    useEffect(() => setEnter(open), [open]);
    useEffect(() => {
        if (!open) {
            return undefined;
        }
        const handleResize = debounce(() => {
            setPositioningStyles();
        });
        window.addEventListener('resize', handleResize);
        return () => {
            handleResize.clear();
            window.removeEventListener('resize', handleResize);
        };
    }, [anchorEl, open, setPositioningStyles]);
    const handleBackdropClick = (event) => {
        event.stopPropagation();
        event.preventDefault();
        onClose && onClose(event);
    };
    if (!open) {
        return null;
    }
    const classes = classNames('ndl-popover', themeClassName, baseClasses, className);
    const handleKeyDown = (event) => {
        if (event.key === 'Escape') {
            onClose && onClose(event);
        }
    };
    const anchor = anchorEl.current
        ? anchorEl.current
        : anchorEl;
    return (_jsxs(Portal, { container: anchorPortal ? anchor || undefined : undefined, children: [_jsx("div", { className: classNames('ndl-popover-backdrop', {
                    'ndl-allow-click-event-captured': disableBackdrop,
                }), ref: backdropRef, role: "button", tabIndex: 0, onClick: handleBackdropClick, onKeyDown: handleBackdropClick, "data-testid": "ndl-popover-backdrop", "aria-label": "Close popover" }), _jsx(ConditionalWrap, { condition: captureFocus, wrapper: (children) => (_jsx(FocusLock, Object.assign({ onDeactivation: () => {
                        const anchor = isRefObject(anchorEl)
                            ? anchorEl.current
                            : anchorEl;
                        if (!(anchor instanceof HTMLElement)) {
                            console.warn(anchorElNotSetWarningMessage);
                            return;
                        }
                        // setTimeout needed, read more: https://www.npmjs.com/package/react-focus-lock#unmounting-and-focus-management
                        setTimeout(() => anchor === null || anchor === void 0 ? void 0 : anchor.focus(), 0);
                    } }, focusLockProps, { children: children }))), children: _jsx(Component, Object.assign({ "data-testid": "ndl-popover-content" }, restProps, { className: classes, onKeyDown: handleKeyDown, ref: popoverRef, children: children })) })] }));
});
//# sourceMappingURL=Popover.js.map