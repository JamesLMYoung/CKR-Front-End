var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
/**
 *
 *  Copyright (c) "Neo4j"
 *  Neo4j Sweden AB [http://neo4j.com]
 *
 *  This file is part of Neo4j.
 *
 *  Neo4j is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import { useFloating, autoUpdate, offset, flip, useHover, useFocus, useDismiss, useRole, useInteractions, useMergeRefs, useClick, FloatingFocusManager, FloatingPortal, } from '@floating-ui/react';
import Tooltip from './Tooltip';
import ConditionalWrap from '../_common/ConditionalWrap';
import { Typography } from '../typography';
import { XMarkIconOutline } from '../icons';
import { classNames } from '../_common/defaultImports';
import { tokens } from '@neo4j-ndl/base';
import { IconButton } from '../button';
import React from 'react';
const PLACEMENTS = ['top', 'bottom', 'left', 'right'];
const calculateArrow = (placement) => {
    switch (placement) {
        case 'bottom':
            return 'top';
        case 'left':
            return 'right';
        case 'right':
            return 'left';
        case 'top':
        default:
            return 'bottom';
    }
};
export function useTip({ allowedPlacements = PLACEMENTS, isOpen: controlledOpen, isDisabled = false, onOpenChange: setControlledOpen, type = 'tooltip', } = {}) {
    const [uncontrolledOpen, setUncontrolledOpen] = React.useState(false);
    /** If `isDisabled` is passed, tip is never opened */
    const open = isDisabled === true ? false : controlledOpen !== null && controlledOpen !== void 0 ? controlledOpen : uncontrolledOpen;
    const setOpen = setControlledOpen !== null && setControlledOpen !== void 0 ? setControlledOpen : setUncontrolledOpen;
    const data = useFloating({
        placement: allowedPlacements[0],
        open,
        onOpenChange: setOpen,
        whileElementsMounted: autoUpdate,
        middleware: [
            offset(10),
            flip({
                fallbackAxisSideDirection: 'start',
                fallbackPlacements: allowedPlacements,
            }),
        ],
    });
    const context = data.context;
    const hover = useHover(context, {
        move: false,
        enabled: type == 'tooltip',
        delay: {
            open: parseInt(tokens.transitions.values.duration.slow.replace('ms', '')),
            // Strip the 'ms' from the duration token, need to provide pure ms durations
            close: parseInt(tokens.transitions.values.duration.quick.replace('ms', '')),
        },
    });
    const focus = useFocus(context, {
        enabled: type == 'tooltip',
    });
    const dismiss = useDismiss(context, {
        enabled: type == 'tooltip',
    });
    const click = useClick(context, {
        enabled: type == 'toggletip',
    });
    const role = useRole(context, { role: 'tooltip' });
    const interactions = useInteractions([hover, focus, dismiss, role, click]);
    return React.useMemo(() => (Object.assign(Object.assign({ open,
        setOpen,
        type }, interactions), data)), [open, setOpen, interactions, data, type]);
}
const TooltipContext = React.createContext(null);
export const useTipContext = () => {
    const context = React.useContext(TooltipContext);
    if (context == null) {
        throw new Error('Tip components must be wrapped in <Tip />');
    }
    return context;
};
export function Tip(_a) {
    var { children } = _a, options = __rest(_a, ["children"]);
    // This can accept any props as options, e.g. `placement`,
    // or other positioning options.
    const tooltip = useTip(Object.assign({}, options));
    return (_jsx(TooltipContext.Provider, { value: tooltip, children: children }));
}
/**
 * Wrapping the trigger in a button by default
 * Use `asChild` to pass any element as the trigger
 */
export const Trigger = React.forwardRef(function Trigger(_a, propRef) {
    var { children, hasButtonWrapper = false } = _a, restProps = __rest(_a, ["children", "hasButtonWrapper"]);
    const context = useTipContext();
    const childrenRef = children.ref;
    const ref = useMergeRefs([context.refs.setReference, propRef, childrenRef]);
    // `hasButtonWrapper=false` allows the user to pass any element as the anchor
    if (!hasButtonWrapper && React.isValidElement(children)) {
        return React.cloneElement(children, context.getReferenceProps(Object.assign(Object.assign(Object.assign({ ref }, restProps), children.props), { 'data-state': context.open ? 'open' : 'closed' })));
    }
    return (_jsx("button", Object.assign({ ref: ref, "data-state": context.open ? 'open' : 'closed' }, context.getReferenceProps(restProps), { children: children })));
});
export const Content = React.forwardRef(function Content(_a, propRef) {
    var { style, isPortaled = true, portalProps = {}, className, children } = _a, restProps = __rest(_a, ["style", "isPortaled", "portalProps", "className", "children"]);
    const { open, type, context, getFloatingProps, placement } = useTipContext();
    const ref = useMergeRefs([context.refs.setFloating, propRef]);
    if (!open)
        return null;
    const floatingProps = getFloatingProps(Object.assign(Object.assign({}, restProps), {
        className: classNames('ndl-tip ndl-tooltip-wrapper', className, {
            'ndl-toggletip': type === 'toggletip',
        }),
    }));
    return (_jsx(ConditionalWrap, { condition: isPortaled, wrap: (wrapChildren) => (_jsx(FloatingPortal, Object.assign({ preserveTabOrder: true }, portalProps, { children: wrapChildren }))), children: _jsx(FloatingFocusManager, { context: context, disabled: type === 'tooltip', children: _jsx(Tooltip, Object.assign({ ref: ref }, floatingProps, { arrowPosition: calculateArrow(placement), style: Object.assign(Object.assign({ zIndex: tokens.zIndex.alias.tooltip }, context.floatingStyles), style), children: children })) }) }));
});
export const Header = React.forwardRef(function Content(_a, ref) {
    var { isCloseable = true } = _a, restProps = __rest(_a, ["isCloseable"]);
    const { open, setOpen } = useTipContext();
    if (!open)
        return null;
    return (_jsxs("div", Object.assign({ className: "ndl-toggletip-header" }, restProps, { ref: ref, children: [_jsx(Typography, { variant: "h6", children: restProps.children }), isCloseable && (_jsx(IconButton, { clean: true, tabIndex: 0, role: "button", size: "small", className: "ndl-toggletip-close-icon", onKeyDown: (event) => {
                    if (event.key === 'Enter' || event.key === 'Space') {
                        setOpen(false, event.nativeEvent);
                    }
                }, onClick: (event) => {
                    setOpen(false, event.nativeEvent);
                }, "aria-label": "close-toggletip", "data-testid": "ndl-close-toggletip", children: _jsx(XMarkIconOutline, {}) }))] })));
});
export const Body = React.forwardRef(function Body(_a, ref) {
    var restProps = __rest(_a, []);
    const { open } = useTipContext();
    if (!open)
        return null;
    return _jsx("div", Object.assign({}, restProps, { ref: ref }));
});
export const Actions = React.forwardRef(function Actions(_a, ref) {
    var restProps = __rest(_a, []);
    const { open } = useTipContext();
    const classes = classNames('ndl-toggletip-actions', restProps.className);
    if (!open)
        return null;
    return _jsx("div", Object.assign({}, restProps, { className: classes, ref: ref }));
});
export const Action = (_a) => {
    var { className } = _a, restProps = __rest(_a, ["className"]);
    const { open } = useTipContext();
    const classes = classNames('ndl-toggletip-action', className);
    if (!open)
        return null;
    return (_jsx(Typography, Object.assign({ as: "button" }, restProps, { tabIndex: 0, variant: "label", className: classes })));
};
Tip.Content = Content;
Tip.Trigger = Trigger;
Tip.Header = Header;
Tip.Body = Body;
Tip.Actions = Actions;
Tip.Action = Action;
//# sourceMappingURL=Tip.js.map