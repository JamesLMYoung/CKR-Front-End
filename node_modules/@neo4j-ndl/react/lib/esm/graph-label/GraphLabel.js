var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
/**
 *
 *  Copyright (c) "Neo4j"
 *  Neo4j Sweden AB [http://neo4j.com]
 *
 *  This file is part of Neo4j.
 *
 *  Neo4j is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import React, { useMemo, useState } from 'react';
import { classNames } from '../_common/defaultImports';
import { tokens } from '@neo4j-ndl/base';
import { getDisabledColor, getDisabledTextColor, getHoverColor, getTextColorFromBackground, } from './color';
/**
 *
 *
 * Helpers
 *
 *
 */
const HexagonEnd = ({ direction = 'left', color }) => {
    const classes = classNames('ndl-hexagon-end', {
        'ndl-left': direction === 'left',
        'ndl-right': direction === 'right',
    });
    return (_jsxs("div", { className: classes, children: [_jsx("svg", { width: "8", height: "24", viewBox: "0 0 7 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: _jsx("path", { className: "ndl-hexagon-end-inner", style: { fill: color }, fillRule: "evenodd", clipRule: "evenodd", d: "M5.73024 1.03676C6.08165 0.397331 6.75338 0 7.48301 0H9V24H7.483C6.75338 24 6.08165 23.6027 5.73024 22.9632L0.315027 13.1094C-0.105009 12.4376 -0.105009 11.5624 0.315026 10.8906L5.73024 1.03676Z" }) }), _jsx("svg", { className: "ndl-hexagon-end-active", width: "13", height: "30", viewBox: "0 0 13 30", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: _jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.075 2C9.12474 2 8.24318 2.54521 7.74867 3.43873L2.21419 13.4387C1.68353 14.3976 1.68353 15.6024 2.21419 16.5613L7.74867 26.5613C8.24318 27.4548 9.12474 28 10.075 28H13V30H10.075C8.49126 30 7.022 29.0913 6.1978 27.6021L0.663324 17.6021C-0.221109 16.0041 -0.221108 13.9959 0.663325 12.3979L6.1978 2.39789C7.022 0.90869 8.49126 0 10.075 0H13V2H10.075Z" }) })] }));
};
/**
 *
 *
 * GraphLabel Component
 *
 *
 */
const MAX_WIDTH = 200;
const GraphLabel = React.forwardRef(function GraphLabel(_a, ref) {
    var { type = 'node', color, disabled = false, selected = false, as, onClick, onMouseEnter, onMouseLeave, className, style, children } = _a, restProps = __rest(_a, ["type", "color", "disabled", "selected", "as", "onClick", "onMouseEnter", "onMouseLeave", "className", "style", "children"]);
    const [isHover, setIsHover] = useState(false);
    const handleMouseEnter = (event) => {
        setIsHover(true);
        onMouseEnter && onMouseEnter(event);
    };
    const handleMouseLeave = (event) => {
        setIsHover(false);
        onMouseLeave && onMouseLeave(event);
    };
    const handleClick = (e) => {
        // By default, a <button /> element with disabled set to true will not get its
        // on click handler called. To support the same behavior on <a /> tags we
        // swallow the event here when disabled, since the <a /> tag with disabled set to
        // true will have its onClick handler called
        if (disabled) {
            e.preventDefault();
            e.stopPropagation();
            return;
        }
        if (onClick) {
            onClick(e);
        }
    };
    let backgroundColor = useMemo(() => {
        if (!color) {
            switch (type) {
                case 'node':
                    return tokens.palette.graph['1'];
                case 'relationship':
                    return tokens.theme.light.palette.neutral.bg.strong;
                default:
                    return tokens.theme.light.palette.neutral.bg.strongest;
            }
        }
        return color;
    }, [color, type]);
    const hoverColor = useMemo(() => getHoverColor(backgroundColor ? backgroundColor : tokens.colors.lemon[40]), [backgroundColor]);
    const textColor = useMemo(() => getTextColorFromBackground(backgroundColor ? backgroundColor : tokens.colors.lemon[40]), [backgroundColor]);
    const disabledTextColor = useMemo(() => getDisabledTextColor(backgroundColor ? backgroundColor : tokens.colors.lemon[40]), [backgroundColor]);
    if (isHover && !disabled)
        backgroundColor = hoverColor;
    if (disabled)
        backgroundColor = getDisabledColor(backgroundColor);
    let Component = 'button';
    if (as) {
        Component = as;
    }
    const commonClasses = classNames(className, {
        'ndl-disabled': disabled,
        'ndl-selected': selected,
    });
    if (type === 'node') {
        const classes = `ndl-node-label ${commonClasses}`;
        return (_jsx(Component, Object.assign({}, restProps, { className: classes, ref: ref, style: Object.assign({ backgroundColor: backgroundColor, color: disabled ? disabledTextColor : textColor, maxWidth: MAX_WIDTH }, style), onClick: handleClick, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, children: _jsx("div", { className: "ndl-node-label-content", children: children }) })));
    }
    else if (type === 'relationship') {
        const classes = `ndl-relationship-label ${commonClasses}`;
        return (_jsxs(Component, Object.assign({}, restProps, { style: Object.assign(Object.assign({ maxWidth: MAX_WIDTH }, style), { color: disabled ? disabledTextColor : textColor }), className: classes, onClick: handleClick, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, ref: ref, children: [_jsx("svg", { style: { display: 'none' }, children: _jsx("mask", { id: "ndl-relationship-label-mask-outer-border", fill: "white", children: _jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.73024 1.03676C6.08165 0.397331 6.75338 0 7.48301 0H9V24H7.483C6.75338 24 6.08165 23.6027 5.73024 22.9632L0.315027 13.1094C-0.105009 12.4376 -0.105009 11.5624 0.315026 10.8906L5.73024 1.03676Z" }) }) }), _jsx(HexagonEnd, { direction: "left", color: backgroundColor }), _jsx("div", { className: "ndl-relationship-label-container", style: {
                        backgroundColor: backgroundColor,
                    }, children: _jsx("div", { className: "ndl-relationship-label-content", children: children }) }), _jsx(HexagonEnd, { direction: "right", color: backgroundColor })] })));
    }
    else {
        const classes = `ndl-property-key-label ${commonClasses}`;
        return (_jsx(Component, Object.assign({}, restProps, { style: Object.assign({ backgroundColor: backgroundColor, color: disabled ? disabledTextColor : textColor, maxWidth: MAX_WIDTH }, style), className: classes, onClick: handleClick, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, ref: ref, children: _jsx("div", { className: "ndl-property-key-label-content", children: children }) })));
    }
});
export default GraphLabel;
//# sourceMappingURL=GraphLabel.js.map