import { createElement as _createElement } from "react";
import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
/**
 *
 *  Copyright (c) "Neo4j"
 *  Neo4j Sweden AB [http://neo4j.com]
 *
 *  This file is part of Neo4j.
 *
 *  Neo4j is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import { flexRender, } from '@tanstack/react-table';
import { classNames } from '../_common/defaultImports';
import { Fragment, useCallback, useEffect, useMemo, useRef, useState, } from 'react';
import { Bars3CenterLeftIconOutline, BarsArrowDownIconOutline, BarsArrowUpIconOutline, ChevronLeftIconOutline, ChevronRightIconOutline, ChevronDownIconSolid, Bars3CenterLeftIconSolid, } from '../icons';
import { LoadingSpinner } from '../loading-spinner';
import { isSizeConstrained, userFriendlyPagination } from './helpers';
import { useDataGridContext } from './DataGridContext';
import { IconButton } from '../button';
import { Menu } from '../context-menu';
/** Table results per page, with the first option being the default */
const TABLE_RESULTS = {
    DEFAULT: 10,
    values: [10, 25, 50, 100],
};
export const DEFAULT_SORT_ACTIONS = (cell) => ({
    asc: {
        title: 'Sort ascending',
        icon: _jsx(BarsArrowUpIconOutline, {}),
        onClick: () => cell.column.toggleSorting(false),
    },
    desc: {
        title: 'Sort descending',
        icon: _jsx(BarsArrowDownIconOutline, {}),
        onClick: () => cell.column.toggleSorting(true),
    },
    default: {
        title: 'Default sort',
        icon: _jsx(Bars3CenterLeftIconOutline, {}),
        onClick: () => cell.column.clearSorting(),
    },
});
const ResizingBar = ({ header, children, innerProps, }) => {
    const { className = undefined } = innerProps || {};
    return (_jsx(_Fragment, { children: children || (_jsx("button", Object.assign({}, innerProps, { type: "button", className: "ndl-data-grid-resizer-wrapper", onMouseDown: header.getResizeHandler(), onTouchStart: header.getResizeHandler(), "aria-label": "resizing bar", children: _jsx("div", { className: classNames('ndl-data-grid-resizer', className, {
                    'ndl-data-grid-is-resizing': header.column.getIsResizing(),
                }) }) }))) }));
};
const Scrollable = ({ children, innerProps }) => {
    const { className } = innerProps || {};
    return (_jsx("div", Object.assign({}, innerProps, { className: classNames('ndl-data-grid-scrollable', className), children: children })));
};
const Header = ({ children, innerProps }) => {
    const { tableProps, components } = useDataGridContext();
    const { getHeaderGroups, getState } = tableProps;
    const { className = undefined } = innerProps || {};
    return (_jsx("div", Object.assign({}, innerProps, { role: "rowgroup", className: classNames('ndl-data-grid-thead', className, {
            'ndl-data-grid-is-resizing': getState().columnSizingInfo.isResizingColumn,
        }), children: children || (_jsx(_Fragment, { children: getHeaderGroups().map((headerGroup) => (_jsx("div", { className: "ndl-data-grid-tr", role: "row", children: headerGroup.headers.map((header) => components.HeaderCell && (_jsx(components.HeaderCell, { cell: header }, header.id))) }, headerGroup.id))) })) })));
};
export const ActionButton = ({ action, children, onClose, innerProps, }) => {
    const { className } = innerProps || {};
    const { onClick } = action;
    const interceptedOnClick = useCallback((e) => {
        const providedOnClick = onClick || (innerProps === null || innerProps === void 0 ? void 0 : innerProps.onClick);
        if (typeof providedOnClick === 'function') {
            providedOnClick(e);
        }
        onClose();
    }, [innerProps === null || innerProps === void 0 ? void 0 : innerProps.onClick, onClick, onClose]);
    // const commonProps: MenuItemProps = {
    const commonProps = Object.assign(Object.assign(Object.assign({}, innerProps), action), { className: classNames('ndl-data-grid-column-action', className), onClick: interceptedOnClick });
    return _jsx(Fragment, { children: children || _jsx(Menu.Item, Object.assign({}, commonProps)) });
};
export const RowActionCell = ({ cell, innerProps, }) => {
    var _a, _b;
    const { components } = useDataGridContext();
    const actionsButtonRef = useRef(null);
    const [actionsOpen, setActionsOpen] = useState(false);
    if (!cell ||
        !cell.column.columnDef.meta ||
        typeof ((_b = (_a = cell.column.columnDef) === null || _a === void 0 ? void 0 : _a.meta) === null || _b === void 0 ? void 0 : _b.isActionCell) !== 'object')
        return null;
    const { actions, onOpenChange } = cell.column.columnDef.meta.isActionCell;
    return (_jsxs(Fragment, { children: [_jsx(IconButton, Object.assign({ clean: true, size: "medium", "aria-label": `Row actions for row id: ${cell.row.id}`, ref: actionsButtonRef, active: actionsOpen, onClick: () => {
                    onOpenChange && onOpenChange(!actionsOpen);
                    setActionsOpen(!actionsOpen);
                } }, innerProps, { children: _jsx(ChevronDownIconSolid, {}) })), _jsx(Menu, { open: actionsOpen, anchorEl: actionsButtonRef.current, onClose: () => {
                    onOpenChange && onOpenChange(false);
                    setActionsOpen(false);
                }, anchorOrigin: {
                    vertical: 'bottom',
                    horizontal: 'left',
                }, transformOrigin: {
                    horizontal: 'right',
                    vertical: 'top',
                }, children: actions.map((action, i) => components.ActionButton && (_jsx(components.ActionButton, { action: action, onClose: () => setActionsOpen(false) }, `${cell.column.id}-action-${i}`))) })] }));
};
export const ColumnControls = ({ cell, children, innerProps, }) => {
    var _a;
    const { className } = innerProps || {};
    const { components } = useDataGridContext();
    const sort = cell.column.getIsSorted();
    const canSort = cell.column.getCanSort();
    const { defaultSortingActions = true, actions } = ((_a = cell.column.columnDef.meta) === null || _a === void 0 ? void 0 : _a.columnActions) || {};
    const sortingActions = useMemo(() => {
        if (canSort) {
            if (sort !== 'asc' && sort !== 'desc') {
                return [
                    DEFAULT_SORT_ACTIONS(cell).asc,
                    DEFAULT_SORT_ACTIONS(cell).desc,
                ];
            }
            if (sort === 'asc') {
                return [
                    DEFAULT_SORT_ACTIONS(cell).default,
                    DEFAULT_SORT_ACTIONS(cell).desc,
                ];
            }
            if (sort === 'desc') {
                return [
                    DEFAULT_SORT_ACTIONS(cell).default,
                    DEFAULT_SORT_ACTIONS(cell).asc,
                ];
            }
        }
        // Default case
        return [];
    }, [sort, cell, canSort]);
    const newActions = [
        ...(defaultSortingActions ? sortingActions : []),
        ...(actions !== null && actions !== void 0 ? actions : []),
    ];
    const actionsButtonRef = useRef(null);
    const [actionsOpen, setActionsOpen] = useState(false);
    if (!actions || actions.length === 0)
        return null;
    return newActions.length > 0 ? (_jsx("div", Object.assign({}, innerProps, { className: classNames('ndl-header-action-group', className), style: {
            zIndex: 100000,
            position: 'relative',
            right: '12px',
        }, children: children || (_jsxs(Fragment, { children: [_jsx(IconButton, { clean: true, size: "medium", "arial-label": `Column actions for ${cell.column.id} column`, ref: actionsButtonRef, active: actionsOpen, onClick: () => {
                        setActionsOpen(!actionsOpen);
                    }, children: _jsx(ChevronDownIconSolid, {}) }), _jsx(Menu, { open: actionsOpen, anchorEl: actionsButtonRef.current, onClose: () => setActionsOpen(false), anchorOrigin: {
                        vertical: 'bottom',
                        horizontal: 'center',
                    }, transformOrigin: {
                        horizontal: 'center',
                        vertical: 'top',
                    }, children: newActions.map((action, i) => components.ActionButton && (_jsx(components.ActionButton, { action: action, onClose: () => setActionsOpen(false) }, `${cell.column.id}-action-${i}`))) })] })) }))) : null;
};
const HeaderCell = ({ cell, children, innerProps, }) => {
    var _a;
    const { components, resizable, tableProps, resizeColumns } = useDataGridContext();
    const { className } = innerProps || {};
    const sort = cell.column.getIsSorted();
    const canSort = cell.column.getCanSort();
    const ariaSortRole = useMemo(() => {
        switch (sort) {
            case 'asc':
                return 'ascending';
            case 'desc':
                return 'descending';
            default:
                return 'none';
        }
    }, [sort]);
    const Icon = useMemo(() => {
        switch (sort) {
            case 'asc':
                return _jsx(BarsArrowUpIconOutline, { className: "ndl-header-icon" });
            case 'desc':
                return _jsx(BarsArrowDownIconOutline, { className: "ndl-header-icon" });
            default:
                return (_jsx(Bars3CenterLeftIconSolid, { className: "ndl-hoverable-indicator ndl-header-icon" }));
        }
    }, [sort]);
    const ariaDescription = canSort
        ? `Press ENTER or SPACE to sort column ${cell.column.id}`
        : `Column id: ${cell.column.id}`;
    const constrained = isSizeConstrained(cell.column.columnDef);
    const ref = useRef(null);
    const [grow, setGrow] = useState(resizeColumns);
    /**
     * This part enables the auto sizing of the columns.
     *
     * On initial render we need to wait for the width to be
     * calculated by the browser with `flex-grow: 1`, if the size is not
     * constrained by the user.
     * Then we update the table state with the new width to aligned
     * with the one calculated by browser, for optimal user experience.
     */
    useEffect(() => {
        var _a;
        if (resizeColumns) {
            // The `flex-grow` property is modifying the
            // width of the column, update this also in the table state
            const { width } = ((_a = ref.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) || {};
            if (width) {
                // Update column sizing in table's state
                tableProps.setState((prev) => (Object.assign(Object.assign({}, prev), { columnSizing: Object.assign(Object.assign({}, prev.columnSizing), { [cell.column.id]: width }) })));
                // Disable flex grow, to avoid weird resizing behaviour
                setGrow(false);
            }
        }
    }, [tableProps, cell.column.id]);
    const isActionColumn = typeof ((_a = cell.column.columnDef.meta) === null || _a === void 0 ? void 0 : _a.isActionCell) === 'object';
    const Tag = canSort ? 'button' : 'div';
    return (_jsx("div", Object.assign({ tabIndex: -1, role: "columnheader" }, innerProps, { className: classNames('ndl-data-grid-th ndl-focusable-cell', className, {
            'ndl-data-grid-row-action': isActionColumn,
        }), "aria-sort": ariaSortRole, style: {
            width: isActionColumn ? 40 : cell.getSize(),
            maxWidth: cell.column.columnDef.maxSize
                ? `${cell.column.columnDef.maxSize}px`
                : 'none',
            flexGrow: !isActionColumn && !constrained && grow ? 1 : 0,
        }, ref: ref, children: children || (_jsxs(_Fragment, { children: [_jsx(Tag, { className: "ndl-header-group", style: {
                        cursor: canSort ? 'pointer' : 'default',
                    }, tabIndex: canSort ? -1 : undefined, "aria-describedby": ariaDescription, onClick: () => canSort && cell.column.toggleSorting(), children: _jsxs("div", { className: "ndl-header-cell", children: [cell.isPlaceholder
                                ? null
                                : flexRender(cell.column.columnDef.header, cell.getContext()), canSort && Icon] }) }), components.ColumnControls && (_jsx(components.ColumnControls, { cell: cell })), resizable &&
                    cell.headerGroup.headers.length - 1 !== cell.index &&
                    cell.column.getCanResize() &&
                    components.ResizingBar && _jsx(components.ResizingBar, { header: cell })] })) }), cell.id));
};
const Body = ({ children, innerProps }) => {
    const { tableProps, components, loading } = useDataGridContext();
    const { getRowModel } = tableProps;
    const { className } = innerProps || {};
    return (_jsx("div", Object.assign({}, innerProps, { className: classNames('ndl-data-grid-tbody', className), role: "rowgroup", "aria-busy": loading ? 'true' : 'false', children: children || (_jsxs(_Fragment, { children: [loading && components.LoadingPlaceholder && (_jsx(components.LoadingPlaceholder, {})), !loading &&
                    getRowModel().rows.length === 0 &&
                    components.NoDataPlaceholder && _jsx(components.NoDataPlaceholder, {}), !loading &&
                    getRowModel().rows.map((row, idx) => components.BodyRow && (_jsx(components.BodyRow, { row: row }, `table-row-${idx}`)))] })) })));
};
const BodyCell = ({ cell, children, innerProps, }) => {
    var _a;
    const isResizing = cell.column.getIsResizing();
    const { className } = innerProps || {};
    const isActionColumn = typeof ((_a = cell.column.columnDef.meta) === null || _a === void 0 ? void 0 : _a.isActionCell) === 'object';
    return (_jsx("div", Object.assign({}, innerProps, { className: classNames('ndl-data-grid-td ndl-focusable-cell', className, {
            'ndl-data-grid-is-resizing': isResizing,
            'ndl-data-grid-row-action': isActionColumn,
        }), role: "cell", tabIndex: 0, style: {
            width: isActionColumn ? 40 : cell.column.getSize(),
        }, children: children || flexRender(cell.column.columnDef.cell, cell.getContext()) }), cell.id));
};
const BodyRow = ({ row, children, innerProps, }) => {
    const { components } = useDataGridContext();
    const { className, style = {} } = innerProps || {};
    return (_createElement("div", Object.assign({}, innerProps, { key: row.id, className: classNames('ndl-data-grid-tr', className), role: "row", style: Object.assign({ display: 'flex', flexDirection: 'row' }, style) }), children || (_jsx(_Fragment, { children: row
            .getVisibleCells()
            .map((cell) => components.BodyCell && (_jsx(components.BodyCell, { cell: cell }, cell.id))) }))));
};
const TableResults = ({ children, innerProps, manualPagination, }) => {
    const { tableProps } = useDataGridContext();
    const { getState, getRowModel, getCoreRowModel } = tableProps;
    const { pagination: { pageSize, pageIndex }, } = getState();
    const { rows } = getRowModel();
    const { from, to, totalRows } = useMemo(() => manualPagination || {
        from: 1 + pageIndex * pageSize,
        to: rows.length + pageIndex * pageSize,
        totalRows: getCoreRowModel().rows.length,
    }, [pageIndex, pageSize, manualPagination, rows, getCoreRowModel]);
    const { className } = innerProps || {};
    return (_jsx("span", Object.assign({}, innerProps, { className: classNames('ndl-data-grid-results', className), children: children || (_jsxs("span", { children: ["Showing", ' ', _jsx("b", { children: totalRows ? `${from}${to !== from ? `-${to}` : ''}` : 0 }), " of", ' ', _jsx("b", { children: totalRows }), " results"] })) })));
};
const RowsPerPage = ({ children, innerProps, }) => {
    const { tableProps } = useDataGridContext();
    const { setPageSize, getState } = tableProps;
    const { className } = innerProps || {};
    const { pagination: { pageSize }, } = getState();
    return (_jsx("div", Object.assign({}, innerProps, { className: classNames('ndl-data-grid-rows-per-page', className), children: children || (_jsxs(_Fragment, { children: ["Show", _jsx("select", { onChange: (e) => setPageSize(parseInt(e.target.value, 10)), className: "ndl-data-grid-select", value: pageSize, "aria-label": "Select page size", children: [...new Set([...TABLE_RESULTS.values, pageSize])]
                        .sort((a, b) => a - b)
                        .map((option) => (_jsx("option", { value: `${option}`, children: option }, `${option}`))) })] })) })));
};
const PaginationArrowButton = ({ action, children, innerProps, }) => {
    const { className } = innerProps || {};
    return (_jsx("button", Object.assign({}, innerProps, { type: "button", className: classNames('ndl-data-grid-pagination-icon-button', className), children: children || (_jsxs(_Fragment, { children: [action === 'previous' && (_jsxs(_Fragment, { children: [_jsx("span", { className: "n-sr-only", children: "Previous table page" }), _jsx(ChevronLeftIconOutline, { className: "ndl-data-grid-pagination-icon" })] })), action === 'next' && (_jsxs(_Fragment, { children: [_jsx("span", { className: "n-sr-only", children: "Next table page" }), _jsx(ChevronRightIconOutline, { className: "ndl-data-grid-pagination-icon" })] }))] })) })));
};
const PaginationNumericButton = ({ currentIndex, isSelected, children, innerProps, }) => {
    const { className, onClick } = innerProps || {};
    return (_jsx("button", Object.assign({}, innerProps, { type: "button", "data-testid": `ndl-table-${currentIndex}`, className: classNames('ndl-data-grid-pagination-numeric-button', className, {
            'ndl-not-selected-numeric': typeof currentIndex === 'number' && !isSelected,
            'ndl-is-selected': isSelected,
            'ndl-not-selected': !isSelected,
        }), onClick: (e) => typeof currentIndex === 'number' && onClick && onClick(e), tabIndex: typeof currentIndex === 'number' ? 0 : -1, children: children || currentIndex })));
};
const PaginationNumericButtons = () => {
    const { tableProps, components } = useDataGridContext();
    const { getState, setPageIndex, getPageCount } = tableProps;
    const { pagination: { pageIndex }, } = getState();
    return (_jsx(_Fragment, { children: userFriendlyPagination(pageIndex + 1, getPageCount()).map((option, idx) => components.PaginationNumericButton && (_jsx(components.PaginationNumericButton
        /** Use index to avoid situations where two "..." values will appear, causing a key conflict */
        , { innerProps: {
                onClick: () => typeof option === 'number' && setPageIndex(option - 1),
            }, currentIndex: option, isSelected: option === pageIndex + 1 }, `${option}-${idx}`))) }));
};
const Pagination = ({ children, innerProps, }) => {
    const { tableProps, components } = useDataGridContext();
    const { getCanPreviousPage, getCanNextPage, previousPage, nextPage } = tableProps;
    const { className } = innerProps || {};
    return (_jsx("nav", Object.assign({}, innerProps, { className: classNames('ndl-data-grid-nav', className), "aria-label": "Pagination", children: children || (_jsxs(_Fragment, { children: [getCanPreviousPage()
                    ? components.PaginationArrowButton && (_jsx(components.PaginationArrowButton, { action: "previous", innerProps: {
                            onClick: previousPage,
                        } }))
                    : null, components.PaginationNumericButtons && (_jsx(components.PaginationNumericButtons, {})), getCanNextPage()
                    ? components.PaginationArrowButton && (_jsx(components.PaginationArrowButton, { action: "next", innerProps: {
                            onClick: nextPage,
                        } }))
                    : null] })) })));
};
const Navigation = ({ children, innerProps, }) => {
    const { tableProps, components } = useDataGridContext();
    const { getPageCount } = tableProps;
    const { className } = innerProps || {};
    return (_jsx("div", Object.assign({}, innerProps, { className: classNames('ndl-data-grid-navigation', className), children: _jsx(_Fragment, { children: children || (_jsxs(_Fragment, { children: [components.TableResults && _jsx(components.TableResults, {}), _jsxs("div", { className: "ndl-data-grid-navigation-right-items", children: [getPageCount() > 1 && components.Pagination && (_jsx(components.Pagination, {})), components.RowsPerPage && _jsx(components.RowsPerPage, {})] })] })) }) })));
};
const LoadingPlaceholder = ({ children, innerProps, }) => {
    const { className } = innerProps || {};
    return (_jsx("div", Object.assign({}, innerProps, { className: classNames('nld-table-placeholder-wrapper', className), role: "row", children: children || (_jsx("div", { role: "cell", className: "ndl-data-grid-placeholder", children: _jsxs("div", { className: "ndl-data-grid-loading-placeholder", children: [_jsx(LoadingSpinner, {}), _jsx("h6", { children: "Loading data" })] }) })) })));
};
const NoDataPlaceholder = ({ children, innerProps, }) => {
    const { className } = innerProps || {};
    return (_jsx("div", Object.assign({}, innerProps, { className: classNames('nld-table-placeholder-wrapper', className), role: "row", children: children || (_jsx("div", { role: "cell", className: "ndl-data-grid-placeholder", children: _jsx("h6", { children: "No data present" }) })) })));
};
export { ResizingBar, Header, Body, BodyCell, BodyRow, HeaderCell, Navigation, TableResults, RowsPerPage, Pagination, PaginationNumericButtons, PaginationArrowButton, PaginationNumericButton, NoDataPlaceholder, LoadingPlaceholder, Scrollable, };
//# sourceMappingURL=Components.js.map